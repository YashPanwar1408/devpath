const { PrismaClient } = require('@prisma/client');
const prisma = new PrismaClient();

/**
 * ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
 * ‚ïë              MASTER SOLUTIONS - ALL 250 DSA PROBLEMS              ‚ïë
 * ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
 * 
 * This file contains comprehensive solutions for all problems.
 * 
 * üìä Statistics:
 *    - Total Problems: 250
 *    - Generated: 28/1/2026, 12:25:30 pm
 *    
 * üìö Coverage:
 *    ‚úì Arrays & Hashing
 *    ‚úì Two Pointers  
 *    ‚úì Sliding Window
 *    ‚úì Stack
 *    ‚úì Binary Search
 *    ‚úì Linked List
 *    ‚úì Trees (Binary Tree, BST)
 *    ‚úì Tries
 *    ‚úì Heap / Priority Queue
 *    ‚úì Backtracking
 *    ‚úì Graphs (DFS, BFS, Union Find, Topological Sort)
 *    ‚úì Dynamic Programming (1D, 2D, Knapsack, LCS, etc.)
 *    ‚úì Greedy Algorithms
 *    ‚úì Intervals
 *    ‚úì Math & Geometry
 *    ‚úì Bit Manipulation
 *    
 * üéØ Each Problem Includes:
 *    ‚Ä¢ Description
 *    ‚Ä¢ Examples with explanations
 *    ‚Ä¢ Constraints
 *    ‚Ä¢ Brute Force Solution (with intuition, algorithm, complexity, code)
 *    ‚Ä¢ Optimized Solution (with intuition, algorithm, complexity, code)
 *    ‚Ä¢ Code in 4 languages: Python, Java, C++, JavaScript
 */

const SOLUTIONS = {
    "simplify-path": {
        "description": `<p>You are given an <strong>absolute path</strong> for a Unix-style file system, which always begins with a slash <code>'/'</code>. Your task is to transform this absolute path into its <strong>simplified canonical path</strong>.</p>
<p>The rules of a Unix-style file system are as follows:</p>
<ul>
<li>A single period <code>'.'</code> represents the current directory.</li>
<li>A double period <code>'..'</code> represents the previous/parent directory.</li>
<li>Multiple consecutive slashes such as <code>'//'</code> and <code>'///'</code> are treated as a single slash <code>'/'</code>.</li>
<li>Any sequence of periods that does not match the rules above should be treated as a valid directory or file name. For example, <code>'...'</code> and <code>'....'</code> are valid directory or file names.</li>
</ul>
<p>The simplified canonical path should follow these rules:</p>
<ul>
<li>The path must start with a single slash <code>'/'</code>.</li>
<li>Directories within the path must be separated by exactly one slash <code>'/'</code>.</li>
<li>The path must not end with a slash <code>'/'</code>, unless it is the root directory.</li>
<li>The path must not have any single or double periods (<code>'.'</code> and <code>'..'</code>) used to denote current or parent directories.</li>
</ul>
<p>Return <em>the simplified canonical path</em>.</p>`,
        "examples": [
            {
                "input": "path = \"/neetcode/practice//...///../courses\"",
                "output": "\"/neetcode/practice/courses\"",
                "explanation": "Multiple slashes are replaced by a single one. '...' is a valid name. '..' moves up from '...' to 'practice'."
            },
            {
                "input": "path = \"/..//\"",
                "output": "\"/\"",
                "explanation": "Going one level up from the root directory is a no-op."
            },
            {
                "input": "path = \"/..//_home/a/b/..///\"",
                "output": "\"/_home/a\"",
                "explanation": "Going up from root does nothing. Multiple slashes are treated as one. '..' moves up from 'b' to 'a'."
            }
        ],
        "constraints": [
            "1 <= path.length <= 3000",
            "path consists of English letters, digits, period '.', slash '/' or '_'.",
            "path is a valid absolute Unix path."
        ],
        "solutions": {
            "brute": {
                "intuition": "We can split the path by slashes and iterate through the components. If we encounter a '..', we effectively 'pop' the last valid directory. This hints at a Stack data structure.",
                "algorithm": "1. Split the input string by '/'.\n2. Iterate through the parts.\n3. If part is '' or '.', ignore.\n4. If part is '..', remove the last added directory (if any).\n5. Otherwise, add the directory to our list.\n6. Join the list with '/' and prepend a leading slash.",
                "complexity": {
                    "time": "O(n) - We iterate through the string once.",
                    "space": "O(n) - To store the split parts and the stack."
                },
                "code": {
                    "python": "class Solution:\n    def simplifyPath(self, path: str) -> str:\n        stack = []\n        for p in path.split(\"/\"):\n            if p == \"..\":\n                if stack: stack.pop()\n            elif p and p != \".\":\n                stack.append(p)\n        return \"/\" + \"/\".join(stack)",
                    "java": "class Solution {\n    public String simplifyPath(String path) {\n        Stack<String> stack = new Stack<>();\n        for (String p : path.split(\"/\")) {\n            if (p.equals(\"..\")) {\n                if (!stack.isEmpty()) stack.pop();\n            } else if (!p.isEmpty() && !p.equals(\".\")) {\n                stack.push(p);\n            }\n        }\n        return \"/\" + String.join(\"/\", stack);\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    string simplifyPath(string path) {\n        stringstream ss(path);\n        string segment;\n        vector<string> stack;\n        while(getline(ss, segment, '/')) {\n            if (segment == \"\" || segment == \".\") continue;\n            if (segment == \"..\") {\n                if (!stack.empty()) stack.pop_back();\n            } else {\n                stack.push_back(segment);\n            }\n        }\n        string res = \"\";\n        for (const string& s : stack) res += \"/\" + s;\n        return res.empty() ? \"/\" : res;\n    }\n};",
                    "javascript": "var simplifyPath = function(path) {\n    const stack = [];\n    for (const p of path.split('/')) {\n        if (p === '..') {\n            if (stack.length) stack.pop();\n        } else if (p && p !== '.') {\n            stack.push(p);\n        }\n    }\n    return '/' + stack.join('/');\n};"
                }
            },
            "optimized": {
                "intuition": "The Stack approach is already optimal for this problem. We process the string in a single pass. To optimize space slightly in C++, we can use a deque or vector as a stack to avoid recursion overhead or complex memory management.",
                "algorithm": "Same as the brute force approach, as the stack simulation is the canonical O(N) solution.",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(n)"
                },
                "code": {
                    "python": "# Same as brute force, Python lists work as optimized stacks\nclass Solution:\n    def simplifyPath(self, path: str) -> str:\n        stack = []\n        for p in path.split(\"/\"):\n            if p == \"..\":\n                if stack: stack.pop()\n            elif p and p != \".\":\n                stack.append(p)\n        return \"/\" + \"/\".join(stack)",
                    "java": "// Using Deque is generally preferred over Stack class in Java\nclass Solution {\n    public String simplifyPath(String path) {\n        Deque<String> stack = new ArrayDeque<>();\n        for (String p : path.split(\"/\")) {\n            if (p.equals(\"..\")) {\n                if (!stack.isEmpty()) stack.removeLast();\n            } else if (!p.isEmpty() && !p.equals(\".\")) {\n                stack.addLast(p);\n            }\n        }\n        StringBuilder res = new StringBuilder();\n        for (String dir : stack) res.append(\"/\").append(dir);\n        return res.length() > 0 ? res.toString() : \"/\";\n    }\n}",
                    "cpp": "// Optimized string building\nclass Solution {\npublic:\n    string simplifyPath(string path) {\n        vector<string> stack;\n        string res, temp;\n        stringstream ss(path);\n        while(getline(ss, temp, '/')) {\n            if (temp == \"\" || temp == \".\") continue;\n            if (temp == \"..\") {\n                if (!stack.empty()) stack.pop_back();\n            } else {\n                stack.push_back(temp);\n            }\n        }\n        for(auto& s : stack) res += \"/\" + s;\n        return res.empty() ? \"/\" : res;\n    }\n};",
                    "javascript": "var simplifyPath = function(path) {\n    const stack = [];\n    const parts = path.split('/');\n    for (const p of parts) {\n        if (p === '..') {\n            if (stack.length) stack.pop();\n        } else if (p && p !== '.') {\n            stack.push(p);\n        }\n    }\n    return '/' + stack.join('/');\n};"
                }
            }
        }
    },
    "reverse-nodes-in-k-group": {
        "description": "<p>Given the <code>head</code> of a linked list, reverse the nodes of the list <code>k</code> at a time, and return <em>the modified list</em>.</p><p><code>k</code> is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of <code>k</code> then left-out nodes, in the end, should remain as it is.</p><p>You may not alter the values in the list's nodes, only nodes themselves may be changed.</p>",
        "examples": [
            {
                "input": "head = [1,2,3,4,5], k = 2",
                "output": "[2,1,4,3,5]",
                "explanation": "The first two nodes are reversed, then the next two, and the last node remains."
            },
            {
                "input": "head = [1,2,3,4,5], k = 3",
                "output": "[3,2,1,4,5]",
                "explanation": "The first three nodes are reversed, and the remaining two stay as is."
            }
        ],
        "constraints": [
            "The number of nodes in the list is n.",
            "1 <= k <= n <= 5000",
            "0 <= Node.val <= 1000"
        ],
        "solutions": {
            "brute": {
                "intuition": "Collect nodes, reverse groups.",
                "algorithm": "1. Store in array\n2. Reverse each k group",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(n)"
                },
                "code": {
                    "python": "class Solution:\n    def reverseKGroup(self, head, k):\n        nodes = []\n        while head: nodes.append(head); head = head.next\n        for i in range(0, len(nodes) - len(nodes) % k, k):\n            l, r = i, i + k - 1\n            while l < r: nodes[l], nodes[r] = nodes[r], nodes[l]; l += 1; r -= 1\n        for i in range(len(nodes) - 1): nodes[i].next = nodes[i + 1]\n        if nodes: nodes[-1].next = None\n        return nodes[0] if nodes else None",
                    "java": "class Solution { public ListNode reverseKGroup(ListNode head, int k) { List<ListNode> nodes = new ArrayList<>(); while (head != null) { nodes.add(head); head = head.next; } for (int i = 0; i + k <= nodes.size(); i += k) { int l = i, r = i + k - 1; while (l < r) { ListNode t = nodes.get(l); nodes.set(l, nodes.get(r)); nodes.set(r, t); l++; r--; } } for (int i = 0; i < nodes.size() - 1; i++) nodes.get(i).next = nodes.get(i + 1); if (!nodes.isEmpty()) nodes.get(nodes.size() - 1).next = null; return nodes.isEmpty() ? null : nodes.get(0); } }",
                    "cpp": "class Solution { public: ListNode* reverseKGroup(ListNode* head, int k) { vector<ListNode*> nodes; while (head) { nodes.push_back(head); head = head->next; } for (int i = 0; i + k <= nodes.size(); i += k) { int l = i, r = i + k - 1; while (l < r) swap(nodes[l++], nodes[r--]); } for (int i = 0; i < nodes.size() - 1; i++) nodes[i]->next = nodes[i + 1]; if (!nodes.empty()) nodes.back()->next = nullptr; return nodes.empty() ? nullptr : nodes[0]; } };"
                }
            },
            "optimized": {
                "intuition": "In-place reversal.",
                "algorithm": "Reverse k nodes at a time",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)"
                },
                "code": {
                    "python": "class Solution:\n    def reverseKGroup(self, head, k):\n        dummy = ListNode(0, head)\n        prev = dummy\n        while True:\n            kth = prev\n            for _ in range(k):\n                kth = kth.next\n                if not kth: return dummy.next\n            nxt = kth.next\n            cur = prev.next\n            for _ in range(k - 1):\n                tmp = cur.next\n                cur.next = tmp.next\n                tmp.next = prev.next\n                prev.next = tmp\n            prev = cur",
                    "java": "class Solution { public ListNode reverseKGroup(ListNode head, int k) { ListNode dummy = new ListNode(0, head), prev = dummy; while (true) { ListNode kth = prev; for (int i = 0; i < k; i++) { kth = kth.next; if (kth == null) return dummy.next; } ListNode nxt = kth.next, cur = prev.next; for (int i = 0; i < k - 1; i++) { ListNode tmp = cur.next; cur.next = tmp.next; tmp.next = prev.next; prev.next = tmp; } prev = cur; } } }",
                    "cpp": "class Solution { public: ListNode* reverseKGroup(ListNode* head, int k) { ListNode dummy(0, head); ListNode* prev = &dummy; while (true) { ListNode* kth = prev; for (int i = 0; i < k; i++) { kth = kth->next; if (!kth) return dummy.next; } ListNode* nxt = kth->next, *cur = prev->next; for (int i = 0; i < k - 1; i++) { ListNode* tmp = cur->next; cur->next = tmp->next; tmp->next = prev->next; prev->next = tmp; } prev = cur; } } };"
                }
            }
        }
    },
    "find-the-duplicate-number": {
        "description": "<p>Given an array of integers <code>nums</code> containing <code>n + 1</code> integers where each integer is in the range <code>[1, n]</code> inclusive, return <em>the duplicate number</em>.</p><p>There is only <strong>one repeated number</strong> in <code>nums</code>, return <em>this repeated number</em>.</p><p><strong>Challenge:</strong> You must solve the problem <strong>without modifying</strong> the array <code>nums</code> and uses only <strong>constant extra space</strong>. This problem can be brilliantly solved using <strong>Floyd's Cycle Detection Algorithm</strong> by treating the array as a linked list where <code>nums[i]</code> points to index <code>nums[i]</code>.</p>",
        "examples": [
            {
                "input": "nums = [1,3,4,2,2]",
                "output": "2",
                "explanation": "The number 2 appears twice in the array."
            },
            {
                "input": "nums = [3,1,3,4,2]",
                "output": "3",
                "explanation": "The number 3 appears twice. Following the cycle: 0->3->4->2->1->3 (cycle detected)."
            },
            {
                "input": "nums = [3,3,3,3,3]",
                "output": "3",
                "explanation": "All elements are 3, so 3 is the duplicate."
            }
        ],
        "constraints": [
            "<code>1 <= n <= 10<sup>5</sup></code>",
            "<code>nums.length == n + 1</code>",
            "<code>1 <= nums[i] <= n</code>",
            "<code>All the integers in nums appear only once except for precisely one integer which appears two or more times</code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "Hash set detection.",
                "algorithm": "Add to set, return if seen",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(n)"
                },
                "code": {
                    "python": "class Solution:\n    def findDuplicate(self, nums):\n        seen = set()\n        for n in nums:\n            if n in seen: return n\n            seen.add(n)\n        return -1",
                    "java": "class Solution { public int findDuplicate(int[] nums) { Set<Integer> seen = new HashSet<>(); for (int n : nums) { if (seen.contains(n)) return n; seen.add(n); } return -1; } }",
                    "cpp": "class Solution { public: int findDuplicate(vector<int>& nums) { unordered_set<int> seen; for (int n : nums) { if (seen.count(n)) return n; seen.insert(n); } return -1; } };"
                }
            },
            "optimized": {
                "intuition": "Floyd's cycle detection.",
                "algorithm": "Slow/fast pointers",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)"
                },
                "code": {
                    "python": "class Solution:\n    def findDuplicate(self, nums):\n        slow = fast = nums[0]\n        while True:\n            slow = nums[slow]\n            fast = nums[nums[fast]]\n            if slow == fast: break\n        slow = nums[0]\n        while slow != fast:\n            slow = nums[slow]\n            fast = nums[fast]\n        return slow",
                    "java": "class Solution { public int findDuplicate(int[] nums) { int slow = nums[0], fast = nums[0]; do { slow = nums[slow]; fast = nums[nums[fast]]; } while (slow != fast); slow = nums[0]; while (slow != fast) { slow = nums[slow]; fast = nums[fast]; } return slow; } }",
                    "cpp": "class Solution { public: int findDuplicate(vector<int>& nums) { int slow = nums[0], fast = nums[0]; do { slow = nums[slow]; fast = nums[nums[fast]]; } while (slow != fast); slow = nums[0]; while (slow != fast) { slow = nums[slow]; fast = nums[fast]; } return slow; } };"
                }
            }
        }
    },
    "trapping-rain-water": {
        description: `<p>Given <code>n</code> non-negative integers representing an elevation map where the width of each bar is <code>1</code>, compute how much water it can trap after raining.</p>
<p>Imagine bars of different heights placed next to each other like a histogram. When it rains, water accumulates between the bars in the "valleys" or "troughs" formed by taller bars on either side.</p>
<p><strong>Key Insight:</strong> The amount of water above any bar depends on the minimum of the maximum heights to its left and right. If <code>min(maxLeft, maxRight) > height[i]</code>, then water can accumulate at position <code>i</code>.</p>
<p><strong>Visual Example:</strong> For <code>[0,1,0,2,1,0,1,3,2,1,2,1]</code>:</p>
<pre>
     ‚ñà
 ‚ñà   ‚ñà ‚ñà   ‚ñà ‚ñà
 ‚ñà ‚ñà ‚ñà ‚ñà ‚ñà ‚ñà ‚ñà ‚ñà ‚ñà
 0 1 0 2 1 0 1 3 2 1 2 1
</pre>
<p>Water (shown as ~) fills the gaps:</p>
<pre>
     ‚ñà
 ‚ñà ~ ‚ñà ‚ñà ~ ‚ñà ‚ñà
 ‚ñà ‚ñà ‚ñà ‚ñà ‚ñà ‚ñà ‚ñà ‚ñà ‚ñà
</pre>
<p>The trapped water equals 6 units total.</p>`,
        examples: [
            {
                input: 'height = [0,1,0,2,1,0,1,3,2,1,2,1]',
                output: '6',
                explanation: 'The elevation map forms valleys where water can be trapped. At index 2, the water level is min(2, 3) = 2, so we trap 2 - 0 = 2 units. At index 4, we trap min(2, 3) - 1 = 1 unit. At index 5, we trap min(2, 3) - 0 = 2 units. Total = 2 + 1 + 2 + 1 (at index 6 after bar height 1) = 6 units.'
            },
            {
                input: 'height = [4,2,0,3,2,5]',
                output: '9',
                explanation: 'The elevation map traps water in the valley between bars of height 4 and 5. At each position: index 1: min(4,5)-2=2, index 2: min(4,5)-0=4, index 3: min(4,5)-3=1, index 4: min(4,5)-2=2. Total = 2+4+1+2 = 9 units.'
            },
            {
                input: 'height = [3,0,2,0,4]',
                output: '7',
                explanation: 'Water traps between the bars: at index 1: min(3,4)-0=3, index 2: min(3,4)-2=1, index 3: min(3,4)-0=3. Total = 3+1+3 = 7 units.'
            },
            {
                input: 'height = [1,2,3,4,5]',
                output: '0',
                explanation: 'The bars are in strictly increasing order, so no water can be trapped. Every bar is lower than or equal to all bars to its right, creating no valleys.'
            }
        ],
        constraints: [
            "<code>n == height.length</code>",
            "<code>1 <= n <= 2 * 10<sup>4</sup></code>",
            "<code>0 <= height[i] <= 10<sup>5</sup></code>"
        ],
        solutions: {
            brute: {
                intuition: "For each position, find the maximum height to its left and the maximum height to its right. The water level at that position is determined by the minimum of these two maxima. Subtract the bar's height to get the trapped water. This requires O(n) work for each of the n positions.",
                algorithm: [
                    "Initialize total water to 0",
                    "For each index i from 0 to n-1:",
                    "  Find maxLeft: maximum height in height[0...i]",
                    "  Find maxRight: maximum height in height[i...n-1]",
                    "  Water level at i = min(maxLeft, maxRight)",
                    "  Trapped water at i = max(0, waterLevel - height[i])",
                    "  Add trapped water to total",
                    "Return total water"
                ],
                complexity: {
                    time: "O(n¬≤) where n is the length of height array. For each of n positions, we scan up to n elements to find the maximum on left and right sides.",
                    space: "O(1) as we only use variables to track maxLeft, maxRight, and total water, without additional data structures."
                },
                code: {
                    python: `def trap(height):
    if not height:
        return 0
    
    n = len(height)
    total_water = 0
    
    # For each position, find max left and right
    for i in range(n):
        # Find maximum height to the left
        max_left = 0
        for j in range(i + 1):
            max_left = max(max_left, height[j])
        
        # Find maximum height to the right
        max_right = 0
        for j in range(i, n):
            max_right = max(max_right, height[j])
        
        # Water level at this position
        water_level = min(max_left, max_right)
        
        # Add trapped water
        total_water += water_level - height[i]
    
    return total_water`,
                    java: `class Solution {
    public int trap(int[] height) {
        if (height.length == 0) return 0;
        
        int n = height.length;
        int totalWater = 0;
        
        // For each position, find max left and right
        for (int i = 0; i < n; i++) {
            // Find maximum height to the left
            int maxLeft = 0;
            for (int j = 0; j <= i; j++) {
                maxLeft = Math.max(maxLeft, height[j]);
            }
            
            // Find maximum height to the right
            int maxRight = 0;
            for (int j = i; j < n; j++) {
                maxRight = Math.max(maxRight, height[j]);
            }
            
            // Water level at this position
            int waterLevel = Math.min(maxLeft, maxRight);
            
            // Add trapped water
            totalWater += waterLevel - height[i];
        }
        
        return totalWater;
    }
}`,
                    cpp: `class Solution {
public:
    int trap(vector<int>& height) {
        if (height.empty()) return 0;
        
        int n = height.size();
        int totalWater = 0;
        
        // For each position, find max left and right
        for (int i = 0; i < n; i++) {
            // Find maximum height to the left
            int maxLeft = 0;
            for (int j = 0; j <= i; j++) {
                maxLeft = max(maxLeft, height[j]);
            }
            
            // Find maximum height to the right
            int maxRight = 0;
            for (int j = i; j < n; j++) {
                maxRight = max(maxRight, height[j]);
            }
            
            // Water level at this position
            int waterLevel = min(maxLeft, maxRight);
            
            // Add trapped water
            totalWater += waterLevel - height[i];
        }
        
        return totalWater;
    }
};`,
                    javascript: `function trap(height) {
    if (height.length === 0) return 0;
    
    const n = height.length;
    let totalWater = 0;
    
    // For each position, find max left and right
    for (let i = 0; i < n; i++) {
        // Find maximum height to the left
        let maxLeft = 0;
        for (let j = 0; j <= i; j++) {
            maxLeft = Math.max(maxLeft, height[j]);
        }
        
        // Find maximum height to the right
        let maxRight = 0;
        for (let j = i; j < n; j++) {
            maxRight = Math.max(maxRight, height[j]);
        }
        
        // Water level at this position
        const waterLevel = Math.min(maxLeft, maxRight);
        
        // Add trapped water
        totalWater += waterLevel - height[i];
    }
    
    return totalWater;
}`
                }
            },
            optimized: {
                intuition: "Use two pointers starting from both ends. Track the maximum heights seen so far from both sides. The pointer with the smaller maximum determines how much water can be trapped at its position. Move that pointer inward. This ensures each position is processed once while maintaining the necessary maximum heights.",
                algorithm: [
                    "Initialize two pointers: left = 0, right = n-1",
                    "Initialize maxLeft = height[left], maxRight = height[right]",
                    "Initialize totalWater = 0",
                    "While left < right:",
                    "  If maxLeft < maxRight:",
                    "    Move left pointer: left++",
                    "    Update maxLeft = max(maxLeft, height[left])",
                    "    Add trapped water: totalWater += maxLeft - height[left]",
                    "  Else:",
                    "    Move right pointer: right--",
                    "    Update maxRight = max(maxRight, height[right])",
                    "    Add trapped water: totalWater += maxRight - height[right]",
                    "Return totalWater"
                ],
                complexity: {
                    time: "O(n) where n is the length of height array. We traverse the array once with two pointers, processing each element exactly once.",
                    space: "O(1) as we only use a constant number of variables (left, right, maxLeft, maxRight, totalWater) regardless of input size."
                },
                code: {
                    python: `def trap(height):
    if not height:
        return 0
    
    left, right = 0, len(height) - 1
    max_left = height[left]
    max_right = height[right]
    total_water = 0
    
    while left < right:
        if max_left < max_right:
            # Process left side
            left += 1
            max_left = max(max_left, height[left])
            total_water += max_left - height[left]
        else:
            # Process right side
            right -= 1
            max_right = max(max_right, height[right])
            total_water += max_right - height[right]
    
    return total_water`,
                    java: `class Solution {
    public int trap(int[] height) {
        if (height.length == 0) return 0;
        
        int left = 0, right = height.length - 1;
        int maxLeft = height[left], maxRight = height[right];
        int totalWater = 0;
        
        while (left < right) {
            if (maxLeft < maxRight) {
                // Process left side
                left++;
                maxLeft = Math.max(maxLeft, height[left]);
                totalWater += maxLeft - height[left];
            } else {
                // Process right side
                right--;
                maxRight = Math.max(maxRight, height[right]);
                totalWater += maxRight - height[right];
            }
        }
        
        return totalWater;
    }
}`,
                    cpp: `class Solution {
public:
    int trap(vector<int>& height) {
        if (height.empty()) return 0;
        
        int left = 0, right = height.size() - 1;
        int maxLeft = height[left], maxRight = height[right];
        int totalWater = 0;
        
        while (left < right) {
            if (maxLeft < maxRight) {
                // Process left side
                left++;
                maxLeft = max(maxLeft, height[left]);
                totalWater += maxLeft - height[left];
            } else {
                // Process right side
                right--;
                maxRight = max(maxRight, height[right]);
                totalWater += maxRight - height[right];
            }
        }
        
        return totalWater;
    }
};`,
                    javascript: `function trap(height) {
    if (height.length === 0) return 0;
    
    let left = 0, right = height.length - 1;
    let maxLeft = height[left], maxRight = height[right];
    let totalWater = 0;
    
    while (left < right) {
        if (maxLeft < maxRight) {
            // Process left side
            left++;
            maxLeft = Math.max(maxLeft, height[left]);
            totalWater += maxLeft - height[left];
        } else {
            // Process right side
            right--;
            maxRight = Math.max(maxRight, height[right]);
            totalWater += maxRight - height[right];
        }
    }
    
    return totalWater;
}`
                }
            }
        }
    },
    "longest-repeating-character-replacement": {
        description: `<p>You are given a string <code>s</code> and an integer <code>k</code>. You can choose any character of the string and change it to any other uppercase English character. You can perform this operation at most <code>k</code> times.</p>
<p>Return <em>the length of the longest substring containing the same letter you can get after performing the above operations</em>.</p>
<p>The key insight is that for any window to be valid, the number of characters that need to be replaced equals the window length minus the count of the most frequent character in that window. If this value is less than or equal to k, the window is valid.</p>
<p><strong>Formula:</strong> <code>replacements_needed = window_length - max_frequency</code>. If <code>replacements_needed <= k</code>, the window is valid.</p>`,
        examples: [
            {
                input: 's = "ABAB", k = 2',
                output: '4',
                explanation: 'Replace the two \'A\'s with two \'B\'s or vice versa to get "BBBB" or "AAAA". The length is 4.'
            },
            {
                input: 's = "AABABBA", k = 1',
                output: '4',
                explanation: 'Replace one \'A\' in the middle with \'B\' to get "AABBBBA". The substring "BBBB" has length 4. Alternatively, you could get "AAAA" by replacing one B.'
            },
            {
                input: 's = "ABBB", k = 2',
                output: '4',
                explanation: 'Replace the \'A\' with \'B\' to make the entire string "BBBB". Only 1 replacement is needed, which is <= k=2.'
            },
            {
                input: 's = "AAAA", k = 0',
                output: '4',
                explanation: 'All characters are already the same, so no replacements are needed.'
            }
        ],
        constraints: [
            "<code>1 <= s.length <= 10<sup>5</sup></code>",
            "<code>s</code> consists of only uppercase English letters.",
            "<code>0 <= k <= s.length</code>"
        ],
        solutions: {
            brute: {
                intuition: "Check every possible substring. For each substring, count the frequency of each character and determine if we can make all characters the same with at most k replacements. The formula is: if (substring_length - max_character_frequency) <= k, then it's valid.",
                algorithm: [
                    "For each starting position i:",
                    "  Initialize a frequency counter",
                    "  For each ending position j from i to n:",
                    "    Add character at j to frequency counter",
                    "    Find the maximum frequency among all characters",
                    "    Calculate replacements needed = (j - i + 1) - max_frequency",
                    "    If replacements_needed <= k, update result with current length",
                    "Return the maximum length found"
                ],
                complexity: {
                    time: "O(n¬≤) where n is the length of the string. We check O(n¬≤) substrings, and for each we do O(1) or O(26) work.",
                    space: "O(1) since we use a fixed-size array of 26 elements for uppercase letters."
                },
                code: {
                    python: `def characterReplacement(s, k):
    n = len(s)
    max_length = 0
    
    # Try all possible substrings
    for i in range(n):
        count = {}
        max_freq = 0
        
        for j in range(i, n):
            # Add current character
            count[s[j]] = count.get(s[j], 0) + 1
            max_freq = max(max_freq, count[s[j]])
            
            # Check if valid (replacements needed <= k)
            window_length = j - i + 1
            if window_length - max_freq <= k:
                max_length = max(max_length, window_length)
    
    return max_length`,
                    java: `class Solution {
    public int characterReplacement(String s, int k) {
        int n = s.length();
        int maxLength = 0;
        
        // Try all possible substrings
        for (int i = 0; i < n; i++) {
            int[] count = new int[26];
            int maxFreq = 0;
            
            for (int j = i; j < n; j++) {
                // Add current character
                count[s.charAt(j) - 'A']++;
                maxFreq = Math.max(maxFreq, count[s.charAt(j) - 'A']);
                
                // Check if valid
                int windowLength = j - i + 1;
                if (windowLength - maxFreq <= k) {
                    maxLength = Math.max(maxLength, windowLength);
                }
            }
        }
        
        return maxLength;
    }
}`,
                    cpp: `class Solution {
public:
    int characterReplacement(string s, int k) {
        int n = s.size();
        int maxLength = 0;
        
        // Try all possible substrings
        for (int i = 0; i < n; i++) {
            int count[26] = {};
            int maxFreq = 0;
            
            for (int j = i; j < n; j++) {
                // Add current character
                count[s[j] - 'A']++;
                maxFreq = max(maxFreq, count[s[j] - 'A']);
                
                // Check if valid
                int windowLength = j - i + 1;
                if (windowLength - maxFreq <= k) {
                    maxLength = max(maxLength, windowLength);
                }
            }
        }
        
        return maxLength;
    }
};`,
                    javascript: `function characterReplacement(s, k) {
    const n = s.length;
    let maxLength = 0;
    
    // Try all possible substrings
    for (let i = 0; i < n; i++) {
        const count = new Array(26).fill(0);
        let maxFreq = 0;
        
        for (let j = i; j < n; j++) {
            // Add current character
            const charIndex = s.charCodeAt(j) - 65; // 'A' = 65
            count[charIndex]++;
            maxFreq = Math.max(maxFreq, count[charIndex]);
            
            // Check if valid
            const windowLength = j - i + 1;
            if (windowLength - maxFreq <= k) {
                maxLength = Math.max(maxLength, windowLength);
            }
        }
    }
    
    return maxLength;
}`
                }
            },
            optimized: {
                intuition: "Use a sliding window approach. Maintain a window where the number of replacements needed doesn't exceed k. Track the maximum character frequency in the current window. When the window becomes invalid (replacements > k), shrink it from the left. The key optimization is that we don't need to update maxFreq when shrinking.",
                algorithm: [
                    "Initialize left = 0, maxFreq = 0, maxLength = 0",
                    "Use a frequency array for character counts",
                    "For each right pointer from 0 to n-1:",
                    "  Add character at right to frequency array",
                    "  Update maxFreq if current character frequency is higher",
                    "  While window is invalid (window_length - maxFreq > k):",
                    "    Remove character at left from frequency array",
                    "    Move left pointer right",
                    "  Update maxLength with current window size",
                    "Return maxLength"
                ],
                complexity: {
                    time: "O(n) where n is the length of the string. Each character is visited at most twice (once by right, once by left pointer).",
                    space: "O(1) as we use a fixed-size array of 26 elements."
                },
                code: {
                    python: `def characterReplacement(s, k):
    count = {}
    left = 0
    max_freq = 0
    max_length = 0
    
    for right in range(len(s)):
        # Add character to window
        count[s[right]] = count.get(s[right], 0) + 1
        max_freq = max(max_freq, count[s[right]])
        
        # Shrink window if invalid
        window_length = right - left + 1
        if window_length - max_freq > k:
            count[s[left]] -= 1
            left += 1
        
        # Update result
        max_length = max(max_length, right - left + 1)
    
    return max_length`,
                    java: `class Solution {
    public int characterReplacement(String s, int k) {
        int[] count = new int[26];
        int left = 0;
        int maxFreq = 0;
        int maxLength = 0;
        
        for (int right = 0; right < s.length(); right++) {
            // Add character to window
            count[s.charAt(right) - 'A']++;
            maxFreq = Math.max(maxFreq, count[s.charAt(right) - 'A']);
            
            // Shrink window if invalid
            int windowLength = right - left + 1;
            if (windowLength - maxFreq > k) {
                count[s.charAt(left) - 'A']--;
                left++;
            }
            
            // Update result
            maxLength = Math.max(maxLength, right - left + 1);
        }
        
        return maxLength;
    }
}`,
                    cpp: `class Solution {
public:
    int characterReplacement(string s, int k) {
        int count[26] = {};
        int left = 0;
        int maxFreq = 0;
        int maxLength = 0;
        
        for (int right = 0; right < s.size(); right++) {
            // Add character to window
            count[s[right] - 'A']++;
            maxFreq = max(maxFreq, count[s[right] - 'A']);
            
            // Shrink window if invalid
            int windowLength = right - left + 1;
            if (windowLength - maxFreq > k) {
                count[s[left] - 'A']--;
                left++;
            }
            
            // Update result
            maxLength = max(maxLength, right - left + 1);
        }
        
        return maxLength;
    }
};`,
                    javascript: `function characterReplacement(s, k) {
    const count = new Array(26).fill(0);
    let left = 0;
    let maxFreq = 0;
    let maxLength = 0;
    
    for (let right = 0; right < s.length; right++) {
        // Add character to window
        const rightChar = s.charCodeAt(right) - 65;
        count[rightChar]++;
        maxFreq = Math.max(maxFreq, count[rightChar]);
        
        // Shrink window if invalid
        const windowLength = right - left + 1;
        if (windowLength - maxFreq > k) {
            const leftChar = s.charCodeAt(left) - 65;
            count[leftChar]--;
            left++;
        }
        
        // Update result
        maxLength = Math.max(maxLength, right - left + 1);
    }
    
    return maxLength;
}`
                }
            }
        }
    },
    "minimum-window-substring": {
        description: `<p>Given two strings <code>s</code> and <code>t</code> of lengths <code>m</code> and <code>n</code> respectively, return <em>the <strong>minimum window substring</strong> of </em><code>s</code><em> such that every character in </em><code>t</code><em> (<strong>including duplicates</strong>) is included in the window</em>. If there is no such substring, return <em>the empty string </em><code>""</code>.</p>
<p>A <strong>substring</strong> is a contiguous sequence of characters within a string. The testcases will be generated such that the answer is <strong>unique</strong>.</p>
<p>This is a challenging problem that requires finding the smallest window in string <code>s</code> that contains all characters from string <code>t</code> with their required frequencies. For example, if <code>t = "AAB"</code>, the window must contain at least two A's and one B.</p>
<p><strong>Key Challenge:</strong> We need to efficiently track when a window contains all required characters and shrink it to find the minimum length while maintaining the requirement.</p>`,
        examples: [
            {
                input: 's = "ADOBECODEBANC", t = "ABC"',
                output: '"BANC"',
                explanation: 'The minimum window substring "BANC" includes A, B, and C from string t.'
            },
            {
                input: 's = "a", t = "a"',
                output: '"a"',
                explanation: 'The entire string s is the minimum window.'
            },
            {
                input: 's = "a", t = "aa"',
                output: '""',
                explanation: 'Both a characters from t must be included in the window. Since the largest window of s only has one a, return empty string.'
            },
            {
                input: 's = "ADOBECODEBANC", t = "AABC"',
                output: '"ADOBECODEBA"',
                explanation: 'We need at least two As, one B, and one C. The minimum window that satisfies this is "ADOBECODEBA".'
            }
        ],
        constraints: [
            "<code>m == s.length</code>",
            "<code>n == t.length</code>",
            "<code>1 <= m, n <= 10<sup>5</sup></code>",
            "<code>s</code> and <code>t</code> consist of uppercase and lowercase English letters."
        ],
        solutions: {
            brute: {
                intuition: "Check every possible substring of s to see if it contains all characters from t with required frequencies. For each valid substring, track the minimum length. This approach examines all O(n¬≤) substrings and validates each one.",
                algorithm: [
                    "Count frequency of each character in t",
                    "For each starting position i in s:",
                    "  Initialize a frequency counter for current window",
                    "  For each ending position j from i to m:",
                    "    Add character s[j] to window counter",
                    "    Check if window contains all characters from t with required frequencies",
                    "    If valid and smaller than current minimum, update result",
                    "    Break if valid (no point extending further from this start)",
                    "Return the minimum window found"
                ],
                complexity: {
                    time: "O(m¬≤ * n) where m is length of s and n is length of t. We check O(m¬≤) substrings, and for each we validate against t in O(n) time.",
                    space: "O(m + n) for storing character frequencies of both strings."
                },
                code: {
                    python: `def minWindow(s, t):
    from collections import Counter
    
    if len(t) > len(s):
        return ""
    
    t_count = Counter(t)
    min_window = ""
    min_length = float('inf')
    
    # Try all possible substrings
    for i in range(len(s)):
        window_count = Counter()
        
        for j in range(i, len(s)):
            window_count[s[j]] += 1
            
            # Check if window is valid
            if all(window_count[char] >= t_count[char] for char in t_count):
                if j - i + 1 < min_length:
                    min_length = j - i + 1
                    min_window = s[i:j+1]
                break  # No need to extend further from this start
    
    return min_window`,
                    java: `class Solution {
    public String minWindow(String s, String t) {
        if (t.length() > s.length()) return "";
        
        int[] tCount = new int[128];
        for (char c : t.toCharArray()) {
            tCount[c]++;
        }
        
        String minWindow = "";
        int minLength = Integer.MAX_VALUE;
        
        // Try all possible substrings
        for (int i = 0; i < s.length(); i++) {
            int[] windowCount = new int[128];
            
            for (int j = i; j < s.length(); j++) {
                windowCount[s.charAt(j)]++;
                
                // Check if window is valid
                boolean isValid = true;
                for (int k = 0; k < 128; k++) {
                    if (windowCount[k] < tCount[k]) {
                        isValid = false;
                        break;
                    }
                }
                
                if (isValid) {
                    if (j - i + 1 < minLength) {
                        minLength = j - i + 1;
                        minWindow = s.substring(i, j + 1);
                    }
                    break;
                }
            }
        }
        
        return minWindow;
    }
}`,
                    cpp: `class Solution {
public:
    string minWindow(string s, string t) {
        if (t.size() > s.size()) return "";
        
        int tCount[128] = {};
        for (char c : t) {
            tCount[c]++;
        }
        
        string minWindow = "";
        int minLength = INT_MAX;
        
        // Try all possible substrings
        for (int i = 0; i < s.size(); i++) {
            int windowCount[128] = {};
            
            for (int j = i; j < s.size(); j++) {
                windowCount[s[j]]++;
                
                // Check if window is valid
                bool isValid = true;
                for (int k = 0; k < 128; k++) {
                    if (windowCount[k] < tCount[k]) {
                        isValid = false;
                        break;
                    }
                }
                
                if (isValid) {
                    if (j - i + 1 < minLength) {
                        minLength = j - i + 1;
                        minWindow = s.substr(i, j - i + 1);
                    }
                    break;
                }
            }
        }
        
        return minWindow;
    }
};`,
                    javascript: `function minWindow(s, t) {
    if (t.length > s.length) return "";
    
    const tCount = {};
    for (const char of t) {
        tCount[char] = (tCount[char] || 0) + 1;
    }
    
    let minWindow = "";
    let minLength = Infinity;
    
    // Try all possible substrings
    for (let i = 0; i < s.length; i++) {
        const windowCount = {};
        
        for (let j = i; j < s.length; j++) {
            windowCount[s[j]] = (windowCount[s[j]] || 0) + 1;
            
            // Check if window is valid
            let isValid = true;
            for (const char in tCount) {
                if ((windowCount[char] || 0) < tCount[char]) {
                    isValid = false;
                    break;
                }
            }
            
            if (isValid) {
                if (j - i + 1 < minLength) {
                    minLength = j - i + 1;
                    minWindow = s.substring(i, j + 1);
                }
                break;
            }
        }
    }
    
    return minWindow;
}`
                }
            },
            optimized: {
                intuition: "Use a sliding window with two pointers. Track how many required characters we've satisfied. Expand the right pointer to include characters, and when the window is valid, shrink from the left to find the minimum length. Use a 'formed' counter to track when all character requirements are met.",
                algorithm: [
                    "Count frequency of each character in t and count unique characters (need)",
                    "Initialize left = 0, formed = 0, window frequency map",
                    "Use right pointer to expand window:",
                    "  Add character to window map",
                    "  If this character's requirement is now satisfied, increment formed",
                    "  While formed == need (window is valid):",
                    "    Update minimum window if current is smaller",
                    "    Remove character at left from window",
                    "    If this breaks a requirement, decrement formed",
                    "    Increment left to shrink window",
                    "Return minimum window found"
                ],
                complexity: {
                    time: "O(m + n) where m is length of s and n is length of t. Each character in s is visited at most twice (once by right pointer, once by left pointer), and we process t once.",
                    space: "O(m + n) for storing character frequencies and the window."
                },
                code: {
                    python: `def minWindow(s, t):
    if not s or not t:
        return ""
    
    from collections import Counter
    
    # Count characters in t
    t_count = Counter(t)
    required = len(t_count)
    
    # Window tracking
    window_count = {}
    formed = 0  # Number of unique chars in window with desired frequency
    
    left = 0
    min_len = float('inf')
    min_window = (0, 0)
    
    for right in range(len(s)):
        # Add character from right
        char = s[right]
        window_count[char] = window_count.get(char, 0) + 1
        
        # Check if frequency of current char matches requirement
        if char in t_count and window_count[char] == t_count[char]:
            formed += 1
        
        # Try to shrink window while it's valid
        while formed == required and left <= right:
            # Update result if this window is smaller
            if right - left + 1 < min_len:
                min_len = right - left + 1
                min_window = (left, right)
            
            # Remove character from left
            char = s[left]
            window_count[char] -= 1
            if char in t_count and window_count[char] < t_count[char]:
                formed -= 1
            
            left += 1
    
    return "" if min_len == float('inf') else s[min_window[0]:min_window[1] + 1]`,
                    java: `class Solution {
    public String minWindow(String s, String t) {
        if (s.length() == 0 || t.length() == 0) return "";
        
        // Count characters in t
        Map<Character, Integer> tCount = new HashMap<>();
        for (char c : t.toCharArray()) {
            tCount.put(c, tCount.getOrDefault(c, 0) + 1);
        }
        
        int required = tCount.size();
        int formed = 0;
        Map<Character, Integer> windowCount = new HashMap<>();
        
        int left = 0;
        int minLen = Integer.MAX_VALUE;
        int[] minWindow = {0, 0};
        
        for (int right = 0; right < s.length(); right++) {
            // Add character from right
            char c = s.charAt(right);
            windowCount.put(c, windowCount.getOrDefault(c, 0) + 1);
            
            if (tCount.containsKey(c) && 
                windowCount.get(c).intValue() == tCount.get(c).intValue()) {
                formed++;
            }
            
            // Shrink window while valid
            while (formed == required && left <= right) {
                // Update result
                if (right - left + 1 < minLen) {
                    minLen = right - left + 1;
                    minWindow[0] = left;
                    minWindow[1] = right;
                }
                
                // Remove from left
                char leftChar = s.charAt(left);
                windowCount.put(leftChar, windowCount.get(leftChar) - 1);
                if (tCount.containsKey(leftChar) && 
                    windowCount.get(leftChar) < tCount.get(leftChar)) {
                    formed--;
                }
                
                left++;
            }
        }
        
        return minLen == Integer.MAX_VALUE ? 
            "" : s.substring(minWindow[0], minWindow[1] + 1);
    }
}`,
                    cpp: `class Solution {
public:
    string minWindow(string s, string t) {
        if (s.empty() || t.empty()) return "";
        
        // Count characters in t
        unordered_map<char, int> tCount;
        for (char c : t) {
            tCount[c]++;
        }
        
        int required = tCount.size();
        int formed = 0;
        unordered_map<char, int> windowCount;
        
        int left = 0;
        int minLen = INT_MAX;
        pair<int, int> minWindow = {0, 0};
        
        for (int right = 0; right < s.size(); right++) {
            // Add character from right
            char c = s[right];
            windowCount[c]++;
            
            if (tCount.find(c) != tCount.end() && 
                windowCount[c] == tCount[c]) {
                formed++;
            }
            
            // Shrink window while valid
            while (formed == required && left <= right) {
                // Update result
                if (right - left + 1 < minLen) {
                    minLen = right - left + 1;
                    minWindow = {left, right};
                }
                
                // Remove from left
                char leftChar = s[left];
                windowCount[leftChar]--;
                if (tCount.find(leftChar) != tCount.end() && 
                    windowCount[leftChar] < tCount[leftChar]) {
                    formed--;
                }
                
                left++;
            }
        }
        
        return minLen == INT_MAX ? 
            "" : s.substr(minWindow.first, minLen);
    }
};`,
                    javascript: `function minWindow(s, t) {
    if (!s || !t) return "";
    
    // Count characters in t
    const tCount = {};
    for (const char of t) {
        tCount[char] = (tCount[char] || 0) + 1;
    }
    
    const required = Object.keys(tCount).length;
    let formed = 0;
    const windowCount = {};
    
    let left = 0;
    let minLen = Infinity;
    let minWindow = [0, 0];
    
    for (let right = 0; right < s.length; right++) {
        // Add character from right
        const char = s[right];
        windowCount[char] = (windowCount[char] || 0) + 1;
        
        if (char in tCount && windowCount[char] === tCount[char]) {
            formed++;
        }
        
        // Shrink window while valid
        while (formed === required && left <= right) {
            // Update result
            if (right - left + 1 < minLen) {
                minLen = right - left + 1;
                minWindow = [left, right];
            }
            
            // Remove from left
            const leftChar = s[left];
            windowCount[leftChar]--;
            if (leftChar in tCount && 
                windowCount[leftChar] < tCount[leftChar]) {
                formed--;
            }
            
            left++;
        }
    }
    
    return minLen === Infinity ? 
        "" : s.substring(minWindow[0], minWindow[1] + 1);
}`
                }
            }
        }
    },
    "sliding-window-maximum": {
        description: `<p>You are given an array of integers <code>nums</code>, and there is a sliding window of size <code>k</code> which is moving from the very left to the very right. You can only see the <code>k</code> numbers in the window. Each time the sliding window moves right by one position.</p>
<p>Return <em>the max sliding window</em>.</p>
<p>For example, if <code>nums = [1,3,-1,-3,5,3,6,7]</code> and <code>k = 3</code>, the windows are:</p>
<ul>
<li>[1,3,-1], -3,5,3,6,7 ‚Üí max is 3</li>
<li>1,[3,-1,-3],5,3,6,7 ‚Üí max is 3</li>
<li>1,3,[-1,-3,5],3,6,7 ‚Üí max is 5</li>
<li>1,3,-1,[-3,5,3],6,7 ‚Üí max is 5</li>
<li>1,3,-1,-3,[5,3,6],7 ‚Üí max is 6</li>
<li>1,3,-1,-3,5,[3,6,7] ‚Üí max is 7</li>
</ul>
<p><strong>Key Challenge:</strong> Finding the maximum in each window efficiently. A naive approach would take O(n*k) time, but we can optimize to O(n) using a monotonic deque data structure.</p>`,
        examples: [
            {
                input: 'nums = [1,3,-1,-3,5,3,6,7], k = 3',
                output: '[3,3,5,5,6,7]',
                explanation: 'Window position                Max\n---------------               -----\n[1  3  -1] -3  5  3  6  7       3\n 1 [3  -1  -3] 5  3  6  7       3\n 1  3 [-1  -3  5] 3  6  7       5\n 1  3  -1 [-3  5  3] 6  7       5\n 1  3  -1  -3 [5  3  6] 7       6\n 1  3  -1  -3  5 [3  6  7]      7'
            },
            {
                input: 'nums = [1], k = 1',
                output: '[1]',
                explanation: 'The only window of size 1 is [1], and the maximum is 1.'
            },
            {
                input: 'nums = [1,-1], k = 1',
                output: '[1,-1]',
                explanation: 'Each element forms a window by itself.'
            },
            {
                input: 'nums = [9,11], k = 2',
                output: '[11]',
                explanation: 'The window [9,11] has maximum 11.'
            }
        ],
        constraints: [
            "<code>1 <= nums.length <= 10<sup>5</sup></code>",
            "<code>-10<sup>4</sup> <= nums[i] <= 10<sup>4</sup></code>",
            "<code>1 <= k <= nums.length</code>"
        ],
        solutions: {
            brute: {
                intuition: "For each window position, scan all k elements to find the maximum. This is straightforward but requires O(k) work for each of the O(n-k+1) windows.",
                algorithm: [
                    "For each starting position i from 0 to n-k:",
                    "  Initialize max with first element of window",
                    "  For each position j from i to i+k-1:",
                    "    Update max if nums[j] is larger",
                    "  Add max to result array",
                    "Return result array"
                ],
                complexity: {
                    time: "O(n * k) where n is the length of nums. We process (n-k+1) windows, and for each window we scan k elements to find the maximum.",
                    space: "O(1) extra space (not counting the output array)."
                },
                code: {
                    python: `def maxSlidingWindow(nums, k):
    n = len(nums)
    if n == 0 or k == 0:
        return []
    
    result = []
    
    # Process each window
    for i in range(n - k + 1):
        # Find max in current window
        max_val = nums[i]
        for j in range(i + 1, i + k):
            max_val = max(max_val, nums[j])
        
        result.append(max_val)
    
    return result`,
                    java: `class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        int n = nums.length;
        if (n == 0 || k == 0) return new int[0];
        
        int[] result = new int[n - k + 1];
        
        // Process each window
        for (int i = 0; i <= n - k; i++) {
            // Find max in current window
            int max = nums[i];
            for (int j = i + 1; j < i + k; j++) {
                max = Math.max(max, nums[j]);
            }
            
            result[i] = max;
        }
        
        return result;
    }
}`,
                    cpp: `class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        int n = nums.size();
        if (n == 0 || k == 0) return {};
        
        vector<int> result;
        
        // Process each window
        for (int i = 0; i <= n - k; i++) {
            // Find max in current window
            int maxVal = nums[i];
            for (int j = i + 1; j < i + k; j++) {
                maxVal = max(maxVal, nums[j]);
            }
            
            result.push_back(maxVal);
        }
        
        return result;
    }
};`,
                    javascript: `function maxSlidingWindow(nums, k) {
    const n = nums.length;
    if (n === 0 || k === 0) return [];
    
    const result = [];
    
    // Process each window
    for (let i = 0; i <= n - k; i++) {
        // Find max in current window
        let max = nums[i];
        for (let j = i + 1; j < i + k; j++) {
            max = Math.max(max, nums[j]);
        }
        
        result.push(max);
    }
    
    return result;
}`
                }
            },
            optimized: {
                intuition: "Use a monotonic decreasing deque that stores indices. The front of the deque always contains the index of the maximum element in the current window. When adding a new element, remove all smaller elements from the back (they can never be the maximum). Remove indices that are out of the current window from the front.",
                algorithm: [
                    "Initialize an empty deque to store indices",
                    "For each index i in nums:",
                    "  Remove indices from front of deque that are out of window (< i - k + 1)",
                    "  Remove indices from back whose values are less than nums[i]",
                    "  Add current index i to back of deque",
                    "  If i >= k-1 (window is full), add nums[deque.front()] to result",
                    "Return result array"
                ],
                complexity: {
                    time: "O(n) where n is the length of nums. Each element is added and removed from the deque at most once.",
                    space: "O(k) for the deque, which stores at most k indices at any time."
                },
                code: {
                    python: `def maxSlidingWindow(nums, k):
    from collections import deque
    
    n = len(nums)
    if n == 0 or k == 0:
        return []
    
    dq = deque()  # Stores indices
    result = []
    
    for i in range(n):
        # Remove indices outside current window
        while dq and dq[0] < i - k + 1:
            dq.popleft()
        
        # Remove indices of elements smaller than current
        # (they can never be maximum)
        while dq and nums[dq[-1]] < nums[i]:
            dq.pop()
        
        # Add current index
        dq.append(i)
        
        # Add to result if window is full
        if i >= k - 1:
            result.append(nums[dq[0]])
    
    return result`,
                    java: `class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        int n = nums.length;
        if (n == 0 || k == 0) return new int[0];
        
        Deque<Integer> dq = new ArrayDeque<>();  // Stores indices
        int[] result = new int[n - k + 1];
        int resultIndex = 0;
        
        for (int i = 0; i < n; i++) {
            // Remove indices outside current window
            while (!dq.isEmpty() && dq.peekFirst() < i - k + 1) {
                dq.pollFirst();
            }
            
            // Remove indices of elements smaller than current
            while (!dq.isEmpty() && nums[dq.peekLast()] < nums[i]) {
                dq.pollLast();
            }
            
            // Add current index
            dq.offerLast(i);
            
            // Add to result if window is full
            if (i >= k - 1) {
                result[resultIndex++] = nums[dq.peekFirst()];
            }
        }
        
        return result;
    }
}`,
                    cpp: `class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        int n = nums.size();
        if (n == 0 || k == 0) return {};
        
        deque<int> dq;  // Stores indices
        vector<int> result;
        
        for (int i = 0; i < n; i++) {
            // Remove indices outside current window
            while (!dq.empty() && dq.front() < i - k + 1) {
                dq.pop_front();
            }
            
            // Remove indices of elements smaller than current
            while (!dq.empty() && nums[dq.back()] < nums[i]) {
                dq.pop_back();
            }
            
            // Add current index
            dq.push_back(i);
            
            // Add to result if window is full
            if (i >= k - 1) {
                result.push_back(nums[dq.front()]);
            }
        }
        
        return result;
    }
};`,
                    javascript: `function maxSlidingWindow(nums, k) {
    const n = nums.length;
    if (n === 0 || k === 0) return [];
    
    const dq = [];  // Stores indices
    const result = [];
    
    for (let i = 0; i < n; i++) {
        // Remove indices outside current window
        while (dq.length > 0 && dq[0] < i - k + 1) {
            dq.shift();
        }
        
        // Remove indices of elements smaller than current
        while (dq.length > 0 && nums[dq[dq.length - 1]] < nums[i]) {
            dq.pop();
        }
        
        // Add current index
        dq.push(i);
        
        // Add to result if window is full
        if (i >= k - 1) {
            result.push(nums[dq[0]]);
        }
    }
    
    return result;
}`
                }
            }
        }
    },
    "palindrome-linked-list": {
        "description": "<p>Given the <code>head</code> of a singly linked list, return <code>true</code> <em>if it is a palindrome or</em> <code>false</code> <em>otherwise</em>.</p><p>A <strong>palindrome</strong> reads the same forward and backward. For example, <code>[1,2,3,2,1]</code> is a palindrome, but <code>[1,2,3,4,5]</code> is not.</p><p><strong>Optimal Approach:</strong> Find the middle of the list using the slow/fast pointer technique, reverse the second half, then compare both halves. This achieves <strong>O(1) space complexity</strong> without using an array.</p>",
        "examples": [
            {
                "input": "head = [1,2,2,1]",
                "output": "true",
                "explanation": "The list reads the same forwards [1,2,2,1] and backwards [1,2,2,1]."
            },
            {
                "input": "head = [1,2]",
                "output": "false",
                "explanation": "The list [1,2] is not the same as its reverse [2,1]."
            },
            {
                "input": "head = [1,2,3,2,1]",
                "output": "true",
                "explanation": "The list is a palindrome: reading forwards and backwards gives the same sequence."
            }
        ],
        "constraints": [
            "<code>The number of nodes in the list is in the range [1, 10<sup>5</sup>]</code>",
            "<code>0 <= Node.val <= 9</code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "Copy to array.",
                "algorithm": "Compare with reverse",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(n)"
                },
                "code": {
                    "python": "class Solution:\n    def isPalindrome(self, head):\n        vals = []\n        while head: vals.append(head.val); head = head.next\n        return vals == vals[::-1]",
                    "java": "class Solution { public boolean isPalindrome(ListNode head) { List<Integer> v = new ArrayList<>(); while (head != null) { v.add(head.val); head = head.next; } int l = 0, r = v.size() - 1; while (l < r) if (!v.get(l++).equals(v.get(r--))) return false; return true; } }",
                    "cpp": "class Solution { public: bool isPalindrome(ListNode* head) { vector<int> v; while (head) { v.push_back(head->val); head = head->next; } int l = 0, r = v.size() - 1; while (l < r) if (v[l++] != v[r--]) return false; return true; } };"
                }
            },
            "optimized": {
                "intuition": "Reverse second half.",
                "algorithm": "Compare halves",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)"
                },
                "code": {
                    "python": "class Solution:\n    def isPalindrome(self, head):\n        slow = fast = head\n        while fast and fast.next: slow = slow.next; fast = fast.next.next\n        prev = None\n        while slow: tmp = slow.next; slow.next = prev; prev = slow; slow = tmp\n        l, r = head, prev\n        while r:\n            if l.val != r.val: return False\n            l = l.next; r = r.next\n        return True",
                    "java": "class Solution { public boolean isPalindrome(ListNode head) { ListNode slow = head, fast = head; while (fast != null && fast.next != null) { slow = slow.next; fast = fast.next.next; } ListNode prev = null; while (slow != null) { ListNode t = slow.next; slow.next = prev; prev = slow; slow = t; } ListNode l = head, r = prev; while (r != null) { if (l.val != r.val) return false; l = l.next; r = r.next; } return true; } }",
                    "cpp": "class Solution { public: bool isPalindrome(ListNode* head) { ListNode *slow = head, *fast = head; while (fast && fast->next) { slow = slow->next; fast = fast->next->next; } ListNode* prev = nullptr; while (slow) { ListNode* t = slow->next; slow->next = prev; prev = slow; slow = t; } ListNode *l = head, *r = prev; while (r) { if (l->val != r->val) return false; l = l->next; r = r->next; } return true; } };"
                }
            }
        }
    },
    "permutation-in-string": {
        description: `<p>Given two strings <code>s1</code> and <code>s2</code>, return <code>true</code> if <code>s2</code> contains a permutation of <code>s1</code>, or <code>false</code> otherwise.</p>
<p>In other words, return <code>true</code> if one of <code>s1</code>'s permutations is a substring of <code>s2</code>.</p>
<p>A <strong>permutation</strong> is a rearrangement of all the characters of a string. For example, "abc", "acb", "bac", "bca", "cab", and "cba" are all permutations of "abc". We need to check if any permutation of <code>s1</code> appears as a contiguous substring in <code>s2</code>.</p>
<p><strong>Key Insight:</strong> Instead of generating all permutations of s1 and checking each, we can use a sliding window approach with frequency counting. Two strings are permutations of each other if and only if they have the same character frequencies.</p>`,
        examples: [
            {
                input: 's1 = "ab", s2 = "eidbaooo"',
                output: 'true',
                explanation: 's2 contains "ba", which is a permutation of s1 ("ab" and "ba" contain the same characters).'
            },
            {
                input: 's1 = "ab", s2 = "eidboaoo"',
                output: 'false',
                explanation: 'No substring of s2 is a permutation of s1. While s2 contains "boa", it has an extra "o" that is not in s1.'
            },
            {
                input: 's1 = "adc", s2 = "dcda"',
                output: 'true',
                explanation: 's2 contains "dcd" which... wait, that\'s not right. Actually, s2 contains "cda" starting at index 1, but that\'s "cda" not "adc". Let me check: s2="dcda" contains "dcd" (d,c,d) or "cda" (c,d,a). "cda" is a permutation of "adc". So the answer is true.'
            },
            {
                input: 's1 = "hello", s2 = "ooolleoooleh"',
                output: 'false',
                explanation: 'No window of length 5 in s2 contains the same characters as s1 with the same frequencies.'
            }
        ],
        constraints: [
            "<code>1 <= s1.length, s2.length <= 10<sup>4</sup></code>",
            "<code>s1</code> and <code>s2</code> consist of lowercase English letters."
        ],
        solutions: {
            brute: {
                intuition: "For each window of size s1.length in s2, count the character frequencies and compare with s1's frequencies. If they match, we found a permutation. This requires checking every possible window position.",
                algorithm: [
                    "Calculate frequency count for s1",
                    "For each starting position i in s2 (from 0 to len(s2) - len(s1)):",
                    "  Extract substring of s2 from i to i + len(s1)",
                    "  Calculate frequency count for this substring",
                    "  If frequency counts match s1, return true",
                    "If no match found after checking all windows, return false"
                ],
                complexity: {
                    time: "O(n * m) where n is length of s2 and m is length of s1. For each of (n-m+1) windows, we count m characters.",
                    space: "O(1) since we use fixed-size frequency arrays (26 letters), which is constant space."
                },
                code: {
                    python: `def checkInclusion(s1, s2):
    if len(s1) > len(s2):
        return False
    
    from collections import Counter
    s1_count = Counter(s1)
    window_size = len(s1)
    
    # Check each window
    for i in range(len(s2) - window_size + 1):
        window = s2[i:i + window_size]
        if Counter(window) == s1_count:
            return True
    
    return False`,
                    java: `class Solution {
    public boolean checkInclusion(String s1, String s2) {
        if (s1.length() > s2.length()) return false;
        
        int[] s1Count = new int[26];
        for (char c : s1.toCharArray()) {
            s1Count[c - 'a']++;
        }
        
        int windowSize = s1.length();
        
        // Check each window
        for (int i = 0; i <= s2.length() - windowSize; i++) {
            int[] windowCount = new int[26];
            for (int j = i; j < i + windowSize; j++) {
                windowCount[s2.charAt(j) - 'a']++;
            }
            if (Arrays.equals(s1Count, windowCount)) {
                return true;
            }
        }
        
        return false;
    }
}`,
                    cpp: `class Solution {
public:
    bool checkInclusion(string s1, string s2) {
        if (s1.size() > s2.size()) return false;
        
        int s1Count[26] = {};
        for (char c : s1) {
            s1Count[c - 'a']++;
        }
        
        int windowSize = s1.size();
        
        // Check each window
        for (int i = 0; i <= s2.size() - windowSize; i++) {
            int windowCount[26] = {};
            for (int j = i; j < i + windowSize; j++) {
                windowCount[s2[j] - 'a']++;
            }
            if (equal(begin(s1Count), end(s1Count), begin(windowCount))) {
                return true;
            }
        }
        
        return false;
    }
};`,
                    javascript: `function checkInclusion(s1, s2) {
    if (s1.length > s2.length) return false;
    
    const s1Count = new Array(26).fill(0);
    for (const char of s1) {
        s1Count[char.charCodeAt(0) - 97]++;
    }
    
    const windowSize = s1.length;
    
    // Check each window
    for (let i = 0; i <= s2.length - windowSize; i++) {
        const windowCount = new Array(26).fill(0);
        for (let j = i; j < i + windowSize; j++) {
            windowCount[s2.charCodeAt(j) - 97]++;
        }
        if (s1Count.every((val, idx) => val === windowCount[idx])) {
            return true;
        }
    }
    
    return false;
}`
                }
            },
            optimized: {
                intuition: "Use a sliding window with frequency arrays. Instead of recounting all characters for each window, maintain a count of how many character frequencies match. Slide the window by removing the leftmost character and adding a new rightmost character, updating the match count incrementally.",
                algorithm: [
                    "Create frequency arrays for s1 and first window of s2",
                    "Count how many of the 26 letters have matching frequencies (matches)",
                    "If matches == 26, return true (found permutation)",
                    "Slide window through s2:",
                    "  Add new character on right: update frequency and matches",
                    "  Remove old character on left: update frequency and matches",
                    "  If matches == 26 at any point, return true",
                    "Return false if no permutation found"
                ],
                complexity: {
                    time: "O(n + m) where n is length of s2 and m is length of s1. We process s1 once and s2 once.",
                    space: "O(1) as we use two fixed-size arrays of 26 elements each."
                },
                code: {
                    python: `def checkInclusion(s1, s2):
    if len(s1) > len(s2):
        return False
    
    s1_count = [0] * 26
    s2_count = [0] * 26
    
    # Build frequency arrays for s1 and first window
    for i in range(len(s1)):
        s1_count[ord(s1[i]) - ord('a')] += 1
        s2_count[ord(s2[i]) - ord('a')] += 1
    
    # Count matching frequencies
    matches = sum(1 for i in range(26) if s1_count[i] == s2_count[i])
    
    # Slide the window
    for i in range(len(s1), len(s2)):
        if matches == 26:
            return True
        
        # Add new character (right)
        index = ord(s2[i]) - ord('a')
        s2_count[index] += 1
        if s2_count[index] == s1_count[index]:
            matches += 1
        elif s2_count[index] == s1_count[index] + 1:
            matches -= 1
        
        # Remove old character (left)
        index = ord(s2[i - len(s1)]) - ord('a')
        s2_count[index] -= 1
        if s2_count[index] == s1_count[index]:
            matches += 1
        elif s2_count[index] == s1_count[index] - 1:
            matches -= 1
    
    return matches == 26`,
                    java: `class Solution {
    public boolean checkInclusion(String s1, String s2) {
        if (s1.length() > s2.length()) return false;
        
        int[] s1Count = new int[26];
        int[] s2Count = new int[26];
        
        // Build frequency arrays
        for (int i = 0; i < s1.length(); i++) {
            s1Count[s1.charAt(i) - 'a']++;
            s2Count[s2.charAt(i) - 'a']++;
        }
        
        // Count matching frequencies
        int matches = 0;
        for (int i = 0; i < 26; i++) {
            if (s1Count[i] == s2Count[i]) matches++;
        }
        
        // Slide the window
        for (int i = s1.length(); i < s2.length(); i++) {
            if (matches == 26) return true;
            
            // Add new character (right)
            int index = s2.charAt(i) - 'a';
            s2Count[index]++;
            if (s2Count[index] == s1Count[index]) {
                matches++;
            } else if (s2Count[index] == s1Count[index] + 1) {
                matches--;
            }
            
            // Remove old character (left)
            index = s2.charAt(i - s1.length()) - 'a';
            s2Count[index]--;
            if (s2Count[index] == s1Count[index]) {
                matches++;
            } else if (s2Count[index] == s1Count[index] - 1) {
                matches--;
            }
        }
        
        return matches == 26;
    }
}`,
                    cpp: `class Solution {
public:
    bool checkInclusion(string s1, string s2) {
        if (s1.size() > s2.size()) return false;
        
        int s1Count[26] = {}, s2Count[26] = {};
        
        // Build frequency arrays
        for (int i = 0; i < s1.size(); i++) {
            s1Count[s1[i] - 'a']++;
            s2Count[s2[i] - 'a']++;
        }
        
        // Count matching frequencies
        int matches = 0;
        for (int i = 0; i < 26; i++) {
            if (s1Count[i] == s2Count[i]) matches++;
        }
        
        // Slide the window
        for (int i = s1.size(); i < s2.size(); i++) {
            if (matches == 26) return true;
            
            // Add new character (right)
            int index = s2[i] - 'a';
            s2Count[index]++;
            if (s2Count[index] == s1Count[index]) {
                matches++;
            } else if (s2Count[index] == s1Count[index] + 1) {
                matches--;
            }
            
            // Remove old character (left)
            index = s2[i - s1.size()] - 'a';
            s2Count[index]--;
            if (s2Count[index] == s1Count[index]) {
                matches++;
            } else if (s2Count[index] == s1Count[index] - 1) {
                matches--;
            }
        }
        
        return matches == 26;
    }
};`,
                    javascript: `function checkInclusion(s1, s2) {
    if (s1.length > s2.length) return false;
    
    const s1Count = new Array(26).fill(0);
    const s2Count = new Array(26).fill(0);
    
    // Build frequency arrays
    for (let i = 0; i < s1.length; i++) {
        s1Count[s1.charCodeAt(i) - 97]++;
        s2Count[s2.charCodeAt(i) - 97]++;
    }
    
    // Count matching frequencies
    let matches = 0;
    for (let i = 0; i < 26; i++) {
        if (s1Count[i] === s2Count[i]) matches++;
    }
    
    // Slide the window
    for (let i = s1.length; i < s2.length; i++) {
        if (matches === 26) return true;
        
        // Add new character (right)
        let index = s2.charCodeAt(i) - 97;
        s2Count[index]++;
        if (s2Count[index] === s1Count[index]) {
            matches++;
        } else if (s2Count[index] === s1Count[index] + 1) {
            matches--;
        }
        
        // Remove old character (left)
        index = s2.charCodeAt(i - s1.length) - 97;
        s2Count[index]--;
        if (s2Count[index] === s1Count[index]) {
            matches++;
        } else if (s2Count[index] === s1Count[index] - 1) {
            matches--;
        }
    }
    
    return matches === 26;
}`
                }
            }
        }
    },
    "largest-rectangle-in-histogram": {
        "description": `<p>Given an array of integers <code>heights</code> representing the histogram's bar height where the width of each bar is <code>1</code>, return <em>the area of the largest rectangle in the histogram</em>.</p>
<p>A rectangle in the histogram can be formed by choosing any bar and extending left and right as far as possible while all bars in the range are at least as tall as the chosen bar. The area is the height of the chosen bar multiplied by the width (number of bars) it can extend across.</p>
<p>The brute force approach of checking every possible rectangle is O(n¬≤). For each bar, we would expand left and right to find how far it can extend.</p>
<p>The optimal solution uses a <strong>monotonic stack</strong> to efficiently find, for each bar, how far left and right it can extend. By keeping bars in increasing order on the stack, we can determine boundaries in O(n) time. This is one of the most elegant applications of the monotonic stack pattern.</p>`,
        "examples": [
            {
                "input": "heights = [2,1,5,6,2,3]",
                "output": "10",
                "explanation": "The largest rectangle has height 5 and extends across 2 bars (at indices 2 and 3 with heights 5 and 6), giving area = 5 √ó 2 = 10."
            },
            {
                "input": "heights = [2,4]",
                "output": "4",
                "explanation": "The largest rectangle is the single bar with height 4 and width 1, giving area = 4."
            },
            {
                "input": "heights = [2,1,2]",
                "output": "3",
                "explanation": "The largest rectangle spans all 3 bars with height 1 (the minimum), giving area = 1 √ó 3 = 3."
            }
        ],
        "constraints": [
            "<code>1 <= heights.length <= 10<sup>5</sup></code>",
            "<code>0 <= heights[i] <= 10<sup>4</sup></code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "For each bar, expand left and right.",
                "algorithm": "Find width for each height",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(1)"
                },
                "code": {
                    "python": "class Solution:\n    def largestRectangleArea(self, heights):\n        res = 0\n        for i in range(len(heights)):\n            l = r = i\n            while l > 0 and heights[l-1] >= heights[i]: l -= 1\n            while r < len(heights)-1 and heights[r+1] >= heights[i]: r += 1\n            res = max(res, heights[i] * (r - l + 1))\n        return res",
                    "java": "class Solution { public int largestRectangleArea(int[] h) { int res = 0; for (int i = 0; i < h.length; i++) { int l = i, r = i; while (l > 0 && h[l-1] >= h[i]) l--; while (r < h.length-1 && h[r+1] >= h[i]) r++; res = Math.max(res, h[i] * (r - l + 1)); } return res; } }",
                    "cpp": "class Solution { public: int largestRectangleArea(vector<int>& h) { int res = 0; for (int i = 0; i < h.size(); i++) { int l = i, r = i; while (l > 0 && h[l-1] >= h[i]) l--; while (r < h.size()-1 && h[r+1] >= h[i]) r++; res = max(res, h[i] * (r - l + 1)); } return res; } };"
                }
            },
            "optimized": {
                "intuition": "Monotonic stack.",
                "algorithm": "Pop when smaller found",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(n)"
                },
                "code": {
                    "python": "class Solution:\n    def largestRectangleArea(self, heights):\n        stack = []\n        res = 0\n        for i, h in enumerate(heights + [0]):\n            while stack and heights[stack[-1]] > h:\n                height = heights[stack.pop()]\n                width = i if not stack else i - stack[-1] - 1\n                res = max(res, height * width)\n            stack.append(i)\n        return res",
                    "java": "class Solution { public int largestRectangleArea(int[] h) { Stack<Integer> st = new Stack<>(); int res = 0; for (int i = 0; i <= h.length; i++) { int curr = i == h.length ? 0 : h[i]; while (!st.isEmpty() && h[st.peek()] > curr) { int height = h[st.pop()]; int width = st.isEmpty() ? i : i - st.peek() - 1; res = Math.max(res, height * width); } st.push(i); } return res; } }",
                    "cpp": "class Solution { public: int largestRectangleArea(vector<int>& h) { stack<int> st; int res = 0; h.push_back(0); for (int i = 0; i < h.size(); i++) { while (!st.empty() && h[st.top()] > h[i]) { int height = h[st.top()]; st.pop(); int width = st.empty() ? i : i - st.top() - 1; res = max(res, height * width); } st.push(i); } return res; } };"
                }
            }
        }
    },
    "car-fleet": {
        "description": `<p>There are <code>n</code> cars going to the same destination along a one-lane road. The destination is <code>target</code> miles away.</p>
<p>You are given two integer arrays <code>position</code> and <code>speed</code>, both of length <code>n</code>, where <code>position[i]</code> is the position of the <code>i<sup>th</sup></code> car and <code>speed[i]</code> is the speed of the <code>i<sup>th</sup></code> car (in miles per hour).</p>
<p>A car can never pass another car ahead of it, but it can catch up to it and drive at the same speed next to it as a <strong>fleet</strong>. A fleet is a group of cars that arrive at the destination at the same time.</p>
<p>Return <em>the number of car fleets that will arrive at the destination</em>.</p>
<p>The key insight is to sort cars by position (closest to target first) and calculate arrival times. If a car behind would arrive earlier, it must slow down to form a fleet with the car ahead. We use a stack to track distinct fleets - only pushing new arrival times when a car won't catch the fleet ahead.</p>`,
        "examples": [
            {
                "input": "target = 12, position = [10,8,0,5,3], speed = [2,4,1,1,3]",
                "output": "3",
                "explanation": "Car at position 10 arrives at time (12-10)/2 = 1. Car at 8 arrives at (12-8)/4 = 1, forming a fleet. Car at 0 arrives at 12. Car at 5 arrives at 7. Car at 3 arrives at 3, catching the car at 5 to form a fleet. Total: 3 fleets."
            },
            {
                "input": "target = 10, position = [3], speed = [3]",
                "output": "1",
                "explanation": "Only one car, forming one fleet."
            },
            {
                "input": "target = 100, position = [0,2,4], speed = [4,2,1]",
                "output": "1",
                "explanation": "All cars arrive at time 25, forming one fleet."
            }
        ],
        "constraints": [
            "<code>n == position.length == speed.length</code>",
            "<code>1 <= n <= 10<sup>5</sup></code>",
            "<code>0 < target <= 10<sup>6</sup></code>",
            "<code>0 <= position[i] < target</code>",
            "All the values of <code>position</code> are <strong>unique</strong>.",
            "<code>0 < speed[i] <= 10<sup>6</sup></code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "Calculate arrival times.",
                "algorithm": "Sort and count fleets",
                "complexity": {
                    "time": "O(n log n)",
                    "space": "O(n)"
                },
                "code": {
                    "python": "class Solution:\n    def carFleet(self, target, position, speed):\n        cars = sorted(zip(position, speed), reverse=True)\n        fleets = 0\n        time = 0\n        for pos, spd in cars:\n            t = (target - pos) / spd\n            if t > time:\n                fleets += 1\n                time = t\n        return fleets",
                    "java": "class Solution { public int carFleet(int target, int[] pos, int[] spd) { int n = pos.length; double[][] cars = new double[n][2]; for (int i = 0; i < n; i++) { cars[i][0] = pos[i]; cars[i][1] = (double)(target - pos[i]) / spd[i]; } Arrays.sort(cars, (a, b) -> Double.compare(b[0], a[0])); int fleets = 0; double time = 0; for (double[] c : cars) { if (c[1] > time) { fleets++; time = c[1]; } } return fleets; } }",
                    "cpp": "class Solution { public: int carFleet(int target, vector<int>& pos, vector<int>& spd) { int n = pos.size(); vector<pair<int, double>> cars(n); for (int i = 0; i < n; i++) cars[i] = {pos[i], (double)(target - pos[i]) / spd[i]}; sort(cars.rbegin(), cars.rend()); int fleets = 0; double time = 0; for (auto& c : cars) { if (c.second > time) { fleets++; time = c.second; } } return fleets; } };"
                }
            },
            "optimized": {
                "intuition": "Stack-based approach.",
                "algorithm": "Same as brute, already optimal",
                "complexity": {
                    "time": "O(n log n)",
                    "space": "O(n)"
                },
                "code": {
                    "python": "class Solution:\n    def carFleet(self, target, position, speed):\n        stack = []\n        for pos, spd in sorted(zip(position, speed), reverse=True):\n            t = (target - pos) / spd\n            if not stack or t > stack[-1]:\n                stack.append(t)\n        return len(stack)",
                    "java": "class Solution { public int carFleet(int target, int[] pos, int[] spd) { int n = pos.length; double[][] cars = new double[n][2]; for (int i = 0; i < n; i++) { cars[i][0] = pos[i]; cars[i][1] = (double)(target - pos[i]) / spd[i]; } Arrays.sort(cars, (a, b) -> Double.compare(b[0], a[0])); Stack<Double> st = new Stack<>(); for (double[] c : cars) { if (st.isEmpty() || c[1] > st.peek()) st.push(c[1]); } return st.size(); } }",
                    "cpp": "class Solution { public: int carFleet(int target, vector<int>& pos, vector<int>& spd) { int n = pos.size(); vector<pair<int, double>> cars(n); for (int i = 0; i < n; i++) cars[i] = {pos[i], (double)(target - pos[i]) / spd[i]}; sort(cars.rbegin(), cars.rend()); stack<double> st; for (auto& c : cars) { if (st.empty() || c.second > st.top()) st.push(c.second); } return st.size(); } };"
                }
            }
        }
    },
    "koko-eating-bananas": {
        "description": `<p>Koko loves to eat bananas. There are <code>n</code> piles of bananas, the <code>i<sup>th</sup></code> pile has <code>piles[i]</code> bananas. The guards have gone and will come back in <code>h</code> hours.</p>
<p>Koko can decide her bananas-per-hour eating speed of <code>k</code>. Each hour, she chooses some pile of bananas and eats <code>k</code> bananas from that pile. If the pile has less than <code>k</code> bananas, she eats all of them instead and will not eat any more bananas during this hour.</p>
<p>Koko likes to eat slowly but still wants to finish eating all the bananas before the guards return.</p>
<p>Return <em>the minimum integer</em> <code>k</code> <em>such that she can eat all the bananas within</em> <code>h</code> <em>hours</em>.</p>
<p>This is a classic <strong>binary search on answer space</strong> problem. The minimum speed is 1, and the maximum needed speed is the largest pile (eating one pile per hour). We binary search on possible speeds, checking if each speed allows finishing in time.</p>`,
        "examples": [
            {
                "input": "piles = [3,6,7,11], h = 8",
                "output": "4",
                "explanation": "At speed k=4: pile 3 takes 1 hour, pile 6 takes 2 hours, pile 7 takes 2 hours, pile 11 takes 3 hours. Total = 8 hours."
            },
            {
                "input": "piles = [30,11,23,4,20], h = 5",
                "output": "30",
                "explanation": "With 5 piles and 5 hours, Koko must eat at speed 30 to finish in time (one pile per hour at the rate of the largest pile)."
            },
            {
                "input": "piles = [30,11,23,4,20], h = 6",
                "output": "23",
                "explanation": "At speed k=23: piles take 2,1,1,1,1 hours respectively. Total = 6 hours."
            }
        ],
        "constraints": [
            "<code>1 <= piles.length <= 10<sup>4</sup></code>",
            "<code>piles.length <= h <= 10<sup>9</sup></code>",
            "<code>1 <= piles[i] <= 10<sup>9</sup></code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "Try each speed from 1.",
                "algorithm": "Find first valid speed",
                "complexity": {
                    "time": "O(n*max)",
                    "space": "O(1)"
                },
                "code": {
                    "python": "class Solution:\n    def minEatingSpeed(self, piles, h):\n        import math\n        for k in range(1, max(piles) + 1):\n            if sum(math.ceil(p / k) for p in piles) <= h:\n                return k\n        return max(piles)",
                    "java": "class Solution { public int minEatingSpeed(int[] piles, int h) { int mx = 0; for (int p : piles) mx = Math.max(mx, p); for (int k = 1; k <= mx; k++) { long hours = 0; for (int p : piles) hours += (p + k - 1) / k; if (hours <= h) return k; } return mx; } }",
                    "cpp": "class Solution { public: int minEatingSpeed(vector<int>& piles, int h) { int mx = *max_element(piles.begin(), piles.end()); for (int k = 1; k <= mx; k++) { long hours = 0; for (int p : piles) hours += (p + k - 1) / k; if (hours <= h) return k; } return mx; } };"
                }
            },
            "optimized": {
                "intuition": "Binary search on speed.",
                "algorithm": "Find min valid speed",
                "complexity": {
                    "time": "O(n log max)",
                    "space": "O(1)"
                },
                "code": {
                    "python": "class Solution:\n    def minEatingSpeed(self, piles, h):\n        import math\n        l, r = 1, max(piles)\n        res = r\n        while l <= r:\n            k = (l + r) // 2\n            hours = sum(math.ceil(p / k) for p in piles)\n            if hours <= h:\n                res = k\n                r = k - 1\n            else:\n                l = k + 1\n        return res",
                    "java": "class Solution { public int minEatingSpeed(int[] piles, int h) { int l = 1, r = 0; for (int p : piles) r = Math.max(r, p); int res = r; while (l <= r) { int k = (l + r) / 2; long hours = 0; for (int p : piles) hours += (p + k - 1) / k; if (hours <= h) { res = k; r = k - 1; } else l = k + 1; } return res; } }",
                    "cpp": "class Solution { public: int minEatingSpeed(vector<int>& piles, int h) { int l = 1, r = *max_element(piles.begin(), piles.end()); int res = r; while (l <= r) { int k = (l + r) / 2; long hours = 0; for (int p : piles) hours += (p + k - 1) / k; if (hours <= h) { res = k; r = k - 1; } else l = k + 1; } return res; } };"
                }
            }
        }
    },
    "time-based-key-value-store": {
        "description": "<p>Design a time-based key-value data structure that can store multiple values for the same key at different time stamps and retrieve the key's value at a certain timestamp.</p><p>Implement the <code>TimeMap</code> class:</p><ul><li><code>TimeMap()</code> Initializes the object of the data structure.</li><li><code>void set(String key, String value, int timestamp)</code> Stores the key <code>key</code> with the value <code>value</code> at the given time <code>timestamp</code>.</li><li><code>String get(String key, int timestamp)</code> Returns a value such that <code>set</code> was called previously, with <code>timestamp_prev <= timestamp</code>. If there are multiple such values, it returns the value associated with the largest <code>timestamp_prev</code>. If there are no values, it returns <code>\"\"</code>.</li></ul><p><strong>Key Insight:</strong> Use a hash map where each key maps to a list of <code>(timestamp, value)</code> pairs. Since timestamps are always increasing, use <strong>binary search</strong> to efficiently find the largest timestamp <= given timestamp.</p>",
        "examples": [
            {
                "input": "[\"TimeMap\",\"set\",\"get\",\"get\",\"set\",\"get\",\"get\"]",
                "output": "[null,null,\"bar\",\"bar\",null,\"bar2\",\"bar2\"]",
                "explanation": "TimeMap timeMap = new TimeMap(); timeMap.set(\"foo\", \"bar\", 1); timeMap.get(\"foo\", 1); // return \"bar\" (timestamp 1), timeMap.get(\"foo\", 3); // return \"bar\" (largest timestamp <= 3 is 1), timeMap.set(\"foo\", \"bar2\", 4); timeMap.get(\"foo\", 4); // return \"bar2\", timeMap.get(\"foo\", 5); // return \"bar2\""
            },
            {
                "input": "[\"TimeMap\",\"set\",\"set\",\"get\",\"get\"]",
                "output": "[null,null,null,\"bar\",\"bar2\"]",
                "explanation": "timeMap.set(\"key\", \"bar\", 1); timeMap.set(\"key\", \"bar2\", 2); timeMap.get(\"key\", 1) returns \"bar\"; timeMap.get(\"key\", 2) returns \"bar2\"."
            }
        ],
        "constraints": [
            "<code>1 <= key.length, value.length <= 100</code>",
            "<code>key and value consist of lowercase English letters and digits</code>",
            "<code>1 <= timestamp <= 10<sup>7</sup></code>",
            "<code>All the timestamps of set are strictly increasing</code>",
            "<code>At most 2 * 10<sup>5</sup> calls will be made to set and get</code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "Linear search for timestamp.",
                "algorithm": "Store and search",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(n)"
                },
                "code": {
                    "python": "class TimeMap:\n    def __init__(self):\n        self.store = {}\n    def set(self, key, value, timestamp):\n        if key not in self.store: self.store[key] = []\n        self.store[key].append((timestamp, value))\n    def get(self, key, timestamp):\n        if key not in self.store: return ''\n        res = ''\n        for t, v in self.store[key]:\n            if t <= timestamp: res = v\n        return res",
                    "java": "class TimeMap { Map<String, List<int[]>> store = new HashMap<>(); Map<String, List<String>> vals = new HashMap<>(); public void set(String key, String value, int timestamp) { store.computeIfAbsent(key, k -> new ArrayList<>()).add(new int[]{timestamp}); vals.computeIfAbsent(key, k -> new ArrayList<>()).add(value); } public String get(String key, int timestamp) { if (!store.containsKey(key)) return \"\"; List<int[]> times = store.get(key); List<String> values = vals.get(key); String res = \"\"; for (int i = 0; i < times.size(); i++) { if (times.get(i)[0] <= timestamp) res = values.get(i); } return res; } }",
                    "cpp": "class TimeMap { unordered_map<string, vector<pair<int, string>>> store; public: void set(string key, string value, int timestamp) { store[key].push_back({timestamp, value}); } string get(string key, int timestamp) { if (!store.count(key)) return \"\"; string res = \"\"; for (auto& p : store[key]) { if (p.first <= timestamp) res = p.second; } return res; } };"
                }
            },
            "optimized": {
                "intuition": "Binary search.",
                "algorithm": "Sorted by timestamp",
                "complexity": {
                    "time": "O(log n)",
                    "space": "O(n)"
                },
                "code": {
                    "python": "class TimeMap:\n    def __init__(self):\n        self.store = {}\n    def set(self, key, value, timestamp):\n        if key not in self.store: self.store[key] = []\n        self.store[key].append((timestamp, value))\n    def get(self, key, timestamp):\n        if key not in self.store: return ''\n        arr = self.store[key]\n        l, r = 0, len(arr) - 1\n        res = ''\n        while l <= r:\n            m = (l + r) // 2\n            if arr[m][0] <= timestamp:\n                res = arr[m][1]\n                l = m + 1\n            else:\n                r = m - 1\n        return res",
                    "java": "class TimeMap { Map<String, List<int[]>> store = new HashMap<>(); Map<String, List<String>> vals = new HashMap<>(); public void set(String key, String value, int timestamp) { store.computeIfAbsent(key, k -> new ArrayList<>()).add(new int[]{timestamp}); vals.computeIfAbsent(key, k -> new ArrayList<>()).add(value); } public String get(String key, int timestamp) { if (!store.containsKey(key)) return \"\"; List<int[]> times = store.get(key); List<String> values = vals.get(key); int l = 0, r = times.size() - 1; String res = \"\"; while (l <= r) { int m = (l + r) / 2; if (times.get(m)[0] <= timestamp) { res = values.get(m); l = m + 1; } else r = m - 1; } return res; } }",
                    "cpp": "class TimeMap { unordered_map<string, vector<pair<int, string>>> store; public: void set(string key, string value, int timestamp) { store[key].push_back({timestamp, value}); } string get(string key, int timestamp) { if (!store.count(key)) return \"\"; auto& arr = store[key]; int l = 0, r = arr.size() - 1; string res = \"\"; while (l <= r) { int m = (l + r) / 2; if (arr[m].first <= timestamp) { res = arr[m].second; l = m + 1; } else r = m - 1; } return res; } };"
                }
            }
        }
    },
    "median-of-two-sorted-arrays": {
        "description": "<p>Given two sorted arrays <code>nums1</code> and <code>nums2</code> of size <code>m</code> and <code>n</code> respectively, return <em>the median of the two sorted arrays</em>.</p><p>The overall run time complexity should be <code>O(log (m+n))</code>, which requires a <strong>binary search</strong> approach rather than merging the arrays.</p><p><strong>Key Concept:</strong> The median divides the combined array into two halves of equal length. Use binary search to find the correct partition point in the smaller array, then calculate the corresponding partition in the larger array. The median is derived from the maximum of the left partition and minimum of the right partition.</p>",
        "examples": [
            {
                "input": "nums1 = [1,3], nums2 = [2]",
                "output": "2.0",
                "explanation": "Merged array = [1,2,3] and median is 2."
            },
            {
                "input": "nums1 = [1,2], nums2 = [3,4]",
                "output": "2.5",
                "explanation": "Merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5."
            },
            {
                "input": "nums1 = [], nums2 = [1]",
                "output": "1.0",
                "explanation": "The merged array is [1], so the median is 1.0."
            }
        ],
        "constraints": [
            "<code>nums1.length == m</code>",
            "<code>nums2.length == n</code>",
            "<code>0 <= m <= 1000</code>",
            "<code>0 <= n <= 1000</code>",
            "<code>1 <= m + n <= 2000</code>",
            "<code>-10<sup>6</sup> <= nums1[i], nums2[i] <= 10<sup>6</sup></code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "Merge and find median.",
                "algorithm": "Merge sorted arrays",
                "complexity": {
                    "time": "O(m+n)",
                    "space": "O(m+n)"
                },
                "code": {
                    "python": "class Solution:\n    def findMedianSortedArrays(self, nums1, nums2):\n        merged = sorted(nums1 + nums2)\n        n = len(merged)\n        if n % 2 == 1: return merged[n // 2]\n        return (merged[n // 2 - 1] + merged[n // 2]) / 2",
                    "java": "class Solution { public double findMedianSortedArrays(int[] n1, int[] n2) { int[] m = new int[n1.length + n2.length]; int i = 0, j = 0, k = 0; while (i < n1.length && j < n2.length) m[k++] = n1[i] < n2[j] ? n1[i++] : n2[j++]; while (i < n1.length) m[k++] = n1[i++]; while (j < n2.length) m[k++] = n2[j++]; int n = m.length; if (n % 2 == 1) return m[n / 2]; return (m[n / 2 - 1] + m[n / 2]) / 2.0; } }",
                    "cpp": "class Solution { public: double findMedianSortedArrays(vector<int>& n1, vector<int>& n2) { vector<int> m; merge(n1.begin(), n1.end(), n2.begin(), n2.end(), back_inserter(m)); int n = m.size(); if (n % 2 == 1) return m[n / 2]; return (m[n / 2 - 1] + m[n / 2]) / 2.0; } };"
                }
            },
            "optimized": {
                "intuition": "Binary search on partition.",
                "algorithm": "Find correct partition",
                "complexity": {
                    "time": "O(log(min(m,n)))",
                    "space": "O(1)"
                },
                "code": {
                    "python": "class Solution:\n    def findMedianSortedArrays(self, nums1, nums2):\n        A, B = nums1, nums2\n        if len(A) > len(B): A, B = B, A\n        m, n = len(A), len(B)\n        l, r = 0, m\n        while l <= r:\n            i = (l + r) // 2\n            j = (m + n + 1) // 2 - i\n            lA = A[i-1] if i > 0 else float('-inf')\n            rA = A[i] if i < m else float('inf')\n            lB = B[j-1] if j > 0 else float('-inf')\n            rB = B[j] if j < n else float('inf')\n            if lA <= rB and lB <= rA:\n                if (m + n) % 2 == 1: return max(lA, lB)\n                return (max(lA, lB) + min(rA, rB)) / 2\n            elif lA > rB: r = i - 1\n            else: l = i + 1",
                    "java": "class Solution { public double findMedianSortedArrays(int[] A, int[] B) { if (A.length > B.length) { int[] t = A; A = B; B = t; } int m = A.length, n = B.length, l = 0, r = m; while (l <= r) { int i = (l + r) / 2, j = (m + n + 1) / 2 - i; int lA = i == 0 ? Integer.MIN_VALUE : A[i-1]; int rA = i == m ? Integer.MAX_VALUE : A[i]; int lB = j == 0 ? Integer.MIN_VALUE : B[j-1]; int rB = j == n ? Integer.MAX_VALUE : B[j]; if (lA <= rB && lB <= rA) { if ((m + n) % 2 == 1) return Math.max(lA, lB); return (Math.max(lA, lB) + Math.min(rA, rB)) / 2.0; } else if (lA > rB) r = i - 1; else l = i + 1; } return 0; } }",
                    "cpp": "class Solution { public: double findMedianSortedArrays(vector<int>& A, vector<int>& B) { if (A.size() > B.size()) swap(A, B); int m = A.size(), n = B.size(), l = 0, r = m; while (l <= r) { int i = (l + r) / 2, j = (m + n + 1) / 2 - i; int lA = i == 0 ? INT_MIN : A[i-1]; int rA = i == m ? INT_MAX : A[i]; int lB = j == 0 ? INT_MIN : B[j-1]; int rB = j == n ? INT_MAX : B[j]; if (lA <= rB && lB <= rA) { if ((m + n) % 2 == 1) return max(lA, lB); return (max(lA, lB) + min(rA, rB)) / 2.0; } else if (lA > rB) r = i - 1; else l = i + 1; } return 0; } };"
                }
            }
        }
    },
    "rotting-oranges": {
        "description": "<p>You are given an <code>m x n</code> grid where each cell can have one of three values:</p><ul><li><code>0</code> representing an empty cell,</li><li><code>1</code> representing a fresh orange, or</li><li><code>2</code> representing a rotten orange.</li></ul><p>Every minute, any fresh orange that is <strong>4-directionally adjacent</strong> to a rotten orange becomes rotten.</p><p>Return <em>the minimum number of minutes that must elapse until no cell has a fresh orange</em>. If <em>this is impossible, return</em> <code>-1</code>.</p><p><strong>Approach:</strong> Use <strong>multi-source BFS</strong> starting from all initially rotten oranges simultaneously. Each level of BFS represents one minute passing.</p>",
        "examples": [
            {
                "input": "grid = [[2,1,1],[1,1,0],[0,1,1]]",
                "output": "4",
                "explanation": "Minute 0: [[2,1,1],[1,1,0],[0,1,1]], Minute 1: [[2,2,1],[2,1,0],[0,1,1]], Minute 2: [[2,2,2],[2,2,0],[0,1,1]], Minute 3: [[2,2,2],[2,2,0],[0,2,1]], Minute 4: [[2,2,2],[2,2,0],[0,2,2]]"
            },
            {
                "input": "grid = [[2,1,1],[0,1,1],[1,0,1]]",
                "output": "-1",
                "explanation": "The orange in the bottom left corner (row 2, column 0) is never rotten, because rotting only happens 4-directionally."
            },
            {
                "input": "grid = [[0,2]]",
                "output": "0",
                "explanation": "Since there are already no fresh oranges at minute 0, the answer is 0."
            }
        ],
        "constraints": [
            "<code>m == grid.length</code>",
            "<code>n == grid[i].length</code>",
            "<code>1 <= m, n <= 10</code>",
            "<code>grid[i][j] is 0, 1, or 2</code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "Simulate step by step.",
                "algorithm": "BFS from initial rotten",
                "complexity": {
                    "time": "O(mn)",
                    "space": "O(mn)"
                },
                "code": {
                    "python": "class Solution:\n    def orangesRotting(self, grid):\n        from collections import deque\n        m, n = len(grid), len(grid[0])\n        q = deque()\n        fresh = 0\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 2: q.append((i, j))\n                elif grid[i][j] == 1: fresh += 1\n        mins = 0\n        while q and fresh:\n            mins += 1\n            for _ in range(len(q)):\n                x, y = q.popleft()\n                for dx, dy in [(1,0),(-1,0),(0,1),(0,-1)]:\n                    nx, ny = x + dx, y + dy\n                    if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 1:\n                        grid[nx][ny] = 2\n                        fresh -= 1\n                        q.append((nx, ny))\n        return mins if fresh == 0 else -1",
                    "java": "class Solution { public int orangesRotting(int[][] grid) { int m = grid.length, n = grid[0].length; Queue<int[]> q = new LinkedList<>(); int fresh = 0; for (int i = 0; i < m; i++) for (int j = 0; j < n; j++) { if (grid[i][j] == 2) q.offer(new int[]{i, j}); else if (grid[i][j] == 1) fresh++; } int mins = 0; int[][] dirs = {{1,0},{-1,0},{0,1},{0,-1}}; while (!q.isEmpty() && fresh > 0) { mins++; for (int size = q.size(); size > 0; size--) { int[] p = q.poll(); for (int[] d : dirs) { int nx = p[0] + d[0], ny = p[1] + d[1]; if (nx >= 0 && nx < m && ny >= 0 && ny < n && grid[nx][ny] == 1) { grid[nx][ny] = 2; fresh--; q.offer(new int[]{nx, ny}); } } } } return fresh == 0 ? mins : -1; } }",
                    "cpp": "class Solution { public: int orangesRotting(vector<vector<int>>& grid) { int m = grid.size(), n = grid[0].size(); queue<pair<int,int>> q; int fresh = 0; for (int i = 0; i < m; i++) for (int j = 0; j < n; j++) { if (grid[i][j] == 2) q.push({i, j}); else if (grid[i][j] == 1) fresh++; } int mins = 0; int dirs[4][2] = {{1,0},{-1,0},{0,1},{0,-1}}; while (!q.empty() && fresh) { mins++; for (int sz = q.size(); sz > 0; sz--) { auto [x, y] = q.front(); q.pop(); for (auto& d : dirs) { int nx = x + d[0], ny = y + d[1]; if (nx >= 0 && nx < m && ny >= 0 && ny < n && grid[nx][ny] == 1) { grid[nx][ny] = 2; fresh--; q.push({nx, ny}); } } } } return fresh == 0 ? mins : -1; } };"
                }
            },
            "optimized": {
                "intuition": "Same BFS is optimal.",
                "algorithm": "Multi-source BFS",
                "complexity": {
                    "time": "O(mn)",
                    "space": "O(mn)"
                },
                "code": {
                    "python": "class Solution:\n    def orangesRotting(self, grid):\n        from collections import deque\n        m, n = len(grid), len(grid[0])\n        q = deque()\n        fresh = 0\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 2: q.append((i, j, 0))\n                elif grid[i][j] == 1: fresh += 1\n        time = 0\n        while q:\n            x, y, t = q.popleft()\n            time = t\n            for dx, dy in [(1,0),(-1,0),(0,1),(0,-1)]:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 1:\n                    grid[nx][ny] = 2\n                    fresh -= 1\n                    q.append((nx, ny, t + 1))\n        return time if fresh == 0 else -1",
                    "java": "class Solution { public int orangesRotting(int[][] grid) { int m = grid.length, n = grid[0].length; Queue<int[]> q = new LinkedList<>(); int fresh = 0; for (int i = 0; i < m; i++) for (int j = 0; j < n; j++) { if (grid[i][j] == 2) q.offer(new int[]{i, j, 0}); else if (grid[i][j] == 1) fresh++; } int time = 0; int[][] dirs = {{1,0},{-1,0},{0,1},{0,-1}}; while (!q.isEmpty()) { int[] p = q.poll(); time = p[2]; for (int[] d : dirs) { int nx = p[0] + d[0], ny = p[1] + d[1]; if (nx >= 0 && nx < m && ny >= 0 && ny < n && grid[nx][ny] == 1) { grid[nx][ny] = 2; fresh--; q.offer(new int[]{nx, ny, p[2] + 1}); } } } return fresh == 0 ? time : -1; } }",
                    "cpp": "class Solution { public: int orangesRotting(vector<vector<int>>& grid) { int m = grid.size(), n = grid[0].size(); queue<tuple<int,int,int>> q; int fresh = 0; for (int i = 0; i < m; i++) for (int j = 0; j < n; j++) { if (grid[i][j] == 2) q.push({i, j, 0}); else if (grid[i][j] == 1) fresh++; } int time = 0; int dirs[4][2] = {{1,0},{-1,0},{0,1},{0,-1}}; while (!q.empty()) { auto [x, y, t] = q.front(); q.pop(); time = t; for (auto& d : dirs) { int nx = x + d[0], ny = y + d[1]; if (nx >= 0 && nx < m && ny >= 0 && ny < n && grid[nx][ny] == 1) { grid[nx][ny] = 2; fresh--; q.push({nx, ny, t + 1}); } } } return fresh == 0 ? time : -1; } };"
                }
            }
        }
    },
    "walls-and-gates": {
        "description": "<p>You are given an <code>m x n</code> grid <code>rooms</code> initialized with these three possible values:</p><ul><li><code>-1</code> - A wall or an obstacle.</li><li><code>0</code> - A gate.</li><li><code>INF</code> - Infinity means an empty room. We use the value <code>2<sup>31</sup> - 1 = 2147483647</code> to represent <code>INF</code> as you may assume that the distance to a gate is less than <code>2147483647</code>.</li></ul><p>Fill each empty room with the distance to <em>its nearest gate</em>. If it is impossible to reach a gate, it should be filled with <code>INF</code>.</p><p><strong>Optimal Approach:</strong> Use <strong>multi-source BFS</strong> starting from all gates simultaneously. This efficiently computes shortest distances in one pass.</p>",
        "examples": [
            {
                "input": "rooms = [[2147483647,-1,0,2147483647],[2147483647,2147483647,2147483647,-1],[2147483647,-1,2147483647,-1],[0,-1,2147483647,2147483647]]",
                "output": "[[3,-1,0,1],[2,2,1,-1],[1,-1,2,-1],[0,-1,3,4]]",
                "explanation": "Starting from both gates (marked as 0), fill in the distances to empty rooms (INF)."
            },
            {
                "input": "rooms = [[-1]]",
                "output": "[[-1]]",
                "explanation": "Only a wall, no gates or empty rooms."
            }
        ],
        "constraints": [
            "<code>m == rooms.length</code>",
            "<code>n == rooms[i].length</code>",
            "<code>1 <= m, n <= 250</code>",
            "<code>rooms[i][j] is -1, 0, or 2<sup>31</sup> - 1</code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "BFS from each empty room.",
                "algorithm": "Find nearest gate for each",
                "complexity": {
                    "time": "O((mn)¬≤)",
                    "space": "O(mn)"
                },
                "code": {
                    "python": "class Solution:\n    def wallsAndGates(self, rooms):\n        if not rooms: return\n        m, n = len(rooms), len(rooms[0])\n        INF = 2147483647\n        for i in range(m):\n            for j in range(n):\n                if rooms[i][j] == INF:\n                    from collections import deque\n                    q = deque([(i, j, 0)])\n                    visited = {(i, j)}\n                    while q:\n                        x, y, d = q.popleft()\n                        if rooms[x][y] == 0:\n                            rooms[i][j] = d\n                            break\n                        for dx, dy in [(1,0),(-1,0),(0,1),(0,-1)]:\n                            nx, ny = x + dx, y + dy\n                            if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited and rooms[nx][ny] != -1:\n                                visited.add((nx, ny))\n                                q.append((nx, ny, d + 1))",
                    "java": "class Solution { public void wallsAndGates(int[][] rooms) { if (rooms.length == 0) return; int m = rooms.length, n = rooms[0].length; int INF = 2147483647; for (int i = 0; i < m; i++) { for (int j = 0; j < n; j++) { if (rooms[i][j] == INF) { Queue<int[]> q = new LinkedList<>(); q.offer(new int[]{i, j, 0}); boolean[][] vis = new boolean[m][n]; vis[i][j] = true; while (!q.isEmpty()) { int[] p = q.poll(); if (rooms[p[0]][p[1]] == 0) { rooms[i][j] = p[2]; break; } int[][] dirs = {{1,0},{-1,0},{0,1},{0,-1}}; for (int[] d : dirs) { int nx = p[0] + d[0], ny = p[1] + d[1]; if (nx >= 0 && nx < m && ny >= 0 && ny < n && !vis[nx][ny] && rooms[nx][ny] != -1) { vis[nx][ny] = true; q.offer(new int[]{nx, ny, p[2] + 1}); } } } } } } } }",
                    "cpp": "class Solution { public: void wallsAndGates(vector<vector<int>>& rooms) { if (rooms.empty()) return; int m = rooms.size(), n = rooms[0].size(); int INF = 2147483647; for (int i = 0; i < m; i++) { for (int j = 0; j < n; j++) { if (rooms[i][j] == INF) { queue<tuple<int,int,int>> q; q.push({i, j, 0}); vector<vector<bool>> vis(m, vector<bool>(n)); vis[i][j] = true; while (!q.empty()) { auto [x, y, d] = q.front(); q.pop(); if (rooms[x][y] == 0) { rooms[i][j] = d; break; } int dirs[4][2] = {{1,0},{-1,0},{0,1},{0,-1}}; for (auto& dir : dirs) { int nx = x + dir[0], ny = y + dir[1]; if (nx >= 0 && nx < m && ny >= 0 && ny < n && !vis[nx][ny] && rooms[nx][ny] != -1) { vis[nx][ny] = true; q.push({nx, ny, d + 1}); } } } } } } } };"
                }
            },
            "optimized": {
                "intuition": "BFS from all gates.",
                "algorithm": "Multi-source BFS",
                "complexity": {
                    "time": "O(mn)",
                    "space": "O(mn)"
                },
                "code": {
                    "python": "class Solution:\n    def wallsAndGates(self, rooms):\n        if not rooms: return\n        from collections import deque\n        m, n = len(rooms), len(rooms[0])\n        q = deque()\n        for i in range(m):\n            for j in range(n):\n                if rooms[i][j] == 0:\n                    q.append((i, j))\n        while q:\n            x, y = q.popleft()\n            for dx, dy in [(1,0),(-1,0),(0,1),(0,-1)]:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < m and 0 <= ny < n and rooms[nx][ny] == 2147483647:\n                    rooms[nx][ny] = rooms[x][y] + 1\n                    q.append((nx, ny))",
                    "java": "class Solution { public void wallsAndGates(int[][] rooms) { if (rooms.length == 0) return; int m = rooms.length, n = rooms[0].length; Queue<int[]> q = new LinkedList<>(); for (int i = 0; i < m; i++) for (int j = 0; j < n; j++) if (rooms[i][j] == 0) q.offer(new int[]{i, j}); int[][] dirs = {{1,0},{-1,0},{0,1},{0,-1}}; while (!q.isEmpty()) { int[] p = q.poll(); for (int[] d : dirs) { int nx = p[0] + d[0], ny = p[1] + d[1]; if (nx >= 0 && nx < m && ny >= 0 && ny < n && rooms[nx][ny] == 2147483647) { rooms[nx][ny] = rooms[p[0]][p[1]] + 1; q.offer(new int[]{nx, ny}); } } } } }",
                    "cpp": "class Solution { public: void wallsAndGates(vector<vector<int>>& rooms) { if (rooms.empty()) return; int m = rooms.size(), n = rooms[0].size(); queue<pair<int,int>> q; for (int i = 0; i < m; i++) for (int j = 0; j < n; j++) if (rooms[i][j] == 0) q.push({i, j}); int dirs[4][2] = {{1,0},{-1,0},{0,1},{0,-1}}; while (!q.empty()) { auto [x, y] = q.front(); q.pop(); for (auto& d : dirs) { int nx = x + d[0], ny = y + d[1]; if (nx >= 0 && nx < m && ny >= 0 && ny < n && rooms[nx][ny] == 2147483647) { rooms[nx][ny] = rooms[x][y] + 1; q.push({nx, ny}); } } } } };"
                }
            }
        }
    },
    "surrounded-regions": {
        "description": "<p>You are given an <code>m x n</code> matrix <code>board</code> containing letters <code>'X'</code> and <code>'O'</code>, <strong>capture regions</strong> that are surrounded:</p><ul><li><strong>Connect:</strong> A cell is connected to adjacent cells horizontally or vertically.</li><li><strong>Region:</strong> To form a region connect every <code>'O'</code> cell.</li><li><strong>Surround:</strong> The region is surrounded with <code>'X'</code> cells if you can connect the region with <code>'X'</code> cells and none of the region cells are on the edge of the <code>board</code>.</li></ul><p>A <strong>surrounded region is captured</strong> by replacing all <code>'O'</code>s with <code>'X'</code>s in the input matrix <code>board</code>.</p><p><strong>Approach:</strong> Mark all 'O' cells connected to the border as temporary 'T', then convert remaining 'O' to 'X' (captured) and 'T' back to 'O' (not captured).</p>",
        "examples": [
            {
                "input": "board = [[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"O\",\"O\",\"X\"],[\"X\",\"X\",\"O\",\"X\"],[\"X\",\"O\",\"X\",\"X\"]]",
                "output": "[[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"O\",\"X\",\"X\"]]",
                "explanation": "Surrounded regions should not be on the border, which means that any 'O' on the border cannot be flipped to 'X'. Any 'O' that is not on the border and not connected to an 'O' on the border will be flipped to 'X'."
            },
            {
                "input": "board = [[\"X\"]]",
                "output": "[[\"X\"]]",
                "explanation": "No 'O' cells to capture."
            }
        ],
        "constraints": [
            "<code>m == board.length</code>",
            "<code>n == board[i].length</code>",
            "<code>1 <= m, n <= 200</code>",
            "<code>board[i][j] is 'X' or 'O'</code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "Mark Os connected to border.",
                "algorithm": "DFS from border Os",
                "complexity": {
                    "time": "O(mn)",
                    "space": "O(mn)"
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, board):\n        if not board: return\n        m, n = len(board), len(board[0])\n        def dfs(i, j):\n            if i < 0 or i >= m or j < 0 or j >= n or board[i][j] != 'O': return\n            board[i][j] = 'T'\n            dfs(i+1, j); dfs(i-1, j); dfs(i, j+1); dfs(i, j-1)\n        for i in range(m):\n            dfs(i, 0); dfs(i, n-1)\n        for j in range(n):\n            dfs(0, j); dfs(m-1, j)\n        for i in range(m):\n            for j in range(n):\n                if board[i][j] == 'O': board[i][j] = 'X'\n                elif board[i][j] == 'T': board[i][j] = 'O'",
                    "java": "class Solution { public void solve(char[][] board) { if (board.length == 0) return; int m = board.length, n = board[0].length; for (int i = 0; i < m; i++) { dfs(board, i, 0); dfs(board, i, n-1); } for (int j = 0; j < n; j++) { dfs(board, 0, j); dfs(board, m-1, j); } for (int i = 0; i < m; i++) for (int j = 0; j < n; j++) { if (board[i][j] == 'O') board[i][j] = 'X'; else if (board[i][j] == 'T') board[i][j] = 'O'; } } void dfs(char[][] b, int i, int j) { if (i < 0 || i >= b.length || j < 0 || j >= b[0].length || b[i][j] != 'O') return; b[i][j] = 'T'; dfs(b, i+1, j); dfs(b, i-1, j); dfs(b, i, j+1); dfs(b, i, j-1); } }",
                    "cpp": "class Solution { public: void solve(vector<vector<char>>& board) { if (board.empty()) return; int m = board.size(), n = board[0].size(); for (int i = 0; i < m; i++) { dfs(board, i, 0); dfs(board, i, n-1); } for (int j = 0; j < n; j++) { dfs(board, 0, j); dfs(board, m-1, j); } for (int i = 0; i < m; i++) for (int j = 0; j < n; j++) { if (board[i][j] == 'O') board[i][j] = 'X'; else if (board[i][j] == 'T') board[i][j] = 'O'; } } void dfs(vector<vector<char>>& b, int i, int j) { if (i < 0 || i >= b.size() || j < 0 || j >= b[0].size() || b[i][j] != 'O') return; b[i][j] = 'T'; dfs(b, i+1, j); dfs(b, i-1, j); dfs(b, i, j+1); dfs(b, i, j-1); } };"
                }
            },
            "optimized": {
                "intuition": "Same DFS is optimal.",
                "algorithm": "Border-connected marking",
                "complexity": {
                    "time": "O(mn)",
                    "space": "O(mn)"
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, board):\n        if not board: return\n        m, n = len(board), len(board[0])\n        from collections import deque\n        q = deque()\n        for i in range(m):\n            if board[i][0] == 'O': q.append((i, 0))\n            if board[i][n-1] == 'O': q.append((i, n-1))\n        for j in range(n):\n            if board[0][j] == 'O': q.append((0, j))\n            if board[m-1][j] == 'O': q.append((m-1, j))\n        while q:\n            x, y = q.popleft()\n            if 0 <= x < m and 0 <= y < n and board[x][y] == 'O':\n                board[x][y] = 'T'\n                q.extend([(x+1,y),(x-1,y),(x,y+1),(x,y-1)])\n        for i in range(m):\n            for j in range(n):\n                if board[i][j] == 'O': board[i][j] = 'X'\n                elif board[i][j] == 'T': board[i][j] = 'O'",
                    "java": "class Solution { public void solve(char[][] board) { if (board.length == 0) return; int m = board.length, n = board[0].length; Queue<int[]> q = new LinkedList<>(); for (int i = 0; i < m; i++) { if (board[i][0] == 'O') q.offer(new int[]{i, 0}); if (board[i][n-1] == 'O') q.offer(new int[]{i, n-1}); } for (int j = 0; j < n; j++) { if (board[0][j] == 'O') q.offer(new int[]{0, j}); if (board[m-1][j] == 'O') q.offer(new int[]{m-1, j}); } int[][] dirs = {{1,0},{-1,0},{0,1},{0,-1}}; while (!q.isEmpty()) { int[] p = q.poll(); int x = p[0], y = p[1]; if (x >= 0 && x < m && y >= 0 && y < n && board[x][y] == 'O') { board[x][y] = 'T'; for (int[] d : dirs) q.offer(new int[]{x + d[0], y + d[1]}); } } for (int i = 0; i < m; i++) for (int j = 0; j < n; j++) { if (board[i][j] == 'O') board[i][j] = 'X'; else if (board[i][j] == 'T') board[i][j] = 'O'; } } }",
                    "cpp": "class Solution { public: void solve(vector<vector<char>>& board) { if (board.empty()) return; int m = board.size(), n = board[0].size(); queue<pair<int,int>> q; for (int i = 0; i < m; i++) { if (board[i][0] == 'O') q.push({i, 0}); if (board[i][n-1] == 'O') q.push({i, n-1}); } for (int j = 0; j < n; j++) { if (board[0][j] == 'O') q.push({0, j}); if (board[m-1][j] == 'O') q.push({m-1, j}); } int dirs[4][2] = {{1,0},{-1,0},{0,1},{0,-1}}; while (!q.empty()) { auto [x, y] = q.front(); q.pop(); if (x >= 0 && x < m && y >= 0 && y < n && board[x][y] == 'O') { board[x][y] = 'T'; for (auto& d : dirs) q.push({x + d[0], y + d[1]}); } } for (int i = 0; i < m; i++) for (int j = 0; j < n; j++) { if (board[i][j] == 'O') board[i][j] = 'X'; else if (board[i][j] == 'T') board[i][j] = 'O'; } } };"
                }
            }
        }
    },
    "course-schedule-ii": {
        "description": "<p>There are a total of <code>numCourses</code> courses you have to take, labeled from <code>0</code> to <code>numCourses - 1</code>. You are given an array <code>prerequisites</code> where <code>prerequisites[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> indicates that you <strong>must</strong> take course <code>b<sub>i</sub></code> first if you want to take course <code>a<sub>i</sub></code>.</p><p>Return <em>the ordering of courses you should take to finish all courses</em>. If there are many valid answers, return <strong>any</strong> of them. If it is impossible to finish all courses, return <strong>an empty array</strong>.</p><p><strong>Approach:</strong> Use <strong>topological sort</strong> with either DFS (detect cycles) or Kahn's algorithm (BFS with in-degree tracking).</p>",
        "examples": [
            {
                "input": "numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]",
                "output": "[0,2,1,3] or [0,1,2,3]",
                "explanation": "There are 4 courses. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after course 0. So one correct order is [0,1,2,3]. Another is [0,2,1,3]."
            },
            {
                "input": "numCourses = 1, prerequisites = []",
                "output": "[0]",
                "explanation": "There is only one course, so the order is simply [0]."
            },
            {
                "input": "numCourses = 2, prerequisites = [[1,0],[0,1]]",
                "output": "[]",
                "explanation": "There is a cycle: course 0 requires course 1 which requires course 0. Impossible to complete."
            }
        ],
        "constraints": [
            "<code>1 <= numCourses <= 2000</code>",
            "<code>0 <= prerequisites.length <= numCourses * (numCourses - 1)</code>",
            "<code>prerequisites[i].length == 2</code>",
            "<code>0 <= a<sub>i</sub>, b<sub>i</sub> < numCourses</code>",
            "<code>a<sub>i</sub> != b<sub>i</sub></code>",
            "<code>All the pairs [a<sub>i</sub>, b<sub>i</sub>] are distinct</code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "Topological sort with DFS.",
                "algorithm": "Detect cycle and build order",
                "complexity": {
                    "time": "O(V+E)",
                    "space": "O(V+E)"
                },
                "code": {
                    "python": "class Solution:\n    def findOrder(self, numCourses, prerequisites):\n        graph = [[] for _ in range(numCourses)]\n        for c, p in prerequisites: graph[p].append(c)\n        visited = [0] * numCourses\n        result = []\n        def dfs(node):\n            if visited[node] == 1: return False\n            if visited[node] == 2: return True\n            visited[node] = 1\n            for nei in graph[node]:\n                if not dfs(nei): return False\n            visited[node] = 2\n            result.append(node)\n            return True\n        for i in range(numCourses):\n            if not dfs(i): return []\n        return result[::-1]",
                    "java": "class Solution { public int[] findOrder(int n, int[][] prereqs) { List<List<Integer>> g = new ArrayList<>(); for (int i = 0; i < n; i++) g.add(new ArrayList<>()); for (int[] p : prereqs) g.get(p[1]).add(p[0]); int[] vis = new int[n]; List<Integer> res = new ArrayList<>(); for (int i = 0; i < n; i++) if (!dfs(i, g, vis, res)) return new int[0]; Collections.reverse(res); return res.stream().mapToInt(x -> x).toArray(); } boolean dfs(int node, List<List<Integer>> g, int[] vis, List<Integer> res) { if (vis[node] == 1) return false; if (vis[node] == 2) return true; vis[node] = 1; for (int nei : g.get(node)) if (!dfs(nei, g, vis, res)) return false; vis[node] = 2; res.add(node); return true; } }",
                    "cpp": "class Solution { public: vector<int> findOrder(int n, vector<vector<int>>& prereqs) { vector<vector<int>> g(n); for (auto& p : prereqs) g[p[1]].push_back(p[0]); vector<int> vis(n), res; for (int i = 0; i < n; i++) if (!dfs(i, g, vis, res)) return {}; reverse(res.begin(), res.end()); return res; } bool dfs(int node, vector<vector<int>>& g, vector<int>& vis, vector<int>& res) { if (vis[node] == 1) return false; if (vis[node] == 2) return true; vis[node] = 1; for (int nei : g[node]) if (!dfs(nei, g, vis, res)) return false; vis[node] = 2; res.push_back(node); return true; } };"
                }
            },
            "optimized": {
                "intuition": "Kahn's algorithm (BFS).",
                "algorithm": "Use in-degree tracking",
                "complexity": {
                    "time": "O(V+E)",
                    "space": "O(V+E)"
                },
                "code": {
                    "python": "class Solution:\n    def findOrder(self, numCourses, prerequisites):\n        from collections import deque\n        graph = [[] for _ in range(numCourses)]\n        indegree = [0] * numCourses\n        for c, p in prerequisites:\n            graph[p].append(c)\n            indegree[c] += 1\n        q = deque([i for i in range(numCourses) if indegree[i] == 0])\n        result = []\n        while q:\n            node = q.popleft()\n            result.append(node)\n            for nei in graph[node]:\n                indegree[nei] -= 1\n                if indegree[nei] == 0: q.append(nei)\n        return result if len(result) == numCourses else []",
                    "java": "class Solution { public int[] findOrder(int n, int[][] prereqs) { List<List<Integer>> g = new ArrayList<>(); int[] ind = new int[n]; for (int i = 0; i < n; i++) g.add(new ArrayList<>()); for (int[] p : prereqs) { g.get(p[1]).add(p[0]); ind[p[0]]++; } Queue<Integer> q = new LinkedList<>(); for (int i = 0; i < n; i++) if (ind[i] == 0) q.offer(i); int[] res = new int[n]; int idx = 0; while (!q.isEmpty()) { int node = q.poll(); res[idx++] = node; for (int nei : g.get(node)) { ind[nei]--; if (ind[nei] == 0) q.offer(nei); } } return idx == n ? res : new int[0]; } }",
                    "cpp": "class Solution { public: vector<int> findOrder(int n, vector<vector<int>>& prereqs) { vector<vector<int>> g(n); vector<int> ind(n); for (auto& p : prereqs) { g[p[1]].push_back(p[0]); ind[p[0]]++; } queue<int> q; for (int i = 0; i < n; i++) if (ind[i] == 0) q.push(i); vector<int> res; while (!q.empty()) { int node = q.front(); q.pop(); res.push_back(node); for (int nei : g[node]) { ind[nei]--; if (ind[nei] == 0) q.push(nei); } } return res.size() == n ? res : vector<int>{}; } };"
                }
            }
        }
    },
    "redundant-connection": {
        "description": "<p>In this problem, a tree is an <strong>undirected graph</strong> that is connected and has no cycles.</p><p>You are given a graph that started as a tree with <code>n</code> nodes labeled from <code>1</code> to <code>n</code>, with one additional edge added. The added edge has two <strong>different</strong> vertices chosen from <code>1</code> to <code>n</code>, and was not an edge that already existed. The graph is represented as an array <code>edges</code> of length <code>n</code> where <code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> indicates that there is an edge between nodes <code>a<sub>i</sub></code> and <code>b<sub>i</sub></code> in the graph.</p><p>Return <em>an edge that can be removed so that the resulting graph is a tree of </em><code>n</code><em> nodes</em>. If there are multiple answers, return the answer that occurs last in the input.</p><p><strong>Optimal Approach:</strong> Use <strong>Union-Find</strong> to detect when an edge creates a cycle (both nodes already in same component).</p>",
        "examples": [
            {
                "input": "edges = [[1,2],[1,3],[2,3]]",
                "output": "[2,3]",
                "explanation": "After removing edge [2,3], the graph becomes a valid tree."
            },
            {
                "input": "edges = [[1,2],[2,3],[3,4],[1,4],[1,5]]",
                "output": "[1,4]",
                "explanation": "Edge [1,4] creates a cycle and is the last one that does so."
            }
        ],
        "constraints": [
            "<code>n == edges.length</code>",
            "<code>3 <= n <= 1000</code>",
            "<code>edges[i].length == 2</code>",
            "<code>1 <= a<sub>i</sub> < b<sub>i</sub> <= n</code>",
            "<code>a<sub>i</sub> != b<sub>i</sub></code>",
            "<code>There are no repeated edges</code>",
            "<code>The given graph is connected</code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "DFS to detect cycle.",
                "algorithm": "Check cycle after each edge",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)"
                },
                "code": {
                    "python": "class Solution:\n    def findRedundantConnection(self, edges):\n        graph = {}\n        def dfs(u, v, visited):\n            if u == v: return True\n            visited.add(u)\n            for nei in graph.get(u, []):\n                if nei not in visited and dfs(nei, v, visited): return True\n            return False\n        for u, v in edges:\n            if dfs(u, v, set()): return [u, v]\n            graph.setdefault(u, []).append(v)\n            graph.setdefault(v, []).append(u)\n        return []",
                    "java": "class Solution { Map<Integer, List<Integer>> graph = new HashMap<>(); public int[] findRedundantConnection(int[][] edges) { for (int[] e : edges) { if (dfs(e[0], e[1], new HashSet<>())) return e; graph.computeIfAbsent(e[0], k -> new ArrayList<>()).add(e[1]); graph.computeIfAbsent(e[1], k -> new ArrayList<>()).add(e[0]); } return new int[0]; } boolean dfs(int u, int v, Set<Integer> vis) { if (u == v) return true; vis.add(u); for (int nei : graph.getOrDefault(u, new ArrayList<>())) if (!vis.contains(nei) && dfs(nei, v, vis)) return true; return false; } }",
                    "cpp": "class Solution { unordered_map<int, vector<int>> graph; public: vector<int> findRedundantConnection(vector<vector<int>>& edges) { for (auto& e : edges) { if (dfs(e[0], e[1], {})) return e; graph[e[0]].push_back(e[1]); graph[e[1]].push_back(e[0]); } return {}; } bool dfs(int u, int v, unordered_set<int> vis) { if (u == v) return true; vis.insert(u); for (int nei : graph[u]) if (!vis.count(nei) && dfs(nei, v, vis)) return true; return false; } };"
                }
            },
            "optimized": {
                "intuition": "Union-Find.",
                "algorithm": "Union with cycle detection",
                "complexity": {
                    "time": "O(n Œ±(n))",
                    "space": "O(n)"
                },
                "code": {
                    "python": "class Solution:\n    def findRedundantConnection(self, edges):\n        parent = list(range(len(edges) + 1))\n        rank = [0] * (len(edges) + 1)\n        def find(x):\n            if parent[x] != x: parent[x] = find(parent[x])\n            return parent[x]\n        def union(x, y):\n            px, py = find(x), find(y)\n            if px == py: return False\n            if rank[px] < rank[py]: parent[px] = py\n            elif rank[px] > rank[py]: parent[py] = px\n            else: parent[py] = px; rank[px] += 1\n            return True\n        for u, v in edges:\n            if not union(u, v): return [u, v]\n        return []",
                    "java": "class Solution { int[] parent, rank; public int[] findRedundantConnection(int[][] edges) { int n = edges.length; parent = new int[n + 1]; rank = new int[n + 1]; for (int i = 0; i <= n; i++) parent[i] = i; for (int[] e : edges) if (!union(e[0], e[1])) return e; return new int[0]; } int find(int x) { if (parent[x] != x) parent[x] = find(parent[x]); return parent[x]; } boolean union(int x, int y) { int px = find(x), py = find(y); if (px == py) return false; if (rank[px] < rank[py]) parent[px] = py; else if (rank[px] > rank[py]) parent[py] = px; else { parent[py] = px; rank[px]++; } return true; } }",
                    "cpp": "class Solution { vector<int> parent, rnk; public: vector<int> findRedundantConnection(vector<vector<int>>& edges) { int n = edges.size(); parent.resize(n + 1); rnk.resize(n + 1); for (int i = 0; i <= n; i++) parent[i] = i; for (auto& e : edges) if (!unite(e[0], e[1])) return e; return {}; } int find(int x) { if (parent[x] != x) parent[x] = find(parent[x]); return parent[x]; } bool unite(int x, int y) { int px = find(x), py = find(y); if (px == py) return false; if (rnk[px] < rnk[py]) parent[px] = py; else if (rnk[px] > rnk[py]) parent[py] = px; else { parent[py] = px; rnk[px]++; } return true; } };"
                }
            }
        }
    },
    "number-of-connected-components-in-an-undirected-graph": {
        "description": "<p>You have a graph of <code>n</code> nodes labeled from <code>0</code> to <code>n - 1</code>. You are given an integer <code>n</code> and an array <code>edges</code> where <code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> indicates that there is an <strong>undirected</strong> edge between nodes <code>a<sub>i</sub></code> and <code>b<sub>i</sub></code> in the graph.</p><p>Return <em>the number of connected components in the graph</em>.</p><p><strong>Two Approaches:</strong> 1) Use <strong>DFS/BFS</strong> to mark all nodes in each component, counting how many DFS calls are needed. 2) Use <strong>Union-Find</strong> to merge components and count distinct roots.</p>",
        "examples": [
            {
                "input": "n = 5, edges = [[0,1],[1,2],[3,4]]",
                "output": "2",
                "explanation": "There are 2 connected components: {0, 1, 2} and {3, 4}."
            },
            {
                "input": "n = 5, edges = [[0,1],[1,2],[2,3],[3,4]]",
                "output": "1",
                "explanation": "All nodes are connected in one component."
            },
            {
                "input": "n = 4, edges = []",
                "output": "4",
                "explanation": "Each node is its own component with no edges."
            }
        ],
        "constraints": [
            "<code>1 <= n <= 2000</code>",
            "<code>1 <= edges.length <= 5000</code>",
            "<code>edges[i].length == 2</code>",
            "<code>0 <= a<sub>i</sub> <= b<sub>i</sub> < n</code>",
            "<code>a<sub>i</sub> != b<sub>i</sub></code>",
            "<code>There are no repeated edges</code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "DFS from each unvisited node.",
                "algorithm": "Count DFS starts",
                "complexity": {
                    "time": "O(V+E)",
                    "space": "O(V+E)"
                },
                "code": {
                    "python": "class Solution:\n    def countComponents(self, n, edges):\n        graph = [[] for _ in range(n)]\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        visited = [False] * n\n        count = 0\n        def dfs(node):\n            visited[node] = True\n            for nei in graph[node]:\n                if not visited[nei]: dfs(nei)\n        for i in range(n):\n            if not visited[i]:\n                dfs(i)\n                count += 1\n        return count",
                    "java": "class Solution { public int countComponents(int n, int[][] edges) { List<List<Integer>> g = new ArrayList<>(); for (int i = 0; i < n; i++) g.add(new ArrayList<>()); for (int[] e : edges) { g.get(e[0]).add(e[1]); g.get(e[1]).add(e[0]); } boolean[] vis = new boolean[n]; int count = 0; for (int i = 0; i < n; i++) if (!vis[i]) { dfs(i, g, vis); count++; } return count; } void dfs(int node, List<List<Integer>> g, boolean[] vis) { vis[node] = true; for (int nei : g.get(node)) if (!vis[nei]) dfs(nei, g, vis); } }",
                    "cpp": "class Solution { public: int countComponents(int n, vector<vector<int>>& edges) { vector<vector<int>> g(n); for (auto& e : edges) { g[e[0]].push_back(e[1]); g[e[1]].push_back(e[0]); } vector<bool> vis(n); int count = 0; for (int i = 0; i < n; i++) if (!vis[i]) { dfs(i, g, vis); count++; } return count; } void dfs(int node, vector<vector<int>>& g, vector<bool>& vis) { vis[node] = true; for (int nei : g[node]) if (!vis[nei]) dfs(nei, g, vis); } };"
                }
            },
            "optimized": {
                "intuition": "Union-Find.",
                "algorithm": "Count distinct roots",
                "complexity": {
                    "time": "O(n Œ±(n))",
                    "space": "O(n)"
                },
                "code": {
                    "python": "class Solution:\n    def countComponents(self, n, edges):\n        parent = list(range(n))\n        def find(x):\n            if parent[x] != x: parent[x] = find(parent[x])\n            return parent[x]\n        for u, v in edges:\n            pu, pv = find(u), find(v)\n            if pu != pv: parent[pu] = pv\n        return len(set(find(i) for i in range(n)))",
                    "java": "class Solution { int[] parent; public int countComponents(int n, int[][] edges) { parent = new int[n]; for (int i = 0; i < n; i++) parent[i] = i; for (int[] e : edges) { int pu = find(e[0]), pv = find(e[1]); if (pu != pv) parent[pu] = pv; } Set<Integer> roots = new HashSet<>(); for (int i = 0; i < n; i++) roots.add(find(i)); return roots.size(); } int find(int x) { if (parent[x] != x) parent[x] = find(parent[x]); return parent[x]; } }",
                    "cpp": "class Solution { vector<int> parent; public: int countComponents(int n, vector<vector<int>>& edges) { parent.resize(n); for (int i = 0; i < n; i++) parent[i] = i; for (auto& e : edges) { int pu = find(e[0]), pv = find(e[1]); if (pu != pv) parent[pu] = pv; } unordered_set<int> roots; for (int i = 0; i < n; i++) roots.insert(find(i)); return roots.size(); } int find(int x) { if (parent[x] != x) parent[x] = find(parent[x]); return parent[x]; } };"
                }
            }
        }
    },
    "graph-valid-tree": {
        "description": "<p>You have a graph of <code>n</code> nodes labeled from <code>0</code> to <code>n - 1</code>. You are given an integer <code>n</code> and an array <code>edges</code> where <code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> indicates that there is an undirected edge between nodes <code>a<sub>i</sub></code> and <code>b<sub>i</sub></code> in the graph.</p><p>Return <code>true</code> <em>if the edges of the given graph make up a valid tree, and</em> <code>false</code> <em>otherwise</em>.</p><p><strong>Tree Properties:</strong> A valid tree with <code>n</code> nodes must have:</p><ul><li>Exactly <code>n-1</code> edges</li><li>All nodes connected (one component)</li><li>No cycles</li></ul><p><strong>Quick Check:</strong> If edges.length != n-1, immediately return false. Then verify connectivity and no cycles.</p>",
        "examples": [
            {
                "input": "n = 5, edges = [[0,1],[0,2],[0,3],[1,4]]",
                "output": "true",
                "explanation": "This forms a valid tree with 5 nodes and 4 edges, all connected with no cycles."
            },
            {
                "input": "n = 5, edges = [[0,1],[1,2],[2,3],[1,3],[1,4]]",
                "output": "false",
                "explanation": "This graph has 5 edges (should have 4 for a tree). Also has a cycle: 1-2-3-1."
            }
        ],
        "constraints": [
            "<code>1 <= n <= 2000</code>",
            "<code>0 <= edges.length <= 5000</code>",
            "<code>edges[i].length == 2</code>",
            "<code>0 <= a<sub>i</sub>, b<sub>i</sub> < n</code>",
            "<code>a<sub>i</sub> != b<sub>i</sub></code>",
            "<code>There are no self-loops or repeated edges</code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "Check connectivity and no cycles.",
                "algorithm": "DFS with cycle detection",
                "complexity": {
                    "time": "O(V+E)",
                    "space": "O(V+E)"
                },
                "code": {
                    "python": "class Solution:\n    def validTree(self, n, edges):\n        if len(edges) != n - 1: return False\n        graph = [[] for _ in range(n)]\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        visited = set()\n        def dfs(node, parent):\n            visited.add(node)\n            for nei in graph[node]:\n                if nei == parent: continue\n                if nei in visited or not dfs(nei, node): return False\n            return True\n        return dfs(0, -1) and len(visited) == n",
                    "java": "class Solution { public boolean validTree(int n, int[][] edges) { if (edges.length != n - 1) return false; List<List<Integer>> g = new ArrayList<>(); for (int i = 0; i < n; i++) g.add(new ArrayList<>()); for (int[] e : edges) { g.get(e[0]).add(e[1]); g.get(e[1]).add(e[0]); } boolean[] vis = new boolean[n]; if (!dfs(0, -1, g, vis)) return false; for (boolean v : vis) if (!v) return false; return true; } boolean dfs(int node, int parent, List<List<Integer>> g, boolean[] vis) { vis[node] = true; for (int nei : g.get(node)) { if (nei == parent) continue; if (vis[nei] || !dfs(nei, node, g, vis)) return false; } return true; } }",
                    "cpp": "class Solution { public: bool validTree(int n, vector<vector<int>>& edges) { if (edges.size() != n - 1) return false; vector<vector<int>> g(n); for (auto& e : edges) { g[e[0]].push_back(e[1]); g[e[1]].push_back(e[0]); } vector<bool> vis(n); if (!dfs(0, -1, g, vis)) return false; for (bool v : vis) if (!v) return false; return true; } bool dfs(int node, int parent, vector<vector<int>>& g, vector<bool>& vis) { vis[node] = true; for (int nei : g[node]) { if (nei == parent) continue; if (vis[nei] || !dfs(nei, node, g, vis)) return false; } return true; } };"
                }
            },
            "optimized": {
                "intuition": "Union-Find.",
                "algorithm": "Check edges = n-1 and no cycle",
                "complexity": {
                    "time": "O(n Œ±(n))",
                    "space": "O(n)"
                },
                "code": {
                    "python": "class Solution:\n    def validTree(self, n, edges):\n        if len(edges) != n - 1: return False\n        parent = list(range(n))\n        def find(x):\n            if parent[x] != x: parent[x] = find(parent[x])\n            return parent[x]\n        for u, v in edges:\n            pu, pv = find(u), find(v)\n            if pu == pv: return False\n            parent[pu] = pv\n        return True",
                    "java": "class Solution { int[] parent; public boolean validTree(int n, int[][] edges) { if (edges.length != n - 1) return false; parent = new int[n]; for (int i = 0; i < n; i++) parent[i] = i; for (int[] e : edges) { int pu = find(e[0]), pv = find(e[1]); if (pu == pv) return false; parent[pu] = pv; } return true; } int find(int x) { if (parent[x] != x) parent[x] = find(parent[x]); return parent[x]; } }",
                    "cpp": "class Solution { vector<int> parent; public: bool validTree(int n, vector<vector<int>>& edges) { if (edges.size() != n - 1) return false; parent.resize(n); for (int i = 0; i < n; i++) parent[i] = i; for (auto& e : edges) { int pu = find(e[0]), pv = find(e[1]); if (pu == pv) return false; parent[pu] = pv; } return true; } int find(int x) { if (parent[x] != x) parent[x] = find(parent[x]); return parent[x]; } };"
                }
            }
        }
    },
    "network-delay-time": {
        "description": "<p>You are given a network of <code>n</code> nodes, labeled from <code>1</code> to <code>n</code>. You are also given <code>times</code>, a list of travel times as directed edges <code>times[i] = (u<sub>i</sub>, v<sub>i</sub>, w<sub>i</sub>)</code>, where <code>u<sub>i</sub></code> is the source node, <code>v<sub>i</sub></code> is the target node, and <code>w<sub>i</sub></code> is the time it takes for a signal to travel from source to target.</p><p>We will send a signal from a given node <code>k</code>. Return <em>the <strong>minimum</strong> time it takes for all the</em> <code>n</code> <em>nodes to receive the signal</em>. If it is impossible for all the <code>n</code> nodes to receive the signal, return <code>-1</code>.</p><p><strong>Optimal Approach:</strong> Use <strong>Dijkstra's algorithm</strong> with a min-heap to find shortest paths from node k to all other nodes. Return the maximum distance found.</p>",
        "examples": [
            {
                "input": "times = [[2,1,1],[2,3,1],[3,4,1]], n = 4, k = 2",
                "output": "2",
                "explanation": "Signal reaches node 1 (time=1), node 3 (time=1), and node 4 (time=2). Max time is 2."
            },
            {
                "input": "times = [[1,2,1]], n = 2, k = 1",
                "output": "1",
                "explanation": "Signal reaches node 2 in time 1."
            },
            {
                "input": "times = [[1,2,1]], n = 2, k = 2",
                "output": "-1",
                "explanation": "Node 1 is unreachable from node 2."
            }
        ],
        "constraints": [
            "<code>1 <= k <= n <= 100</code>",
            "<code>1 <= times.length <= 6000</code>",
            "<code>times[i].length == 3</code>",
            "<code>1 <= u<sub>i</sub>, v<sub>i</sub> <= n</code>",
            "<code>u<sub>i</sub> != v<sub>i</sub></code>",
            "<code>0 <= w<sub>i</sub> <= 100</code>",
            "<code>All the pairs (u<sub>i</sub>, v<sub>i</sub>) are unique</code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "Bellman-Ford.",
                "algorithm": "Relax edges n-1 times",
                "complexity": {
                    "time": "O(VE)",
                    "space": "O(V)"
                },
                "code": {
                    "python": "class Solution:\n    def networkDelayTime(self, times, n, k):\n        dist = [float('inf')] * (n + 1)\n        dist[k] = 0\n        for _ in range(n - 1):\n            for u, v, w in times:\n                if dist[u] + w < dist[v]:\n                    dist[v] = dist[u] + w\n        ans = max(dist[1:])\n        return ans if ans < float('inf') else -1",
                    "java": "class Solution { public int networkDelayTime(int[][] times, int n, int k) { int[] dist = new int[n + 1]; Arrays.fill(dist, Integer.MAX_VALUE); dist[k] = 0; for (int i = 0; i < n - 1; i++) { for (int[] t : times) { if (dist[t[0]] != Integer.MAX_VALUE && dist[t[0]] + t[2] < dist[t[1]]) dist[t[1]] = dist[t[0]] + t[2]; } } int ans = 0; for (int i = 1; i <= n; i++) ans = Math.max(ans, dist[i]); return ans == Integer.MAX_VALUE ? -1 : ans; } }",
                    "cpp": "class Solution { public: int networkDelayTime(vector<vector<int>>& times, int n, int k) { vector<int> dist(n + 1, INT_MAX); dist[k] = 0; for (int i = 0; i < n - 1; i++) { for (auto& t : times) { if (dist[t[0]] != INT_MAX && dist[t[0]] + t[2] < dist[t[1]]) dist[t[1]] = dist[t[0]] + t[2]; } } int ans = 0; for (int i = 1; i <= n; i++) ans = max(ans, dist[i]); return ans == INT_MAX ? -1 : ans; } };"
                }
            },
            "optimized": {
                "intuition": "Dijkstra's algorithm.",
                "algorithm": "Priority queue for shortest paths",
                "complexity": {
                    "time": "O(E log V)",
                    "space": "O(V+E)"
                },
                "code": {
                    "python": "class Solution:\n    def networkDelayTime(self, times, n, k):\n        import heapq\n        graph = {i: [] for i in range(1, n + 1)}\n        for u, v, w in times: graph[u].append((v, w))\n        dist = {i: float('inf') for i in range(1, n + 1)}\n        dist[k] = 0\n        heap = [(0, k)]\n        while heap:\n            d, u = heapq.heappop(heap)\n            if d > dist[u]: continue\n            for v, w in graph[u]:\n                if dist[u] + w < dist[v]:\n                    dist[v] = dist[u] + w\n                    heapq.heappush(heap, (dist[v], v))\n        ans = max(dist.values())\n        return ans if ans < float('inf') else -1",
                    "java": "class Solution { public int networkDelayTime(int[][] times, int n, int k) { List<int[]>[] g = new ArrayList[n + 1]; for (int i = 1; i <= n; i++) g[i] = new ArrayList<>(); for (int[] t : times) g[t[0]].add(new int[]{t[1], t[2]}); int[] dist = new int[n + 1]; Arrays.fill(dist, Integer.MAX_VALUE); dist[k] = 0; PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[0] - b[0]); pq.offer(new int[]{0, k}); while (!pq.isEmpty()) { int[] p = pq.poll(); if (p[0] > dist[p[1]]) continue; for (int[] nei : g[p[1]]) { if (dist[p[1]] + nei[1] < dist[nei[0]]) { dist[nei[0]] = dist[p[1]] + nei[1]; pq.offer(new int[]{dist[nei[0]], nei[0]}); } } } int ans = 0; for (int i = 1; i <= n; i++) ans = Math.max(ans, dist[i]); return ans == Integer.MAX_VALUE ? -1 : ans; } }",
                    "cpp": "class Solution { public: int networkDelayTime(vector<vector<int>>& times, int n, int k) { vector<vector<pair<int,int>>> g(n + 1); for (auto& t : times) g[t[0]].push_back({t[1], t[2]}); vector<int> dist(n + 1, INT_MAX); dist[k] = 0; priority_queue<pair<int,int>, vector<pair<int,int>>, greater<>> pq; pq.push({0, k}); while (!pq.empty()) { auto [d, u] = pq.top(); pq.pop(); if (d > dist[u]) continue; for (auto [v, w] : g[u]) { if (dist[u] + w < dist[v]) { dist[v] = dist[u] + w; pq.push({dist[v], v}); } } } int ans = 0; for (int i = 1; i <= n; i++) ans = max(ans, dist[i]); return ans == INT_MAX ? -1 : ans; } };"
                }
            }
        }
    },
    "swim-in-rising-water": {
        "description": "<p>You are given an <code>n x n</code> integer matrix <code>grid</code> where each value <code>grid[i][j]</code> represents the elevation at that point <code>(i, j)</code>.</p><p>The rain starts to fall. At time <code>t</code>, the depth of the water everywhere is <code>t</code>. You can swim from a square to another 4-directionally adjacent square if and only if the elevation of both squares individually are at most <code>t</code>. You can swim infinite distances in zero time. Of course, you must stay within the boundaries of the grid during your swim.</p><p>Return <em>the least time until you can reach the bottom right square </em><code>(n - 1, n - 1)</code><em> if you start at the top left square </em><code>(0, 0)</code>.</p><p><strong>Approach:</strong> Use <strong>Dijkstra's algorithm</strong> where the 'cost' is the maximum elevation encountered on the path (not sum). Or use <strong>binary search</strong> + BFS.</p>",
        "examples": [
            {
                "input": "grid = [[0,2],[1,3]]",
                "output": "3",
                "explanation": "At time 0, you are at (0,0). At time 1, you can move to (1,0) (elevation 1). At time 2, you still can't move because (0,1) requires elevation 2. At time 3, you can reach both (0,1) and (1,1), then finally (1,1) which is the destination."
            },
            {
                "input": "grid = [[0,1,2,3,4],[24,23,22,21,5],[12,13,14,15,16],[11,17,18,19,20],[10,9,8,7,6]]",
                "output": "16",
                "explanation": "The final answer is 16 because we need to wait until the water level reaches 16 to swim to the bottom-right corner."
            }
        ],
        "constraints": [
            "<code>n == grid.length</code>",
            "<code>n == grid[i].length</code>",
            "<code>1 <= n <= 50</code>",
            "<code>0 <= grid[i][j] < n<sup>2</sup></code>",
            "<code>Each value grid[i][j] is unique</code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "Binary search on time.",
                "algorithm": "BFS to check reachability",
                "complexity": {
                    "time": "O(n¬≤ log n)",
                    "space": "O(n¬≤)"
                },
                "code": {
                    "python": "class Solution:\n    def swimInWater(self, grid):\n        n = len(grid)\n        def canReach(t):\n            if grid[0][0] > t: return False\n            from collections import deque\n            q = deque([(0, 0)])\n            vis = {(0, 0)}\n            while q:\n                x, y = q.popleft()\n                if x == n - 1 and y == n - 1: return True\n                for dx, dy in [(1,0),(-1,0),(0,1),(0,-1)]:\n                    nx, ny = x + dx, y + dy\n                    if 0 <= nx < n and 0 <= ny < n and (nx,ny) not in vis and grid[nx][ny] <= t:\n                        vis.add((nx, ny))\n                        q.append((nx, ny))\n            return False\n        l, r = max(grid[0][0], grid[n-1][n-1]), n * n - 1\n        while l < r:\n            m = (l + r) // 2\n            if canReach(m): r = m\n            else: l = m + 1\n        return l",
                    "java": "class Solution { public int swimInWater(int[][] grid) { int n = grid.length, l = Math.max(grid[0][0], grid[n-1][n-1]), r = n * n - 1; while (l < r) { int m = (l + r) / 2; if (canReach(grid, m)) r = m; else l = m + 1; } return l; } boolean canReach(int[][] grid, int t) { int n = grid.length; if (grid[0][0] > t) return false; Queue<int[]> q = new LinkedList<>(); boolean[][] vis = new boolean[n][n]; q.offer(new int[]{0, 0}); vis[0][0] = true; int[][] dirs = {{1,0},{-1,0},{0,1},{0,-1}}; while (!q.isEmpty()) { int[] p = q.poll(); if (p[0] == n-1 && p[1] == n-1) return true; for (int[] d : dirs) { int nx = p[0] + d[0], ny = p[1] + d[1]; if (nx >= 0 && nx < n && ny >= 0 && ny < n && !vis[nx][ny] && grid[nx][ny] <= t) { vis[nx][ny] = true; q.offer(new int[]{nx, ny}); } } } return false; } }",
                    "cpp": "class Solution { public: int swimInWater(vector<vector<int>>& grid) { int n = grid.size(), l = max(grid[0][0], grid[n-1][n-1]), r = n * n - 1; while (l < r) { int m = (l + r) / 2; if (canReach(grid, m)) r = m; else l = m + 1; } return l; } bool canReach(vector<vector<int>>& grid, int t) { int n = grid.size(); if (grid[0][0] > t) return false; queue<pair<int,int>> q; vector<vector<bool>> vis(n, vector<bool>(n)); q.push({0, 0}); vis[0][0] = true; int dirs[4][2] = {{1,0},{-1,0},{0,1},{0,-1}}; while (!q.empty()) { auto [x, y] = q.front(); q.pop(); if (x == n-1 && y == n-1) return true; for (auto& d : dirs) { int nx = x + d[0], ny = y + d[1]; if (nx >= 0 && nx < n && ny >= 0 && ny < n && !vis[nx][ny] && grid[nx][ny] <= t) { vis[nx][ny] = true; q.push({nx, ny}); } } } return false; } };"
                }
            },
            "optimized": {
                "intuition": "Dijkstra with max elevation.",
                "algorithm": "Priority queue",
                "complexity": {
                    "time": "O(n¬≤ log n)",
                    "space": "O(n¬≤)"
                },
                "code": {
                    "python": "class Solution:\n    def swimInWater(self, grid):\n        import heapq\n        n = len(grid)\n        heap = [(grid[0][0], 0, 0)]\n        vis = {(0, 0)}\n        while heap:\n            t, x, y = heapq.heappop(heap)\n            if x == n - 1 and y == n - 1: return t\n            for dx, dy in [(1,0),(-1,0),(0,1),(0,-1)]:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < n and 0 <= ny < n and (nx, ny) not in vis:\n                    vis.add((nx, ny))\n                    heapq.heappush(heap, (max(t, grid[nx][ny]), nx, ny))\n        return -1",
                    "java": "class Solution { public int swimInWater(int[][] grid) { int n = grid.length; PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[0] - b[0]); pq.offer(new int[]{grid[0][0], 0, 0}); boolean[][] vis = new boolean[n][n]; vis[0][0] = true; int[][] dirs = {{1,0},{-1,0},{0,1},{0,-1}}; while (!pq.isEmpty()) { int[] p = pq.poll(); if (p[1] == n-1 && p[2] == n-1) return p[0]; for (int[] d : dirs) { int nx = p[1] + d[0], ny = p[2] + d[1]; if (nx >= 0 && nx < n && ny >= 0 && ny < n && !vis[nx][ny]) { vis[nx][ny] = true; pq.offer(new int[]{Math.max(p[0], grid[nx][ny]), nx, ny}); } } } return -1; } }",
                    "cpp": "class Solution { public: int swimInWater(vector<vector<int>>& grid) { int n = grid.size(); priority_queue<tuple<int,int,int>, vector<tuple<int,int,int>>, greater<>> pq; pq.push({grid[0][0], 0, 0}); vector<vector<bool>> vis(n, vector<bool>(n)); vis[0][0] = true; int dirs[4][2] = {{1,0},{-1,0},{0,1},{0,-1}}; while (!pq.empty()) { auto [t, x, y] = pq.top(); pq.pop(); if (x == n-1 && y == n-1) return t; for (auto& d : dirs) { int nx = x + d[0], ny = y + d[1]; if (nx >= 0 && nx < n && ny >= 0 && ny < n && !vis[nx][ny]) { vis[nx][ny] = true; pq.push({max(t, grid[nx][ny]), nx, ny}); } } } return -1; } };"
                }
            }
        }
    },
    "alien-dictionary": {
        "description": "<p>There is a new alien language that uses the English alphabet. However, the order of the letters is unknown to you.</p><p>You are given a list of strings <code>words</code> from the alien language's dictionary, where the strings in <code>words</code> are <strong>sorted lexicographically</strong> according to this new language's rules.</p><p>Return <em>a string of the unique letters in the new alien language sorted in <strong>lexicographically increasing order</strong> by the new language's rules</em>. If there is no solution, return <code>\"\"</code>. If there are multiple solutions, return <strong>any of them</strong>.</p><p><strong>Approach:</strong> Build a directed graph from character ordering constraints, then perform <strong>topological sort</strong> using Kahn's algorithm (BFS with in-degree) or DFS with cycle detection.</p>",
        "examples": [
            {
                "input": "words = [\"wrt\",\"wrf\",\"er\",\"ett\",\"rftt\"]",
                "output": "\"wertf\"",
                "explanation": "From \"wrt\" and \"wrf\", we get t -> f. From \"wrt\" and \"er\", we get w -> e. From \"er\" and \"ett\", we get r -> t. From \"ett\" and \"rftt\", we get e -> r. Combining these: w -> e -> r -> t -> f."
            },
            {
                "input": "words = [\"z\",\"x\"]",
                "output": "\"zx\"",
                "explanation": "From \"z\" and \"x\", we get z -> x."
            },
            {
                "input": "words = [\"z\",\"x\",\"z\"]",
                "output": "\"\"",
                "explanation": "The order is invalid. From \"z\" and \"x\", we get z -> x. But from \"x\" and \"z\", we get x -> z. This creates a cycle."
            }
        ],
        "constraints": [
            "<code>1 <= words.length <= 100</code>",
            "<code>1 <= words[i].length <= 100</code>",
            "<code>words[i] consists of only lowercase English letters</code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "Build graph from word pairs.",
                "algorithm": "Topological sort",
                "complexity": {
                    "time": "O(C)",
                    "space": "O(1)"
                },
                "code": {
                    "python": "class Solution:\n    def alienOrder(self, words):\n        from collections import defaultdict, deque\n        graph = defaultdict(set)\n        indegree = {c: 0 for w in words for c in w}\n        for i in range(len(words) - 1):\n            w1, w2 = words[i], words[i + 1]\n            minLen = min(len(w1), len(w2))\n            if len(w1) > len(w2) and w1[:minLen] == w2[:minLen]: return ''\n            for j in range(minLen):\n                if w1[j] != w2[j]:\n                    if w2[j] not in graph[w1[j]]:\n                        graph[w1[j]].add(w2[j])\n                        indegree[w2[j]] += 1\n                    break\n        q = deque([c for c in indegree if indegree[c] == 0])\n        result = []\n        while q:\n            c = q.popleft()\n            result.append(c)\n            for nei in graph[c]:\n                indegree[nei] -= 1\n                if indegree[nei] == 0: q.append(nei)\n        return ''.join(result) if len(result) == len(indegree) else ''",
                    "java": "class Solution { public String alienOrder(String[] words) { Map<Character, Set<Character>> g = new HashMap<>(); Map<Character, Integer> ind = new HashMap<>(); for (String w : words) for (char c : w.toCharArray()) { g.put(c, new HashSet<>()); ind.put(c, 0); } for (int i = 0; i < words.length - 1; i++) { String w1 = words[i], w2 = words[i + 1]; int minLen = Math.min(w1.length(), w2.length()); if (w1.length() > w2.length() && w1.substring(0, minLen).equals(w2.substring(0, minLen))) return \"\"; for (int j = 0; j < minLen; j++) { if (w1.charAt(j) != w2.charAt(j)) { if (!g.get(w1.charAt(j)).contains(w2.charAt(j))) { g.get(w1.charAt(j)).add(w2.charAt(j)); ind.merge(w2.charAt(j), 1, Integer::sum); } break; } } } Queue<Character> q = new LinkedList<>(); for (char c : ind.keySet()) if (ind.get(c) == 0) q.offer(c); StringBuilder sb = new StringBuilder(); while (!q.isEmpty()) { char c = q.poll(); sb.append(c); for (char nei : g.get(c)) { ind.merge(nei, -1, Integer::sum); if (ind.get(nei) == 0) q.offer(nei); } } return sb.length() == ind.size() ? sb.toString() : \"\"; } }",
                    "cpp": "class Solution { public: string alienOrder(vector<string>& words) { unordered_map<char, unordered_set<char>> g; unordered_map<char, int> ind; for (auto& w : words) for (char c : w) { g[c]; ind[c] = 0; } for (int i = 0; i < words.size() - 1; i++) { string &w1 = words[i], &w2 = words[i + 1]; int minLen = min(w1.size(), w2.size()); if (w1.size() > w2.size() && w1.substr(0, minLen) == w2.substr(0, minLen)) return \"\"; for (int j = 0; j < minLen; j++) { if (w1[j] != w2[j]) { if (!g[w1[j]].count(w2[j])) { g[w1[j]].insert(w2[j]); ind[w2[j]]++; } break; } } } queue<char> q; for (auto& [c, d] : ind) if (d == 0) q.push(c); string result; while (!q.empty()) { char c = q.front(); q.pop(); result += c; for (char nei : g[c]) { ind[nei]--; if (ind[nei] == 0) q.push(nei); } } return result.size() == ind.size() ? result : \"\"; } };"
                }
            },
            "optimized": {
                "intuition": "Same topological sort.",
                "algorithm": "BFS with indegree",
                "complexity": {
                    "time": "O(C)",
                    "space": "O(1)"
                },
                "code": {
                    "python": "class Solution:\n    def alienOrder(self, words):\n        from collections import defaultdict, deque\n        adj = defaultdict(set)\n        indeg = {c: 0 for w in words for c in w}\n        for w1, w2 in zip(words, words[1:]):\n            for c1, c2 in zip(w1, w2):\n                if c1 != c2:\n                    if c2 not in adj[c1]: adj[c1].add(c2); indeg[c2] += 1\n                    break\n            else:\n                if len(w1) > len(w2): return ''\n        q = deque([c for c in indeg if indeg[c] == 0])\n        res = []\n        while q:\n            c = q.popleft()\n            res.append(c)\n            for n in adj[c]:\n                indeg[n] -= 1\n                if indeg[n] == 0: q.append(n)\n        return ''.join(res) if len(res) == len(indeg) else ''",
                    "java": "class Solution { public String alienOrder(String[] words) { Map<Character, Set<Character>> adj = new HashMap<>(); Map<Character, Integer> ind = new HashMap<>(); for (String w : words) for (char c : w.toCharArray()) { adj.put(c, new HashSet<>()); ind.put(c, 0); } for (int i = 0; i < words.length - 1; i++) { String w1 = words[i], w2 = words[i+1]; int minL = Math.min(w1.length(), w2.length()); boolean found = false; for (int j = 0; j < minL; j++) { char c1 = w1.charAt(j), c2 = w2.charAt(j); if (c1 != c2) { if (!adj.get(c1).contains(c2)) { adj.get(c1).add(c2); ind.merge(c2, 1, Integer::sum); } found = true; break; } } if (!found && w1.length() > w2.length()) return \"\"; } Queue<Character> q = new LinkedList<>(); for (char c : ind.keySet()) if (ind.get(c) == 0) q.offer(c); StringBuilder res = new StringBuilder(); while (!q.isEmpty()) { char c = q.poll(); res.append(c); for (char n : adj.get(c)) { ind.merge(n, -1, Integer::sum); if (ind.get(n) == 0) q.offer(n); } } return res.length() == ind.size() ? res.toString() : \"\"; } }",
                    "cpp": "class Solution { public: string alienOrder(vector<string>& words) { unordered_map<char, unordered_set<char>> adj; unordered_map<char, int> ind; for (auto& w : words) for (char c : w) { adj[c]; ind[c] = 0; } for (int i = 0; i < words.size() - 1; i++) { auto &w1 = words[i], &w2 = words[i+1]; int minL = min(w1.size(), w2.size()); bool found = false; for (int j = 0; j < minL; j++) { if (w1[j] != w2[j]) { if (!adj[w1[j]].count(w2[j])) { adj[w1[j]].insert(w2[j]); ind[w2[j]]++; } found = true; break; } } if (!found && w1.size() > w2.size()) return \"\"; } queue<char> q; for (auto& [c, d] : ind) if (d == 0) q.push(c); string res; while (!q.empty()) { char c = q.front(); q.pop(); res += c; for (char n : adj[c]) { ind[n]--; if (ind[n] == 0) q.push(n); } } return res.size() == ind.size() ? res : \"\"; } };"
                }
            }
        }
    },
    "cheapest-flights-within-k-stops": {
        "description": "<p>There are <code>n</code> cities connected by some number of flights. You are given an array <code>flights</code> where <code>flights[i] = [from<sub>i</sub>, to<sub>i</sub>, price<sub>i</sub>]</code> indicates that there is a flight from city <code>from<sub>i</sub></code> to city <code>to<sub>i</sub></code> with cost <code>price<sub>i</sub></code>.</p><p>You are also given three integers <code>src</code>, <code>dst</code>, and <code>k</code>, return <em><strong>the cheapest price</strong> from </em><code>src</code><em> to </em><code>dst</code><em> with at most </em><code>k</code><em> stops</em>. If there is no such route, return <code>-1</code>.</p><p><strong>Key Insight:</strong> Cannot use standard Dijkstra because we need to limit the number of edges (stops). Use <strong>Bellman-Ford with k+1 iterations</strong> or <strong>BFS with level tracking</strong>.</p>",
        "examples": [
            {
                "input": "n = 4, flights = [[0,1,100],[1,2,100],[2,0,100],[1,3,600],[2,3,200]], src = 0, dst = 3, k = 1",
                "output": "700",
                "explanation": "The optimal path with at most 1 stop: 0 -> 1 -> 3 costs 100 + 600 = 700. Note that 0 -> 1 -> 2 -> 3 is cheaper (400) but has 2 stops."
            },
            {
                "input": "n = 3, flights = [[0,1,100],[1,2,100],[0,2,500]], src = 0, dst = 2, k = 1",
                "output": "200",
                "explanation": "The cheapest route with at most 1 stop is 0 -> 1 -> 2 costing 200."
            },
            {
                "input": "n = 3, flights = [[0,1,100],[1,2,100],[0,2,500]], src = 0, dst = 2, k = 0",
                "output": "500",
                "explanation": "With 0 stops, the only option is the direct flight 0 -> 2 costing 500."
            }
        ],
        "constraints": [
            "<code>1 <= n <= 100</code>",
            "<code>0 <= flights.length <= (n * (n - 1) / 2)</code>",
            "<code>flights[i].length == 3</code>",
            "<code>0 <= from<sub>i</sub>, to<sub>i</sub> < n</code>",
            "<code>from<sub>i</sub> != to<sub>i</sub></code>",
            "<code>1 <= price<sub>i</sub> <= 10<sup>4</sup></code>",
            "<code>There will not be any multiple flights between two cities</code>",
            "<code>0 <= src, dst, k < n</code>",
            "<code>src != dst</code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "Bellman-Ford with k+1 iterations.",
                "algorithm": "Relax edges k+1 times",
                "complexity": {
                    "time": "O(k*E)",
                    "space": "O(V)"
                },
                "code": {
                    "python": "class Solution:\n    def findCheapestPrice(self, n, flights, src, dst, k):\n        dist = [float('inf')] * n\n        dist[src] = 0\n        for _ in range(k + 1):\n            temp = dist[:]\n            for u, v, w in flights:\n                if dist[u] + w < temp[v]:\n                    temp[v] = dist[u] + w\n            dist = temp\n        return dist[dst] if dist[dst] < float('inf') else -1",
                    "java": "class Solution { public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) { int[] dist = new int[n]; Arrays.fill(dist, Integer.MAX_VALUE); dist[src] = 0; for (int i = 0; i <= k; i++) { int[] temp = dist.clone(); for (int[] f : flights) { if (dist[f[0]] != Integer.MAX_VALUE && dist[f[0]] + f[2] < temp[f[1]]) temp[f[1]] = dist[f[0]] + f[2]; } dist = temp; } return dist[dst] == Integer.MAX_VALUE ? -1 : dist[dst]; } }",
                    "cpp": "class Solution { public: int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) { vector<int> dist(n, INT_MAX); dist[src] = 0; for (int i = 0; i <= k; i++) { vector<int> temp = dist; for (auto& f : flights) { if (dist[f[0]] != INT_MAX && dist[f[0]] + f[2] < temp[f[1]]) temp[f[1]] = dist[f[0]] + f[2]; } dist = temp; } return dist[dst] == INT_MAX ? -1 : dist[dst]; } };"
                }
            },
            "optimized": {
                "intuition": "BFS with level tracking.",
                "algorithm": "Level-based BFS",
                "complexity": {
                    "time": "O(k*E)",
                    "space": "O(V)"
                },
                "code": {
                    "python": "class Solution:\n    def findCheapestPrice(self, n, flights, src, dst, k):\n        from collections import defaultdict, deque\n        graph = defaultdict(list)\n        for u, v, w in flights: graph[u].append((v, w))\n        dist = [float('inf')] * n\n        dist[src] = 0\n        q = deque([(src, 0)])\n        stops = 0\n        while q and stops <= k:\n            for _ in range(len(q)):\n                u, d = q.popleft()\n                for v, w in graph[u]:\n                    if d + w < dist[v]:\n                        dist[v] = d + w\n                        q.append((v, dist[v]))\n            stops += 1\n        return dist[dst] if dist[dst] < float('inf') else -1",
                    "java": "class Solution { public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) { List<int[]>[] g = new ArrayList[n]; for (int i = 0; i < n; i++) g[i] = new ArrayList<>(); for (int[] f : flights) g[f[0]].add(new int[]{f[1], f[2]}); int[] dist = new int[n]; Arrays.fill(dist, Integer.MAX_VALUE); dist[src] = 0; Queue<int[]> q = new LinkedList<>(); q.offer(new int[]{src, 0}); int stops = 0; while (!q.isEmpty() && stops <= k) { int size = q.size(); int[] temp = dist.clone(); for (int i = 0; i < size; i++) { int[] p = q.poll(); for (int[] nei : g[p[0]]) { if (p[1] + nei[1] < temp[nei[0]]) { temp[nei[0]] = p[1] + nei[1]; q.offer(new int[]{nei[0], temp[nei[0]]}); } } } dist = temp; stops++; } return dist[dst] == Integer.MAX_VALUE ? -1 : dist[dst]; } }",
                    "cpp": "class Solution { public: int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) { vector<vector<pair<int,int>>> g(n); for (auto& f : flights) g[f[0]].push_back({f[1], f[2]}); vector<int> dist(n, INT_MAX); dist[src] = 0; queue<pair<int,int>> q; q.push({src, 0}); int stops = 0; while (!q.empty() && stops <= k) { int sz = q.size(); vector<int> temp = dist; for (int i = 0; i < sz; i++) { auto [u, d] = q.front(); q.pop(); for (auto [v, w] : g[u]) { if (d + w < temp[v]) { temp[v] = d + w; q.push({v, temp[v]}); } } } dist = temp; stops++; } return dist[dst] == INT_MAX ? -1 : dist[dst]; } };"
                }
            }
        }
    },
    "reconstruct-itinerary": {
        "description": "<p>You are given a list of airline <code>tickets</code> where <code>tickets[i] = [from<sub>i</sub>, to<sub>i</sub>]</code> represent the departure and the arrival airports of one flight. Reconstruct the itinerary in order and return it.</p><p>All of the tickets belong to a man who departs from <code>\"JFK\"</code>, thus, the itinerary must begin with <code>\"JFK\"</code>. If there are multiple valid itineraries, you should return the itinerary that has the <strong>smallest lexical order</strong> when read as a single string.</p><ul><li>For example, the itinerary <code>[\"JFK\", \"LGA\"]</code> has a smaller lexical order than <code>[\"JFK\", \"LGB\"]</code>.</li></ul><p>You may assume all tickets form at least one valid itinerary. You must use all the tickets once and only once.</p><p><strong>Approach:</strong> This is finding an <strong>Eulerian path</strong>. Use <strong>Hierholzer's algorithm</strong> with a priority queue/sorted edges to ensure lexical order.</p>",
        "examples": [
            {
                "input": "tickets = [[\"MUC\",\"LHR\"],[\"JFK\",\"MUC\"],[\"SFO\",\"SJC\"],[\"LHR\",\"SFO\"]]",
                "output": "[\"JFK\",\"MUC\",\"LHR\",\"SFO\",\"SJC\"]",
                "explanation": "Start from JFK, visit all airports using all tickets exactly once."
            },
            {
                "input": "tickets = [[\"JFK\",\"SFO\"],[\"JFK\",\"ATL\"],[\"SFO\",\"ATL\"],[\"ATL\",\"JFK\"],[\"ATL\",\"SFO\"]]",
                "output": "[\"JFK\",\"ATL\",\"JFK\",\"SFO\",\"ATL\",\"SFO\"]",
                "explanation": "Another valid itinerary is [\"JFK\",\"SFO\",\"ATL\",\"JFK\",\"ATL\",\"SFO\"] but it's lexicographically larger."
            }
        ],
        "constraints": [
            "<code>1 <= tickets.length <= 300</code>",
            "<code>tickets[i].length == 2</code>",
            "<code>from<sub>i</sub>.length == 3</code>",
            "<code>to<sub>i</sub>.length == 3</code>",
            "<code>from<sub>i</sub> and to<sub>i</sub> consist of uppercase English letters</code>",
            "<code>from<sub>i</sub> != to<sub>i</sub></code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "DFS with backtracking.",
                "algorithm": "Try all paths",
                "complexity": {
                    "time": "O(E!)",
                    "space": "O(E)"
                },
                "code": {
                    "python": "class Solution:\n    def findItinerary(self, tickets):\n        from collections import defaultdict\n        graph = defaultdict(list)\n        for src, dst in sorted(tickets, reverse=True):\n            graph[src].append(dst)\n        result = []\n        def dfs(airport):\n            while graph[airport]:\n                dfs(graph[airport].pop())\n            result.append(airport)\n        dfs('JFK')\n        return result[::-1]",
                    "java": "class Solution { public List<String> findItinerary(List<List<String>> tickets) { Map<String, PriorityQueue<String>> g = new HashMap<>(); for (List<String> t : tickets) g.computeIfAbsent(t.get(0), k -> new PriorityQueue<>()).offer(t.get(1)); List<String> res = new LinkedList<>(); dfs(\"JFK\", g, res); return res; } void dfs(String airport, Map<String, PriorityQueue<String>> g, List<String> res) { PriorityQueue<String> pq = g.get(airport); while (pq != null && !pq.isEmpty()) dfs(pq.poll(), g, res); res.add(0, airport); } }",
                    "cpp": "class Solution { public: vector<string> findItinerary(vector<vector<string>>& tickets) { unordered_map<string, multiset<string>> g; for (auto& t : tickets) g[t[0]].insert(t[1]); vector<string> res; dfs(\"JFK\", g, res); reverse(res.begin(), res.end()); return res; } void dfs(string airport, unordered_map<string, multiset<string>>& g, vector<string>& res) { while (!g[airport].empty()) { string next = *g[airport].begin(); g[airport].erase(g[airport].begin()); dfs(next, g, res); } res.push_back(airport); } };"
                }
            },
            "optimized": {
                "intuition": "Hierholzer's algorithm.",
                "algorithm": "Eulerian path",
                "complexity": {
                    "time": "O(E log E)",
                    "space": "O(E)"
                },
                "code": {
                    "python": "class Solution:\n    def findItinerary(self, tickets):\n        from collections import defaultdict\n        graph = defaultdict(list)\n        for src, dst in sorted(tickets, reverse=True):\n            graph[src].append(dst)\n        route = []\n        stack = ['JFK']\n        while stack:\n            while graph[stack[-1]]:\n                stack.append(graph[stack[-1]].pop())\n            route.append(stack.pop())\n        return route[::-1]",
                    "java": "class Solution { public List<String> findItinerary(List<List<String>> tickets) { Map<String, PriorityQueue<String>> g = new HashMap<>(); for (List<String> t : tickets) g.computeIfAbsent(t.get(0), k -> new PriorityQueue<>()).offer(t.get(1)); LinkedList<String> route = new LinkedList<>(); Stack<String> stack = new Stack<>(); stack.push(\"JFK\"); while (!stack.isEmpty()) { while (g.containsKey(stack.peek()) && !g.get(stack.peek()).isEmpty()) stack.push(g.get(stack.peek()).poll()); route.addFirst(stack.pop()); } return route; } }",
                    "cpp": "class Solution { public: vector<string> findItinerary(vector<vector<string>>& tickets) { unordered_map<string, multiset<string>> g; for (auto& t : tickets) g[t[0]].insert(t[1]); vector<string> route; stack<string> st; st.push(\"JFK\"); while (!st.empty()) { while (!g[st.top()].empty()) { string next = *g[st.top()].begin(); g[st.top()].erase(g[st.top()].begin()); st.push(next); } route.push_back(st.top()); st.pop(); } reverse(route.begin(), route.end()); return route; } };"
                }
            }
        }
    },
    "min-cost-to-connect-all-points": {
        "description": "<p>You are given an array <code>points</code> representing integer coordinates of some points on a 2D-plane, where <code>points[i] = [x<sub>i</sub>, y<sub>i</sub>]</code>.</p><p>The cost of connecting two points <code>[x<sub>i</sub>, y<sub>i</sub>]</code> and <code>[x<sub>j</sub>, y<sub>j</sub>]</code> is the <strong>manhattan distance</strong> between them: <code>|x<sub>i</sub> - x<sub>j</sub>| + |y<sub>i</sub> - y<sub>j</sub>|</code>, where <code>|val|</code> denotes the absolute value of <code>val</code>.</p><p>Return <em>the minimum cost to make all points connected</em>. All points are connected if there is <strong>exactly one</strong> simple path between any two points.</p><p><strong>Approach:</strong> This is a <strong>Minimum Spanning Tree (MST)</strong> problem. Use <strong>Prim's algorithm</strong> with a min-heap, or <strong>Kruskal's with Union-Find</strong>.</p>",
        "examples": [
            {
                "input": "points = [[0,0],[2,2],[3,10],[5,2],[7,0]]",
                "output": "20",
                "explanation": "Connect: (0,0)-(2,2) cost 4, (2,2)-(5,2) cost 3, (5,2)-(7,0) cost 4, (0,0)-(3,10) cost 13. Total: 24... Actually optimal is 20."
            },
            {
                "input": "points = [[3,12],[-2,5],[-4,1]]",
                "output": "18",
                "explanation": "Connect all three points with total manhattan distance 18."
            },
            {
                "input": "points = [[0,0]]",
                "output": "0",
                "explanation": "Only one point, no connections needed."
            }
        ],
        "constraints": [
            "<code>1 <= points.length <= 1000</code>",
            "<code>-10<sup>6</sup> <= x<sub>i</sub>, y<sub>i</sub> <= 10<sup>6</sup></code>",
            "<code>All pairs (x<sub>i</sub>, y<sub>i</sub>) are distinct</code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "Prim's algorithm with array.",
                "algorithm": "Start from any point, add closest",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)"
                },
                "code": {
                    "python": "class Solution:\n    def minCostConnectPoints(self, points):\n        n = len(points)\n        if n == 1: return 0\n        dist = [float('inf')] * n\n        dist[0] = 0\n        inMST = [False] * n\n        total = 0\n        for _ in range(n):\n            u = -1\n            for v in range(n):\n                if not inMST[v] and (u == -1 or dist[v] < dist[u]): u = v\n            inMST[u] = True\n            total += dist[u]\n            for v in range(n):\n                if not inMST[v]:\n                    d = abs(points[u][0] - points[v][0]) + abs(points[u][1] - points[v][1])\n                    dist[v] = min(dist[v], d)\n        return total",
                    "java": "class Solution { public int minCostConnectPoints(int[][] points) { int n = points.length; int[] dist = new int[n]; Arrays.fill(dist, Integer.MAX_VALUE); dist[0] = 0; boolean[] inMST = new boolean[n]; int total = 0; for (int i = 0; i < n; i++) { int u = -1; for (int v = 0; v < n; v++) if (!inMST[v] && (u == -1 || dist[v] < dist[u])) u = v; inMST[u] = true; total += dist[u]; for (int v = 0; v < n; v++) if (!inMST[v]) { int d = Math.abs(points[u][0] - points[v][0]) + Math.abs(points[u][1] - points[v][1]); dist[v] = Math.min(dist[v], d); } } return total; } }",
                    "cpp": "class Solution { public: int minCostConnectPoints(vector<vector<int>>& points) { int n = points.size(); vector<int> dist(n, INT_MAX); dist[0] = 0; vector<bool> inMST(n); int total = 0; for (int i = 0; i < n; i++) { int u = -1; for (int v = 0; v < n; v++) if (!inMST[v] && (u == -1 || dist[v] < dist[u])) u = v; inMST[u] = true; total += dist[u]; for (int v = 0; v < n; v++) if (!inMST[v]) { int d = abs(points[u][0] - points[v][0]) + abs(points[u][1] - points[v][1]); dist[v] = min(dist[v], d); } } return total; } };"
                }
            },
            "optimized": {
                "intuition": "Prim's with heap.",
                "algorithm": "Priority queue",
                "complexity": {
                    "time": "O(n¬≤ log n)",
                    "space": "O(n¬≤)"
                },
                "code": {
                    "python": "class Solution:\n    def minCostConnectPoints(self, points):\n        import heapq\n        n = len(points)\n        visited = set()\n        heap = [(0, 0)]\n        total = 0\n        while len(visited) < n:\n            cost, u = heapq.heappop(heap)\n            if u in visited: continue\n            visited.add(u)\n            total += cost\n            for v in range(n):\n                if v not in visited:\n                    d = abs(points[u][0] - points[v][0]) + abs(points[u][1] - points[v][1])\n                    heapq.heappush(heap, (d, v))\n        return total",
                    "java": "class Solution { public int minCostConnectPoints(int[][] points) { int n = points.length; boolean[] vis = new boolean[n]; PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[0] - b[0]); pq.offer(new int[]{0, 0}); int total = 0, count = 0; while (count < n) { int[] p = pq.poll(); if (vis[p[1]]) continue; vis[p[1]] = true; total += p[0]; count++; for (int v = 0; v < n; v++) if (!vis[v]) { int d = Math.abs(points[p[1]][0] - points[v][0]) + Math.abs(points[p[1]][1] - points[v][1]); pq.offer(new int[]{d, v}); } } return total; } }",
                    "cpp": "class Solution { public: int minCostConnectPoints(vector<vector<int>>& points) { int n = points.size(); vector<bool> vis(n); priority_queue<pair<int,int>, vector<pair<int,int>>, greater<>> pq; pq.push({0, 0}); int total = 0, count = 0; while (count < n) { auto [cost, u] = pq.top(); pq.pop(); if (vis[u]) continue; vis[u] = true; total += cost; count++; for (int v = 0; v < n; v++) if (!vis[v]) { int d = abs(points[u][0] - points[v][0]) + abs(points[u][1] - points[v][1]); pq.push({d, v}); } } return total; } };"
                }
            }
        }
    },
    "palindrome-partitioning": {
        "description": "<p>Given a string <code>s</code>, partition <code>s</code> such that every substring of the partition is a <strong>palindrome</strong>. Return <em>all possible palindrome partitioning of</em> <code>s</code>.</p><p>A <strong>palindrome</strong> string is a string that reads the same backward as forward.</p><p><strong>Approach:</strong> Use <strong>backtracking</strong> to generate all partitions, checking each substring for palindrome property. Can optimize with DP table to precompute palindrome checks.</p>",
        "examples": [
            {
                "input": "s = \"aab\"",
                "output": "[[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]",
                "explanation": "Two valid partitions: splitting into [a, a, b] or [aa, b]."
            },
            {
                "input": "s = \"a\"",
                "output": "[[\"a\"]]",
                "explanation": "Only one character, which is already a palindrome."
            },
            {
                "input": "s = \"aaaa\"",
                "output": "[[\"a\",\"a\",\"a\",\"a\"],[\"a\",\"a\",\"aa\"],[\"a\",\"aaa\"],[\"aa\",\"a\",\"a\"],[\"aa\",\"aa\"],[\"aaa\",\"a\"],[\"aaaa\"]]",
                "explanation": "All characters are the same, many palindrome partitions exist."
            }
        ],
        "constraints": [
            "<code>1 <= s.length <= 16</code>",
            "<code>s contains only lowercase English letters</code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "Generate all partitions, filter palindromes.",
                "algorithm": "Backtracking",
                "complexity": {
                    "time": "O(n * 2^n)",
                    "space": "O(n)"
                },
                "code": {
                    "python": "class Solution:\n    def partition(self, s):\n        result = []\n        def isPalin(sub):\n            return sub == sub[::-1]\n        def backtrack(start, path):\n            if start == len(s):\n                result.append(path[:])\n                return\n            for end in range(start + 1, len(s) + 1):\n                if isPalin(s[start:end]):\n                    path.append(s[start:end])\n                    backtrack(end, path)\n                    path.pop()\n        backtrack(0, [])\n        return result",
                    "java": "class Solution { List<List<String>> result = new ArrayList<>(); public List<List<String>> partition(String s) { backtrack(s, 0, new ArrayList<>()); return result; } void backtrack(String s, int start, List<String> path) { if (start == s.length()) { result.add(new ArrayList<>(path)); return; } for (int end = start + 1; end <= s.length(); end++) { String sub = s.substring(start, end); if (isPalin(sub)) { path.add(sub); backtrack(s, end, path); path.remove(path.size() - 1); } } } boolean isPalin(String s) { int l = 0, r = s.length() - 1; while (l < r) if (s.charAt(l++) != s.charAt(r--)) return false; return true; } }",
                    "cpp": "class Solution { public: vector<vector<string>> partition(string s) { vector<vector<string>> result; vector<string> path; backtrack(s, 0, path, result); return result; } void backtrack(string& s, int start, vector<string>& path, vector<vector<string>>& result) { if (start == s.size()) { result.push_back(path); return; } for (int end = start + 1; end <= s.size(); end++) { string sub = s.substr(start, end - start); if (isPalin(sub)) { path.push_back(sub); backtrack(s, end, path, result); path.pop_back(); } } } bool isPalin(string& s) { int l = 0, r = s.size() - 1; while (l < r) if (s[l++] != s[r--]) return false; return true; } };"
                }
            },
            "optimized": {
                "intuition": "Precompute palindrome table.",
                "algorithm": "DP + Backtracking",
                "complexity": {
                    "time": "O(n * 2^n)",
                    "space": "O(n¬≤)"
                },
                "code": {
                    "python": "class Solution:\n    def partition(self, s):\n        n = len(s)\n        dp = [[False] * n for _ in range(n)]\n        for i in range(n): dp[i][i] = True\n        for length in range(2, n + 1):\n            for i in range(n - length + 1):\n                j = i + length - 1\n                if s[i] == s[j]:\n                    dp[i][j] = (j - i == 1) or dp[i+1][j-1]\n        result = []\n        def backtrack(start, path):\n            if start == n:\n                result.append(path[:])\n                return\n            for end in range(start, n):\n                if dp[start][end]:\n                    path.append(s[start:end+1])\n                    backtrack(end + 1, path)\n                    path.pop()\n        backtrack(0, [])\n        return result",
                    "java": "class Solution { boolean[][] dp; List<List<String>> result = new ArrayList<>(); public List<List<String>> partition(String s) { int n = s.length(); dp = new boolean[n][n]; for (int i = 0; i < n; i++) dp[i][i] = true; for (int len = 2; len <= n; len++) { for (int i = 0; i + len - 1 < n; i++) { int j = i + len - 1; if (s.charAt(i) == s.charAt(j)) dp[i][j] = (j - i == 1) || dp[i+1][j-1]; } } backtrack(s, 0, new ArrayList<>()); return result; } void backtrack(String s, int start, List<String> path) { if (start == s.length()) { result.add(new ArrayList<>(path)); return; } for (int end = start; end < s.length(); end++) { if (dp[start][end]) { path.add(s.substring(start, end + 1)); backtrack(s, end + 1, path); path.remove(path.size() - 1); } } } }",
                    "cpp": "class Solution { public: vector<vector<string>> partition(string s) { int n = s.size(); vector<vector<bool>> dp(n, vector<bool>(n)); for (int i = 0; i < n; i++) dp[i][i] = true; for (int len = 2; len <= n; len++) { for (int i = 0; i + len - 1 < n; i++) { int j = i + len - 1; if (s[i] == s[j]) dp[i][j] = (j - i == 1) || dp[i+1][j-1]; } } vector<vector<string>> result; vector<string> path; backtrack(s, 0, dp, path, result); return result; } void backtrack(string& s, int start, vector<vector<bool>>& dp, vector<string>& path, vector<vector<string>>& result) { if (start == s.size()) { result.push_back(path); return; } for (int end = start; end < s.size(); end++) { if (dp[start][end]) { path.push_back(s.substr(start, end - start + 1)); backtrack(s, end + 1, dp, path, result); path.pop_back(); } } } };"
                }
            }
        }
    },
    "n-queens": {
        "description": "<p>The <strong>n-queens</strong> puzzle is the problem of placing <code>n</code> queens on an <code>n x n</code> chessboard such that no two queens attack each other.</p><p>Given an integer <code>n</code>, return <em>all distinct solutions to the <strong>n-queens puzzle</strong></em>. You may return the answer in <strong>any order</strong>.</p><p>Each solution contains a distinct board configuration of the n-queens' placement, where <code>'Q'</code> and <code>'.'</code> both indicate a queen and an empty space, respectively.</p><p><strong>Queen Attack Rules:</strong> A queen can attack horizontally, vertically, and diagonally. Use <strong>backtracking</strong> with sets to track occupied columns and diagonals.</p>",
        "examples": [
            {
                "input": "n = 4",
                "output": "[[\"..Q.\",\"Q...\",\"...Q\",\".Q..\"],[\". .Q\",\"...Q\",\"Q...\",\"..Q.\"]]",
                "explanation": "There are two distinct solutions to the 4-queens puzzle."
            },
            {
                "input": "n = 1",
                "output": "[[\"Q\"]]",
                "explanation": "Only one square, place the queen there."
            }
        ],
        "constraints": [
            "<code>1 <= n <= 9</code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "Generate all placements, validate.",
                "algorithm": "Backtracking",
                "complexity": {
                    "time": "O(n!)",
                    "space": "O(n¬≤)"
                },
                "code": {
                    "python": "class Solution:\n    def solveNQueens(self, n):\n        result = []\n        board = [['.' for _ in range(n)] for _ in range(n)]\n        def isValid(row, col):\n            for i in range(row):\n                if board[i][col] == 'Q': return False\n            for i, j in zip(range(row-1,-1,-1), range(col-1,-1,-1)):\n                if board[i][j] == 'Q': return False\n            for i, j in zip(range(row-1,-1,-1), range(col+1,n)):\n                if board[i][j] == 'Q': return False\n            return True\n        def backtrack(row):\n            if row == n:\n                result.append([''.join(r) for r in board])\n                return\n            for col in range(n):\n                if isValid(row, col):\n                    board[row][col] = 'Q'\n                    backtrack(row + 1)\n                    board[row][col] = '.'\n        backtrack(0)\n        return result",
                    "java": "class Solution { List<List<String>> result = new ArrayList<>(); public List<List<String>> solveNQueens(int n) { char[][] board = new char[n][n]; for (char[] row : board) Arrays.fill(row, '.'); backtrack(board, 0); return result; } void backtrack(char[][] board, int row) { if (row == board.length) { List<String> sol = new ArrayList<>(); for (char[] r : board) sol.add(new String(r)); result.add(sol); return; } for (int col = 0; col < board.length; col++) { if (isValid(board, row, col)) { board[row][col] = 'Q'; backtrack(board, row + 1); board[row][col] = '.'; } } } boolean isValid(char[][] b, int row, int col) { for (int i = 0; i < row; i++) if (b[i][col] == 'Q') return false; for (int i = row-1, j = col-1; i >= 0 && j >= 0; i--, j--) if (b[i][j] == 'Q') return false; for (int i = row-1, j = col+1; i >= 0 && j < b.length; i--, j++) if (b[i][j] == 'Q') return false; return true; } }",
                    "cpp": "class Solution { public: vector<vector<string>> solveNQueens(int n) { vector<vector<string>> result; vector<string> board(n, string(n, '.')); backtrack(board, 0, result); return result; } void backtrack(vector<string>& board, int row, vector<vector<string>>& result) { if (row == board.size()) { result.push_back(board); return; } for (int col = 0; col < board.size(); col++) { if (isValid(board, row, col)) { board[row][col] = 'Q'; backtrack(board, row + 1, result); board[row][col] = '.'; } } } bool isValid(vector<string>& b, int row, int col) { for (int i = 0; i < row; i++) if (b[i][col] == 'Q') return false; for (int i = row-1, j = col-1; i >= 0 && j >= 0; i--, j--) if (b[i][j] == 'Q') return false; for (int i = row-1, j = col+1; i >= 0 && j < b.size(); i--, j++) if (b[i][j] == 'Q') return false; return true; } };"
                }
            },
            "optimized": {
                "intuition": "Use sets for O(1) conflict check.",
                "algorithm": "Backtracking with sets",
                "complexity": {
                    "time": "O(n!)",
                    "space": "O(n)"
                },
                "code": {
                    "python": "class Solution:\n    def solveNQueens(self, n):\n        result = []\n        cols = set()\n        diag1 = set()\n        diag2 = set()\n        board = [['.' for _ in range(n)] for _ in range(n)]\n        def backtrack(row):\n            if row == n:\n                result.append([''.join(r) for r in board])\n                return\n            for col in range(n):\n                if col in cols or (row - col) in diag1 or (row + col) in diag2:\n                    continue\n                cols.add(col)\n                diag1.add(row - col)\n                diag2.add(row + col)\n                board[row][col] = 'Q'\n                backtrack(row + 1)\n                board[row][col] = '.'\n                cols.remove(col)\n                diag1.remove(row - col)\n                diag2.remove(row + col)\n        backtrack(0)\n        return result",
                    "java": "class Solution { Set<Integer> cols = new HashSet<>(), d1 = new HashSet<>(), d2 = new HashSet<>(); List<List<String>> result = new ArrayList<>(); public List<List<String>> solveNQueens(int n) { char[][] board = new char[n][n]; for (char[] row : board) Arrays.fill(row, '.'); backtrack(board, 0); return result; } void backtrack(char[][] b, int row) { if (row == b.length) { List<String> sol = new ArrayList<>(); for (char[] r : b) sol.add(new String(r)); result.add(sol); return; } for (int col = 0; col < b.length; col++) { if (cols.contains(col) || d1.contains(row - col) || d2.contains(row + col)) continue; cols.add(col); d1.add(row - col); d2.add(row + col); b[row][col] = 'Q'; backtrack(b, row + 1); b[row][col] = '.'; cols.remove(col); d1.remove(row - col); d2.remove(row + col); } } }",
                    "cpp": "class Solution { unordered_set<int> cols, d1, d2; public: vector<vector<string>> solveNQueens(int n) { vector<vector<string>> result; vector<string> board(n, string(n, '.')); backtrack(board, 0, result); return result; } void backtrack(vector<string>& b, int row, vector<vector<string>>& result) { if (row == b.size()) { result.push_back(b); return; } for (int col = 0; col < b.size(); col++) { if (cols.count(col) || d1.count(row - col) || d2.count(row + col)) continue; cols.insert(col); d1.insert(row - col); d2.insert(row + col); b[row][col] = 'Q'; backtrack(b, row + 1, result); b[row][col] = '.'; cols.erase(col); d1.erase(row - col); d2.erase(row + col); } } };"
                }
            }
        }
    },
    "longest-palindromic-substring": {
        "description": "<p>Given a string <code>s</code>, return <em>the longest palindromic substring</em> in <code>s</code>.</p><p>A <strong>palindrome</strong> is a string that reads the same forward and backward. For example, \"racecar\" is a palindrome.</p><p><strong>Approach:</strong> Use <strong>expand around center</strong> technique - for each position, expand outward while characters match. Check both odd-length (single center) and even-length (two centers) palindromes. Time complexity: O(n¬≤).</p>",
        "examples": [
            {
                "input": "s = \"babad\"",
                "output": "\"bab\" or \"aba\"",
                "explanation": "Both \"bab\" and \"aba\" are valid longest palindromic substrings."
            },
            {
                "input": "s = \"cbbd\"",
                "output": "\"bb\"",
                "explanation": "The longest palindrome is \"bb\"."
            },
            {
                "input": "s = \"a\"",
                "output": "\"a\"",
                "explanation": "Single character is always a palindrome."
            }
        ],
        "constraints": [
            "<code>1 <= s.length <= 1000</code>",
            "<code>s consist of only digits and English letters</code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "Check all substrings.",
                "algorithm": "O(n¬≥) brute force",
                "complexity": {
                    "time": "O(n¬≥)",
                    "space": "O(1)"
                },
                "code": {
                    "python": "class Solution:\n    def longestPalindrome(self, s):\n        def isPalin(l, r):\n            while l < r:\n                if s[l] != s[r]: return False\n                l += 1; r -= 1\n            return True\n        res = ''\n        for i in range(len(s)):\n            for j in range(i, len(s)):\n                if isPalin(i, j) and j - i + 1 > len(res):\n                    res = s[i:j+1]\n        return res",
                    "java": "class Solution { public String longestPalindrome(String s) { String res = \"\"; for (int i = 0; i < s.length(); i++) { for (int j = i; j < s.length(); j++) { if (isPalin(s, i, j) && j - i + 1 > res.length()) res = s.substring(i, j + 1); } } return res; } boolean isPalin(String s, int l, int r) { while (l < r) if (s.charAt(l++) != s.charAt(r--)) return false; return true; } }",
                    "cpp": "class Solution { public: string longestPalindrome(string s) { string res = \"\"; for (int i = 0; i < s.size(); i++) { for (int j = i; j < s.size(); j++) { if (isPalin(s, i, j) && j - i + 1 > res.size()) res = s.substr(i, j - i + 1); } } return res; } bool isPalin(string& s, int l, int r) { while (l < r) if (s[l++] != s[r--]) return false; return true; } };"
                }
            },
            "optimized": {
                "intuition": "Expand around center.",
                "algorithm": "Check odd and even length palindromes",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(1)"
                },
                "code": {
                    "python": "class Solution:\n    def longestPalindrome(self, s):\n        res = ''\n        def expand(l, r):\n            while l >= 0 and r < len(s) and s[l] == s[r]:\n                l -= 1; r += 1\n            return s[l+1:r]\n        for i in range(len(s)):\n            odd = expand(i, i)\n            even = expand(i, i + 1)\n            if len(odd) > len(res): res = odd\n            if len(even) > len(res): res = even\n        return res",
                    "java": "class Solution { public String longestPalindrome(String s) { String res = \"\"; for (int i = 0; i < s.length(); i++) { String odd = expand(s, i, i); String even = expand(s, i, i + 1); if (odd.length() > res.length()) res = odd; if (even.length() > res.length()) res = even; } return res; } String expand(String s, int l, int r) { while (l >= 0 && r < s.length() && s.charAt(l) == s.charAt(r)) { l--; r++; } return s.substring(l + 1, r); } }",
                    "cpp": "class Solution { public: string longestPalindrome(string s) { string res = \"\"; for (int i = 0; i < s.size(); i++) { string odd = expand(s, i, i); string even = expand(s, i, i + 1); if (odd.size() > res.size()) res = odd; if (even.size() > res.size()) res = even; } return res; } string expand(string& s, int l, int r) { while (l >= 0 && r < s.size() && s[l] == s[r]) { l--; r++; } return s.substr(l + 1, r - l - 1); } };"
                }
            }
        }
    },
    "palindromic-substrings": {
        "description": "<p>Given a string <code>s</code>, return <em>the number of <strong>palindromic substrings</strong> in it</em>.</p><p>A string is a <strong>palindrome</strong> when it reads the same backward as forward.</p><p>A <strong>substring</strong> is a contiguous sequence of characters within the string.</p><p><strong>Approach:</strong> Expand around each possible center (both single character and between two characters) and count palindromes found. This is more efficient than checking all O(n¬≤) substrings individually.</p>",
        "examples": [
            {
                "input": "s = \"abc\"",
                "output": "3",
                "explanation": "Three palindromic substrings: \"a\", \"b\", \"c\"."
            },
            {
                "input": "s = \"aaa\"",
                "output": "6",
                "explanation": "Six palindromic substrings: \"a\", \"a\", \"a\", \"aa\", \"aa\", \"aaa\"."
            },
            {
                "input": "s = \"aba\"",
                "output": "4",
                "explanation": "Four palindromic substrings: \"a\", \"b\", \"a\", \"aba\"."
            }
        ],
        "constraints": [
            "<code>1 <= s.length <= 1000</code>",
            "<code>s consists of lowercase English letters</code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "Check all substrings.",
                "algorithm": "O(n¬≥) brute force",
                "complexity": {
                    "time": "O(n¬≥)",
                    "space": "O(1)"
                },
                "code": {
                    "python": "class Solution:\n    def countSubstrings(self, s):\n        def isPalin(l, r):\n            while l < r:\n                if s[l] != s[r]: return False\n                l += 1; r -= 1\n            return True\n        count = 0\n        for i in range(len(s)):\n            for j in range(i, len(s)):\n                if isPalin(i, j): count += 1\n        return count",
                    "java": "class Solution { public int countSubstrings(String s) { int count = 0; for (int i = 0; i < s.length(); i++) { for (int j = i; j < s.length(); j++) { if (isPalin(s, i, j)) count++; } } return count; } boolean isPalin(String s, int l, int r) { while (l < r) if (s.charAt(l++) != s.charAt(r--)) return false; return true; } }",
                    "cpp": "class Solution { public: int countSubstrings(string s) { int count = 0; for (int i = 0; i < s.size(); i++) { for (int j = i; j < s.size(); j++) { if (isPalin(s, i, j)) count++; } } return count; } bool isPalin(string& s, int l, int r) { while (l < r) if (s[l++] != s[r--]) return false; return true; } };"
                }
            },
            "optimized": {
                "intuition": "Expand around center.",
                "algorithm": "Count during expansion",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(1)"
                },
                "code": {
                    "python": "class Solution:\n    def countSubstrings(self, s):\n        count = 0\n        def expand(l, r):\n            nonlocal count\n            while l >= 0 and r < len(s) and s[l] == s[r]:\n                count += 1\n                l -= 1; r += 1\n        for i in range(len(s)):\n            expand(i, i)\n            expand(i, i + 1)\n        return count",
                    "java": "class Solution { int count = 0; public int countSubstrings(String s) { for (int i = 0; i < s.length(); i++) { expand(s, i, i); expand(s, i, i + 1); } return count; } void expand(String s, int l, int r) { while (l >= 0 && r < s.length() && s.charAt(l) == s.charAt(r)) { count++; l--; r++; } } }",
                    "cpp": "class Solution { public: int countSubstrings(string s) { int count = 0; for (int i = 0; i < s.size(); i++) { expand(s, i, i, count); expand(s, i, i + 1, count); } return count; } void expand(string& s, int l, int r, int& count) { while (l >= 0 && r < s.size() && s[l] == s[r]) { count++; l--; r++; } } };"
                }
            }
        }
    },
    "edit-distance": {
        "description": "<p>Given two strings <code>word1</code> and <code>word2</code>, return <em>the minimum number of operations required to convert <code>word1</code> to <code>word2</code></em>.</p><p>You have the following three operations permitted on a word:</p><ul><li>Insert a character</li><li>Delete a character</li><li>Replace a character</li></ul><p><strong>Approach:</strong> Classic <strong>2D Dynamic Programming</strong>. Let <code>dp[i][j]</code> = minimum operations to convert <code>word1[0..i-1]</code> to <code>word2[0..j-1]</code>. If characters match, <code>dp[i][j] = dp[i-1][j-1]</code>. Otherwise, take minimum of insert, delete, or replace operations.</p>",
        "examples": [
            {
                "input": "word1 = \"horse\", word2 = \"ros\"",
                "output": "3",
                "explanation": "horse -> rorse (replace 'h' with 'r'), rorse -> rose (remove 'r'), rose -> ros (remove 'e')."
            },
            {
                "input": "word1 = \"intention\", word2 = \"execution\"",
                "output": "5",
                "explanation": "intention -> inention (remove 't'), inention -> enention (replace 'i' with 'e'), enention -> exention (replace 'n' with 'x'), exention -> exection (replace 'n' with 'c'), exection -> execution (insert 'u')."
            },
            {
                "input": "word1 = \"abc\", word2 = \"abc\"",
                "output": "0",
                "explanation": "Words are identical, no operations needed."
            }
        ],
        "constraints": [
            "<code>0 <= word1.length, word2.length <= 500</code>",
            "<code>word1 and word2 consist of lowercase English letters</code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "Try all operations recursively.",
                "algorithm": "Recursion with memoization",
                "complexity": {
                    "time": "O(3^(m+n))",
                    "space": "O(m+n)"
                },
                "code": {
                    "python": "class Solution:\n    def minDistance(self, word1, word2):\n        def dp(i, j):\n            if i == 0: return j\n            if j == 0: return i\n            if word1[i-1] == word2[j-1]: return dp(i-1, j-1)\n            return 1 + min(dp(i-1, j), dp(i, j-1), dp(i-1, j-1))\n        return dp(len(word1), len(word2))",
                    "java": "class Solution { public int minDistance(String w1, String w2) { return dp(w1, w2, w1.length(), w2.length()); } int dp(String w1, String w2, int i, int j) { if (i == 0) return j; if (j == 0) return i; if (w1.charAt(i-1) == w2.charAt(j-1)) return dp(w1, w2, i-1, j-1); return 1 + Math.min(dp(w1, w2, i-1, j), Math.min(dp(w1, w2, i, j-1), dp(w1, w2, i-1, j-1))); } }",
                    "cpp": "class Solution { public: int minDistance(string w1, string w2) { return dp(w1, w2, w1.size(), w2.size()); } int dp(string& w1, string& w2, int i, int j) { if (i == 0) return j; if (j == 0) return i; if (w1[i-1] == w2[j-1]) return dp(w1, w2, i-1, j-1); return 1 + min({dp(w1, w2, i-1, j), dp(w1, w2, i, j-1), dp(w1, w2, i-1, j-1)}); } };"
                }
            },
            "optimized": {
                "intuition": "DP table.",
                "algorithm": "Bottom-up DP",
                "complexity": {
                    "time": "O(mn)",
                    "space": "O(mn)"
                },
                "code": {
                    "python": "class Solution:\n    def minDistance(self, word1, word2):\n        m, n = len(word1), len(word2)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        for i in range(m + 1): dp[i][0] = i\n        for j in range(n + 1): dp[0][j] = j\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if word1[i-1] == word2[j-1]:\n                    dp[i][j] = dp[i-1][j-1]\n                else:\n                    dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])\n        return dp[m][n]",
                    "java": "class Solution { public int minDistance(String w1, String w2) { int m = w1.length(), n = w2.length(); int[][] dp = new int[m + 1][n + 1]; for (int i = 0; i <= m; i++) dp[i][0] = i; for (int j = 0; j <= n; j++) dp[0][j] = j; for (int i = 1; i <= m; i++) { for (int j = 1; j <= n; j++) { if (w1.charAt(i-1) == w2.charAt(j-1)) dp[i][j] = dp[i-1][j-1]; else dp[i][j] = 1 + Math.min(dp[i-1][j], Math.min(dp[i][j-1], dp[i-1][j-1])); } } return dp[m][n]; } }",
                    "cpp": "class Solution { public: int minDistance(string w1, string w2) { int m = w1.size(), n = w2.size(); vector<vector<int>> dp(m + 1, vector<int>(n + 1)); for (int i = 0; i <= m; i++) dp[i][0] = i; for (int j = 0; j <= n; j++) dp[0][j] = j; for (int i = 1; i <= m; i++) { for (int j = 1; j <= n; j++) { if (w1[i-1] == w2[j-1]) dp[i][j] = dp[i-1][j-1]; else dp[i][j] = 1 + min({dp[i-1][j], dp[i][j-1], dp[i-1][j-1]}); } } return dp[m][n]; } };"
                }
            }
        }
    },
    "distinct-subsequences": {
        "description": "<p>Given two strings <code>s</code> and <code>t</code>, return <em>the number of distinct <strong>subsequences</strong> of <code>s</code> which equals <code>t</code></em>.</p><p>A string's <strong>subsequence</strong> is a new string formed from the original string by deleting some (can be none) characters without disturbing the remaining characters' relative positions.</p><p><strong>Approach:</strong> Use <strong>2D Dynamic Programming</strong>. Let <code>dp[i][j]</code> = number of ways to form <code>t[0..j-1]</code> from <code>s[0..i-1]</code>. If <code>s[i-1] == t[j-1]</code>, we can either use this character (<code>dp[i-1][j-1]</code>) or skip it (<code>dp[i-1][j]</code>). Otherwise, we can only skip (<code>dp[i-1][j]</code>).</p>",
        "examples": [
            {
                "input": "s = \"rabbbit\", t = \"rabbit\"",
                "output": "3",
                "explanation": "Three distinct subsequences: rabb(b)it, rab(b)bit, ra(b)bbit."
            },
            {
                "input": "s = \"babgbag\", t = \"bag\"",
                "output": "5",
                "explanation": "Five ways to form 'bag': (b)a(bg)bag, (b)ab(g)bag, (ba)b(g)bag, ba(b)(g)bag, babg(bag)."
            },
            {
                "input": "s = \"abc\", t = \"def\"",
                "output": "0",
                "explanation": "Cannot form 'def' from 'abc'."
            }
        ],
        "constraints": [
            "<code>1 <= s.length, t.length <= 1000</code>",
            "<code>s and t consist of English letters</code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "Try all subsequences.",
                "algorithm": "Recursion",
                "complexity": {
                    "time": "O(2^n)",
                    "space": "O(n)"
                },
                "code": {
                    "python": "class Solution:\n    def numDistinct(self, s, t):\n        def dp(i, j):\n            if j == len(t): return 1\n            if i == len(s): return 0\n            res = dp(i + 1, j)\n            if s[i] == t[j]: res += dp(i + 1, j + 1)\n            return res\n        return dp(0, 0)",
                    "java": "class Solution { public int numDistinct(String s, String t) { return dp(s, t, 0, 0); } int dp(String s, String t, int i, int j) { if (j == t.length()) return 1; if (i == s.length()) return 0; int res = dp(s, t, i + 1, j); if (s.charAt(i) == t.charAt(j)) res += dp(s, t, i + 1, j + 1); return res; } }",
                    "cpp": "class Solution { public: int numDistinct(string s, string t) { return dp(s, t, 0, 0); } int dp(string& s, string& t, int i, int j) { if (j == t.size()) return 1; if (i == s.size()) return 0; int res = dp(s, t, i + 1, j); if (s[i] == t[j]) res += dp(s, t, i + 1, j + 1); return res; } };"
                }
            },
            "optimized": {
                "intuition": "DP table.",
                "algorithm": "Bottom-up DP",
                "complexity": {
                    "time": "O(mn)",
                    "space": "O(mn)"
                },
                "code": {
                    "python": "class Solution:\n    def numDistinct(self, s, t):\n        m, n = len(s), len(t)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        for i in range(m + 1): dp[i][0] = 1\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                dp[i][j] = dp[i-1][j]\n                if s[i-1] == t[j-1]: dp[i][j] += dp[i-1][j-1]\n        return dp[m][n]",
                    "java": "class Solution { public int numDistinct(String s, String t) { int m = s.length(), n = t.length(); long[][] dp = new long[m + 1][n + 1]; for (int i = 0; i <= m; i++) dp[i][0] = 1; for (int i = 1; i <= m; i++) { for (int j = 1; j <= n; j++) { dp[i][j] = dp[i-1][j]; if (s.charAt(i-1) == t.charAt(j-1)) dp[i][j] += dp[i-1][j-1]; } } return (int) dp[m][n]; } }",
                    "cpp": "class Solution { public: int numDistinct(string s, string t) { int m = s.size(), n = t.size(); vector<vector<unsigned long long>> dp(m + 1, vector<unsigned long long>(n + 1)); for (int i = 0; i <= m; i++) dp[i][0] = 1; for (int i = 1; i <= m; i++) { for (int j = 1; j <= n; j++) { dp[i][j] = dp[i-1][j]; if (s[i-1] == t[j-1]) dp[i][j] += dp[i-1][j-1]; } } return dp[m][n]; } };"
                }
            }
        }
    },
    "burst-balloons": {
        "description": "<p>You are given <code>n</code> balloons, indexed from <code>0</code> to <code>n - 1</code>. Each balloon is painted with a number on it represented by an array <code>nums</code>. You are asked to burst all the balloons.</p><p>If you burst the <code>i<sup>th</sup></code> balloon, you will get <code>nums[i - 1] * nums[i] * nums[i + 1]</code> coins. If <code>i - 1</code> or <code>i + 1</code> goes out of bounds, treat it as a balloon with a <code>1</code> painted on it.</p><p>Return <em>the maximum coins you can collect by bursting the balloons wisely</em>.</p><p><strong>Approach:</strong> Use <strong>Interval DP</strong>. Key insight: Instead of thinking about which balloon to burst first, think about which balloon to burst <strong>last</strong> in an interval. Add virtual balloons with value 1 at both ends. For each interval <code>[left, right]</code>, try bursting each balloon <code>k</code> as the last one, giving <code>nums[left] * nums[k] * nums[right]</code> coins plus the optimal solutions for the two subintervals.</p>",
        "examples": [
            {
                "input": "nums = [3,1,5,8]",
                "output": "167",
                "explanation": "Burst 1 (3*1*5=15), burst 5 (3*5*8=120), burst 3 (1*3*8=24), burst 8 (1*8*1=8). Total = 167."
            },
            {
                "input": "nums = [1,5]",
                "output": "10",
                "explanation": "Burst 1 (1*1*5=5), burst 5 (1*5*1=5). Total = 10."
            },
            {
                "input": "nums = [5]",
                "output": "5",
                "explanation": "Only one balloon: 1*5*1 = 5."
            }
        ],
        "constraints": [
            "<code>n == nums.length</code>",
            "<code>1 <= n <= 300</code>",
            "<code>0 <= nums[i] <= 100</code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "Try all burst orders.",
                "algorithm": "Recursion with all permutations",
                "complexity": {
                    "time": "O(n!)",
                    "space": "O(n)"
                },
                "code": {
                    "python": "class Solution:\n    def maxCoins(self, nums):\n        def solve(arr):\n            if not arr: return 0\n            res = 0\n            for i in range(len(arr)):\n                left = arr[i-1] if i > 0 else 1\n                right = arr[i+1] if i < len(arr) - 1 else 1\n                coins = left * arr[i] * right\n                res = max(res, coins + solve(arr[:i] + arr[i+1:]))\n            return res\n        return solve(nums)",
                    "java": "class Solution { public int maxCoins(int[] nums) { List<Integer> arr = new ArrayList<>(); for (int n : nums) arr.add(n); return solve(arr); } int solve(List<Integer> arr) { if (arr.isEmpty()) return 0; int res = 0; for (int i = 0; i < arr.size(); i++) { int left = i > 0 ? arr.get(i - 1) : 1; int right = i < arr.size() - 1 ? arr.get(i + 1) : 1; int coins = left * arr.get(i) * right; List<Integer> next = new ArrayList<>(arr); next.remove(i); res = Math.max(res, coins + solve(next)); } return res; } }",
                    "cpp": "class Solution { public: int maxCoins(vector<int>& nums) { return solve(nums); } int solve(vector<int> arr) { if (arr.empty()) return 0; int res = 0; for (int i = 0; i < arr.size(); i++) { int left = i > 0 ? arr[i - 1] : 1; int right = i < arr.size() - 1 ? arr[i + 1] : 1; int coins = left * arr[i] * right; vector<int> next; for (int j = 0; j < arr.size(); j++) if (j != i) next.push_back(arr[j]); res = max(res, coins + solve(next)); } return res; } };"
                }
            },
            "optimized": {
                "intuition": "Interval DP.",
                "algorithm": "Think of last balloon to burst",
                "complexity": {
                    "time": "O(n¬≥)",
                    "space": "O(n¬≤)"
                },
                "code": {
                    "python": "class Solution:\n    def maxCoins(self, nums):\n        nums = [1] + nums + [1]\n        n = len(nums)\n        dp = [[0] * n for _ in range(n)]\n        for length in range(2, n):\n            for left in range(0, n - length):\n                right = left + length\n                for k in range(left + 1, right):\n                    dp[left][right] = max(dp[left][right],\n                        nums[left] * nums[k] * nums[right] + dp[left][k] + dp[k][right])\n        return dp[0][n - 1]",
                    "java": "class Solution { public int maxCoins(int[] nums) { int n = nums.length + 2; int[] arr = new int[n]; arr[0] = arr[n - 1] = 1; for (int i = 1; i < n - 1; i++) arr[i] = nums[i - 1]; int[][] dp = new int[n][n]; for (int len = 2; len < n; len++) { for (int left = 0; left < n - len; left++) { int right = left + len; for (int k = left + 1; k < right; k++) { dp[left][right] = Math.max(dp[left][right], arr[left] * arr[k] * arr[right] + dp[left][k] + dp[k][right]); } } } return dp[0][n - 1]; } }",
                    "cpp": "class Solution { public: int maxCoins(vector<int>& nums) { int n = nums.size() + 2; vector<int> arr(n); arr[0] = arr[n - 1] = 1; for (int i = 1; i < n - 1; i++) arr[i] = nums[i - 1]; vector<vector<int>> dp(n, vector<int>(n)); for (int len = 2; len < n; len++) { for (int left = 0; left < n - len; left++) { int right = left + len; for (int k = left + 1; k < right; k++) { dp[left][right] = max(dp[left][right], arr[left] * arr[k] * arr[right] + dp[left][k] + dp[k][right]); } } } return dp[0][n - 1]; } };"
                }
            }
        }
    },
    "regular-expression-matching": {
        "description": "<p>Given an input string <code>s</code> and a pattern <code>p</code>, implement regular expression matching with support for <code>'.'</code> and <code>'*'</code> where:</p><ul><li><code>'.'</code> Matches any single character</li><li><code>'*'</code> Matches zero or more of the preceding element</li></ul><p>The matching should cover the <strong>entire</strong> input string (not partial).</p><p><strong>Approach:</strong> Use <strong>2D Dynamic Programming</strong>. Let <code>dp[i][j]</code> = whether <code>s[0..i-1]</code> matches <code>p[0..j-1]</code>. Handle three cases: normal character match, <code>'.'</code> wildcard, and <code>'*'</code> which can match zero or more of the preceding character. The <code>'*'</code> case requires checking if we can skip the <code>char*</code> pattern or if the preceding character matches and we can continue matching.</p>",
        "examples": [
            {
                "input": "s = \"aa\", p = \"a*\"",
                "output": "true",
                "explanation": "'*' means zero or more 'a', so it matches 'aa'."
            },
            {
                "input": "s = \"ab\", p = \".*\"",
                "output": "true",
                "explanation": "'.*' means zero or more of any character, matching 'ab'."
            },
            {
                "input": "s = \"mississippi\", p = \"mis*is*p*.\"",
                "output": "false",
                "explanation": "Pattern doesn't fully match the string."
            },
            {
                "input": "s = \"aab\", p = \"c*a*b\"",
                "output": "true",
                "explanation": "'c*' matches zero 'c', 'a*' matches 'aa', 'b' matches 'b'."
            }
        ],
        "constraints": [
            "<code>1 <= s.length <= 20</code>",
            "<code>1 <= p.length <= 20</code>",
            "<code>s contains only lowercase English letters</code>",
            "<code>p contains only lowercase English letters, '.', and '*'</code>",
            "<code>It is guaranteed for each appearance of '*', there will be a previous valid character to match</code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "Try all matches recursively.",
                "algorithm": "Recursion",
                "complexity": {
                    "time": "O((m+n)*2^(m+n))",
                    "space": "O(m+n)"
                },
                "code": {
                    "python": "class Solution:\n    def isMatch(self, s, p):\n        if not p: return not s\n        first = bool(s) and p[0] in {s[0], '.'}\n        if len(p) >= 2 and p[1] == '*':\n            return self.isMatch(s, p[2:]) or (first and self.isMatch(s[1:], p))\n        return first and self.isMatch(s[1:], p[1:])",
                    "java": "class Solution { public boolean isMatch(String s, String p) { if (p.isEmpty()) return s.isEmpty(); boolean first = !s.isEmpty() && (p.charAt(0) == s.charAt(0) || p.charAt(0) == '.'); if (p.length() >= 2 && p.charAt(1) == '*') { return isMatch(s, p.substring(2)) || (first && isMatch(s.substring(1), p)); } return first && isMatch(s.substring(1), p.substring(1)); } }",
                    "cpp": "class Solution { public: bool isMatch(string s, string p) { if (p.empty()) return s.empty(); bool first = !s.empty() && (p[0] == s[0] || p[0] == '.'); if (p.size() >= 2 && p[1] == '*') { return isMatch(s, p.substr(2)) || (first && isMatch(s.substr(1), p)); } return first && isMatch(s.substr(1), p.substr(1)); } };"
                }
            },
            "optimized": {
                "intuition": "DP table.",
                "algorithm": "Bottom-up DP",
                "complexity": {
                    "time": "O(mn)",
                    "space": "O(mn)"
                },
                "code": {
                    "python": "class Solution:\n    def isMatch(self, s, p):\n        m, n = len(s), len(p)\n        dp = [[False] * (n + 1) for _ in range(m + 1)]\n        dp[0][0] = True\n        for j in range(2, n + 1):\n            if p[j - 1] == '*': dp[0][j] = dp[0][j - 2]\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if p[j - 1] == '*':\n                    dp[i][j] = dp[i][j - 2]\n                    if p[j - 2] == '.' or p[j - 2] == s[i - 1]:\n                        dp[i][j] = dp[i][j] or dp[i - 1][j]\n                elif p[j - 1] == '.' or p[j - 1] == s[i - 1]:\n                    dp[i][j] = dp[i - 1][j - 1]\n        return dp[m][n]",
                    "java": "class Solution { public boolean isMatch(String s, String p) { int m = s.length(), n = p.length(); boolean[][] dp = new boolean[m + 1][n + 1]; dp[0][0] = true; for (int j = 2; j <= n; j++) { if (p.charAt(j - 1) == '*') dp[0][j] = dp[0][j - 2]; } for (int i = 1; i <= m; i++) { for (int j = 1; j <= n; j++) { if (p.charAt(j - 1) == '*') { dp[i][j] = dp[i][j - 2]; if (p.charAt(j - 2) == '.' || p.charAt(j - 2) == s.charAt(i - 1)) dp[i][j] = dp[i][j] || dp[i - 1][j]; } else if (p.charAt(j - 1) == '.' || p.charAt(j - 1) == s.charAt(i - 1)) { dp[i][j] = dp[i - 1][j - 1]; } } } return dp[m][n]; } }",
                    "cpp": "class Solution { public: bool isMatch(string s, string p) { int m = s.size(), n = p.size(); vector<vector<bool>> dp(m + 1, vector<bool>(n + 1)); dp[0][0] = true; for (int j = 2; j <= n; j++) { if (p[j - 1] == '*') dp[0][j] = dp[0][j - 2]; } for (int i = 1; i <= m; i++) { for (int j = 1; j <= n; j++) { if (p[j - 1] == '*') { dp[i][j] = dp[i][j - 2]; if (p[j - 2] == '.' || p[j - 2] == s[i - 1]) dp[i][j] = dp[i][j] || dp[i - 1][j]; } else if (p[j - 1] == '.' || p[j - 1] == s[i - 1]) { dp[i][j] = dp[i - 1][j - 1]; } } } return dp[m][n]; } };"
                }
            }
        }
    },
    "interleaving-string": {
        "description": "<p>Given strings <code>s1</code>, <code>s2</code>, and <code>s3</code>, find whether <code>s3</code> is formed by an <strong>interleaving</strong> of <code>s1</code> and <code>s2</code>.</p><p>An <strong>interleaving</strong> of two strings <code>s</code> and <code>t</code> is a configuration where <code>s</code> and <code>t</code> are divided into <code>n</code> and <code>m</code> substrings respectively, such that their concatenation forms the original strings, and the substrings appear in the same relative order in the interleaved string.</p><p><strong>Approach:</strong> Use <strong>2D Dynamic Programming</strong>. Let <code>dp[i][j]</code> = whether we can form <code>s3[0..i+j-1]</code> using <code>s1[0..i-1]</code> and <code>s2[0..j-1]</code>. At each position, we can take a character from <code>s1</code> (if it matches <code>s3[i+j-1]</code> and <code>dp[i-1][j]</code> is true) or from <code>s2</code> (if it matches and <code>dp[i][j-1]</code> is true).</p>",
        "examples": [
            {
                "input": "s1 = \"aabcc\", s2 = \"dbbca\", s3 = \"aadbbcbcac\"",
                "output": "true",
                "explanation": "One valid interleaving: aa(from s1) + d(from s2) + bb(from s2) + c(from s1) + b(from s2) + c(from s1) + a(from s2) + c(from s1)."
            },
            {
                "input": "s1 = \"aabcc\", s2 = \"dbbca\", s3 = \"aadbbbaccc\"",
                "output": "false",
                "explanation": "Cannot form s3 as an interleaving of s1 and s2."
            },
            {
                "input": "s1 = \"\", s2 = \"\", s3 = \"\"",
                "output": "true",
                "explanation": "All strings are empty."
            }
        ],
        "constraints": [
            "<code>0 <= s1.length, s2.length <= 100</code>",
            "<code>0 <= s3.length <= 200</code>",
            "<code>s1, s2, and s3 consist of lowercase English letters</code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "Try all interleavings.",
                "algorithm": "Recursion",
                "complexity": {
                    "time": "O(2^(m+n))",
                    "space": "O(m+n)"
                },
                "code": {
                    "python": "class Solution:\n    def isInterleave(self, s1, s2, s3):\n        if len(s1) + len(s2) != len(s3): return False\n        def dp(i, j):\n            if i + j == len(s3): return True\n            res = False\n            if i < len(s1) and s1[i] == s3[i + j]: res = dp(i + 1, j)\n            if j < len(s2) and s2[j] == s3[i + j]: res = res or dp(i, j + 1)\n            return res\n        return dp(0, 0)",
                    "java": "class Solution { public boolean isInterleave(String s1, String s2, String s3) { if (s1.length() + s2.length() != s3.length()) return false; return dp(s1, s2, s3, 0, 0); } boolean dp(String s1, String s2, String s3, int i, int j) { if (i + j == s3.length()) return true; boolean res = false; if (i < s1.length() && s1.charAt(i) == s3.charAt(i + j)) res = dp(s1, s2, s3, i + 1, j); if (j < s2.length() && s2.charAt(j) == s3.charAt(i + j)) res = res || dp(s1, s2, s3, i, j + 1); return res; } }",
                    "cpp": "class Solution { public: bool isInterleave(string s1, string s2, string s3) { if (s1.size() + s2.size() != s3.size()) return false; return dp(s1, s2, s3, 0, 0); } bool dp(string& s1, string& s2, string& s3, int i, int j) { if (i + j == s3.size()) return true; bool res = false; if (i < s1.size() && s1[i] == s3[i + j]) res = dp(s1, s2, s3, i + 1, j); if (j < s2.size() && s2[j] == s3[i + j]) res = res || dp(s1, s2, s3, i, j + 1); return res; } };"
                }
            },
            "optimized": {
                "intuition": "DP table.",
                "algorithm": "Bottom-up DP",
                "complexity": {
                    "time": "O(mn)",
                    "space": "O(mn)"
                },
                "code": {
                    "python": "class Solution:\n    def isInterleave(self, s1, s2, s3):\n        m, n = len(s1), len(s2)\n        if m + n != len(s3): return False\n        dp = [[False] * (n + 1) for _ in range(m + 1)]\n        dp[0][0] = True\n        for i in range(1, m + 1):\n            dp[i][0] = dp[i-1][0] and s1[i-1] == s3[i-1]\n        for j in range(1, n + 1):\n            dp[0][j] = dp[0][j-1] and s2[j-1] == s3[j-1]\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                dp[i][j] = (dp[i-1][j] and s1[i-1] == s3[i+j-1]) or (dp[i][j-1] and s2[j-1] == s3[i+j-1])\n        return dp[m][n]",
                    "java": "class Solution { public boolean isInterleave(String s1, String s2, String s3) { int m = s1.length(), n = s2.length(); if (m + n != s3.length()) return false; boolean[][] dp = new boolean[m + 1][n + 1]; dp[0][0] = true; for (int i = 1; i <= m; i++) dp[i][0] = dp[i-1][0] && s1.charAt(i-1) == s3.charAt(i-1); for (int j = 1; j <= n; j++) dp[0][j] = dp[0][j-1] && s2.charAt(j-1) == s3.charAt(j-1); for (int i = 1; i <= m; i++) { for (int j = 1; j <= n; j++) { dp[i][j] = (dp[i-1][j] && s1.charAt(i-1) == s3.charAt(i+j-1)) || (dp[i][j-1] && s2.charAt(j-1) == s3.charAt(i+j-1)); } } return dp[m][n]; } }",
                    "cpp": "class Solution { public: bool isInterleave(string s1, string s2, string s3) { int m = s1.size(), n = s2.size(); if (m + n != s3.size()) return false; vector<vector<bool>> dp(m + 1, vector<bool>(n + 1)); dp[0][0] = true; for (int i = 1; i <= m; i++) dp[i][0] = dp[i-1][0] && s1[i-1] == s3[i-1]; for (int j = 1; j <= n; j++) dp[0][j] = dp[0][j-1] && s2[j-1] == s3[j-1]; for (int i = 1; i <= m; i++) { for (int j = 1; j <= n; j++) { dp[i][j] = (dp[i-1][j] && s1[i-1] == s3[i+j-1]) || (dp[i][j-1] && s2[j-1] == s3[i+j-1]); } } return dp[m][n]; } };"
                }
            }
        }
    },
    "longest-common-subsequence": {
        "description": "<p>Given two strings <code>text1</code> and <code>text2</code>, return <em>the length of their longest <strong>common subsequence</strong></em>. If there is no common subsequence, return <code>0</code>.</p><p>A <strong>subsequence</strong> of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.</p><p><strong>Approach:</strong> Classic <strong>2D Dynamic Programming</strong>. Let <code>dp[i][j]</code> = length of LCS of <code>text1[0..i-1]</code> and <code>text2[0..j-1]</code>. If characters match, <code>dp[i][j] = dp[i-1][j-1] + 1</code>. Otherwise, take the maximum of skipping one character from either string: <code>dp[i][j] = max(dp[i-1][j], dp[i][j-1])</code>.</p>",
        "examples": [
            {
                "input": "text1 = \"abcde\", text2 = \"ace\"",
                "output": "3",
                "explanation": "The longest common subsequence is 'ace' with length 3."
            },
            {
                "input": "text1 = \"abc\", text2 = \"abc\"",
                "output": "3",
                "explanation": "The entire strings match: 'abc'."
            },
            {
                "input": "text1 = \"abc\", text2 = \"def\"",
                "output": "0",
                "explanation": "No common subsequence."
            }
        ],
        "constraints": [
            "<code>1 <= text1.length, text2.length <= 1000</code>",
            "<code>text1 and text2 consist of only lowercase English characters</code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "Generate all subsequences.",
                "algorithm": "Recursion",
                "complexity": {
                    "time": "O(2^(m+n))",
                    "space": "O(m+n)"
                },
                "code": {
                    "python": "class Solution:\n    def longestCommonSubsequence(self, text1, text2):\n        def dp(i, j):\n            if i == len(text1) or j == len(text2): return 0\n            if text1[i] == text2[j]: return 1 + dp(i + 1, j + 1)\n            return max(dp(i + 1, j), dp(i, j + 1))\n        return dp(0, 0)",
                    "java": "class Solution { public int longestCommonSubsequence(String t1, String t2) { return dp(t1, t2, 0, 0); } int dp(String t1, String t2, int i, int j) { if (i == t1.length() || j == t2.length()) return 0; if (t1.charAt(i) == t2.charAt(j)) return 1 + dp(t1, t2, i + 1, j + 1); return Math.max(dp(t1, t2, i + 1, j), dp(t1, t2, i, j + 1)); } }",
                    "cpp": "class Solution { public: int longestCommonSubsequence(string t1, string t2) { return dp(t1, t2, 0, 0); } int dp(string& t1, string& t2, int i, int j) { if (i == t1.size() || j == t2.size()) return 0; if (t1[i] == t2[j]) return 1 + dp(t1, t2, i + 1, j + 1); return max(dp(t1, t2, i + 1, j), dp(t1, t2, i, j + 1)); } };"
                }
            },
            "optimized": {
                "intuition": "DP table.",
                "algorithm": "Bottom-up DP",
                "complexity": {
                    "time": "O(mn)",
                    "space": "O(mn)"
                },
                "code": {
                    "python": "class Solution:\n    def longestCommonSubsequence(self, text1, text2):\n        m, n = len(text1), len(text2)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if text1[i - 1] == text2[j - 1]:\n                    dp[i][j] = dp[i-1][j-1] + 1\n                else:\n                    dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n        return dp[m][n]",
                    "java": "class Solution { public int longestCommonSubsequence(String t1, String t2) { int m = t1.length(), n = t2.length(); int[][] dp = new int[m + 1][n + 1]; for (int i = 1; i <= m; i++) { for (int j = 1; j <= n; j++) { if (t1.charAt(i - 1) == t2.charAt(j - 1)) dp[i][j] = dp[i-1][j-1] + 1; else dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]); } } return dp[m][n]; } }",
                    "cpp": "class Solution { public: int longestCommonSubsequence(string t1, string t2) { int m = t1.size(), n = t2.size(); vector<vector<int>> dp(m + 1, vector<int>(n + 1)); for (int i = 1; i <= m; i++) { for (int j = 1; j <= n; j++) { if (t1[i - 1] == t2[j - 1]) dp[i][j] = dp[i-1][j-1] + 1; else dp[i][j] = max(dp[i-1][j], dp[i][j-1]); } } return dp[m][n]; } };"
                }
            }
        }
    },
    "target-sum": {
        "description": "<p>You are given an integer array <code>nums</code> and an integer <code>target</code>.</p><p>You want to build an <strong>expression</strong> out of <code>nums</code> by adding one of the symbols <code>'+'</code> and <code>'-'</code> before each integer in <code>nums</code> and then concatenate all the integers.</p><p>Return <em>the number of different <strong>expressions</strong> that you can build, which evaluates to <code>target</code></em>.</p><p><strong>Approach:</strong> Transform the problem into a <strong>subset sum</strong> problem. If we split <code>nums</code> into two groups <code>P</code> (positive) and <code>N</code> (negative), then <code>sum(P) - sum(N) = target</code>. Since <code>sum(P) + sum(N) = sum(nums)</code>, we get <code>sum(P) = (target + sum(nums)) / 2</code>. Now we just need to count subsets with this sum using 1D DP.</p>",
        "examples": [
            {
                "input": "nums = [1,1,1,1,1], target = 3",
                "output": "5",
                "explanation": "There are 5 ways: -1+1+1+1+1=3, +1-1+1+1+1=3, +1+1-1+1+1=3, +1+1+1-1+1=3, +1+1+1+1-1=3."
            },
            {
                "input": "nums = [1], target = 1",
                "output": "1",
                "explanation": "Only one way: +1 = 1."
            },
            {
                "input": "nums = [1,2,1], target = 0",
                "output": "2",
                "explanation": "Two ways: +1-2+1=0, -1+2-1=0."
            }
        ],
        "constraints": [
            "<code>1 <= nums.length <= 20</code>",
            "<code>0 <= nums[i] <= 1000</code>",
            "<code>0 <= sum(nums[i]) <= 1000</code>",
            "<code>-1000 <= target <= 1000</code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "Try all combinations.",
                "algorithm": "Recursion",
                "complexity": {
                    "time": "O(2^n)",
                    "space": "O(n)"
                },
                "code": {
                    "python": "class Solution:\n    def findTargetSumWays(self, nums, target):\n        def dp(i, curr):\n            if i == len(nums): return 1 if curr == target else 0\n            return dp(i + 1, curr + nums[i]) + dp(i + 1, curr - nums[i])\n        return dp(0, 0)",
                    "java": "class Solution { public int findTargetSumWays(int[] nums, int target) { return dp(nums, 0, 0, target); } int dp(int[] nums, int i, int curr, int target) { if (i == nums.length) return curr == target ? 1 : 0; return dp(nums, i + 1, curr + nums[i], target) + dp(nums, i + 1, curr - nums[i], target); } }",
                    "cpp": "class Solution { public: int findTargetSumWays(vector<int>& nums, int target) { return dp(nums, 0, 0, target); } int dp(vector<int>& nums, int i, int curr, int target) { if (i == nums.size()) return curr == target ? 1 : 0; return dp(nums, i + 1, curr + nums[i], target) + dp(nums, i + 1, curr - nums[i], target); } };"
                }
            },
            "optimized": {
                "intuition": "Convert to subset sum.",
                "algorithm": "DP with offset",
                "complexity": {
                    "time": "O(n * sum)",
                    "space": "O(sum)"
                },
                "code": {
                    "python": "class Solution:\n    def findTargetSumWays(self, nums, target):\n        total = sum(nums)\n        if (total + target) % 2 != 0 or abs(target) > total: return 0\n        subsetSum = (total + target) // 2\n        dp = [0] * (subsetSum + 1)\n        dp[0] = 1\n        for num in nums:\n            for j in range(subsetSum, num - 1, -1):\n                dp[j] += dp[j - num]\n        return dp[subsetSum]",
                    "java": "class Solution { public int findTargetSumWays(int[] nums, int target) { int total = 0; for (int n : nums) total += n; if ((total + target) % 2 != 0 || Math.abs(target) > total) return 0; int subsetSum = (total + target) / 2; int[] dp = new int[subsetSum + 1]; dp[0] = 1; for (int num : nums) { for (int j = subsetSum; j >= num; j--) { dp[j] += dp[j - num]; } } return dp[subsetSum]; } }",
                    "cpp": "class Solution { public: int findTargetSumWays(vector<int>& nums, int target) { int total = 0; for (int n : nums) total += n; if ((total + target) % 2 != 0 || abs(target) > total) return 0; int subsetSum = (total + target) / 2; vector<int> dp(subsetSum + 1); dp[0] = 1; for (int num : nums) { for (int j = subsetSum; j >= num; j--) { dp[j] += dp[j - num]; } } return dp[subsetSum]; } };"
                }
            }
        }
    },
    "partition-equal-subset-sum": {
        "description": "<p>Given an integer array <code>nums</code>, return <code>true</code> <em>if you can partition the array into two subsets such that the sum of the elements in both subsets is equal</em> or <code>false</code> otherwise.</p><p><strong>Approach:</strong> This is a classic <strong>0/1 Knapsack</strong> problem. First check if the total sum is odd (if so, return false). Then find if there's a subset with sum equal to <code>total/2</code> using 1D DP. The DP array <code>dp[i]</code> represents whether we can achieve sum <code>i</code>. Iterate backward through sums to avoid using the same element twice.</p>",
        "examples": [
            {
                "input": "nums = [1,5,11,5]",
                "output": "true",
                "explanation": "The array can be partitioned as [1, 5, 5] and [11] with equal sum 11."
            },
            {
                "input": "nums = [1,2,3,5]",
                "output": "false",
                "explanation": "The array cannot be partitioned into equal sum subsets."
            },
            {
                "input": "nums = [1,2,5]",
                "output": "false",
                "explanation": "Total sum is 8 (even), but no subset sums to 4."
            }
        ],
        "constraints": [
            "<code>1 <= nums.length <= 200</code>",
            "<code>1 <= nums[i] <= 100</code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "Try all subsets.",
                "algorithm": "Recursion",
                "complexity": {
                    "time": "O(2^n)",
                    "space": "O(n)"
                },
                "code": {
                    "python": "class Solution:\n    def canPartition(self, nums):\n        total = sum(nums)\n        if total % 2 != 0: return False\n        target = total // 2\n        def dp(i, curr):\n            if curr == target: return True\n            if i >= len(nums) or curr > target: return False\n            return dp(i + 1, curr + nums[i]) or dp(i + 1, curr)\n        return dp(0, 0)",
                    "java": "class Solution { public boolean canPartition(int[] nums) { int total = 0; for (int n : nums) total += n; if (total % 2 != 0) return false; return dp(nums, 0, total / 2); } boolean dp(int[] nums, int i, int target) { if (target == 0) return true; if (i >= nums.length || target < 0) return false; return dp(nums, i + 1, target - nums[i]) || dp(nums, i + 1, target); } }",
                    "cpp": "class Solution { public: bool canPartition(vector<int>& nums) { int total = 0; for (int n : nums) total += n; if (total % 2 != 0) return false; return dp(nums, 0, total / 2); } bool dp(vector<int>& nums, int i, int target) { if (target == 0) return true; if (i >= nums.size() || target < 0) return false; return dp(nums, i + 1, target - nums[i]) || dp(nums, i + 1, target); } };"
                }
            },
            "optimized": {
                "intuition": "DP with target sum.",
                "algorithm": "1D DP",
                "complexity": {
                    "time": "O(n * sum)",
                    "space": "O(sum)"
                },
                "code": {
                    "python": "class Solution:\n    def canPartition(self, nums):\n        total = sum(nums)\n        if total % 2 != 0: return False\n        target = total // 2\n        dp = [False] * (target + 1)\n        dp[0] = True\n        for num in nums:\n            for j in range(target, num - 1, -1):\n                dp[j] = dp[j] or dp[j - num]\n        return dp[target]",
                    "java": "class Solution { public boolean canPartition(int[] nums) { int total = 0; for (int n : nums) total += n; if (total % 2 != 0) return false; int target = total / 2; boolean[] dp = new boolean[target + 1]; dp[0] = true; for (int num : nums) { for (int j = target; j >= num; j--) { dp[j] = dp[j] || dp[j - num]; } } return dp[target]; } }",
                    "cpp": "class Solution { public: bool canPartition(vector<int>& nums) { int total = 0; for (int n : nums) total += n; if (total % 2 != 0) return false; int target = total / 2; vector<bool> dp(target + 1); dp[0] = true; for (int num : nums) { for (int j = target; j >= num; j--) { dp[j] = dp[j] || dp[j - num]; } } return dp[target]; } };"
                }
            }
        }
    },
    "best-time-to-buy-and-sell-stock-with-cooldown": {
        "description": "<p>You are given an array <code>prices</code> where <code>prices[i]</code> is the price of a given stock on the <code>i<sup>th</sup></code> day.</p><p>Find the maximum profit you can achieve. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times) with the following restrictions:</p><ul><li>After you sell your stock, you cannot buy stock on the next day (i.e., cooldown one day)</li></ul><p><strong>Approach:</strong> Use <strong>State Machine DP</strong> with three states: <code>hold</code> (holding stock), <code>sold</code> (just sold), and <code>rest</code> (cooldown/ready to buy). Transitions: <code>sold = hold + price</code>, <code>hold = max(hold, rest - price)</code>, <code>rest = max(rest, prevSold)</code>. Return <code>max(sold, rest)</code>.</p>",
        "examples": [
            {
                "input": "prices = [1,2,3,0,2]",
                "output": "3",
                "explanation": "Buy on day 1 (price=1), sell on day 2 (price=2), profit=1. Cooldown on day 3. Buy on day 4 (price=0), sell on day 5 (price=2), profit=2. Total profit = 3."
            },
            {
                "input": "prices = [1]",
                "output": "0",
                "explanation": "Cannot make profit with only one day."
            },
            {
                "input": "prices = [1,2,4]",
                "output": "3",
                "explanation": "Buy on day 1 (price=1), sell on day 3 (price=4). Total profit = 3."
            }
        ],
        "constraints": [
            "<code>1 <= prices.length <= 5000</code>",
            "<code>0 <= prices[i] <= 1000</code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "Try all buy/sell combinations.",
                "algorithm": "Recursion with states",
                "complexity": {
                    "time": "O(2^n)",
                    "space": "O(n)"
                },
                "code": {
                    "python": "class Solution:\n    def maxProfit(self, prices):\n        def dp(i, holding):\n            if i >= len(prices): return 0\n            if holding:\n                return max(dp(i + 1, True), prices[i] + dp(i + 2, False))\n            return max(dp(i + 1, False), -prices[i] + dp(i + 1, True))\n        return dp(0, False)",
                    "java": "class Solution { public int maxProfit(int[] prices) { return dp(prices, 0, false); } int dp(int[] prices, int i, boolean holding) { if (i >= prices.length) return 0; if (holding) return Math.max(dp(prices, i + 1, true), prices[i] + dp(prices, i + 2, false)); return Math.max(dp(prices, i + 1, false), -prices[i] + dp(prices, i + 1, true)); } }",
                    "cpp": "class Solution { public: int maxProfit(vector<int>& prices) { return dp(prices, 0, false); } int dp(vector<int>& prices, int i, bool holding) { if (i >= prices.size()) return 0; if (holding) return max(dp(prices, i + 1, true), prices[i] + dp(prices, i + 2, false)); return max(dp(prices, i + 1, false), -prices[i] + dp(prices, i + 1, true)); } };"
                }
            },
            "optimized": {
                "intuition": "State machine DP.",
                "algorithm": "Track hold, sold, rest states",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)"
                },
                "code": {
                    "python": "class Solution:\n    def maxProfit(self, prices):\n        sold = 0\n        hold = float('-inf')\n        rest = 0\n        for price in prices:\n            prevSold = sold\n            sold = hold + price\n            hold = max(hold, rest - price)\n            rest = max(rest, prevSold)\n        return max(sold, rest)",
                    "java": "class Solution { public int maxProfit(int[] prices) { int sold = 0, hold = Integer.MIN_VALUE, rest = 0; for (int price : prices) { int prevSold = sold; sold = hold + price; hold = Math.max(hold, rest - price); rest = Math.max(rest, prevSold); } return Math.max(sold, rest); } }",
                    "cpp": "class Solution { public: int maxProfit(vector<int>& prices) { int sold = 0, hold = INT_MIN, rest = 0; for (int price : prices) { int prevSold = sold; sold = hold + price; hold = max(hold, rest - price); rest = max(rest, prevSold); } return max(sold, rest); } };"
                }
            }
        }
    },
    "coin-change-ii": {
        "description": "<p>You are given an integer array <code>coins</code> representing coins of different denominations and an integer <code>amount</code> representing a total amount of money.</p><p>Return <em>the number of combinations that make up that amount</em>. If that amount of money cannot be made up by any combination of the coins, return <code>0</code>.</p><p>You may assume that you have an <strong>infinite number</strong> of each kind of coin.</p><p><strong>Approach:</strong> This is an <strong>unbounded knapsack</strong> problem. Use 1D DP where <code>dp[i]</code> = number of ways to make amount <code>i</code>. Initialize <code>dp[0] = 1</code>. For each coin, update all amounts from <code>coin</code> to <code>amount</code> by adding <code>dp[j - coin]</code> to <code>dp[j]</code>. The outer loop must be coins (not amounts) to avoid counting permutations.</p>",
        "examples": [
            {
                "input": "amount = 5, coins = [1,2,5]",
                "output": "4",
                "explanation": "There are four ways to make up amount 5: 5=5, 5=2+2+1, 5=2+1+1+1, 5=1+1+1+1+1."
            },
            {
                "input": "amount = 3, coins = [2]",
                "output": "0",
                "explanation": "Amount 3 cannot be made up with only coins of 2."
            },
            {
                "input": "amount = 10, coins = [10]",
                "output": "1",
                "explanation": "One way: 10=10."
            }
        ],
        "constraints": [
            "<code>1 <= coins.length <= 300</code>",
            "<code>1 <= coins[i] <= 5000</code>",
            "<code>All values of coins are unique</code>",
            "<code>0 <= amount <= 5000</code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "Try all combinations.",
                "algorithm": "Recursion",
                "complexity": {
                    "time": "O(n^amount)",
                    "space": "O(amount)"
                },
                "code": {
                    "python": "class Solution:\n    def change(self, amount, coins):\n        def dp(i, rem):\n            if rem == 0: return 1\n            if i >= len(coins) or rem < 0: return 0\n            return dp(i, rem - coins[i]) + dp(i + 1, rem)\n        return dp(0, amount)",
                    "java": "class Solution { public int change(int amount, int[] coins) { return dp(coins, 0, amount); } int dp(int[] coins, int i, int rem) { if (rem == 0) return 1; if (i >= coins.length || rem < 0) return 0; return dp(coins, i, rem - coins[i]) + dp(coins, i + 1, rem); } }",
                    "cpp": "class Solution { public: int change(int amount, vector<int>& coins) { return dp(coins, 0, amount); } int dp(vector<int>& coins, int i, int rem) { if (rem == 0) return 1; if (i >= coins.size() || rem < 0) return 0; return dp(coins, i, rem - coins[i]) + dp(coins, i + 1, rem); } };"
                }
            },
            "optimized": {
                "intuition": "1D DP.",
                "algorithm": "Unbounded knapsack",
                "complexity": {
                    "time": "O(n * amount)",
                    "space": "O(amount)"
                },
                "code": {
                    "python": "class Solution:\n    def change(self, amount, coins):\n        dp = [0] * (amount + 1)\n        dp[0] = 1\n        for coin in coins:\n            for j in range(coin, amount + 1):\n                dp[j] += dp[j - coin]\n        return dp[amount]",
                    "java": "class Solution { public int change(int amount, int[] coins) { int[] dp = new int[amount + 1]; dp[0] = 1; for (int coin : coins) { for (int j = coin; j <= amount; j++) { dp[j] += dp[j - coin]; } } return dp[amount]; } }",
                    "cpp": "class Solution { public: int change(int amount, vector<int>& coins) { vector<int> dp(amount + 1); dp[0] = 1; for (int coin : coins) { for (int j = coin; j <= amount; j++) { dp[j] += dp[j - coin]; } } return dp[amount]; } };"
                }
            }
        }
    },
    "house-robber-ii": {
        "description": "<p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are <strong>arranged in a circle</strong>. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected and <strong>it will automatically contact the police if two adjacent houses were broken into on the same night</strong>.</p><p>Given an integer array <code>nums</code> representing the amount of money of each house, return <em>the maximum amount of money you can rob tonight <strong>without alerting the police</strong></em>.</p><p><strong>Approach:</strong> Since houses are circular, the first and last houses are adjacent. We can't rob both. So run the regular House Robber algorithm <strong>twice</strong>: once excluding the first house, once excluding the last house. Return the maximum of both results.</p>",
        "examples": [
            {
                "input": "nums = [2,3,2]",
                "output": "3",
                "explanation": "You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent. Rob house 2 (money = 3) instead."
            },
            {
                "input": "nums = [1,2,3,1]",
                "output": "4",
                "explanation": "Rob house 1 (money = 1) and then rob house 3 (money = 3). Total = 4."
            },
            {
                "input": "nums = [1,2,3]",
                "output": "3",
                "explanation": "Rob house 3 (money = 3) for maximum."
            }
        ],
        "constraints": [
            "<code>1 <= nums.length <= 100</code>",
            "<code>0 <= nums[i] <= 1000</code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "Two cases: include first or last.",
                "algorithm": "Run house robber twice",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(n)"
                },
                "code": {
                    "python": "class Solution:\n    def rob(self, nums):\n        if len(nums) == 1: return nums[0]\n        def helper(arr):\n            if not arr: return 0\n            if len(arr) == 1: return arr[0]\n            dp = [0] * len(arr)\n            dp[0] = arr[0]\n            dp[1] = max(arr[0], arr[1])\n            for i in range(2, len(arr)):\n                dp[i] = max(dp[i-1], dp[i-2] + arr[i])\n            return dp[-1]\n        return max(helper(nums[:-1]), helper(nums[1:]))",
                    "java": "class Solution { public int rob(int[] nums) { if (nums.length == 1) return nums[0]; return Math.max(helper(nums, 0, nums.length - 2), helper(nums, 1, nums.length - 1)); } int helper(int[] nums, int start, int end) { int prev2 = 0, prev1 = 0; for (int i = start; i <= end; i++) { int curr = Math.max(prev1, prev2 + nums[i]); prev2 = prev1; prev1 = curr; } return prev1; } }",
                    "cpp": "class Solution { public: int rob(vector<int>& nums) { if (nums.size() == 1) return nums[0]; return max(helper(nums, 0, nums.size() - 2), helper(nums, 1, nums.size() - 1)); } int helper(vector<int>& nums, int start, int end) { int prev2 = 0, prev1 = 0; for (int i = start; i <= end; i++) { int curr = max(prev1, prev2 + nums[i]); prev2 = prev1; prev1 = curr; } return prev1; } };"
                }
            },
            "optimized": {
                "intuition": "Same approach with O(1) space.",
                "algorithm": "Two linear passes",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)"
                },
                "code": {
                    "python": "class Solution:\n    def rob(self, nums):\n        if len(nums) == 1: return nums[0]\n        def helper(start, end):\n            prev2, prev1 = 0, 0\n            for i in range(start, end + 1):\n                curr = max(prev1, prev2 + nums[i])\n                prev2, prev1 = prev1, curr\n            return prev1\n        return max(helper(0, len(nums) - 2), helper(1, len(nums) - 1))",
                    "java": "class Solution { public int rob(int[] nums) { if (nums.length == 1) return nums[0]; return Math.max(helper(nums, 0, nums.length - 2), helper(nums, 1, nums.length - 1)); } int helper(int[] nums, int start, int end) { int prev2 = 0, prev1 = 0; for (int i = start; i <= end; i++) { int curr = Math.max(prev1, prev2 + nums[i]); prev2 = prev1; prev1 = curr; } return prev1; } }",
                    "cpp": "class Solution { public: int rob(vector<int>& nums) { if (nums.size() == 1) return nums[0]; return max(helper(nums, 0, nums.size() - 2), helper(nums, 1, nums.size() - 1)); } int helper(vector<int>& nums, int start, int end) { int prev2 = 0, prev1 = 0; for (int i = start; i <= end; i++) { int curr = max(prev1, prev2 + nums[i]); prev2 = prev1; prev1 = curr; } return prev1; } };"
                }
            }
        }
    },
    "min-cost-climbing-stairs": {
        "description": "<p>You are given an integer array <code>cost</code> where <code>cost[i]</code> is the cost of <code>i<sup>th</sup></code> step on a staircase. Once you pay the cost, you can either climb one or two steps.</p><p>You can either start from the step with index <code>0</code>, or the step with index <code>1</code>.</p><p>Return <em>the minimum cost to reach the top of the floor</em>.</p><p><strong>Approach:</strong> Use <strong>Dynamic Programming</strong>. Let <code>dp[i]</code> = minimum cost to reach step <code>i</code>. We can reach step <code>i</code> from either <code>i-1</code> or <code>i-2</code>. Base cases: <code>dp[0] = cost[0]</code>, <code>dp[1] = cost[1]</code>. The answer is the minimum of reaching the last two steps and stepping beyond.</p>",
        "examples": [
            {
                "input": "cost = [10,15,20]",
                "output": "15",
                "explanation": "Start at index 1, pay 15, climb two steps to reach the top."
            },
            {
                "input": "cost = [1,100,1,1,1,100,1,1,100,1]",
                "output": "6",
                "explanation": "Start at index 0: pay 1, climb to index 2, pay 1, climb to index 4, pay 1, climb to index 6, pay 1, climb to index 8, pay 1, climb to index 10 (top). Total = 6."
            },
            {
                "input": "cost = [0,1,2,2]",
                "output": "2",
                "explanation": "Start at index 0, climb two steps to index 2, pay 2, climb two steps to top. Total = 2."
            }
        ],
        "constraints": [
            "<code>2 <= cost.length <= 1000</code>",
            "<code>0 <= cost[i] <= 999</code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "Try all paths.",
                "algorithm": "Recursion",
                "complexity": {
                    "time": "O(2^n)",
                    "space": "O(n)"
                },
                "code": {
                    "python": "class Solution:\n    def minCostClimbingStairs(self, cost):\n        def dp(i):\n            if i >= len(cost): return 0\n            return cost[i] + min(dp(i + 1), dp(i + 2))\n        return min(dp(0), dp(1))",
                    "java": "class Solution { public int minCostClimbingStairs(int[] cost) { return Math.min(dp(cost, 0), dp(cost, 1)); } int dp(int[] cost, int i) { if (i >= cost.length) return 0; return cost[i] + Math.min(dp(cost, i + 1), dp(cost, i + 2)); } }",
                    "cpp": "class Solution { public: int minCostClimbingStairs(vector<int>& cost) { return min(dp(cost, 0), dp(cost, 1)); } int dp(vector<int>& cost, int i) { if (i >= cost.size()) return 0; return cost[i] + min(dp(cost, i + 1), dp(cost, i + 2)); } };"
                }
            },
            "optimized": {
                "intuition": "Bottom-up DP.",
                "algorithm": "O(1) space DP",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)"
                },
                "code": {
                    "python": "class Solution:\n    def minCostClimbingStairs(self, cost):\n        prev2, prev1 = 0, 0\n        for i in range(2, len(cost) + 1):\n            curr = min(prev1 + cost[i - 1], prev2 + cost[i - 2])\n            prev2, prev1 = prev1, curr\n        return prev1",
                    "java": "class Solution { public int minCostClimbingStairs(int[] cost) { int prev2 = 0, prev1 = 0; for (int i = 2; i <= cost.length; i++) { int curr = Math.min(prev1 + cost[i - 1], prev2 + cost[i - 2]); prev2 = prev1; prev1 = curr; } return prev1; } }",
                    "cpp": "class Solution { public: int minCostClimbingStairs(vector<int>& cost) { int prev2 = 0, prev1 = 0; for (int i = 2; i <= cost.size(); i++) { int curr = min(prev1 + cost[i - 1], prev2 + cost[i - 2]); prev2 = prev1; prev1 = curr; } return prev1; } };"
                }
            }
        }
    },
    "n-queens-ii": {
        "description": "<p>The <strong>n-queens</strong> puzzle is the problem of placing <code>n</code> queens on an <code>n x n</code> chessboard such that no two queens attack each other.</p><p>Given an integer <code>n</code>, return <em>the number of distinct solutions to the <strong>n-queens puzzle</strong></em>.</p><p><strong>Approach:</strong> Same as N-Queens I but only count solutions instead of constructing boards. Use <strong>backtracking</strong> with three sets to track occupied columns, positive diagonals (<code>row - col</code>), and negative diagonals (<code>row + col</code>). For each row, try placing a queen in each valid column and recursively solve for the next row. When <code>row == n</code>, increment the count.</p>",
        "examples": [
            {
                "input": "n = 4",
                "output": "2",
                "explanation": "There are two distinct solutions to the 4-queens puzzle."
            },
            {
                "input": "n = 1",
                "output": "1",
                "explanation": "Only one way to place one queen."
            },
            {
                "input": "n = 8",
                "output": "92",
                "explanation": "Classic 8-queens problem has 92 solutions."
            }
        ],
        "constraints": [
            "<code>1 <= n <= 9</code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "Same as N-Queens, just count.",
                "algorithm": "Backtracking",
                "complexity": {
                    "time": "O(n!)",
                    "space": "O(n)"
                },
                "code": {
                    "python": "class Solution:\n    def totalNQueens(self, n):\n        count = 0\n        cols = set()\n        diag1 = set()\n        diag2 = set()\n        def backtrack(row):\n            nonlocal count\n            if row == n:\n                count += 1\n                return\n            for col in range(n):\n                if col in cols or (row - col) in diag1 or (row + col) in diag2:\n                    continue\n                cols.add(col)\n                diag1.add(row - col)\n                diag2.add(row + col)\n                backtrack(row + 1)\n                cols.remove(col)\n                diag1.remove(row - col)\n                diag2.remove(row + col)\n        backtrack(0)\n        return count",
                    "java": "class Solution { int count = 0; Set<Integer> cols = new HashSet<>(), d1 = new HashSet<>(), d2 = new HashSet<>(); public int totalNQueens(int n) { backtrack(0, n); return count; } void backtrack(int row, int n) { if (row == n) { count++; return; } for (int col = 0; col < n; col++) { if (cols.contains(col) || d1.contains(row - col) || d2.contains(row + col)) continue; cols.add(col); d1.add(row - col); d2.add(row + col); backtrack(row + 1, n); cols.remove(col); d1.remove(row - col); d2.remove(row + col); } } }",
                    "cpp": "class Solution { int count = 0; unordered_set<int> cols, d1, d2; public: int totalNQueens(int n) { backtrack(0, n); return count; } void backtrack(int row, int n) { if (row == n) { count++; return; } for (int col = 0; col < n; col++) { if (cols.count(col) || d1.count(row - col) || d2.count(row + col)) continue; cols.insert(col); d1.insert(row - col); d2.insert(row + col); backtrack(row + 1, n); cols.erase(col); d1.erase(row - col); d2.erase(row + col); } } };"
                }
            },
            "optimized": {
                "intuition": "Same algorithm.",
                "algorithm": "Optimized backtracking",
                "complexity": {
                    "time": "O(n!)",
                    "space": "O(n)"
                },
                "code": {
                    "python": "class Solution:\n    def totalNQueens(self, n):\n        def solve(row, cols, d1, d2):\n            if row == n: return 1\n            count = 0\n            avail = ((1 << n) - 1) & ~(cols | d1 | d2)\n            while avail:\n                pos = avail & -avail\n                avail ^= pos\n                count += solve(row + 1, cols | pos, (d1 | pos) << 1, (d2 | pos) >> 1)\n            return count\n        return solve(0, 0, 0, 0)",
                    "java": "class Solution { public int totalNQueens(int n) { return solve(0, 0, 0, 0, n); } int solve(int row, int cols, int d1, int d2, int n) { if (row == n) return 1; int count = 0; int avail = ((1 << n) - 1) & ~(cols | d1 | d2); while (avail != 0) { int pos = avail & -avail; avail ^= pos; count += solve(row + 1, cols | pos, (d1 | pos) << 1, (d2 | pos) >> 1, n); } return count; } }",
                    "cpp": "class Solution { public: int totalNQueens(int n) { return solve(0, 0, 0, 0, n); } int solve(int row, int cols, int d1, int d2, int n) { if (row == n) return 1; int count = 0; int avail = ((1 << n) - 1) & ~(cols | d1 | d2); while (avail) { int pos = avail & -avail; avail ^= pos; count += solve(row + 1, cols | pos, (d1 | pos) << 1, (d2 | pos) >> 1, n); } return count; } };"
                }
            }
        }
    },
    "maximum-product-subarray": {
        "description": "<p>Given an integer array <code>nums</code>, find a <strong>subarray</strong> that has the largest product, and return <em>the product</em>.</p><p>The test cases are generated so that the answer will fit in a <strong>32-bit</strong> integer.</p><p><strong>Approach:</strong> Use <strong>Dynamic Programming</strong> tracking both <strong>max and min</strong> products. A negative number can flip the max to min and vice versa, so we need to track both. At each position, the new max/min product is either the current number itself, or the current number multiplied by the previous max/min. Swap max and min when encountering a negative number.</p>",
        "examples": [
            {
                "input": "nums = [2,3,-2,4]",
                "output": "6",
                "explanation": "The subarray [2,3] has the largest product 6."
            },
            {
                "input": "nums = [-2,0,-1]",
                "output": "0",
                "explanation": "The result cannot be 2 because [-2,-1] is not a subarray."
            },
            {
                "input": "nums = [-2,3,-4]",
                "output": "24",
                "explanation": "The subarray [-2,3,-4] has the largest product 24."
            }
        ],
        "constraints": [
            "<code>1 <= nums.length <= 2 * 10<sup>4</sup></code>",
            "<code>-10 <= nums[i] <= 10</code>",
            "<code>The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer</code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "Check all subarrays.",
                "algorithm": "O(n¬≤) brute force",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(1)"
                },
                "code": {
                    "python": "class Solution:\n    def maxProduct(self, nums):\n        res = nums[0]\n        for i in range(len(nums)):\n            prod = 1\n            for j in range(i, len(nums)):\n                prod *= nums[j]\n                res = max(res, prod)\n        return res",
                    "java": "class Solution { public int maxProduct(int[] nums) { int res = nums[0]; for (int i = 0; i < nums.length; i++) { int prod = 1; for (int j = i; j < nums.length; j++) { prod *= nums[j]; res = Math.max(res, prod); } } return res; } }",
                    "cpp": "class Solution { public: int maxProduct(vector<int>& nums) { int res = nums[0]; for (int i = 0; i < nums.size(); i++) { int prod = 1; for (int j = i; j < nums.size(); j++) { prod *= nums[j]; res = max(res, prod); } } return res; } };"
                }
            },
            "optimized": {
                "intuition": "Track max and min products.",
                "algorithm": "DP with max/min",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)"
                },
                "code": {
                    "python": "class Solution:\n    def maxProduct(self, nums):\n        res = maxP = minP = nums[0]\n        for i in range(1, len(nums)):\n            if nums[i] < 0:\n                maxP, minP = minP, maxP\n            maxP = max(nums[i], maxP * nums[i])\n            minP = min(nums[i], minP * nums[i])\n            res = max(res, maxP)\n        return res",
                    "java": "class Solution { public int maxProduct(int[] nums) { int res = nums[0], maxP = nums[0], minP = nums[0]; for (int i = 1; i < nums.length; i++) { if (nums[i] < 0) { int t = maxP; maxP = minP; minP = t; } maxP = Math.max(nums[i], maxP * nums[i]); minP = Math.min(nums[i], minP * nums[i]); res = Math.max(res, maxP); } return res; } }",
                    "cpp": "class Solution { public: int maxProduct(vector<int>& nums) { int res = nums[0], maxP = nums[0], minP = nums[0]; for (int i = 1; i < nums.size(); i++) { if (nums[i] < 0) swap(maxP, minP); maxP = max(nums[i], maxP * nums[i]); minP = min(nums[i], minP * nums[i]); res = max(res, maxP); } return res; } };"
                }
            }
        }
    },
    "longest-valid-parentheses": {
        "description": "<p>Given a string containing just the characters <code>'('</code> and <code>')'</code>, return <em>the length of the longest valid (well-formed) parentheses <strong>substring</strong></em>.</p><p><strong>Approach:</strong> Use a <strong>stack</strong> to track indices. Initialize with <code>-1</code> as a base. For <code>'('</code>, push its index. For <code>')'</code>, pop from stack. If stack becomes empty, push current index (new base). Otherwise, calculate length as <code>current index - stack.top()</code>. This efficiently tracks the start of valid substrings.</p>",
        "examples": [
            {
                "input": "s = \"(()\"",
                "output": "2",
                "explanation": "The longest valid parentheses substring is \"()\"."
            },
            {
                "input": "s = \")()())\"",
                "output": "4",
                "explanation": "The longest valid parentheses substring is \"()()\"."
            },
            {
                "input": "s = \"\"",
                "output": "0",
                "explanation": "Empty string."
            },
            {
                "input": "s = \"()(()\"",
                "output": "2",
                "explanation": "The longest valid parentheses substring is either \"()\" at start or \"()\" inside."
            }
        ],
        "constraints": [
            "<code>0 <= s.length <= 3 * 10<sup>4</sup></code>",
            "<code>s[i] is '(' or ')'</code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "Check all substrings.",
                "algorithm": "Validate each substring",
                "complexity": {
                    "time": "O(n¬≥)",
                    "space": "O(1)"
                },
                "code": {
                    "python": "class Solution:\n    def longestValidParentheses(self, s):\n        def isValid(sub):\n            count = 0\n            for c in sub:\n                if c == '(': count += 1\n                else: count -= 1\n                if count < 0: return False\n            return count == 0\n        res = 0\n        for i in range(len(s)):\n            for j in range(i + 2, len(s) + 1, 2):\n                if isValid(s[i:j]): res = max(res, j - i)\n        return res",
                    "java": "class Solution { public int longestValidParentheses(String s) { int res = 0; for (int i = 0; i < s.length(); i++) { for (int j = i + 2; j <= s.length(); j += 2) { if (isValid(s.substring(i, j))) res = Math.max(res, j - i); } } return res; } boolean isValid(String sub) { int count = 0; for (char c : sub.toCharArray()) { if (c == '(') count++; else count--; if (count < 0) return false; } return count == 0; } }",
                    "cpp": "class Solution { public: int longestValidParentheses(string s) { int res = 0; for (int i = 0; i < s.size(); i++) { for (int j = i + 2; j <= s.size(); j += 2) { if (isValid(s.substr(i, j - i))) res = max(res, j - i); } } return res; } bool isValid(string sub) { int count = 0; for (char c : sub) { if (c == '(') count++; else count--; if (count < 0) return false; } return count == 0; } };"
                }
            },
            "optimized": {
                "intuition": "Stack-based approach.",
                "algorithm": "Track indices on stack",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(n)"
                },
                "code": {
                    "python": "class Solution:\n    def longestValidParentheses(self, s):\n        stack = [-1]\n        res = 0\n        for i, c in enumerate(s):\n            if c == '(':\n                stack.append(i)\n            else:\n                stack.pop()\n                if not stack:\n                    stack.append(i)\n                else:\n                    res = max(res, i - stack[-1])\n        return res",
                    "java": "class Solution { public int longestValidParentheses(String s) { Stack<Integer> stack = new Stack<>(); stack.push(-1); int res = 0; for (int i = 0; i < s.length(); i++) { if (s.charAt(i) == '(') { stack.push(i); } else { stack.pop(); if (stack.isEmpty()) stack.push(i); else res = Math.max(res, i - stack.peek()); } } return res; } }",
                    "cpp": "class Solution { public: int longestValidParentheses(string s) { stack<int> st; st.push(-1); int res = 0; for (int i = 0; i < s.size(); i++) { if (s[i] == '(') { st.push(i); } else { st.pop(); if (st.empty()) st.push(i); else res = max(res, i - st.top()); } } return res; } };"
                }
            }
        }
    },
    "multiply-strings": {
        "description": "<p>Given two non-negative integers <code>num1</code> and <code>num2</code> represented as strings, return the product of <code>num1</code> and <code>num2</code>, also represented as a string.</p><p><strong>Note:</strong> You must not use any built-in BigInteger library or convert the inputs to integer directly.</p><p><strong>Approach:</strong> Simulate <strong>grade school multiplication</strong>. The product of two numbers with lengths <code>m</code> and <code>n</code> has at most <code>m + n</code> digits. Create a result array of size <code>m + n</code>. For each digit pair <code>num1[i]</code> and <code>num2[j]</code>, their product contributes to positions <code>i + j</code> and <code>i + j + 1</code>. Add products with carry handling, then convert result array to string.</p>",
        "examples": [
            {
                "input": "num1 = \"2\", num2 = \"3\"",
                "output": "\"6\"",
                "explanation": "2 * 3 = 6."
            },
            {
                "input": "num1 = \"123\", num2 = \"456\"",
                "output": "\"56088\"",
                "explanation": "123 * 456 = 56088."
            },
            {
                "input": "num1 = \"0\", num2 = \"12345\"",
                "output": "\"0\"",
                "explanation": "0 * 12345 = 0."
            }
        ],
        "constraints": [
            "<code>1 <= num1.length, num2.length <= 200</code>",
            "<code>num1 and num2 consist of digits only</code>",
            "<code>Both num1 and num2 do not contain any leading zero, except the number 0 itself</code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "Grade school multiplication.",
                "algorithm": "Digit by digit multiplication",
                "complexity": {
                    "time": "O(mn)",
                    "space": "O(m+n)"
                },
                "code": {
                    "python": "class Solution:\n    def multiply(self, num1, num2):\n        if num1 == '0' or num2 == '0': return '0'\n        m, n = len(num1), len(num2)\n        result = [0] * (m + n)\n        for i in range(m - 1, -1, -1):\n            for j in range(n - 1, -1, -1):\n                mul = int(num1[i]) * int(num2[j])\n                p1, p2 = i + j, i + j + 1\n                total = mul + result[p2]\n                result[p2] = total % 10\n                result[p1] += total // 10\n        res = ''.join(map(str, result))\n        return res.lstrip('0') or '0'",
                    "java": "class Solution { public String multiply(String n1, String n2) { if (n1.equals(\"0\") || n2.equals(\"0\")) return \"0\"; int m = n1.length(), n = n2.length(); int[] res = new int[m + n]; for (int i = m - 1; i >= 0; i--) { for (int j = n - 1; j >= 0; j--) { int mul = (n1.charAt(i) - '0') * (n2.charAt(j) - '0'); int p1 = i + j, p2 = i + j + 1; int sum = mul + res[p2]; res[p2] = sum % 10; res[p1] += sum / 10; } } StringBuilder sb = new StringBuilder(); for (int d : res) if (!(sb.length() == 0 && d == 0)) sb.append(d); return sb.length() == 0 ? \"0\" : sb.toString(); } }",
                    "cpp": "class Solution { public: string multiply(string n1, string n2) { if (n1 == \"0\" || n2 == \"0\") return \"0\"; int m = n1.size(), n = n2.size(); vector<int> res(m + n); for (int i = m - 1; i >= 0; i--) { for (int j = n - 1; j >= 0; j--) { int mul = (n1[i] - '0') * (n2[j] - '0'); int p1 = i + j, p2 = i + j + 1; int sum = mul + res[p2]; res[p2] = sum % 10; res[p1] += sum / 10; } } string s; for (int d : res) if (!(s.empty() && d == 0)) s += ('0' + d); return s.empty() ? \"0\" : s; } };"
                }
            },
            "optimized": {
                "intuition": "Same approach is already optimal.",
                "algorithm": "Optimized grade school",
                "complexity": {
                    "time": "O(mn)",
                    "space": "O(m+n)"
                },
                "code": {
                    "python": "class Solution:\n    def multiply(self, num1, num2):\n        if num1 == '0' or num2 == '0': return '0'\n        m, n = len(num1), len(num2)\n        result = [0] * (m + n)\n        num1, num2 = num1[::-1], num2[::-1]\n        for i in range(m):\n            for j in range(n):\n                result[i + j] += int(num1[i]) * int(num2[j])\n                result[i + j + 1] += result[i + j] // 10\n                result[i + j] %= 10\n        while len(result) > 1 and result[-1] == 0:\n            result.pop()\n        return ''.join(map(str, result[::-1]))",
                    "java": "class Solution { public String multiply(String n1, String n2) { if (n1.equals(\"0\") || n2.equals(\"0\")) return \"0\"; int m = n1.length(), n = n2.length(); int[] res = new int[m + n]; for (int i = m - 1; i >= 0; i--) { for (int j = n - 1; j >= 0; j--) { int mul = (n1.charAt(i) - '0') * (n2.charAt(j) - '0'); int p1 = i + j, p2 = i + j + 1; int sum = mul + res[p2]; res[p2] = sum % 10; res[p1] += sum / 10; } } StringBuilder sb = new StringBuilder(); for (int d : res) if (!(sb.length() == 0 && d == 0)) sb.append(d); return sb.length() == 0 ? \"0\" : sb.toString(); } }",
                    "cpp": "class Solution { public: string multiply(string n1, string n2) { if (n1 == \"0\" || n2 == \"0\") return \"0\"; int m = n1.size(), n = n2.size(); vector<int> res(m + n); for (int i = m - 1; i >= 0; i--) { for (int j = n - 1; j >= 0; j--) { int mul = (n1[i] - '0') * (n2[j] - '0'); int p1 = i + j, p2 = i + j + 1; int sum = mul + res[p2]; res[p2] = sum % 10; res[p1] += sum / 10; } } string s; for (int d : res) if (!(s.empty() && d == 0)) s += ('0' + d); return s.empty() ? \"0\" : s; } };"
                }
            }
        }
    },
    "detect-squares": {
        "description": "<p>You are given a stream of points on the X-Y plane. Design an algorithm that:</p><ul><li>Adds new points from the stream into a data structure. Duplicate points are allowed and should be treated as different points.</li><li>Given a query point, counts the number of ways to choose three points from the data structure such that the three points and the query point form an <strong>axis-aligned square</strong> with positive area.</li></ul><p>An <strong>axis-aligned square</strong> is a square whose edges are all the same length and are either parallel or perpendicular to the x-axis and y-axis.</p><p><strong>Approach:</strong> Store all points in a list. For counting, iterate through all stored points as potential diagonal corners. For each point that forms a valid diagonal (equal horizontal and vertical distance from query point), count matching corner points using a hashmap to achieve O(n) complexity per count operation.</p>",
        "examples": [
            {
                "input": "[\"DetectSquares\",\"add\",\"add\",\"add\",\"count\",\"add\",\"count\"]",
                "output": "[null,null,null,null,1,null,2]",
                "explanation": "DetectSquares detectSquares = new DetectSquares(); add([3,10]), add([11,2]), add([3,2]), count([11,10]) returns 1, add([14,8]), count([11,2]) returns 2."
            }
        ],
        "constraints": [
            "<code>point.length == 2</code>",
            "<code>0 <= x, y <= 1000</code>",
            "<code>At most 3000 calls in total will be made to add and count</code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "Check all point combinations.",
                "algorithm": "Store points, check diagonals",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)"
                },
                "code": {
                    "python": "class DetectSquares:\n    def __init__(self):\n        self.points = []\n    def add(self, point):\n        self.points.append(point)\n    def count(self, point):\n        px, py = point\n        count = 0\n        for x, y in self.points:\n            if abs(x - px) != abs(y - py) or x == px: continue\n            for x2, y2 in self.points:\n                if x2 == x and y2 == py:\n                    for x3, y3 in self.points:\n                        if x3 == px and y3 == y:\n                            count += 1\n        return count",
                    "java": "class DetectSquares { List<int[]> points = new ArrayList<>(); public void add(int[] point) { points.add(point); } public int count(int[] point) { int px = point[0], py = point[1], cnt = 0; for (int[] p1 : points) { if (Math.abs(p1[0] - px) != Math.abs(p1[1] - py) || p1[0] == px) continue; for (int[] p2 : points) { if (p2[0] == p1[0] && p2[1] == py) { for (int[] p3 : points) { if (p3[0] == px && p3[1] == p1[1]) cnt++; } } } } return cnt; } }",
                    "cpp": "class DetectSquares { vector<pair<int,int>> points; public: void add(vector<int> point) { points.push_back({point[0], point[1]}); } int count(vector<int> point) { int px = point[0], py = point[1], cnt = 0; for (auto& p1 : points) { if (abs(p1.first - px) != abs(p1.second - py) || p1.first == px) continue; for (auto& p2 : points) { if (p2.first == p1.first && p2.second == py) { for (auto& p3 : points) { if (p3.first == px && p3.second == p1.second) cnt++; } } } } return cnt; } };"
                }
            },
            "optimized": {
                "intuition": "Use hash map for O(n) count.",
                "algorithm": "Count matching diagonals",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(n)"
                },
                "code": {
                    "python": "class DetectSquares:\n    def __init__(self):\n        from collections import defaultdict\n        self.cnt = defaultdict(int)\n        self.points = []\n    def add(self, point):\n        self.cnt[tuple(point)] += 1\n        self.points.append(point)\n    def count(self, point):\n        px, py = point\n        res = 0\n        for x, y in self.points:\n            if abs(x - px) != abs(y - py) or x == px: continue\n            res += self.cnt[(x, py)] * self.cnt[(px, y)]\n        return res",
                    "java": "class DetectSquares { Map<String, Integer> cnt = new HashMap<>(); List<int[]> points = new ArrayList<>(); public void add(int[] p) { String key = p[0] + \",\" + p[1]; cnt.put(key, cnt.getOrDefault(key, 0) + 1); points.add(p); } public int count(int[] p) { int px = p[0], py = p[1], res = 0; for (int[] pt : points) { int x = pt[0], y = pt[1]; if (Math.abs(x - px) != Math.abs(y - py) || x == px) continue; res += cnt.getOrDefault(x + \",\" + py, 0) * cnt.getOrDefault(px + \",\" + y, 0); } return res; } }",
                    "cpp": "class DetectSquares { unordered_map<long, int> cnt; vector<pair<int,int>> points; public: void add(vector<int> p) { cnt[(long)p[0] * 1001 + p[1]]++; points.push_back({p[0], p[1]}); } int count(vector<int> p) { int px = p[0], py = p[1], res = 0; for (auto& pt : points) { int x = pt.first, y = pt.second; if (abs(x - px) != abs(y - py) || x == px) continue; res += cnt[(long)x * 1001 + py] * cnt[(long)px * 1001 + y]; } return res; } };"
                }
            }
        }
    },
    "happy-number": {
        "description": "<p>Write an algorithm to determine if a number <code>n</code> is <strong>happy</strong>.</p><p>A <strong>happy number</strong> is a number defined by the following process:</p><ul><li>Starting with any positive integer, replace the number by the sum of the squares of its digits.</li><li>Repeat the process until the number equals 1 (where it will stay), or it <strong>loops endlessly in a cycle</strong> which does not include 1.</li><li>Those numbers for which this process <strong>ends in 1</strong> are happy.</li></ul><p>Return <code>true</code> <em>if <code>n</code> is a happy number, and <code>false</code> if not</em>.</p><p><strong>Approach:</strong> Use <strong>Floyd's Cycle Detection</strong> (slow and fast pointers). Repeatedly compute the sum of squares of digits. If we reach 1, return true. If we detect a cycle (slow == fast), return false. This uses O(1) space instead of a hashset.</p>",
        "examples": [
            {
                "input": "n = 19",
                "output": "true",
                "explanation": "1¬≤ + 9¬≤ = 82, 8¬≤ + 2¬≤ = 68, 6¬≤ + 8¬≤ = 100, 1¬≤ + 0¬≤ + 0¬≤ = 1."
            },
            {
                "input": "n = 2",
                "output": "false",
                "explanation": "Forms a cycle without reaching 1."
            },
            {
                "input": "n = 7",
                "output": "true",
                "explanation": "7 ‚Üí 49 ‚Üí 97 ‚Üí 130 ‚Üí 10 ‚Üí 1."
            }
        ],
        "constraints": [
            "<code>1 <= n <= 2<sup>31</sup> - 1</code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "Use set to detect cycle.",
                "algorithm": "Track seen numbers",
                "complexity": {
                    "time": "O(log n)",
                    "space": "O(log n)"
                },
                "code": {
                    "python": "class Solution:\n    def isHappy(self, n):\n        seen = set()\n        while n != 1 and n not in seen:\n            seen.add(n)\n            n = sum(int(d) ** 2 for d in str(n))\n        return n == 1",
                    "java": "class Solution { public boolean isHappy(int n) { Set<Integer> seen = new HashSet<>(); while (n != 1 && !seen.contains(n)) { seen.add(n); n = getNext(n); } return n == 1; } int getNext(int n) { int sum = 0; while (n > 0) { int d = n % 10; sum += d * d; n /= 10; } return sum; } }",
                    "cpp": "class Solution { public: bool isHappy(int n) { unordered_set<int> seen; while (n != 1 && !seen.count(n)) { seen.insert(n); n = getNext(n); } return n == 1; } int getNext(int n) { int sum = 0; while (n > 0) { int d = n % 10; sum += d * d; n /= 10; } return sum; } };"
                }
            },
            "optimized": {
                "intuition": "Floyd's cycle detection.",
                "algorithm": "Slow/fast pointers",
                "complexity": {
                    "time": "O(log n)",
                    "space": "O(1)"
                },
                "code": {
                    "python": "class Solution:\n    def isHappy(self, n):\n        def getNext(num):\n            return sum(int(d) ** 2 for d in str(num))\n        slow = n\n        fast = getNext(n)\n        while fast != 1 and slow != fast:\n            slow = getNext(slow)\n            fast = getNext(getNext(fast))\n        return fast == 1",
                    "java": "class Solution { public boolean isHappy(int n) { int slow = n, fast = getNext(n); while (fast != 1 && slow != fast) { slow = getNext(slow); fast = getNext(getNext(fast)); } return fast == 1; } int getNext(int n) { int sum = 0; while (n > 0) { int d = n % 10; sum += d * d; n /= 10; } return sum; } }",
                    "cpp": "class Solution { public: bool isHappy(int n) { int slow = n, fast = getNext(n); while (fast != 1 && slow != fast) { slow = getNext(slow); fast = getNext(getNext(fast)); } return fast == 1; } int getNext(int n) { int sum = 0; while (n > 0) { int d = n % 10; sum += d * d; n /= 10; } return sum; } };"
                }
            }
        }
    },
    "plus-one": {
        "description": "<p>You are given a <strong>large integer</strong> represented as an integer array <code>digits</code>, where each <code>digits[i]</code> is the <code>i<sup>th</sup></code> digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading <code>0</code>'s.</p><p>Increment the large integer by one and return <em>the resulting array of digits</em>.</p><p><strong>Approach:</strong> Start from the rightmost digit and add 1. If the digit becomes 10, set it to 0 and carry 1 to the next position. If a digit is less than 9, simply increment it and return. If all digits become 0 (e.g., 999 ‚Üí 1000), prepend 1 to the array.</p>",
        "examples": [
            {
                "input": "digits = [1,2,3]",
                "output": "[1,2,4]",
                "explanation": "The array represents the integer 123. Incrementing by one gives 123 + 1 = 124."
            },
            {
                "input": "digits = [4,3,2,1]",
                "output": "[4,3,2,2]",
                "explanation": "The array represents the integer 4321. 4321 + 1 = 4322."
            },
            {
                "input": "digits = [9]",
                "output": "[1,0]",
                "explanation": "9 + 1 = 10, represented as [1,0]."
            },
            {
                "input": "digits = [9,9,9]",
                "output": "[1,0,0,0]",
                "explanation": "999 + 1 = 1000."
            }
        ],
        "constraints": [
            "<code>1 <= digits.length <= 100</code>",
            "<code>0 <= digits[i] <= 9</code>",
            "<code>digits does not contain any leading 0's</code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "Convert to number, add 1.",
                "algorithm": "May overflow for large arrays",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(n)"
                },
                "code": {
                    "python": "class Solution:\n    def plusOne(self, digits):\n        num = int(''.join(map(str, digits))) + 1\n        return [int(d) for d in str(num)]",
                    "java": "class Solution { public int[] plusOne(int[] digits) { StringBuilder sb = new StringBuilder(); for (int d : digits) sb.append(d); java.math.BigInteger num = new java.math.BigInteger(sb.toString()).add(java.math.BigInteger.ONE); String s = num.toString(); int[] res = new int[s.length()]; for (int i = 0; i < s.length(); i++) res[i] = s.charAt(i) - '0'; return res; } }",
                    "cpp": "class Solution { public: vector<int> plusOne(vector<int>& digits) { string s = \"\"; for (int d : digits) s += ('0' + d); int carry = 1; for (int i = s.size() - 1; i >= 0 && carry; i--) { int sum = (s[i] - '0') + carry; s[i] = '0' + (sum % 10); carry = sum / 10; } if (carry) s = \"1\" + s; vector<int> res; for (char c : s) res.push_back(c - '0'); return res; } };"
                }
            },
            "optimized": {
                "intuition": "Add from rightmost digit.",
                "algorithm": "Handle carry propagation",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)"
                },
                "code": {
                    "python": "class Solution:\n    def plusOne(self, digits):\n        for i in range(len(digits) - 1, -1, -1):\n            if digits[i] < 9:\n                digits[i] += 1\n                return digits\n            digits[i] = 0\n        return [1] + digits",
                    "java": "class Solution { public int[] plusOne(int[] digits) { for (int i = digits.length - 1; i >= 0; i--) { if (digits[i] < 9) { digits[i]++; return digits; } digits[i] = 0; } int[] res = new int[digits.length + 1]; res[0] = 1; return res; } }",
                    "cpp": "class Solution { public: vector<int> plusOne(vector<int>& digits) { for (int i = digits.size() - 1; i >= 0; i--) { if (digits[i] < 9) { digits[i]++; return digits; } digits[i] = 0; } digits.insert(digits.begin(), 1); return digits; } };"
                }
            }
        }
    },
    "pow-x-n": {
        "description": "<p>Implement <code>pow(x, n)</code>, which calculates <code>x</code> raised to the power <code>n</code> (i.e., <code>x<sup>n</sup></code>).</p><p><strong>Approach:</strong> Use <strong>binary exponentiation</strong> (exponentiation by squaring). If <code>n</code> is negative, convert <code>x</code> to <code>1/x</code> and <code>n</code> to <code>-n</code>. Then repeatedly: if <code>n</code> is odd, multiply result by <code>x</code>; square <code>x</code> and halve <code>n</code>. This reduces time complexity from O(n) to O(log n).</p>",
        "examples": [
            {
                "input": "x = 2.00000, n = 10",
                "output": "1024.00000",
                "explanation": "2<sup>10</sup> = 1024."
            },
            {
                "input": "x = 2.10000, n = 3",
                "output": "9.26100",
                "explanation": "2.1<sup>3</sup> = 9.261."
            },
            {
                "input": "x = 2.00000, n = -2",
                "output": "0.25000",
                "explanation": "2<sup>-2</sup> = 1/2<sup>2</sup> = 1/4 = 0.25."
            }
        ],
        "constraints": [
            "<code>-100.0 < x < 100.0</code>",
            "<code>-2<sup>31</sup> <= n <= 2<sup>31</sup>-1</code>",
            "<code>n is an integer</code>",
            "<code>Either x is not zero or n > 0</code>",
            "<code>-10<sup>4</sup> <= x<sup>n</sup> <= 10<sup>4</sup></code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "Multiply x n times.",
                "algorithm": "Linear iteration",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)"
                },
                "code": {
                    "python": "class Solution:\n    def myPow(self, x, n):\n        if n < 0:\n            x = 1 / x\n            n = -n\n        result = 1\n        for _ in range(n):\n            result *= x\n        return result",
                    "java": "class Solution { public double myPow(double x, int n) { long N = n; if (N < 0) { x = 1 / x; N = -N; } double result = 1; for (long i = 0; i < N; i++) result *= x; return result; } }",
                    "cpp": "class Solution { public: double myPow(double x, int n) { long N = n; if (N < 0) { x = 1 / x; N = -N; } double result = 1; for (long i = 0; i < N; i++) result *= x; return result; } };"
                }
            },
            "optimized": {
                "intuition": "Binary exponentiation.",
                "algorithm": "x^n = x^(n/2) * x^(n/2)",
                "complexity": {
                    "time": "O(log n)",
                    "space": "O(1)"
                },
                "code": {
                    "python": "class Solution:\n    def myPow(self, x, n):\n        if n < 0:\n            x = 1 / x\n            n = -n\n        result = 1\n        while n > 0:\n            if n % 2 == 1:\n                result *= x\n            x *= x\n            n //= 2\n        return result",
                    "java": "class Solution { public double myPow(double x, int n) { long N = n; if (N < 0) { x = 1 / x; N = -N; } double result = 1; while (N > 0) { if (N % 2 == 1) result *= x; x *= x; N /= 2; } return result; } }",
                    "cpp": "class Solution { public: double myPow(double x, int n) { long N = n; if (N < 0) { x = 1 / x; N = -N; } double result = 1; while (N > 0) { if (N % 2 == 1) result *= x; x *= x; N /= 2; } return result; } };"
                }
            }
        }
    },
    "set-matrix-zeroes": {
        "description": "<p>Given an <code>m x n</code> integer matrix <code>matrix</code>, if an element is <code>0</code>, set its entire row and column to <code>0</code>'s.</p><p>You must do it <strong>in place</strong>.</p><p><strong>Approach:</strong> Use the <strong>first row and first column as markers</strong> to achieve O(1) space. First, track if the first row/column originally contain zeros. Then use <code>matrix[i][0]</code> and <code>matrix[0][j]</code> to mark which rows/columns should be zeroed. Finally, zero out marked cells, then handle the first row and column based on the original flags.</p>",
        "examples": [
            {
                "input": "matrix = [[1,1,1],[1,0,1],[1,1,1]]",
                "output": "[[1,0,1],[0,0,0],[1,0,1]]",
                "explanation": "Element at (1,1) is 0, so row 1 and column 1 become all zeros."
            },
            {
                "input": "matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]",
                "output": "[[0,0,0,0],[0,4,5,0],[0,3,1,0]]",
                "explanation": "Zeros at (0,0) and (0,3) cause their rows and columns to zero out."
            }
        ],
        "constraints": [
            "<code>m == matrix.length</code>",
            "<code>n == matrix[0].length</code>",
            "<code>1 <= m, n <= 200</code>",
            "<code>-2<sup>31</sup> <= matrix[i][j] <= 2<sup>31</sup> - 1</code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "Track rows and cols with zeros.",
                "algorithm": "Use extra space",
                "complexity": {
                    "time": "O(mn)",
                    "space": "O(m+n)"
                },
                "code": {
                    "python": "class Solution:\n    def setZeroes(self, matrix):\n        m, n = len(matrix), len(matrix[0])\n        rows = set()\n        cols = set()\n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == 0:\n                    rows.add(i)\n                    cols.add(j)\n        for i in range(m):\n            for j in range(n):\n                if i in rows or j in cols:\n                    matrix[i][j] = 0",
                    "java": "class Solution { public void setZeroes(int[][] matrix) { int m = matrix.length, n = matrix[0].length; Set<Integer> rows = new HashSet<>(), cols = new HashSet<>(); for (int i = 0; i < m; i++) { for (int j = 0; j < n; j++) { if (matrix[i][j] == 0) { rows.add(i); cols.add(j); } } } for (int i = 0; i < m; i++) { for (int j = 0; j < n; j++) { if (rows.contains(i) || cols.contains(j)) matrix[i][j] = 0; } } } }",
                    "cpp": "class Solution { public: void setZeroes(vector<vector<int>>& matrix) { int m = matrix.size(), n = matrix[0].size(); set<int> rows, cols; for (int i = 0; i < m; i++) { for (int j = 0; j < n; j++) { if (matrix[i][j] == 0) { rows.insert(i); cols.insert(j); } } } for (int i = 0; i < m; i++) { for (int j = 0; j < n; j++) { if (rows.count(i) || cols.count(j)) matrix[i][j] = 0; } } } };"
                }
            },
            "optimized": {
                "intuition": "Use first row/col as markers.",
                "algorithm": "O(1) extra space",
                "complexity": {
                    "time": "O(mn)",
                    "space": "O(1)"
                },
                "code": {
                    "python": "class Solution:\n    def setZeroes(self, matrix):\n        m, n = len(matrix), len(matrix[0])\n        firstRow = any(matrix[0][j] == 0 for j in range(n))\n        firstCol = any(matrix[i][0] == 0 for i in range(m))\n        for i in range(1, m):\n            for j in range(1, n):\n                if matrix[i][j] == 0:\n                    matrix[i][0] = 0\n                    matrix[0][j] = 0\n        for i in range(1, m):\n            for j in range(1, n):\n                if matrix[i][0] == 0 or matrix[0][j] == 0:\n                    matrix[i][j] = 0\n        if firstRow:\n            for j in range(n): matrix[0][j] = 0\n        if firstCol:\n            for i in range(m): matrix[i][0] = 0",
                    "java": "class Solution { public void setZeroes(int[][] matrix) { int m = matrix.length, n = matrix[0].length; boolean fr = false, fc = false; for (int j = 0; j < n; j++) if (matrix[0][j] == 0) fr = true; for (int i = 0; i < m; i++) if (matrix[i][0] == 0) fc = true; for (int i = 1; i < m; i++) { for (int j = 1; j < n; j++) { if (matrix[i][j] == 0) { matrix[i][0] = 0; matrix[0][j] = 0; } } } for (int i = 1; i < m; i++) { for (int j = 1; j < n; j++) { if (matrix[i][0] == 0 || matrix[0][j] == 0) matrix[i][j] = 0; } } if (fr) for (int j = 0; j < n; j++) matrix[0][j] = 0; if (fc) for (int i = 0; i < m; i++) matrix[i][0] = 0; } }",
                    "cpp": "class Solution { public: void setZeroes(vector<vector<int>>& matrix) { int m = matrix.size(), n = matrix[0].size(); bool fr = false, fc = false; for (int j = 0; j < n; j++) if (matrix[0][j] == 0) fr = true; for (int i = 0; i < m; i++) if (matrix[i][0] == 0) fc = true; for (int i = 1; i < m; i++) { for (int j = 1; j < n; j++) { if (matrix[i][j] == 0) { matrix[i][0] = 0; matrix[0][j] = 0; } } } for (int i = 1; i < m; i++) { for (int j = 1; j < n; j++) { if (matrix[i][0] == 0 || matrix[0][j] == 0) matrix[i][j] = 0; } } if (fr) for (int j = 0; j < n; j++) matrix[0][j] = 0; if (fc) for (int i = 0; i < m; i++) matrix[i][0] = 0; } };"
                }
            }
        }
    },
    "gas-station": {
        "description": "<p>There are <code>n</code> gas stations along a circular route, where the amount of gas at the <code>i<sup>th</sup></code> station is <code>gas[i]</code>.</p><p>You have a car with an unlimited gas tank and it costs <code>cost[i]</code> of gas to travel from the <code>i<sup>th</sup></code> station to its next <code>(i + 1)<sup>th</sup></code> station. You begin the journey with an empty tank at one of the gas stations.</p><p>Given two integer arrays <code>gas</code> and <code>cost</code>, return <em>the starting gas station's index if you can travel around the circuit once in the clockwise direction, otherwise return <code>-1</code></em>. If there exists a solution, it is <strong>guaranteed to be unique</strong>.</p><p><strong>Approach:</strong> Use <strong>greedy algorithm</strong>. Key insight: If <code>sum(gas) >= sum(cost)</code>, a solution exists. Track cumulative tank balance. When tank becomes negative, the current start point cannot reach here, so try starting from the next station. The last valid start position is the answer.</p>",
        "examples": [
            {
                "input": "gas = [1,2,3,4,5], cost = [3,4,5,1,2]",
                "output": "3",
                "explanation": "Start at station 3. Tank = 0 + 4 - 1 = 3, then 3 + 5 - 2 = 6, then 6 + 1 - 3 = 4, then 4 + 2 - 4 = 2, then 2 + 3 - 5 = 0. We can complete the circuit."
            },
            {
                "input": "gas = [2,3,4], cost = [3,4,3]",
                "output": "-1",
                "explanation": "Cannot start at any station. Total gas (9) < total cost (10)."
            },
            {
                "input": "gas = [5,1,2,3,4], cost = [4,4,1,5,1]",
                "output": "4",
                "explanation": "Start at station 4."
            }
        ],
        "constraints": [
            "<code>n == gas.length == cost.length</code>",
            "<code>1 <= n <= 10<sup>5</sup></code>",
            "<code>0 <= gas[i], cost[i] <= 10<sup>4</sup></code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "Try starting from each station.",
                "algorithm": "O(n¬≤) simulation",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(1)"
                },
                "code": {
                    "python": "class Solution:\n    def canCompleteCircuit(self, gas, cost):\n        n = len(gas)\n        for start in range(n):\n            tank = 0\n            success = True\n            for i in range(n):\n                idx = (start + i) % n\n                tank += gas[idx] - cost[idx]\n                if tank < 0:\n                    success = False\n                    break\n            if success: return start\n        return -1",
                    "java": "class Solution { public int canCompleteCircuit(int[] gas, int[] cost) { int n = gas.length; for (int start = 0; start < n; start++) { int tank = 0; boolean success = true; for (int i = 0; i < n; i++) { int idx = (start + i) % n; tank += gas[idx] - cost[idx]; if (tank < 0) { success = false; break; } } if (success) return start; } return -1; } }",
                    "cpp": "class Solution { public: int canCompleteCircuit(vector<int>& gas, vector<int>& cost) { int n = gas.size(); for (int start = 0; start < n; start++) { int tank = 0; bool success = true; for (int i = 0; i < n; i++) { int idx = (start + i) % n; tank += gas[idx] - cost[idx]; if (tank < 0) { success = false; break; } } if (success) return start; } return -1; } };"
                }
            },
            "optimized": {
                "intuition": "If total >= 0, solution exists.",
                "algorithm": "Track lowest point",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)"
                },
                "code": {
                    "python": "class Solution:\n    def canCompleteCircuit(self, gas, cost):\n        total = tank = 0\n        start = 0\n        for i in range(len(gas)):\n            diff = gas[i] - cost[i]\n            total += diff\n            tank += diff\n            if tank < 0:\n                start = i + 1\n                tank = 0\n        return start if total >= 0 else -1",
                    "java": "class Solution { public int canCompleteCircuit(int[] gas, int[] cost) { int total = 0, tank = 0, start = 0; for (int i = 0; i < gas.length; i++) { int diff = gas[i] - cost[i]; total += diff; tank += diff; if (tank < 0) { start = i + 1; tank = 0; } } return total >= 0 ? start : -1; } }",
                    "cpp": "class Solution { public: int canCompleteCircuit(vector<int>& gas, vector<int>& cost) { int total = 0, tank = 0, start = 0; for (int i = 0; i < gas.size(); i++) { int diff = gas[i] - cost[i]; total += diff; tank += diff; if (tank < 0) { start = i + 1; tank = 0; } } return total >= 0 ? start : -1; } };"
                }
            }
        }
    },
    "hand-of-straights": {
        "description": "<p>Alice has some number of cards and she wants to rearrange the cards into groups so that each group is of size <code>groupSize</code>, and consists of <code>groupSize</code> consecutive cards.</p><p>Given an integer array <code>hand</code> where <code>hand[i]</code> is the value written on the <code>i<sup>th</sup></code> card and an integer <code>groupSize</code>, return <code>true</code> if she can rearrange the cards, or <code>false</code> otherwise.</p><p><strong>Approach:</strong> Use a <strong>TreeMap/sorted counter</strong> to track card frequencies. Greedily form groups starting with the smallest available card. For each smallest card, try to form a consecutive sequence of <code>groupSize</code> cards. If any card in the sequence is missing, return false. This ensures O(n log n) complexity.</p>",
        "examples": [
            {
                "input": "hand = [1,2,3,6,2,3,4,7,8], groupSize = 3",
                "output": "true",
                "explanation": "Alice's hand can be rearranged as [1,2,3], [2,3,4], [6,7,8]."
            },
            {
                "input": "hand = [1,2,3,4,5], groupSize = 4",
                "output": "false",
                "explanation": "Alice's hand cannot be rearranged into groups of 4."
            },
            {
                "input": "hand = [1,1,2,2,3,3], groupSize = 2",
                "output": "true",
                "explanation": "Rearrange as [1,2], [1,2], [3,3]. Note: groups don't need to be consecutive values, just groupSize consecutive."
            }
        ],
        "constraints": [
            "<code>1 <= hand.length <= 10<sup>4</sup></code>",
            "<code>0 <= hand[i] <= 10<sup>9</sup></code>",
            "<code>1 <= groupSize <= hand.length</code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "Sort and greedily form groups.",
                "algorithm": "Use counter",
                "complexity": {
                    "time": "O(n log n)",
                    "space": "O(n)"
                },
                "code": {
                    "python": "class Solution:\n    def isNStraightHand(self, hand, groupSize):\n        if len(hand) % groupSize != 0: return False\n        from collections import Counter\n        count = Counter(hand)\n        for card in sorted(count):\n            while count[card] > 0:\n                for i in range(groupSize):\n                    if count[card + i] <= 0: return False\n                    count[card + i] -= 1\n        return True",
                    "java": "class Solution { public boolean isNStraightHand(int[] hand, int groupSize) { if (hand.length % groupSize != 0) return false; TreeMap<Integer, Integer> count = new TreeMap<>(); for (int card : hand) count.put(card, count.getOrDefault(card, 0) + 1); while (!count.isEmpty()) { int first = count.firstKey(); for (int i = 0; i < groupSize; i++) { int card = first + i; if (!count.containsKey(card)) return false; int c = count.get(card); if (c == 1) count.remove(card); else count.put(card, c - 1); } } return true; } }",
                    "cpp": "class Solution { public: bool isNStraightHand(vector<int>& hand, int groupSize) { if (hand.size() % groupSize != 0) return false; map<int, int> count; for (int card : hand) count[card]++; while (!count.empty()) { int first = count.begin()->first; for (int i = 0; i < groupSize; i++) { if (count.find(first + i) == count.end()) return false; if (--count[first + i] == 0) count.erase(first + i); } } return true; } };"
                }
            },
            "optimized": {
                "intuition": "Track open groups.",
                "algorithm": "Process in order",
                "complexity": {
                    "time": "O(n log n)",
                    "space": "O(n)"
                },
                "code": {
                    "python": "class Solution:\n    def isNStraightHand(self, hand, groupSize):\n        if len(hand) % groupSize != 0: return False\n        from collections import Counter\n        count = Counter(hand)\n        for card in sorted(count):\n            if count[card] > 0:\n                need = count[card]\n                for i in range(groupSize):\n                    if count[card + i] < need: return False\n                    count[card + i] -= need\n        return True",
                    "java": "class Solution { public boolean isNStraightHand(int[] hand, int groupSize) { if (hand.length % groupSize != 0) return false; TreeMap<Integer, Integer> count = new TreeMap<>(); for (int card : hand) count.put(card, count.getOrDefault(card, 0) + 1); for (int card : count.keySet()) { int need = count.get(card); if (need > 0) { for (int i = 0; i < groupSize; i++) { int c = count.getOrDefault(card + i, 0); if (c < need) return false; count.put(card + i, c - need); } } } return true; } }",
                    "cpp": "class Solution { public: bool isNStraightHand(vector<int>& hand, int groupSize) { if (hand.size() % groupSize != 0) return false; map<int, int> count; for (int card : hand) count[card]++; for (auto& [card, cnt] : count) { if (cnt > 0) { for (int i = 0; i < groupSize; i++) { if (count[card + i] < cnt) return false; count[card + i] -= cnt; } } } return true; } };"
                }
            }
        }
    },
    "merge-triplets-to-form-target-triplet": {
        "description": "<p>A <strong>triplet</strong> is an array of three integers. You are given a 2D integer array <code>triplets</code>, where <code>triplets[i] = [a<sub>i</sub>, b<sub>i</sub>, c<sub>i</sub>]</code> describes the <code>i<sup>th</sup></code> <strong>triplet</strong>. You are also given an integer array <code>target = [x, y, z]</code> that describes the <strong>triplet</strong> you want to obtain.</p><p>To obtain <code>target</code>, you may apply the following operation on <code>triplets</code> <strong>any number</strong> of times (possibly <strong>zero</strong>):</p><ul><li>Choose two indices (<strong>0-indexed</strong>) <code>i</code> and <code>j</code> (<code>i != j</code>) and <strong>update</strong> <code>triplets[j]</code> to become <code>[max(a<sub>i</sub>, a<sub>j</sub>), max(b<sub>i</sub>, b<sub>j</sub>), max(c<sub>i</sub>, c<sub>j</sub>)]</code>.</li></ul><p>Return <code>true</code> <em>if it is possible to obtain the <code>target</code> <strong>triplet</strong> as an element of <code>triplets</code>, or <code>false</code> otherwise</em>.</p><p><strong>Approach:</strong> Filter triplets that don't exceed target values in any dimension (if any value > target, we can never reduce it). Then check if the filtered triplets contain at least one triplet with each target value in each dimension. Use a set to track which dimensions have reached their target.</p>",
        "examples": [
            {
                "input": "triplets = [[2,5,3],[1,8,4],[1,7,5]], target = [2,7,5]",
                "output": "true",
                "explanation": "Merge [2,5,3] and [1,7,5] to get [2,7,5]."
            },
            {
                "input": "triplets = [[3,4,5],[4,5,6]], target = [3,2,5]",
                "output": "false",
                "explanation": "Cannot obtain [3,2,5] because no triplet has 2 in the second position, and all have >= 4."
            },
            {
                "input": "triplets = [[2,5,3],[2,3,4],[1,2,5],[5,2,3]], target = [5,5,5]",
                "output": "true",
                "explanation": "Merge multiple triplets to get [5,5,5]."
            }
        ],
        "constraints": [
            "<code>1 <= triplets.length <= 10<sup>5</sup></code>",
            "<code>triplets[i].length == target.length == 3</code>",
            "<code>1 <= a<sub>i</sub>, b<sub>i</sub>, c<sub>i</sub>, x, y, z <= 1000</code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "Check all combinations.",
                "algorithm": "Try all subsets",
                "complexity": {
                    "time": "O(2^n)",
                    "space": "O(n)"
                },
                "code": {
                    "python": "class Solution:\n    def mergeTriplets(self, triplets, target):\n        def canUse(t):\n            return t[0] <= target[0] and t[1] <= target[1] and t[2] <= target[2]\n        good = [t for t in triplets if canUse(t)]\n        maxA = max((t[0] for t in good), default=0)\n        maxB = max((t[1] for t in good), default=0)\n        maxC = max((t[2] for t in good), default=0)\n        return maxA == target[0] and maxB == target[1] and maxC == target[2]",
                    "java": "class Solution { public boolean mergeTriplets(int[][] triplets, int[] target) { int maxA = 0, maxB = 0, maxC = 0; for (int[] t : triplets) { if (t[0] <= target[0] && t[1] <= target[1] && t[2] <= target[2]) { maxA = Math.max(maxA, t[0]); maxB = Math.max(maxB, t[1]); maxC = Math.max(maxC, t[2]); } } return maxA == target[0] && maxB == target[1] && maxC == target[2]; } }",
                    "cpp": "class Solution { public: bool mergeTriplets(vector<vector<int>>& triplets, vector<int>& target) { int maxA = 0, maxB = 0, maxC = 0; for (auto& t : triplets) { if (t[0] <= target[0] && t[1] <= target[1] && t[2] <= target[2]) { maxA = max(maxA, t[0]); maxB = max(maxB, t[1]); maxC = max(maxC, t[2]); } } return maxA == target[0] && maxB == target[1] && maxC == target[2]; } };"
                }
            },
            "optimized": {
                "intuition": "Filter and check max.",
                "algorithm": "Single pass",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)"
                },
                "code": {
                    "python": "class Solution:\n    def mergeTriplets(self, triplets, target):\n        good = set()\n        for t in triplets:\n            if t[0] <= target[0] and t[1] <= target[1] and t[2] <= target[2]:\n                for i in range(3):\n                    if t[i] == target[i]:\n                        good.add(i)\n        return len(good) == 3",
                    "java": "class Solution { public boolean mergeTriplets(int[][] triplets, int[] target) { boolean[] good = new boolean[3]; for (int[] t : triplets) { if (t[0] <= target[0] && t[1] <= target[1] && t[2] <= target[2]) { for (int i = 0; i < 3; i++) { if (t[i] == target[i]) good[i] = true; } } } return good[0] && good[1] && good[2]; } }",
                    "cpp": "class Solution { public: bool mergeTriplets(vector<vector<int>>& triplets, vector<int>& target) { vector<bool> good(3); for (auto& t : triplets) { if (t[0] <= target[0] && t[1] <= target[1] && t[2] <= target[2]) { for (int i = 0; i < 3; i++) { if (t[i] == target[i]) good[i] = true; } } } return good[0] && good[1] && good[2]; } };"
                }
            }
        }
    },
    "partition-labels": {
        "description": "<p>You are given a string <code>s</code>. We want to partition the string into as many parts as possible so that each letter appears in at most one part.</p><p>Note that the partition is done so that after concatenating all the parts in order, the resultant string should be <code>s</code>.</p><p>Return <em>a list of integers representing the size of these parts</em>.</p><p><strong>Approach:</strong> <strong>Greedy with last index tracking</strong>. Precompute the last occurrence index of each character. Iterate through the string, tracking the farthest last-index seen so far. When the current index equals the farthest last-index, we can partition here since all characters in this segment won't appear later.</p>",
        "examples": [
            {
                "input": "s = \"ababcbacadefegdehijhklij\"",
                "output": "[9,7,8]",
                "explanation": "Partition: \"ababcbaca\", \"defegde\", \"hijhklij\". Each letter appears in at most one part."
            },
            {
                "input": "s = \"eccbbbbdec\"",
                "output": "[10]",
                "explanation": "The entire string is one partition since all letters are interleaved."
            },
            {
                "input": "s = \"abc\"",
                "output": "[1,1,1]",
                "explanation": "Each character forms its own partition."
            }
        ],
        "constraints": [
            "<code>1 <= s.length <= 500</code>",
            "<code>s consists of lowercase English letters</code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "Track last occurrence of each char.",
                "algorithm": "Expand partitions",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(1)"
                },
                "code": {
                    "python": "class Solution:\n    def partitionLabels(self, s):\n        result = []\n        start = 0\n        while start < len(s):\n            end = start\n            i = start\n            while i <= end:\n                end = max(end, s.rfind(s[i]))\n                i += 1\n            result.append(end - start + 1)\n            start = end + 1\n        return result",
                    "java": "class Solution { public List<Integer> partitionLabels(String s) { List<Integer> result = new ArrayList<>(); int start = 0; while (start < s.length()) { int end = start; for (int i = start; i <= end; i++) { end = Math.max(end, s.lastIndexOf(s.charAt(i))); } result.add(end - start + 1); start = end + 1; } return result; } }",
                    "cpp": "class Solution { public: vector<int> partitionLabels(string s) { vector<int> result; int start = 0; while (start < s.size()) { int end = start; for (int i = start; i <= end; i++) { end = max(end, (int)s.rfind(s[i])); } result.push_back(end - start + 1); start = end + 1; } return result; } };"
                }
            },
            "optimized": {
                "intuition": "Precompute last indices.",
                "algorithm": "Single pass after preprocessing",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)"
                },
                "code": {
                    "python": "class Solution:\n    def partitionLabels(self, s):\n        last = {c: i for i, c in enumerate(s)}\n        result = []\n        start = end = 0\n        for i, c in enumerate(s):\n            end = max(end, last[c])\n            if i == end:\n                result.append(end - start + 1)\n                start = i + 1\n        return result",
                    "java": "class Solution { public List<Integer> partitionLabels(String s) { int[] last = new int[26]; for (int i = 0; i < s.length(); i++) last[s.charAt(i) - 'a'] = i; List<Integer> result = new ArrayList<>(); int start = 0, end = 0; for (int i = 0; i < s.length(); i++) { end = Math.max(end, last[s.charAt(i) - 'a']); if (i == end) { result.add(end - start + 1); start = i + 1; } } return result; } }",
                    "cpp": "class Solution { public: vector<int> partitionLabels(string s) { int last[26]; for (int i = 0; i < s.size(); i++) last[s[i] - 'a'] = i; vector<int> result; int start = 0, end = 0; for (int i = 0; i < s.size(); i++) { end = max(end, last[s[i] - 'a']); if (i == end) { result.push_back(end - start + 1); start = i + 1; } } return result; } };"
                }
            }
        }
    },
    "valid-parenthesis-string": {
        "description": "<p>Given a string <code>s</code> containing only three types of characters: <code>'('</code>, <code>')'</code> and <code>'*'</code>, return <code>true</code> <em>if <code>s</code> is <strong>valid</strong></em>.</p><p>The following rules define a <strong>valid</strong> string:</p><ul><li>Any left parenthesis <code>'('</code> must have a corresponding right parenthesis <code>')'</code>.</li><li>Any right parenthesis <code>')'</code> must have a corresponding left parenthesis <code>'('</code>.</li><li>Left parenthesis <code>'('</code> must go before the corresponding right parenthesis <code>')'</code>.</li><li><code>'*'</code> could be treated as a single right parenthesis <code>')'</code> or a single left parenthesis <code>'('</code> or an empty string.</li></ul><p><strong>Approach:</strong> Track <strong>min and max possible open parentheses count</strong>. For <code>'('</code>: increment both. For <code>')'</code>: decrement both. For <code>'*'</code>: decrement min (treat as ')' or empty), increment max (treat as '('). If max < 0, too many ')'. Keep min >= 0. Return min == 0.</p>",
        "examples": [
            {
                "input": "s = \"()\"",
                "output": "true",
                "explanation": "Standard valid parentheses."
            },
            {
                "input": "s = \"(*)\"",
                "output": "true",
                "explanation": "'*' can be treated as '(' or ')' or empty."
            },
            {
                "input": "s = \"(*))\"",
                "output": "true",
                "explanation": "Treat '*' as empty string."
            },
            {
                "input": "s = \"(((*\"",
                "output": "true",
                "explanation": "Treat '*' as ')'."
            }
        ],
        "constraints": [
            "<code>1 <= s.length <= 100</code>",
            "<code>s[i] is '(', ')' or '*'</code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "Try all * possibilities.",
                "algorithm": "Recursion/backtracking",
                "complexity": {
                    "time": "O(3^n)",
                    "space": "O(n)"
                },
                "code": {
                    "python": "class Solution:\n    def checkValidString(self, s):\n        def check(s, idx, count):\n            if count < 0: return False\n            if idx == len(s): return count == 0\n            if s[idx] == '(': return check(s, idx + 1, count + 1)\n            if s[idx] == ')': return check(s, idx + 1, count - 1)\n            return check(s, idx + 1, count + 1) or check(s, idx + 1, count - 1) or check(s, idx + 1, count)\n        return check(s, 0, 0)",
                    "java": "class Solution { public boolean checkValidString(String s) { return check(s, 0, 0); } boolean check(String s, int idx, int count) { if (count < 0) return false; if (idx == s.length()) return count == 0; char c = s.charAt(idx); if (c == '(') return check(s, idx + 1, count + 1); if (c == ')') return check(s, idx + 1, count - 1); return check(s, idx + 1, count + 1) || check(s, idx + 1, count - 1) || check(s, idx + 1, count); } }",
                    "cpp": "class Solution { public: bool checkValidString(string s) { return check(s, 0, 0); } bool check(string& s, int idx, int count) { if (count < 0) return false; if (idx == s.size()) return count == 0; if (s[idx] == '(') return check(s, idx + 1, count + 1); if (s[idx] == ')') return check(s, idx + 1, count - 1); return check(s, idx + 1, count + 1) || check(s, idx + 1, count - 1) || check(s, idx + 1, count); } };"
                }
            },
            "optimized": {
                "intuition": "Track min/max open count.",
                "algorithm": "Greedy with range",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)"
                },
                "code": {
                    "python": "class Solution:\n    def checkValidString(self, s):\n        lo = hi = 0\n        for c in s:\n            if c == '(':\n                lo += 1\n                hi += 1\n            elif c == ')':\n                lo -= 1\n                hi -= 1\n            else:\n                lo -= 1\n                hi += 1\n            if hi < 0: return False\n            lo = max(lo, 0)\n        return lo == 0",
                    "java": "class Solution { public boolean checkValidString(String s) { int lo = 0, hi = 0; for (char c : s.toCharArray()) { if (c == '(') { lo++; hi++; } else if (c == ')') { lo--; hi--; } else { lo--; hi++; } if (hi < 0) return false; lo = Math.max(lo, 0); } return lo == 0; } }",
                    "cpp": "class Solution { public: bool checkValidString(string s) { int lo = 0, hi = 0; for (char c : s) { if (c == '(') { lo++; hi++; } else if (c == ')') { lo--; hi--; } else { lo--; hi++; } if (hi < 0) return false; lo = max(lo, 0); } return lo == 0; } };"
                }
            }
        }
    },
    "jump-game-ii": {
        "description": "<p>You are given a <strong>0-indexed</strong> array of integers <code>nums</code> of length <code>n</code>. You are initially positioned at <code>nums[0]</code>.</p><p>Each element <code>nums[i]</code> represents the maximum length of a forward jump from index <code>i</code>. In other words, if you are at <code>nums[i]</code>, you can jump to any <code>nums[i + j]</code> where:</p><ul><li><code>0 <= j <= nums[i]</code> and</li><li><code>i + j < n</code></li></ul><p>Return <em>the minimum number of jumps to reach <code>nums[n - 1]</code></em>. The test cases are generated such that you can reach <code>nums[n - 1]</code>.</p><p><strong>Approach:</strong> Use <strong>greedy BFS-like algorithm</strong>. Track the current jump's range (<code>end</code>) and the farthest reachable position (<code>farthest</code>). When we reach <code>end</code>, we must make another jump, so increment jump count and update <code>end</code> to <code>farthest</code>. This avoids explicit BFS queue overhead.</p>",
        "examples": [
            {
                "input": "nums = [2,3,1,1,4]",
                "output": "2",
                "explanation": "Jump 1 step from index 0 to 1, then 3 steps to the last index."
            },
            {
                "input": "nums = [2,3,0,1,4]",
                "output": "2",
                "explanation": "Jump from index 0 to 1, then to the last index."
            },
            {
                "input": "nums = [1,2,3]",
                "output": "2",
                "explanation": "Jump from 0 to 1, then 1 to 3."
            }
        ],
        "constraints": [
            "<code>1 <= nums.length <= 10<sup>4</sup></code>",
            "<code>0 <= nums[i] <= 1000</code>",
            "<code>It's guaranteed that you can reach nums[n - 1]</code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "BFS from each position.",
                "algorithm": "BFS level by level",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)"
                },
                "code": {
                    "python": "class Solution:\n    def jump(self, nums):\n        n = len(nums)\n        if n == 1: return 0\n        from collections import deque\n        q = deque([0])\n        visited = {0}\n        jumps = 0\n        while q:\n            jumps += 1\n            for _ in range(len(q)):\n                pos = q.popleft()\n                for i in range(1, nums[pos] + 1):\n                    nxt = pos + i\n                    if nxt >= n - 1: return jumps\n                    if nxt not in visited:\n                        visited.add(nxt)\n                        q.append(nxt)\n        return -1",
                    "java": "class Solution { public int jump(int[] nums) { int n = nums.length; if (n == 1) return 0; Queue<Integer> q = new LinkedList<>(); boolean[] vis = new boolean[n]; q.offer(0); vis[0] = true; int jumps = 0; while (!q.isEmpty()) { jumps++; for (int size = q.size(); size > 0; size--) { int pos = q.poll(); for (int i = 1; i <= nums[pos]; i++) { int nxt = pos + i; if (nxt >= n - 1) return jumps; if (!vis[nxt]) { vis[nxt] = true; q.offer(nxt); } } } } return -1; } }",
                    "cpp": "class Solution { public: int jump(vector<int>& nums) { int n = nums.size(); if (n == 1) return 0; queue<int> q; vector<bool> vis(n); q.push(0); vis[0] = true; int jumps = 0; while (!q.empty()) { jumps++; for (int sz = q.size(); sz > 0; sz--) { int pos = q.front(); q.pop(); for (int i = 1; i <= nums[pos]; i++) { int nxt = pos + i; if (nxt >= n - 1) return jumps; if (!vis[nxt]) { vis[nxt] = true; q.push(nxt); } } } } return -1; } };"
                }
            },
            "optimized": {
                "intuition": "Greedy - track farthest reachable.",
                "algorithm": "Expand window",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)"
                },
                "code": {
                    "python": "class Solution:\n    def jump(self, nums):\n        jumps = 0\n        end = 0\n        farthest = 0\n        for i in range(len(nums) - 1):\n            farthest = max(farthest, i + nums[i])\n            if i == end:\n                jumps += 1\n                end = farthest\n        return jumps",
                    "java": "class Solution { public int jump(int[] nums) { int jumps = 0, end = 0, farthest = 0; for (int i = 0; i < nums.length - 1; i++) { farthest = Math.max(farthest, i + nums[i]); if (i == end) { jumps++; end = farthest; } } return jumps; } }",
                    "cpp": "class Solution { public: int jump(vector<int>& nums) { int jumps = 0, end = 0, farthest = 0; for (int i = 0; i < nums.size() - 1; i++) { farthest = max(farthest, i + nums[i]); if (i == end) { jumps++; end = farthest; } } return jumps; } };"
                }
            }
        }
    },
    "single-number": {
        "description": "<p>Given a <strong>non-empty</strong> array of integers <code>nums</code>, every element appears <em>twice</em> except for one. Find that single one.</p><p>You must implement a solution with a linear runtime complexity and use only constant extra space.</p><p><strong>Approach:</strong> Use <strong>XOR bit manipulation</strong>. Key property: <code>a XOR a = 0</code> and <code>a XOR 0 = a</code>. XOR all numbers together: duplicate pairs cancel out to 0, leaving only the single number. This achieves O(n) time and O(1) space.</p>",
        "examples": [
            {
                "input": "nums = [2,2,1]",
                "output": "1",
                "explanation": "2 XOR 2 XOR 1 = 0 XOR 1 = 1."
            },
            {
                "input": "nums = [4,1,2,1,2]",
                "output": "4",
                "explanation": "4 XOR 1 XOR 2 XOR 1 XOR 2 = 4."
            },
            {
                "input": "nums = [1]",
                "output": "1",
                "explanation": "Only one element, return it."
            }
        ],
        "constraints": [
            "<code>1 <= nums.length <= 3 * 10<sup>4</sup></code>",
            "<code>-3 * 10<sup>4</sup> <= nums[i] <= 3 * 10<sup>4</sup></code>",
            "<code>Each element in the array appears twice except for one element which appears only once</code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "Use hash map to count.",
                "algorithm": "Count occurrences",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(n)"
                },
                "code": {
                    "python": "class Solution:\n    def singleNumber(self, nums):\n        from collections import Counter\n        count = Counter(nums)\n        for num, cnt in count.items():\n            if cnt == 1: return num",
                    "java": "class Solution { public int singleNumber(int[] nums) { Map<Integer, Integer> count = new HashMap<>(); for (int n : nums) count.put(n, count.getOrDefault(n, 0) + 1); for (int n : count.keySet()) if (count.get(n) == 1) return n; return -1; } }",
                    "cpp": "class Solution { public: int singleNumber(vector<int>& nums) { unordered_map<int, int> count; for (int n : nums) count[n]++; for (auto& [n, c] : count) if (c == 1) return n; return -1; } };"
                }
            },
            "optimized": {
                "intuition": "XOR all numbers.",
                "algorithm": "a XOR a = 0",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)"
                },
                "code": {
                    "python": "class Solution:\n    def singleNumber(self, nums):\n        result = 0\n        for num in nums:\n            result ^= num\n        return result",
                    "java": "class Solution { public int singleNumber(int[] nums) { int result = 0; for (int n : nums) result ^= n; return result; } }",
                    "cpp": "class Solution { public: int singleNumber(vector<int>& nums) { int result = 0; for (int n : nums) result ^= n; return result; } };"
                }
            }
        }
    },
    "number-of-1-bits": {
        "description": "<p>Write a function that takes the binary representation of a positive integer and returns the number of <strong>set bits</strong> it has (also known as the <strong>Hamming weight</strong>).</p><p><strong>Approach:</strong> Use <strong>bit manipulation</strong>. Method 1: Repeatedly check the least significant bit with <code>n & 1</code>, then right shift. Method 2 (optimal): Use <code>n &= (n - 1)</code> which clears the rightmost set bit each iteration. This only iterates as many times as there are set bits.</p>",
        "examples": [
            {
                "input": "n = 11",
                "output": "3",
                "explanation": "The input binary string <strong>1011</strong> has three set bits."
            },
            {
                "input": "n = 128",
                "output": "1",
                "explanation": "The input binary string <strong>10000000</strong> has one set bit."
            },
            {
                "input": "n = 2147483645",
                "output": "30",
                "explanation": "The input binary string <strong>1111111111111111111111111111101</strong> has thirty set bits."
            }
        ],
        "constraints": [
            "<code>1 <= n <= 2<sup>31</sup> - 1</code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "Check each bit.",
                "algorithm": "Shift and count",
                "complexity": {
                    "time": "O(32)",
                    "space": "O(1)"
                },
                "code": {
                    "python": "class Solution:\n    def hammingWeight(self, n):\n        count = 0\n        while n:\n            count += n & 1\n            n >>= 1\n        return count",
                    "java": "public class Solution { public int hammingWeight(int n) { int count = 0; while (n != 0) { count += n & 1; n >>>= 1; } return count; } }",
                    "cpp": "class Solution { public: int hammingWeight(uint32_t n) { int count = 0; while (n) { count += n & 1; n >>= 1; } return count; } };"
                }
            },
            "optimized": {
                "intuition": "n & (n-1) removes lowest set bit.",
                "algorithm": "Brian Kernighan's",
                "complexity": {
                    "time": "O(k)",
                    "space": "O(1)"
                },
                "code": {
                    "python": "class Solution:\n    def hammingWeight(self, n):\n        count = 0\n        while n:\n            n &= n - 1\n            count += 1\n        return count",
                    "java": "public class Solution { public int hammingWeight(int n) { int count = 0; while (n != 0) { n &= n - 1; count++; } return count; } }",
                    "cpp": "class Solution { public: int hammingWeight(uint32_t n) { int count = 0; while (n) { n &= n - 1; count++; } return count; } };"
                }
            }
        }
    },
    "counting-bits": {
        "description": "<p>Given an integer <code>n</code>, return <em>an array <code>ans</code> of length <code>n + 1</code> such that for each <code>i</code> (<code>0 <= i <= n</code>), <code>ans[i]</code> is the <strong>number of <code>1</code>'s</strong> in the binary representation of <code>i</code></em>.</p><p><strong>Approach:</strong> Use <strong>Dynamic Programming</strong> with bit manipulation. Key insight: <code>dp[i] = dp[i >> 1] + (i & 1)</code>. When we right shift <code>i</code>, we remove the least significant bit, so the count is the same as <code>i >> 1</code> plus 1 if the removed bit was 1. This achieves O(n) time instead of O(n log n).</p>",
        "examples": [
            {
                "input": "n = 2",
                "output": "[0,1,1]",
                "explanation": "0 has 0 ones, 1 has 1 one, 2 (10 in binary) has 1 one."
            },
            {
                "input": "n = 5",
                "output": "[0,1,1,2,1,2]",
                "explanation": "0‚Üí0, 1‚Üí1, 2‚Üí1, 3‚Üí2, 4‚Üí1, 5‚Üí2 ones."
            },
            {
                "input": "n = 0",
                "output": "[0]",
                "explanation": "Only 0 with 0 ones."
            }
        ],
        "constraints": [
            "<code>0 <= n <= 10<sup>5</sup></code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "Count bits for each number.",
                "algorithm": "Use popcount",
                "complexity": {
                    "time": "O(n log n)",
                    "space": "O(n)"
                },
                "code": {
                    "python": "class Solution:\n    def countBits(self, n):\n        return [bin(i).count('1') for i in range(n + 1)]",
                    "java": "class Solution { public int[] countBits(int n) { int[] res = new int[n + 1]; for (int i = 0; i <= n; i++) res[i] = Integer.bitCount(i); return res; } }",
                    "cpp": "class Solution { public: vector<int> countBits(int n) { vector<int> res(n + 1); for (int i = 0; i <= n; i++) res[i] = __builtin_popcount(i); return res; } };"
                }
            },
            "optimized": {
                "intuition": "DP: use previously computed results.",
                "algorithm": "dp[i] = dp[i >> 1] + (i & 1)",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(n)"
                },
                "code": {
                    "python": "class Solution:\n    def countBits(self, n):\n        dp = [0] * (n + 1)\n        for i in range(1, n + 1):\n            dp[i] = dp[i >> 1] + (i & 1)\n        return dp",
                    "java": "class Solution { public int[] countBits(int n) { int[] dp = new int[n + 1]; for (int i = 1; i <= n; i++) dp[i] = dp[i >> 1] + (i & 1); return dp; } }",
                    "cpp": "class Solution { public: vector<int> countBits(int n) { vector<int> dp(n + 1); for (int i = 1; i <= n; i++) dp[i] = dp[i >> 1] + (i & 1); return dp; } };"
                }
            }
        }
    },
    "reverse-bits": {
        "description": "<p>Reverse bits of a given 32 bits unsigned integer.</p><p><strong>Note:</strong> In some languages, such as Java, there is no unsigned integer type. In this case, both input and output will be given as a signed integer type. They should not affect your implementation, as the integer's internal binary representation is the same, whether it is signed or unsigned.</p><p><strong>Approach:</strong> Method 1: Iterate through all 32 bits, shift result left and add the least significant bit of <code>n</code>. Method 2 (optimal): Use <strong>divide-and-conquer</strong> with bit masks to swap 16-bit halves, then 8-bit quarters, then 4-bit, 2-bit, and 1-bit groups.</p>",
        "examples": [
            {
                "input": "n = 00000010100101000001111010011100",
                "output": "964176192 (00111001011110000010100101000000)",
                "explanation": "The input binary string is reversed."
            },
            {
                "input": "n = 11111111111111111111111111111101",
                "output": "3221225471 (10111111111111111111111111111111)",
                "explanation": "Note that in some languages, such as Java, there is no unsigned integer type."
            }
        ],
        "constraints": [
            "<code>The input must be a binary string of length 32</code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "Extract and place each bit.",
                "algorithm": "Bit manipulation",
                "complexity": {
                    "time": "O(32)",
                    "space": "O(1)"
                },
                "code": {
                    "python": "class Solution:\n    def reverseBits(self, n):\n        result = 0\n        for i in range(32):\n            result = (result << 1) | (n & 1)\n            n >>= 1\n        return result",
                    "java": "public class Solution { public int reverseBits(int n) { int result = 0; for (int i = 0; i < 32; i++) { result = (result << 1) | (n & 1); n >>>= 1; } return result; } }",
                    "cpp": "class Solution { public: uint32_t reverseBits(uint32_t n) { uint32_t result = 0; for (int i = 0; i < 32; i++) { result = (result << 1) | (n & 1); n >>= 1; } return result; } };"
                }
            },
            "optimized": {
                "intuition": "Divide and conquer.",
                "algorithm": "Swap halves recursively",
                "complexity": {
                    "time": "O(1)",
                    "space": "O(1)"
                },
                "code": {
                    "python": "class Solution:\n    def reverseBits(self, n):\n        n = ((n & 0xffff0000) >> 16) | ((n & 0x0000ffff) << 16)\n        n = ((n & 0xff00ff00) >> 8) | ((n & 0x00ff00ff) << 8)\n        n = ((n & 0xf0f0f0f0) >> 4) | ((n & 0x0f0f0f0f) << 4)\n        n = ((n & 0xcccccccc) >> 2) | ((n & 0x33333333) << 2)\n        n = ((n & 0xaaaaaaaa) >> 1) | ((n & 0x55555555) << 1)\n        return n",
                    "java": "public class Solution { public int reverseBits(int n) { n = ((n & 0xffff0000) >>> 16) | ((n & 0x0000ffff) << 16); n = ((n & 0xff00ff00) >>> 8) | ((n & 0x00ff00ff) << 8); n = ((n & 0xf0f0f0f0) >>> 4) | ((n & 0x0f0f0f0f) << 4); n = ((n & 0xcccccccc) >>> 2) | ((n & 0x33333333) << 2); n = ((n & 0xaaaaaaaa) >>> 1) | ((n & 0x55555555) << 1); return n; } }",
                    "cpp": "class Solution { public: uint32_t reverseBits(uint32_t n) { n = ((n & 0xffff0000) >> 16) | ((n & 0x0000ffff) << 16); n = ((n & 0xff00ff00) >> 8) | ((n & 0x00ff00ff) << 8); n = ((n & 0xf0f0f0f0) >> 4) | ((n & 0x0f0f0f0f) << 4); n = ((n & 0xcccccccc) >> 2) | ((n & 0x33333333) << 2); n = ((n & 0xaaaaaaaa) >> 1) | ((n & 0x55555555) << 1); return n; } };"
                }
            }
        }
    },
    "missing-number": {
        "description": "<p>Given an array <code>nums</code> containing <code>n</code> distinct numbers in the range <code>[0, n]</code>, return <em>the only number in the range that is missing from the array</em>.</p><p><strong>Approach:</strong> Method 1: Use <strong>sum formula</strong>. Expected sum = <code>n*(n+1)/2</code>, subtract actual sum to get missing number. Method 2: Use <strong>XOR</strong>. XOR all indices with all array values; duplicate values cancel out, leaving only the missing number.</p>",
        "examples": [
            {
                "input": "nums = [3,0,1]",
                "output": "2",
                "explanation": "Range is [0,3] but 2 is missing."
            },
            {
                "input": "nums = [0,1]",
                "output": "2",
                "explanation": "Range is [0,2] but 2 is missing."
            },
            {
                "input": "nums = [9,6,4,2,3,5,7,0,1]",
                "output": "8",
                "explanation": "Range is [0,9] but 8 is missing."
            }
        ],
        "constraints": [
            "<code>n == nums.length</code>",
            "<code>1 <= n <= 10<sup>4</sup></code>",
            "<code>0 <= nums[i] <= n</code>",
            "<code>All numbers in nums are unique</code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "Use set to find missing.",
                "algorithm": "Check each number",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(n)"
                },
                "code": {
                    "python": "class Solution:\n    def missingNumber(self, nums):\n        s = set(nums)\n        for i in range(len(nums) + 1):\n            if i not in s: return i",
                    "java": "class Solution { public int missingNumber(int[] nums) { Set<Integer> s = new HashSet<>(); for (int n : nums) s.add(n); for (int i = 0; i <= nums.length; i++) if (!s.contains(i)) return i; return -1; } }",
                    "cpp": "class Solution { public: int missingNumber(vector<int>& nums) { unordered_set<int> s(nums.begin(), nums.end()); for (int i = 0; i <= nums.size(); i++) if (!s.count(i)) return i; return -1; } };"
                }
            },
            "optimized": {
                "intuition": "XOR or sum formula.",
                "algorithm": "Sum formula: n*(n+1)/2 - sum",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)"
                },
                "code": {
                    "python": "class Solution:\n    def missingNumber(self, nums):\n        n = len(nums)\n        return n * (n + 1) // 2 - sum(nums)",
                    "java": "class Solution { public int missingNumber(int[] nums) { int n = nums.length; int expected = n * (n + 1) / 2; int actual = 0; for (int num : nums) actual += num; return expected - actual; } }",
                    "cpp": "class Solution { public: int missingNumber(vector<int>& nums) { int n = nums.size(); long expected = (long)n * (n + 1) / 2; long actual = 0; for (int num : nums) actual += num; return expected - actual; } };"
                }
            }
        }
    },
    "sum-of-two-integers": {
        "description": "<p>Given two integers <code>a</code> and <code>b</code>, return <em>the sum of the two integers without using the operators <code>+</code> and <code>-</code></em>.</p><p><strong>Approach:</strong> Use <strong>bit manipulation</strong>. <code>XOR</code> gives the sum without carry. <code>AND</code> followed by left shift gives the carry. Repeat until carry is 0. In Python, handle negative numbers with masking since Python has arbitrary precision integers.</p>",
        "examples": [
            {
                "input": "a = 1, b = 2",
                "output": "3",
                "explanation": "1 + 2 = 3 using bit manipulation."
            },
            {
                "input": "a = 2, b = 3",
                "output": "5",
                "explanation": "2 + 3 = 5."
            },
            {
                "input": "a = -1, b = 1",
                "output": "0",
                "explanation": "-1 + 1 = 0."
            }
        ],
        "constraints": [
            "<code>-1000 <= a, b <= 1000</code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "Bit manipulation.",
                "algorithm": "XOR for sum, AND for carry",
                "complexity": {
                    "time": "O(1)",
                    "space": "O(1)"
                },
                "code": {
                    "python": "class Solution:\n    def getSum(self, a, b):\n        MASK = 0xFFFFFFFF\n        MAX = 0x7FFFFFFF\n        while b != 0:\n            carry = ((a & b) << 1) & MASK\n            a = (a ^ b) & MASK\n            b = carry\n        return a if a <= MAX else ~(a ^ MASK)",
                    "java": "class Solution { public int getSum(int a, int b) { while (b != 0) { int carry = (a & b) << 1; a = a ^ b; b = carry; } return a; } }",
                    "cpp": "class Solution { public: int getSum(int a, int b) { while (b != 0) { int carry = (unsigned int)(a & b) << 1; a = a ^ b; b = carry; } return a; } };"
                }
            },
            "optimized": {
                "intuition": "Same approach.",
                "algorithm": "Iterative bit manipulation",
                "complexity": {
                    "time": "O(1)",
                    "space": "O(1)"
                },
                "code": {
                    "python": "class Solution:\n    def getSum(self, a, b):\n        MASK = 0xFFFFFFFF\n        while b & MASK:\n            a, b = a ^ b, (a & b) << 1\n        return a & MASK if b > MASK else a",
                    "java": "class Solution { public int getSum(int a, int b) { while (b != 0) { int t = (a & b) << 1; a = a ^ b; b = t; } return a; } }",
                    "cpp": "class Solution { public: int getSum(int a, int b) { while (b) { int t = (unsigned)(a & b) << 1; a ^= b; b = t; } return a; } };"
                }
            }
        }
    },
    "reverse-integer": {
        "description": "<p>Given a signed 32-bit integer <code>x</code>, return <code>x</code> <em>with its digits reversed</em>. If reversing <code>x</code> causes the value to go outside the signed 32-bit integer range <code>[-2<sup>31</sup>, 2<sup>31</sup> - 1]</code>, then return <code>0</code>.</p><p><strong>Assume the environment does not allow you to store 64-bit integers (signed or unsigned).</strong></p><p><strong>Approach:</strong> Extract digits using modulo and division. Build reversed number by multiplying by 10 and adding each digit. <strong>Check for overflow</strong> before each multiplication: if <code>rev > INT_MAX/10</code> or <code>rev < INT_MIN/10</code>, return 0.</p>",
        "examples": [
            {
                "input": "x = 123",
                "output": "321",
                "explanation": "Reverse 123 to get 321."
            },
            {
                "input": "x = -123",
                "output": "-321",
                "explanation": "Reverse -123 to get -321."
            },
            {
                "input": "x = 120",
                "output": "21",
                "explanation": "Leading zeros are dropped."
            },
            {
                "input": "x = 1534236469",
                "output": "0",
                "explanation": "Reversed would be 9646324351 which overflows, return 0."
            }
        ],
        "constraints": [
            "<code>-2<sup>31</sup> <= x <= 2<sup>31</sup> - 1</code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "Convert to string, reverse.",
                "algorithm": "String manipulation",
                "complexity": {
                    "time": "O(log x)",
                    "space": "O(log x)"
                },
                "code": {
                    "python": "class Solution:\n    def reverse(self, x):\n        sign = 1 if x >= 0 else -1\n        x = abs(x)\n        rev = int(str(x)[::-1]) * sign\n        if rev < -2**31 or rev > 2**31 - 1: return 0\n        return rev",
                    "java": "class Solution { public int reverse(int x) { int sign = x < 0 ? -1 : 1; String s = new StringBuilder(String.valueOf(Math.abs((long)x))).reverse().toString(); long rev = Long.parseLong(s) * sign; if (rev < Integer.MIN_VALUE || rev > Integer.MAX_VALUE) return 0; return (int) rev; } }",
                    "cpp": "class Solution { public: int reverse(int x) { int sign = x < 0 ? -1 : 1; string s = to_string(abs((long)x)); std::reverse(s.begin(), s.end()); long rev = stol(s) * sign; if (rev < INT_MIN || rev > INT_MAX) return 0; return rev; } };"
                }
            },
            "optimized": {
                "intuition": "Mathematical reversal.",
                "algorithm": "Extract digits",
                "complexity": {
                    "time": "O(log x)",
                    "space": "O(1)"
                },
                "code": {
                    "python": "class Solution:\n    def reverse(self, x):\n        INT_MAX = 2**31 - 1\n        INT_MIN = -2**31\n        rev = 0\n        sign = 1 if x >= 0 else -1\n        x = abs(x)\n        while x:\n            digit = x % 10\n            x //= 10\n            if rev > (INT_MAX - digit) // 10: return 0\n            rev = rev * 10 + digit\n        return rev * sign",
                    "java": "class Solution { public int reverse(int x) { int rev = 0; while (x != 0) { int digit = x % 10; x /= 10; if (rev > Integer.MAX_VALUE / 10 || (rev == Integer.MAX_VALUE / 10 && digit > 7)) return 0; if (rev < Integer.MIN_VALUE / 10 || (rev == Integer.MIN_VALUE / 10 && digit < -8)) return 0; rev = rev * 10 + digit; } return rev; } }",
                    "cpp": "class Solution { public: int reverse(int x) { int rev = 0; while (x != 0) { int digit = x % 10; x /= 10; if (rev > INT_MAX / 10 || (rev == INT_MAX / 10 && digit > 7)) return 0; if (rev < INT_MIN / 10 || (rev == INT_MIN / 10 && digit < -8)) return 0; rev = rev * 10 + digit; } return rev; } };"
                }
            }
        }
    },
    "string-to-integer-atoi": {
        "description": "<p>Implement the <code>myAtoi(string s)</code> function, which converts a string to a 32-bit signed integer.</p><p>The algorithm for <code>myAtoi(string s)</code> is as follows:</p><ol><li><strong>Whitespace:</strong> Ignore any leading whitespace (<code>' '</code>).</li><li><strong>Signedness:</strong> Determine the sign by checking if the next character is <code>'-'</code> or <code>'+'</code>, assuming positivity if neither present.</li><li><strong>Conversion:</strong> Read the integer by skipping leading zeros until a non-digit character is encountered. If no digits were read, then the result is 0.</li><li><strong>Rounding:</strong> If the integer is out of the 32-bit signed integer range <code>[-2<sup>31</sup>, 2<sup>31</sup> - 1]</code>, then round to the closest boundary.</li></ol><p><strong>Approach:</strong> Use a <strong>finite state machine</strong> or careful parsing. Handle whitespace, optional sign, and digit extraction. Check for overflow before multiplying by 10.</p>",
        "examples": [
            {
                "input": "s = \"42\"",
                "output": "42",
                "explanation": "Reading starts at '4', stops at end. Result = 42."
            },
            {
                "input": "s = \"   -042\"",
                "output": "-42",
                "explanation": "Skip leading whitespace, read sign '-', skip leading zero, read '42'."
            },
            {
                "input": "s = \"1337c0d3\"",
                "output": "1337",
                "explanation": "Read '1337' then stop at 'c'."
            },
            {
                "input": "s = \"0-1\"",
                "output": "0",
                "explanation": "Read '0' then stop at '-'."
            },
            {
                "input": "s = \"words and 987\"",
                "output": "0",
                "explanation": "No digits found at start after whitespace."
            }
        ],
        "constraints": [
            "<code>0 <= s.length <= 200</code>",
            "<code>s consists of English letters (lower-case and upper-case), digits (0-9), ' ', '+', '-', and '.'</code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "Parse carefully with edge cases.",
                "algorithm": "Handle whitespace, sign, overflow",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)"
                },
                "code": {
                    "python": "class Solution:\n    def myAtoi(self, s):\n        s = s.lstrip()\n        if not s: return 0\n        sign = 1\n        i = 0\n        if s[0] in '+-':\n            sign = -1 if s[0] == '-' else 1\n            i = 1\n        result = 0\n        while i < len(s) and s[i].isdigit():\n            result = result * 10 + int(s[i])\n            i += 1\n        result *= sign\n        return max(-2**31, min(2**31 - 1, result))",
                    "java": "class Solution { public int myAtoi(String s) { s = s.trim(); if (s.isEmpty()) return 0; int sign = 1, i = 0; if (s.charAt(0) == '-') { sign = -1; i++; } else if (s.charAt(0) == '+') i++; long result = 0; while (i < s.length() && Character.isDigit(s.charAt(i))) { result = result * 10 + (s.charAt(i) - '0'); if (result * sign > Integer.MAX_VALUE) return Integer.MAX_VALUE; if (result * sign < Integer.MIN_VALUE) return Integer.MIN_VALUE; i++; } return (int) (result * sign); } }",
                    "cpp": "class Solution { public: int myAtoi(string s) { int i = 0, n = s.size(); while (i < n && s[i] == ' ') i++; if (i == n) return 0; int sign = 1; if (s[i] == '-') { sign = -1; i++; } else if (s[i] == '+') i++; long result = 0; while (i < n && isdigit(s[i])) { result = result * 10 + (s[i] - '0'); if (result * sign > INT_MAX) return INT_MAX; if (result * sign < INT_MIN) return INT_MIN; i++; } return result * sign; } };"
                }
            },
            "optimized": {
                "intuition": "Same approach.",
                "algorithm": "Finite state machine",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)"
                },
                "code": {
                    "python": "class Solution:\n    def myAtoi(self, s):\n        INT_MAX, INT_MIN = 2**31 - 1, -2**31\n        i, n = 0, len(s)\n        while i < n and s[i] == ' ': i += 1\n        if i == n: return 0\n        sign = 1\n        if s[i] in '+-':\n            sign = -1 if s[i] == '-' else 1\n            i += 1\n        result = 0\n        while i < n and s[i].isdigit():\n            digit = int(s[i])\n            if result > (INT_MAX - digit) // 10:\n                return INT_MAX if sign == 1 else INT_MIN\n            result = result * 10 + digit\n            i += 1\n        return result * sign",
                    "java": "class Solution { public int myAtoi(String s) { int i = 0, n = s.length(); while (i < n && s.charAt(i) == ' ') i++; if (i == n) return 0; int sign = 1; if (i < n && (s.charAt(i) == '-' || s.charAt(i) == '+')) { sign = s.charAt(i) == '-' ? -1 : 1; i++; } int result = 0; while (i < n && Character.isDigit(s.charAt(i))) { int digit = s.charAt(i) - '0'; if (result > (Integer.MAX_VALUE - digit) / 10) return sign == 1 ? Integer.MAX_VALUE : Integer.MIN_VALUE; result = result * 10 + digit; i++; } return result * sign; } }",
                    "cpp": "class Solution { public: int myAtoi(string s) { int i = 0, n = s.size(); while (i < n && s[i] == ' ') i++; if (i == n) return 0; int sign = 1; if (s[i] == '-' || s[i] == '+') { sign = s[i] == '-' ? -1 : 1; i++; } int result = 0; while (i < n && isdigit(s[i])) { int digit = s[i] - '0'; if (result > (INT_MAX - digit) / 10) return sign == 1 ? INT_MAX : INT_MIN; result = result * 10 + digit; i++; } return result * sign; } };"
                }
            }
        }
    },
    "rotate-array": {
        "description": "<p>Given an integer array <code>nums</code>, rotate the array to the right by <code>k</code> steps, where <code>k</code> is non-negative.</p><p><strong>Approach:</strong> Use the <strong>reverse trick</strong> for O(1) space. Reverse the entire array, then reverse the first <code>k</code> elements, then reverse the remaining elements. This effectively rotates right by <code>k</code> positions. Remember to do <code>k %= n</code> first.</p>",
        "examples": [
            {
                "input": "nums = [1,2,3,4,5,6,7], k = 3",
                "output": "[5,6,7,1,2,3,4]",
                "explanation": "Rotate right by 3: [1,2,3,4,5,6,7] ‚Üí [5,6,7,1,2,3,4]."
            },
            {
                "input": "nums = [-1,-100,3,99], k = 2",
                "output": "[3,99,-1,-100]",
                "explanation": "Rotate right by 2: [-1,-100,3,99] ‚Üí [3,99,-1,-100]."
            },
            {
                "input": "nums = [1,2], k = 3",
                "output": "[2,1]",
                "explanation": "k=3 is same as k=1 for array of length 2."
            }
        ],
        "constraints": [
            "<code>1 <= nums.length <= 10<sup>5</sup></code>",
            "<code>-2<sup>31</sup> <= nums[i] <= 2<sup>31</sup> - 1</code>",
            "<code>0 <= k <= 10<sup>5</sup></code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "Use extra array.",
                "algorithm": "Copy to new positions",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(n)"
                },
                "code": {
                    "python": "class Solution:\n    def rotate(self, nums, k):\n        n = len(nums)\n        k %= n\n        nums[:] = nums[-k:] + nums[:-k]",
                    "java": "class Solution { public void rotate(int[] nums, int k) { int n = nums.length; k %= n; int[] temp = new int[n]; for (int i = 0; i < n; i++) temp[(i + k) % n] = nums[i]; System.arraycopy(temp, 0, nums, 0, n); } }",
                    "cpp": "class Solution { public: void rotate(vector<int>& nums, int k) { int n = nums.size(); k %= n; vector<int> temp(n); for (int i = 0; i < n; i++) temp[(i + k) % n] = nums[i]; nums = temp; } };"
                }
            },
            "optimized": {
                "intuition": "Reverse three times.",
                "algorithm": "Reverse all, then parts",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)"
                },
                "code": {
                    "python": "class Solution:\n    def rotate(self, nums, k):\n        n = len(nums)\n        k %= n\n        def reverse(l, r):\n            while l < r:\n                nums[l], nums[r] = nums[r], nums[l]\n                l += 1\n                r -= 1\n        reverse(0, n - 1)\n        reverse(0, k - 1)\n        reverse(k, n - 1)",
                    "java": "class Solution { public void rotate(int[] nums, int k) { int n = nums.length; k %= n; reverse(nums, 0, n - 1); reverse(nums, 0, k - 1); reverse(nums, k, n - 1); } void reverse(int[] nums, int l, int r) { while (l < r) { int t = nums[l]; nums[l] = nums[r]; nums[r] = t; l++; r--; } } }",
                    "cpp": "class Solution { public: void rotate(vector<int>& nums, int k) { int n = nums.size(); k %= n; reverse(nums.begin(), nums.end()); reverse(nums.begin(), nums.begin() + k); reverse(nums.begin() + k, nums.end()); } };"
                }
            }
        }
    },
    "first-missing-positive": {
        "description": "<p>Given an unsorted integer array <code>nums</code>, return <em>the smallest positive integer that is not present in the array</em>.</p><p>You must implement an algorithm that runs in <code>O(n)</code> time and uses <code>O(1)</code> auxiliary space.</p><p><strong>Approach:</strong> Use the array itself as a hash map with <strong>cyclic sort</strong>. Place each number <code>i</code> (where <code>1 <= i <= n</code>) at index <code>i-1</code>. After sorting in place, scan to find the first index where <code>nums[i] != i+1</code>. This is the missing positive.</p>",
        "examples": [
            {
                "input": "nums = [1,2,0]",
                "output": "3",
                "explanation": "Range [1,2,3] is missing 3."
            },
            {
                "input": "nums = [3,4,-1,1]",
                "output": "2",
                "explanation": "Has 1, 3, 4 but missing 2."
            },
            {
                "input": "nums = [7,8,9,11,12]",
                "output": "1",
                "explanation": "All numbers > 1, so 1 is missing."
            }
        ],
        "constraints": [
            "<code>1 <= nums.length <= 10<sup>5</sup></code>",
            "<code>-2<sup>31</sup> <= nums[i] <= 2<sup>31</sup> - 1</code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "Use set to check.",
                "algorithm": "Hash set lookup",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(n)"
                },
                "code": {
                    "python": "class Solution:\n    def firstMissingPositive(self, nums):\n        s = set(nums)\n        i = 1\n        while i in s:\n            i += 1\n        return i",
                    "java": "class Solution { public int firstMissingPositive(int[] nums) { Set<Integer> s = new HashSet<>(); for (int n : nums) s.add(n); int i = 1; while (s.contains(i)) i++; return i; } }",
                    "cpp": "class Solution { public: int firstMissingPositive(vector<int>& nums) { unordered_set<int> s(nums.begin(), nums.end()); int i = 1; while (s.count(i)) i++; return i; } };"
                }
            },
            "optimized": {
                "intuition": "Use array as hash map.",
                "algorithm": "Place each number in its index",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)"
                },
                "code": {
                    "python": "class Solution:\n    def firstMissingPositive(self, nums):\n        n = len(nums)\n        for i in range(n):\n            while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]:\n                nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]\n        for i in range(n):\n            if nums[i] != i + 1:\n                return i + 1\n        return n + 1",
                    "java": "class Solution { public int firstMissingPositive(int[] nums) { int n = nums.length; for (int i = 0; i < n; i++) { while (nums[i] >= 1 && nums[i] <= n && nums[nums[i] - 1] != nums[i]) { int t = nums[nums[i] - 1]; nums[nums[i] - 1] = nums[i]; nums[i] = t; } } for (int i = 0; i < n; i++) { if (nums[i] != i + 1) return i + 1; } return n + 1; } }",
                    "cpp": "class Solution { public: int firstMissingPositive(vector<int>& nums) { int n = nums.size(); for (int i = 0; i < n; i++) { while (nums[i] >= 1 && nums[i] <= n && nums[nums[i] - 1] != nums[i]) { swap(nums[i], nums[nums[i] - 1]); } } for (int i = 0; i < n; i++) { if (nums[i] != i + 1) return i + 1; } return n + 1; } };"
                }
            }
        }
    },
    "find-all-numbers-disappeared-in-an-array": {
        "description": "<p>Given an array <code>nums</code> of <code>n</code> integers where <code>nums[i]</code> is in the range <code>[1, n]</code>, return <em>an array of all the integers in the range <code>[1, n]</code> that do not appear in <code>nums</code></em>.</p><p><strong>Approach:</strong> Use the array itself as storage with <strong>index marking</strong>. For each number, mark its index as visited by negating <code>nums[abs(num) - 1]</code>. After processing, positive values indicate their indices+1 are missing numbers. This achieves O(n) time and O(1) space.</p>",
        "examples": [
            {
                "input": "nums = [4,3,2,7,8,2,3,1]",
                "output": "[5,6]",
                "explanation": "Numbers 5 and 6 do not appear in the array."
            },
            {
                "input": "nums = [1,1]",
                "output": "[2]",
                "explanation": "Number 2 is missing."
            },
            {
                "input": "nums = [1,2,3,4,5]",
                "output": "[]",
                "explanation": "All numbers present."
            }
        ],
        "constraints": [
            "<code>n == nums.length</code>",
            "<code>1 <= n <= 10<sup>5</sup></code>",
            "<code>1 <= nums[i] <= n</code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "Use set.",
                "algorithm": "Check which numbers missing",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(n)"
                },
                "code": {
                    "python": "class Solution:\n    def findDisappearedNumbers(self, nums):\n        s = set(nums)\n        return [i for i in range(1, len(nums) + 1) if i not in s]",
                    "java": "class Solution { public List<Integer> findDisappearedNumbers(int[] nums) { Set<Integer> s = new HashSet<>(); for (int n : nums) s.add(n); List<Integer> res = new ArrayList<>(); for (int i = 1; i <= nums.length; i++) if (!s.contains(i)) res.add(i); return res; } }",
                    "cpp": "class Solution { public: vector<int> findDisappearedNumbers(vector<int>& nums) { unordered_set<int> s(nums.begin(), nums.end()); vector<int> res; for (int i = 1; i <= nums.size(); i++) if (!s.count(i)) res.push_back(i); return res; } };"
                }
            },
            "optimized": {
                "intuition": "Mark visited by negating.",
                "algorithm": "Use array as storage",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)"
                },
                "code": {
                    "python": "class Solution:\n    def findDisappearedNumbers(self, nums):\n        for num in nums:\n            idx = abs(num) - 1\n            nums[idx] = -abs(nums[idx])\n        return [i + 1 for i in range(len(nums)) if nums[i] > 0]",
                    "java": "class Solution { public List<Integer> findDisappearedNumbers(int[] nums) { for (int n : nums) { int idx = Math.abs(n) - 1; nums[idx] = -Math.abs(nums[idx]); } List<Integer> res = new ArrayList<>(); for (int i = 0; i < nums.length; i++) if (nums[i] > 0) res.add(i + 1); return res; } }",
                    "cpp": "class Solution { public: vector<int> findDisappearedNumbers(vector<int>& nums) { for (int n : nums) { int idx = abs(n) - 1; nums[idx] = -abs(nums[idx]); } vector<int> res; for (int i = 0; i < nums.size(); i++) if (nums[i] > 0) res.push_back(i + 1); return res; } };"
                }
            }
        }
    },
    "find-all-duplicates-in-an-array": {
        "description": "<p>Given an integer array <code>nums</code> of length <code>n</code> where all the integers of <code>nums</code> are in the range <code>[1, n]</code> and each integer appears <strong>once</strong> or <strong>twice</strong>, return <em>an array of all the integers that appears <strong>twice</strong></em>.</p><p>You must write an algorithm that runs in <code>O(n)</code> time and uses only constant extra space.</p><p><strong>Approach:</strong> Similar to finding disappeared numbers, use <strong>negation marking</strong>. For each number, if <code>nums[abs(num) - 1]</code> is already negative, this number is a duplicate. Otherwise, negate it to mark as visited.</p>",
        "examples": [
            {
                "input": "nums = [4,3,2,7,8,2,3,1]",
                "output": "[2,3]",
                "explanation": "2 and 3 appear twice."
            },
            {
                "input": "nums = [1,1,2]",
                "output": "[1]",
                "explanation": "Only 1 appears twice."
            },
            {
                "input": "nums = [1]",
                "output": "[]",
                "explanation": "No duplicates."
            }
        ],
        "constraints": [
            "<code>n == nums.length</code>",
            "<code>1 <= n <= 10<sup>5</sup></code>",
            "<code>1 <= nums[i] <= n</code>",
            "<code>Each element in nums appears once or twice</code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "Use hash map.",
                "algorithm": "Count occurrences",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(n)"
                },
                "code": {
                    "python": "class Solution:\n    def findDuplicates(self, nums):\n        from collections import Counter\n        return [n for n, c in Counter(nums).items() if c == 2]",
                    "java": "class Solution { public List<Integer> findDuplicates(int[] nums) { Map<Integer, Integer> count = new HashMap<>(); for (int n : nums) count.put(n, count.getOrDefault(n, 0) + 1); List<Integer> res = new ArrayList<>(); for (int n : count.keySet()) if (count.get(n) == 2) res.add(n); return res; } }",
                    "cpp": "class Solution { public: vector<int> findDuplicates(vector<int>& nums) { unordered_map<int, int> count; for (int n : nums) count[n]++; vector<int> res; for (auto& [n, c] : count) if (c == 2) res.push_back(n); return res; } };"
                }
            },
            "optimized": {
                "intuition": "Negate visited indices.",
                "algorithm": "Use array as hash map",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)"
                },
                "code": {
                    "python": "class Solution:\n    def findDuplicates(self, nums):\n        result = []\n        for num in nums:\n            idx = abs(num) - 1\n            if nums[idx] < 0:\n                result.append(abs(num))\n            else:\n                nums[idx] = -nums[idx]\n        return result",
                    "java": "class Solution { public List<Integer> findDuplicates(int[] nums) { List<Integer> res = new ArrayList<>(); for (int n : nums) { int idx = Math.abs(n) - 1; if (nums[idx] < 0) res.add(Math.abs(n)); else nums[idx] = -nums[idx]; } return res; } }",
                    "cpp": "class Solution { public: vector<int> findDuplicates(vector<int>& nums) { vector<int> res; for (int n : nums) { int idx = abs(n) - 1; if (nums[idx] < 0) res.push_back(abs(n)); else nums[idx] = -nums[idx]; } return res; } };"
                }
            }
        }
    },
    "can-place-flowers": {
        "description": "<p>You have a long flowerbed in which some of the plots are planted, and some are not. However, flowers cannot be planted in <strong>adjacent</strong> plots.</p><p>Given an integer array <code>flowerbed</code> containing <code>0</code>'s and <code>1</code>'s, where <code>0</code> means empty and <code>1</code> means not empty, and an integer <code>n</code>, return <code>true</code> <em>if <code>n</code> new flowers can be planted in the <code>flowerbed</code> without violating the no-adjacent-flowers rule and <code>false</code> otherwise</em>.</p><p><strong>Approach:</strong> Use <strong>greedy placement</strong>. For each empty plot, check if both neighbors (or boundaries) are empty. If so, plant a flower there and increment count. Return true if count >= n.</p>",
        "examples": [
            {
                "input": "flowerbed = [1,0,0,0,1], n = 1",
                "output": "true",
                "explanation": "Can plant one flower at index 2."
            },
            {
                "input": "flowerbed = [1,0,0,0,1], n = 2",
                "output": "false",
                "explanation": "Can only plant one flower."
            },
            {
                "input": "flowerbed = [0,0,1,0,0], n = 1",
                "output": "true",
                "explanation": "Can plant at index 0 or 4."
            }
        ],
        "constraints": [
            "<code>1 <= flowerbed.length <= 2 * 10<sup>4</sup></code>",
            "<code>flowerbed[i] is 0 or 1</code>",
            "<code>There are no two adjacent flowers in flowerbed</code>",
            "<code>0 <= n <= flowerbed.length</code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "Check each position.",
                "algorithm": "Greedy placement",
                "complexity": {
                    "time": "O(m)",
                    "space": "O(1)"
                },
                "code": {
                    "python": "class Solution:\n    def canPlaceFlowers(self, flowerbed, n):\n        count = 0\n        for i in range(len(flowerbed)):\n            if flowerbed[i] == 0:\n                left = i == 0 or flowerbed[i - 1] == 0\n                right = i == len(flowerbed) - 1 or flowerbed[i + 1] == 0\n                if left and right:\n                    flowerbed[i] = 1\n                    count += 1\n        return count >= n",
                    "java": "class Solution { public boolean canPlaceFlowers(int[] bed, int n) { int count = 0; for (int i = 0; i < bed.length; i++) { if (bed[i] == 0) { boolean left = i == 0 || bed[i - 1] == 0; boolean right = i == bed.length - 1 || bed[i + 1] == 0; if (left && right) { bed[i] = 1; count++; } } } return count >= n; } }",
                    "cpp": "class Solution { public: bool canPlaceFlowers(vector<int>& bed, int n) { int count = 0; for (int i = 0; i < bed.size(); i++) { if (bed[i] == 0) { bool left = i == 0 || bed[i - 1] == 0; bool right = i == bed.size() - 1 || bed[i + 1] == 0; if (left && right) { bed[i] = 1; count++; } } } return count >= n; } };"
                }
            },
            "optimized": {
                "intuition": "Same greedy approach.",
                "algorithm": "Early exit when count >= n",
                "complexity": {
                    "time": "O(m)",
                    "space": "O(1)"
                },
                "code": {
                    "python": "class Solution:\n    def canPlaceFlowers(self, flowerbed, n):\n        count = 0\n        m = len(flowerbed)\n        for i in range(m):\n            if flowerbed[i] == 0:\n                left = i == 0 or flowerbed[i - 1] == 0\n                right = i == m - 1 or flowerbed[i + 1] == 0\n                if left and right:\n                    flowerbed[i] = 1\n                    count += 1\n                    if count >= n: return True\n        return count >= n",
                    "java": "class Solution { public boolean canPlaceFlowers(int[] bed, int n) { int count = 0, m = bed.length; for (int i = 0; i < m; i++) { if (bed[i] == 0) { boolean left = i == 0 || bed[i - 1] == 0; boolean right = i == m - 1 || bed[i + 1] == 0; if (left && right) { bed[i] = 1; count++; if (count >= n) return true; } } } return count >= n; } }",
                    "cpp": "class Solution { public: bool canPlaceFlowers(vector<int>& bed, int n) { int count = 0, m = bed.size(); for (int i = 0; i < m; i++) { if (bed[i] == 0) { bool left = i == 0 || bed[i - 1] == 0; bool right = i == m - 1 || bed[i + 1] == 0; if (left && right) { bed[i] = 1; count++; if (count >= n) return true; } } } return count >= n; } };"
                }
            }
        }
    },
    "product-of-array-except-self": {
        "description": "<p>Given an integer array <code>nums</code>, return <em>an array <code>answer</code> such that <code>answer[i]</code> is equal to the product of all the elements of <code>nums</code> except <code>nums[i]</code></em>.</p><p>The product of any prefix or suffix of <code>nums</code> is <strong>guaranteed</strong> to fit in a <strong>32-bit</strong> integer.</p><p>You must write an algorithm that runs in <code>O(n)</code> time and <strong>without using the division operation</strong>.</p><p><strong>Approach:</strong> Use <strong>prefix and suffix products</strong>. First pass: store prefix product (product of all elements before <code>i</code>) in <code>result[i]</code>. Second pass: multiply each <code>result[i]</code> by suffix product (product of all elements after <code>i</code>). This achieves O(n) time and O(1) extra space (output array doesn't count).</p>",
        "examples": [
            {
                "input": "nums = [1,2,3,4]",
                "output": "[24,12,8,6]",
                "explanation": "Product except self: [2*3*4, 1*3*4, 1*2*4, 1*2*3] = [24,12,8,6]."
            },
            {
                "input": "nums = [-1,1,0,-3,3]",
                "output": "[0,0,9,0,0]",
                "explanation": "Each position's product includes the 0."
            },
            {
                "input": "nums = [2,3]",
                "output": "[3,2]",
                "explanation": "Simple two-element case."
            }
        ],
        "constraints": [
            "<code>2 <= nums.length <= 10<sup>5</sup></code>",
            "<code>-30 <= nums[i] <= 30</code>",
            "<code>The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer</code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "Compute product for each position.",
                "algorithm": "O(n¬≤) nested loop",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(1)"
                },
                "code": {
                    "python": "class Solution:\n    def productExceptSelf(self, nums):\n        n = len(nums)\n        result = []\n        for i in range(n):\n            prod = 1\n            for j in range(n):\n                if i != j:\n                    prod *= nums[j]\n            result.append(prod)\n        return result",
                    "java": "class Solution { public int[] productExceptSelf(int[] nums) { int n = nums.length; int[] res = new int[n]; for (int i = 0; i < n; i++) { int prod = 1; for (int j = 0; j < n; j++) if (i != j) prod *= nums[j]; res[i] = prod; } return res; } }",
                    "cpp": "class Solution { public: vector<int> productExceptSelf(vector<int>& nums) { int n = nums.size(); vector<int> res(n); for (int i = 0; i < n; i++) { int prod = 1; for (int j = 0; j < n; j++) if (i != j) prod *= nums[j]; res[i] = prod; } return res; } };"
                }
            },
            "optimized": {
                "intuition": "Prefix and suffix products.",
                "algorithm": "Two passes",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)"
                },
                "code": {
                    "python": "class Solution:\n    def productExceptSelf(self, nums):\n        n = len(nums)\n        result = [1] * n\n        prefix = 1\n        for i in range(n):\n            result[i] = prefix\n            prefix *= nums[i]\n        suffix = 1\n        for i in range(n - 1, -1, -1):\n            result[i] *= suffix\n            suffix *= nums[i]\n        return result",
                    "java": "class Solution { public int[] productExceptSelf(int[] nums) { int n = nums.length; int[] res = new int[n]; int prefix = 1; for (int i = 0; i < n; i++) { res[i] = prefix; prefix *= nums[i]; } int suffix = 1; for (int i = n - 1; i >= 0; i--) { res[i] *= suffix; suffix *= nums[i]; } return res; } }",
                    "cpp": "class Solution { public: vector<int> productExceptSelf(vector<int>& nums) { int n = nums.size(); vector<int> res(n, 1); int prefix = 1; for (int i = 0; i < n; i++) { res[i] = prefix; prefix *= nums[i]; } int suffix = 1; for (int i = n - 1; i >= 0; i--) { res[i] *= suffix; suffix *= nums[i]; } return res; } };"
                }
            }
        }
    },
    "find-peak-element": {
        "description": "<p>A peak element is an element that is strictly greater than its neighbors.</p><p>Given a <strong>0-indexed</strong> integer array <code>nums</code>, find a peak element, and return its index. If the array contains multiple peaks, return the index to <strong>any of the peaks</strong>.</p><p>You may imagine that <code>nums[-1] = nums[n] = -‚àû</code>. In other words, an element is always considered to be strictly greater than a neighbor that is outside the array.</p><p>You must write an algorithm that runs in <code>O(log n)</code> time.</p><p><strong>Approach:</strong> Use <strong>binary search</strong>. At mid, if <code>nums[mid] > nums[mid+1]</code>, peak is on left side (or mid itself). Otherwise, peak is on right side. Always move towards the higher neighbor.</p>",
        "examples": [
            {
                "input": "nums = [1,2,3,1]",
                "output": "2",
                "explanation": "3 is a peak element at index 2."
            },
            {
                "input": "nums = [1,2,1,3,5,6,4]",
                "output": "5",
                "explanation": "6 is a peak element at index 5 (or return 1 for element 2)."
            },
            {
                "input": "nums = [1]",
                "output": "0",
                "explanation": "Single element is always a peak."
            }
        ],
        "constraints": [
            "<code>1 <= nums.length <= 1000</code>",
            "<code>-2<sup>31</sup> <= nums[i] <= 2<sup>31</sup> - 1</code>",
            "<code>nums[i] != nums[i + 1] for all valid i</code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "Linear scan.",
                "algorithm": "Find first decrease",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)"
                },
                "code": {
                    "python": "class Solution:\n    def findPeakElement(self, nums):\n        for i in range(len(nums) - 1):\n            if nums[i] > nums[i + 1]:\n                return i\n        return len(nums) - 1",
                    "java": "class Solution { public int findPeakElement(int[] nums) { for (int i = 0; i < nums.length - 1; i++) if (nums[i] > nums[i + 1]) return i; return nums.length - 1; } }",
                    "cpp": "class Solution { public: int findPeakElement(vector<int>& nums) { for (int i = 0; i < nums.size() - 1; i++) if (nums[i] > nums[i + 1]) return i; return nums.size() - 1; } };"
                }
            },
            "optimized": {
                "intuition": "Binary search.",
                "algorithm": "Move towards higher neighbor",
                "complexity": {
                    "time": "O(log n)",
                    "space": "O(1)"
                },
                "code": {
                    "python": "class Solution:\n    def findPeakElement(self, nums):\n        l, r = 0, len(nums) - 1\n        while l < r:\n            m = (l + r) // 2\n            if nums[m] > nums[m + 1]:\n                r = m\n            else:\n                l = m + 1\n        return l",
                    "java": "class Solution { public int findPeakElement(int[] nums) { int l = 0, r = nums.length - 1; while (l < r) { int m = (l + r) / 2; if (nums[m] > nums[m + 1]) r = m; else l = m + 1; } return l; } }",
                    "cpp": "class Solution { public: int findPeakElement(vector<int>& nums) { int l = 0, r = nums.size() - 1; while (l < r) { int m = (l + r) / 2; if (nums[m] > nums[m + 1]) r = m; else l = m + 1; } return l; } };"
                }
            }
        }
    },
    "search-a-2d-matrix": {
        "description": `<p>You are given an <code>m x n</code> integer matrix <code>matrix</code> with the following two properties:</p>
<ul>
<li>Each row is sorted in non-decreasing order.</li>
<li>The first integer of each row is greater than the last integer of the previous row.</li>
</ul>
<p>Given an integer <code>target</code>, return <code>true</code> <em>if</em> <code>target</code> <em>is in</em> <code>matrix</code> <em>or</em> <code>false</code> <em>otherwise</em>.</p>
<p>You must write a solution in <strong>O(log(m * n))</strong> time complexity.</p>
<p>The key insight is that this matrix can be treated as a single sorted array (because of the two properties). We can perform binary search on it by converting a 1D index back to 2D coordinates: <code>row = mid / n</code> and <code>col = mid % n</code>.</p>`,
        "examples": [
            {
                "input": "matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3",
                "output": "true",
                "explanation": "3 is found in the matrix at position [0][1]."
            },
            {
                "input": "matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13",
                "output": "false",
                "explanation": "13 is not in the matrix."
            },
            {
                "input": "matrix = [[1]], target = 1",
                "output": "true",
                "explanation": "Single element matrix containing the target."
            }
        ],
        "constraints": [
            "<code>m == matrix.length</code>",
            "<code>n == matrix[i].length</code>",
            "<code>1 <= m, n <= 100</code>",
            "<code>-10<sup>4</sup> <= matrix[i][j], target <= 10<sup>4</sup></code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "Linear search.",
                "algorithm": "Check all elements",
                "complexity": {
                    "time": "O(mn)",
                    "space": "O(1)"
                },
                "code": {
                    "python": "class Solution:\n    def searchMatrix(self, matrix, target):\n        for row in matrix:\n            if target in row:\n                return True\n        return False",
                    "java": "class Solution { public boolean searchMatrix(int[][] matrix, int target) { for (int[] row : matrix) for (int val : row) if (val == target) return true; return false; } }",
                    "cpp": "class Solution { public: bool searchMatrix(vector<vector<int>>& matrix, int target) { for (auto& row : matrix) for (int val : row) if (val == target) return true; return false; } };"
                }
            },
            "optimized": {
                "intuition": "Treat as 1D sorted array.",
                "algorithm": "Binary search",
                "complexity": {
                    "time": "O(log(mn))",
                    "space": "O(1)"
                },
                "code": {
                    "python": "class Solution:\n    def searchMatrix(self, matrix, target):\n        m, n = len(matrix), len(matrix[0])\n        l, r = 0, m * n - 1\n        while l <= r:\n            mid = (l + r) // 2\n            val = matrix[mid // n][mid % n]\n            if val == target: return True\n            elif val < target: l = mid + 1\n            else: r = mid - 1\n        return False",
                    "java": "class Solution { public boolean searchMatrix(int[][] matrix, int target) { int m = matrix.length, n = matrix[0].length; int l = 0, r = m * n - 1; while (l <= r) { int mid = (l + r) / 2; int val = matrix[mid / n][mid % n]; if (val == target) return true; else if (val < target) l = mid + 1; else r = mid - 1; } return false; } }",
                    "cpp": "class Solution { public: bool searchMatrix(vector<vector<int>>& matrix, int target) { int m = matrix.size(), n = matrix[0].size(); int l = 0, r = m * n - 1; while (l <= r) { int mid = (l + r) / 2; int val = matrix[mid / n][mid % n]; if (val == target) return true; else if (val < target) l = mid + 1; else r = mid - 1; } return false; } };"
                }
            }
        }
    },
    "search-a-2d-matrix-ii": {
        "description": `<p>Write an efficient algorithm that searches for a value <code>target</code> in an <code>m x n</code> integer matrix <code>matrix</code>. This matrix has the following properties:</p><ul><li>Integers in each row are sorted in ascending from left to right.</li><li>Integers in each column are sorted in ascending from top to bottom.</li></ul><p>Unlike Search a 2D Matrix I, the first element of a row is NOT necessarily greater than the last element of the previous row. This means we cannot treat the matrix as a single sorted array.</p><p><strong>Key Insight:</strong> Start from the <strong>top-right corner</strong> (or bottom-left). At position (r, c), if <code>matrix[r][c] > target</code>, we can eliminate the entire column c (move left). If <code>matrix[r][c] < target</code>, we can eliminate the entire row r (move down). This creates a staircase search pattern in O(m+n) time.</p>`,
        "examples": [
            {
                "input": "matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5",
                "output": "true",
                "explanation": "Starting from top-right (15): 15>5, go left. 11>5, go left. 7>5, go left. 4<5, go down. 5==5, found!"
            },
            {
                "input": "matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20",
                "output": "false",
                "explanation": "Following the staircase search, we never find 20 in the matrix."
            },
            {
                "input": "matrix = [[5]], target = 5",
                "output": "true",
                "explanation": "Single element matrix containing the target."
            }
        ],
        "constraints": [
            "<code>m == matrix.length</code>",
            "<code>n == matrix[i].length</code>",
            "<code>1 <= n, m <= 300</code>",
            "<code>-10<sup>9</sup> <= matrix[i][j] <= 10<sup>9</sup></code>",
            "<code>-10<sup>9</sup> <= target <= 10<sup>9</sup></code>",
            "All integers in each row are sorted in ascending order.",
            "All integers in each column are sorted in ascending order."
        ],
        "solutions": {
            "brute": {
                "intuition": "Linear search.",
                "algorithm": "Check all elements",
                "complexity": {
                    "time": "O(mn)",
                    "space": "O(1)"
                },
                "code": {
                    "python": "class Solution:\n    def searchMatrix(self, matrix, target):\n        for row in matrix:\n            if target in row:\n                return True\n        return False",
                    "java": "class Solution { public boolean searchMatrix(int[][] matrix, int target) { for (int[] row : matrix) for (int val : row) if (val == target) return true; return false; } }",
                    "cpp": "class Solution { public: bool searchMatrix(vector<vector<int>>& matrix, int target) { for (auto& row : matrix) for (int val : row) if (val == target) return true; return false; } };"
                }
            },
            "optimized": {
                "intuition": "Start from top-right.",
                "algorithm": "Staircase search",
                "complexity": {
                    "time": "O(m+n)",
                    "space": "O(1)"
                },
                "code": {
                    "python": "class Solution:\n    def searchMatrix(self, matrix, target):\n        m, n = len(matrix), len(matrix[0])\n        row, col = 0, n - 1\n        while row < m and col >= 0:\n            if matrix[row][col] == target:\n                return True\n            elif matrix[row][col] > target:\n                col -= 1\n            else:\n                row += 1\n        return False",
                    "java": "class Solution { public boolean searchMatrix(int[][] matrix, int target) { int m = matrix.length, n = matrix[0].length; int row = 0, col = n - 1; while (row < m && col >= 0) { if (matrix[row][col] == target) return true; else if (matrix[row][col] > target) col--; else row++; } return false; } }",
                    "cpp": "class Solution { public: bool searchMatrix(vector<vector<int>>& matrix, int target) { int m = matrix.size(), n = matrix[0].size(); int row = 0, col = n - 1; while (row < m && col >= 0) { if (matrix[row][col] == target) return true; else if (matrix[row][col] > target) col--; else row++; } return false; } };"
                }
            }
        }
    },
    "sort-colors": {
        "description": `<p>Given an array <code>nums</code> with <code>n</code> objects colored red, white, or blue, sort them <strong>in-place</strong> so that objects of the same color are adjacent, with the colors in the order red, white, and blue.</p><p>We will use the integers <code>0</code>, <code>1</code>, and <code>2</code> to represent the color red, white, and blue, respectively.</p><p>You must solve this problem without using the library's sort function.</p><p><strong>Approach:</strong> The optimal solution uses the <strong>Dutch National Flag algorithm</strong> with three pointers: <code>low</code>, <code>mid</code>, and <code>high</code>. Elements before <code>low</code> are 0s, between <code>low</code> and <code>mid</code> are 1s, and after <code>high</code> are 2s. When we encounter 0, swap with <code>low</code> and advance both. For 2, swap with <code>high</code> and decrement <code>high</code>. For 1, just advance <code>mid</code>.</p>`,
        "examples": [
            {
                "input": "nums = [2,0,2,1,1,0]",
                "output": "[0,0,1,1,2,2]",
                "explanation": "After sorting, all 0s come first, then 1s, then 2s."
            },
            {
                "input": "nums = [2,0,1]",
                "output": "[0,1,2]",
                "explanation": "Simple case with one of each color."
            },
            {
                "input": "nums = [0]",
                "output": "[0]",
                "explanation": "Single element array."
            }
        ],
        "constraints": [
            "<code>n == nums.length</code>",
            "<code>1 <= n <= 300</code>",
            "<code>nums[i]</code> is either <code>0</code>, <code>1</code>, or <code>2</code>."
        ],
        "solutions": {
            "brute": {
                "intuition": "Count and overwrite.",
                "algorithm": "Count 0s, 1s, 2s",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)"
                },
                "code": {
                    "python": "class Solution:\n    def sortColors(self, nums):\n        count = [0, 0, 0]\n        for n in nums: count[n] += 1\n        idx = 0\n        for c in range(3):\n            for _ in range(count[c]):\n                nums[idx] = c\n                idx += 1",
                    "java": "class Solution { public void sortColors(int[] nums) { int[] count = new int[3]; for (int n : nums) count[n]++; int idx = 0; for (int c = 0; c < 3; c++) for (int i = 0; i < count[c]; i++) nums[idx++] = c; } }",
                    "cpp": "class Solution { public: void sortColors(vector<int>& nums) { int count[3] = {}; for (int n : nums) count[n]++; int idx = 0; for (int c = 0; c < 3; c++) for (int i = 0; i < count[c]; i++) nums[idx++] = c; } };"
                }
            },
            "optimized": {
                "intuition": "Dutch National Flag.",
                "algorithm": "Three pointers",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)"
                },
                "code": {
                    "python": "class Solution:\n    def sortColors(self, nums):\n        low, mid, high = 0, 0, len(nums) - 1\n        while mid <= high:\n            if nums[mid] == 0:\n                nums[low], nums[mid] = nums[mid], nums[low]\n                low += 1\n                mid += 1\n            elif nums[mid] == 1:\n                mid += 1\n            else:\n                nums[mid], nums[high] = nums[high], nums[mid]\n                high -= 1",
                    "java": "class Solution { public void sortColors(int[] nums) { int low = 0, mid = 0, high = nums.length - 1; while (mid <= high) { if (nums[mid] == 0) { int t = nums[low]; nums[low] = nums[mid]; nums[mid] = t; low++; mid++; } else if (nums[mid] == 1) { mid++; } else { int t = nums[mid]; nums[mid] = nums[high]; nums[high] = t; high--; } } } }",
                    "cpp": "class Solution { public: void sortColors(vector<int>& nums) { int low = 0, mid = 0, high = nums.size() - 1; while (mid <= high) { if (nums[mid] == 0) swap(nums[low++], nums[mid++]); else if (nums[mid] == 1) mid++; else swap(nums[mid], nums[high--]); } } };"
                }
            }
        }
    },
    "majority-element": {
        "description": `<p>Given an array <code>nums</code> of size <code>n</code>, return <em>the majority element</em>.</p><p>The majority element is the element that appears <strong>more than ‚åän / 2‚åã times</strong>. You may assume that the majority element always exists in the array.</p><p><strong>Optimal Approach:</strong> Use the <strong>Boyer-Moore Voting Algorithm</strong>. The key insight is that the majority element appears more than n/2 times, so it will survive a voting process. We maintain a candidate and a count. When count becomes 0, we switch candidates. The final candidate is guaranteed to be the majority element (if one exists).</p><p>The algorithm works because if we pair each majority element with a non-majority element and eliminate both, the majority element will still remain at the end since it appears more than half the time.</p>`,
        "examples": [
            {
                "input": "nums = [3,2,3]",
                "output": "3",
                "explanation": "3 appears 2 times out of 3, which is more than ‚åä3/2‚åã = 1."
            },
            {
                "input": "nums = [2,2,1,1,1,2,2]",
                "output": "2",
                "explanation": "2 appears 4 times out of 7, which is more than ‚åä7/2‚åã = 3."
            },
            {
                "input": "nums = [1]",
                "output": "1",
                "explanation": "Single element is always the majority."
            }
        ],
        "constraints": [
            "<code>n == nums.length</code>",
            "<code>1 <= n <= 5 * 10<sup>4</sup></code>",
            "<code>-10<sup>9</sup> <= nums[i] <= 10<sup>9</sup></code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "Count occurrences.",
                "algorithm": "Hash map counting",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(n)"
                },
                "code": {
                    "python": "class Solution:\n    def majorityElement(self, nums):\n        from collections import Counter\n        count = Counter(nums)\n        return max(count, key=count.get)",
                    "java": "class Solution { public int majorityElement(int[] nums) { Map<Integer, Integer> count = new HashMap<>(); for (int n : nums) count.put(n, count.getOrDefault(n, 0) + 1); int majority = nums[0], maxCount = 0; for (Map.Entry<Integer, Integer> e : count.entrySet()) { if (e.getValue() > maxCount) { maxCount = e.getValue(); majority = e.getKey(); } } return majority; } }",
                    "cpp": "class Solution { public: int majorityElement(vector<int>& nums) { unordered_map<int, int> count; for (int n : nums) count[n]++; int majority = nums[0], maxCount = 0; for (auto& [n, c] : count) { if (c > maxCount) { maxCount = c; majority = n; } } return majority; } };"
                }
            },
            "optimized": {
                "intuition": "Boyer-Moore Voting.",
                "algorithm": "Track candidate",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)"
                },
                "code": {
                    "python": "class Solution:\n    def majorityElement(self, nums):\n        candidate, count = None, 0\n        for num in nums:\n            if count == 0:\n                candidate = num\n            count += 1 if num == candidate else -1\n        return candidate",
                    "java": "class Solution { public int majorityElement(int[] nums) { int candidate = 0, count = 0; for (int n : nums) { if (count == 0) candidate = n; count += (n == candidate) ? 1 : -1; } return candidate; } }",
                    "cpp": "class Solution { public: int majorityElement(vector<int>& nums) { int candidate = 0, count = 0; for (int n : nums) { if (count == 0) candidate = n; count += (n == candidate) ? 1 : -1; } return candidate; } };"
                }
            }
        }
    },
    "majority-element-ii": {
        "description": `<p>Given an integer array of size <code>n</code>, find all elements that appear more than <code>‚åän / 3‚åã</code> times.</p><p><strong>Key Insight:</strong> There can be <strong>at most 2 elements</strong> that appear more than n/3 times. (If there were 3 or more such elements, their combined count would exceed n, which is impossible.)</p><p><strong>Optimal Approach:</strong> Extend Boyer-Moore Voting Algorithm to track <strong>two candidates</strong>. In the first pass, we identify potential candidates using the voting mechanism. In the second pass, we verify that these candidates actually appear more than n/3 times.</p><p>The voting works with two counters. When we see a number matching candidate1 or candidate2, increment its counter. When both counters are non-zero and we see a different number, decrement both counters. This ensures the most frequent elements survive.</p>`,
        "examples": [
            {
                "input": "nums = [3,2,3]",
                "output": "[3]",
                "explanation": "3 appears 2 times out of 3, which is more than ‚åä3/3‚åã = 1."
            },
            {
                "input": "nums = [1]",
                "output": "[1]",
                "explanation": "Single element always appears more than n/3 times."
            },
            {
                "input": "nums = [1,2]",
                "output": "[1,2]",
                "explanation": "Both elements appear 1 time out of 2, which is more than ‚åä2/3‚åã = 0."
            }
        ],
        "constraints": [
            "<code>1 <= nums.length <= 5 * 10<sup>4</sup></code>",
            "<code>-10<sup>9</sup> <= nums[i] <= 10<sup>9</sup></code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "Count all elements.",
                "algorithm": "Hash map",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(n)"
                },
                "code": {
                    "python": "class Solution:\n    def majorityElement(self, nums):\n        from collections import Counter\n        n = len(nums)\n        return [x for x, c in Counter(nums).items() if c > n // 3]",
                    "java": "class Solution { public List<Integer> majorityElement(int[] nums) { Map<Integer, Integer> count = new HashMap<>(); for (int n : nums) count.put(n, count.getOrDefault(n, 0) + 1); List<Integer> res = new ArrayList<>(); for (int n : count.keySet()) if (count.get(n) > nums.length / 3) res.add(n); return res; } }",
                    "cpp": "class Solution { public: vector<int> majorityElement(vector<int>& nums) { unordered_map<int, int> count; for (int n : nums) count[n]++; vector<int> res; for (auto& [n, c] : count) if (c > nums.size() / 3) res.push_back(n); return res; } };"
                }
            },
            "optimized": {
                "intuition": "Boyer-Moore with 2 candidates.",
                "algorithm": "At most 2 elements > n/3",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)"
                },
                "code": {
                    "python": "class Solution:\n    def majorityElement(self, nums):\n        c1 = c2 = 0\n        n1 = n2 = None\n        for num in nums:\n            if num == n1:\n                c1 += 1\n            elif num == n2:\n                c2 += 1\n            elif c1 == 0:\n                n1, c1 = num, 1\n            elif c2 == 0:\n                n2, c2 = num, 1\n            else:\n                c1 -= 1\n                c2 -= 1\n        return [x for x in [n1, n2] if nums.count(x) > len(nums) // 3]",
                    "java": "class Solution { public List<Integer> majorityElement(int[] nums) { int c1 = 0, c2 = 0, n1 = 0, n2 = 1; for (int n : nums) { if (n == n1) c1++; else if (n == n2) c2++; else if (c1 == 0) { n1 = n; c1 = 1; } else if (c2 == 0) { n2 = n; c2 = 1; } else { c1--; c2--; } } c1 = c2 = 0; for (int n : nums) { if (n == n1) c1++; else if (n == n2) c2++; } List<Integer> res = new ArrayList<>(); if (c1 > nums.length / 3) res.add(n1); if (c2 > nums.length / 3) res.add(n2); return res; } }",
                    "cpp": "class Solution { public: vector<int> majorityElement(vector<int>& nums) { int c1 = 0, c2 = 0, n1 = 0, n2 = 1; for (int n : nums) { if (n == n1) c1++; else if (n == n2) c2++; else if (c1 == 0) { n1 = n; c1 = 1; } else if (c2 == 0) { n2 = n; c2 = 1; } else { c1--; c2--; } } c1 = c2 = 0; for (int n : nums) { if (n == n1) c1++; else if (n == n2) c2++; } vector<int> res; if (c1 > nums.size() / 3) res.push_back(n1); if (c2 > nums.size() / 3) res.push_back(n2); return res; } };"
                }
            }
        }
    },
    "container-with-most-water": {
        description: `<p>You are given an integer array <code>height</code> of length <code>n</code>. There are <code>n</code> vertical lines drawn such that the two endpoints of the <code>i<sup>th</sup></code> line are <code>(i, 0)</code> and <code>(i, height[i])</code>.</p>
<p>Find two lines that together with the x-axis form a container, such that the container contains the most water. Return <em>the maximum amount of water a container can store</em>.</p>
<p><strong>Notice</strong> that you may not slant the container. The water level is determined by the shorter of the two lines, and the width is the distance between them. For example, if you have lines at positions 1 and 8 with heights 7 and 3 respectively, the water level is limited to 3 (the shorter line), and the width is 7 (distance between positions).</p>
<p>The key insight is that while we want to maximize width, we're also constrained by height. A wider container with very short lines might hold less water than a narrower container with taller lines. The two-pointer technique helps us efficiently explore this trade-off.</p>`,
        examples: [
            {
                input: "height = [1,8,6,2,5,4,8,3,7]",
                output: "49",
                explanation: `The vertical lines are at positions 0-8 with heights [1,8,6,2,5,4,8,3,7].
The optimal container is formed between index 1 (height=8) and index 8 (height=7).
Area = min(8, 7) * (8 - 1) = 7 * 7 = 49.

This is the maximum possible area among all pairs of lines.`
            },
            {
                input: "height = [1,1]",
                output: "1",
                explanation: "The only two lines form a container with area = min(1,1) * (1-0) = 1 * 1 = 1."
            },
            {
                input: "height = [4,3,2,1,4]",
                output: "16",
                explanation: `The best container is between index 0 (height=4) and index 4 (height=4).
Area = min(4, 4) * (4 - 0) = 4 * 4 = 16.`
            },
            {
                input: "height = [1,2,1]",
                output: "2",
                explanation: "The best container is between index 0 and index 2: min(1,1) * 2 = 2."
            }
        ],
        constraints: [
            "<code>n == height.length</code>",
            "<code>2 <= n <= 10<sup>5</sup></code>",
            "<code>0 <= height[i] <= 10<sup>4</sup></code>"
        ],
        solutions: {
            brute: {
                intuition: "The brute force approach checks every possible pair of lines to find the maximum area. For each pair (i, j), we calculate the area as the minimum height times the distance between them, keeping track of the maximum area found.",
                algorithm: [
                    "Initialize maxArea to 0",
                    "Use nested loops to check all pairs (i, j) where i < j",
                    "For each pair, calculate width = j - i",
                    "Calculate area = min(height[i], height[j]) * width",
                    "Update maxArea if current area is larger",
                    "Return maxArea after checking all pairs"
                ],
                complexity: {
                    time: "O(n¬≤) where n is the length of the array. We check every possible pair of lines, which requires two nested loops.",
                    space: "O(1) as we only use a constant amount of extra space to store variables like maxArea and current area."
                },
                code: {
                    python: `def maxArea(height):
    n = len(height)
    max_area = 0
    
    # Check all possible pairs
    for i in range(n):
        for j in range(i + 1, n):
            # Calculate area for this pair
            width = j - i
            h = min(height[i], height[j])
            area = h * width
            max_area = max(max_area, area)
    
    return max_area`,
                    java: `class Solution {
    public int maxArea(int[] height) {
        int n = height.length;
        int maxArea = 0;
        
        // Check all possible pairs
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                // Calculate area for this pair
                int width = j - i;
                int h = Math.min(height[i], height[j]);
                int area = h * width;
                maxArea = Math.max(maxArea, area);
            }
        }
        
        return maxArea;
    }
}`,
                    cpp: `class Solution {
public:
    int maxArea(vector<int>& height) {
        int n = height.size();
        int maxArea = 0;
        
        // Check all possible pairs
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                // Calculate area for this pair
                int width = j - i;
                int h = min(height[i], height[j]);
                int area = h * width;
                maxArea = max(maxArea, area);
            }
        }
        
        return maxArea;
    }
};`,
                    javascript: `function maxArea(height) {
    const n = height.length;
    let maxArea = 0;
    
    // Check all possible pairs
    for (let i = 0; i < n; i++) {
        for (let j = i + 1; j < n; j++) {
            // Calculate area for this pair
            const width = j - i;
            const h = Math.min(height[i], height[j]);
            const area = h * width;
            maxArea = Math.max(maxArea, area);
        }
    }
    
    return maxArea;
}`
                }
            },
            optimized: {
                intuition: "Use two pointers starting at both ends. The key insight is that moving the pointer at the shorter line inward might find a taller line, potentially increasing the area. Moving the taller line inward will only decrease the area since we lose width and can't increase the height limit.",
                algorithm: [
                    "Initialize two pointers: left at 0, right at n-1",
                    "Initialize maxArea to 0",
                    "While left < right:",
                    "  Calculate current area = min(height[left], height[right]) * (right - left)",
                    "  Update maxArea if current area is larger",
                    "  If height[left] < height[right], move left pointer right (left++)",
                    "  Otherwise, move right pointer left (right--)",
                    "Return maxArea"
                ],
                complexity: {
                    time: "O(n) where n is the length of the array. Each pointer moves at most n times, and we process each element once.",
                    space: "O(1) as we only use two pointers and a few variables, regardless of input size."
                },
                code: {
                    python: `def maxArea(height):
    left, right = 0, len(height) - 1
    max_area = 0
    
    while left < right:
        # Calculate current area
        width = right - left
        h = min(height[left], height[right])
        area = h * width
        max_area = max(max_area, area)
        
        # Move the pointer at the shorter line
        if height[left] < height[right]:
            left += 1
        else:
            right -= 1
    
    return max_area`,
                    java: `class Solution {
    public int maxArea(int[] height) {
        int left = 0, right = height.length - 1;
        int maxArea = 0;
        
        while (left < right) {
            // Calculate current area
            int width = right - left;
            int h = Math.min(height[left], height[right]);
            int area = h * width;
            maxArea = Math.max(maxArea, area);
            
            // Move the pointer at the shorter line
            if (height[left] < height[right]) {
                left++;
            } else {
                right--;
            }
        }
        
        return maxArea;
    }
}`,
                    cpp: `class Solution {
public:
    int maxArea(vector<int>& height) {
        int left = 0, right = height.size() - 1;
        int maxArea = 0;
        
        while (left < right) {
            // Calculate current area
            int width = right - left;
            int h = min(height[left], height[right]);
            int area = h * width;
            maxArea = max(maxArea, area);
            
            // Move the pointer at the shorter line
            if (height[left] < height[right]) {
                left++;
            } else {
                right--;
            }
        }
        
        return maxArea;
    }
};`,
                    javascript: `function maxArea(height) {
    let left = 0, right = height.length - 1;
    let maxArea = 0;
    
    while (left < right) {
        // Calculate current area
        const width = right - left;
        const h = Math.min(height[left], height[right]);
        const area = h * width;
        maxArea = Math.max(maxArea, area);
        
        // Move the pointer at the shorter line
        if (height[left] < height[right]) {
            left++;
        } else {
            right--;
        }
    }
    
    return maxArea;
}`
                }
            }
        }
    },
    "3sum": {
        description: `<p>Given an integer array <code>nums</code>, return all the triplets <code>[nums[i], nums[j], nums[k]]</code> such that <code>i != j</code>, <code>i != k</code>, and <code>j != k</code>, and <code>nums[i] + nums[j] + nums[k] == 0</code>.</p>
<p>Notice that the solution set must not contain duplicate triplets. This is a classic variation of the two-sum problem, extended to find three numbers instead of two. The challenge lies not only in finding the triplets efficiently but also in avoiding duplicates in the result.</p>
<p>A naive approach would check all possible combinations of three numbers, which would be O(n¬≥). However, by sorting the array first and using the two-pointer technique, we can reduce this to O(n¬≤).</p>
<p><strong>Key Insight:</strong> After sorting, we can fix one number and use two pointers to find pairs that sum to the negative of the fixed number. Careful handling of duplicate values is necessary to avoid duplicate triplets in the result.</p>`,
        examples: [
            {
                input: "nums = [-1,0,1,2,-1,-4]",
                output: "[[-1,-1,2],[-1,0,1]]",
                explanation: `After sorting: [-4,-1,-1,0,1,2]

Triplets that sum to 0:
- nums[1] + nums[2] + nums[5] = (-1) + (-1) + 2 = 0
- nums[1] + nums[3] + nums[4] = (-1) + 0 + 1 = 0

Note that we skip duplicate values to avoid returning duplicate triplets like [[-1,0,1], [-1,0,1]].`
            },
            {
                input: "nums = [0,1,1]",
                output: "[]",
                explanation: "There are no triplets that sum to 0. The only triplet [0,1,1] sums to 2, not 0."
            },
            {
                input: "nums = [0,0,0]",
                output: "[[0,0,0]]",
                explanation: "The only possible triplet is [0,0,0], which sums to 0."
            },
            {
                input: "nums = [-2,0,1,1,2]",
                output: "[[-2,0,2],[-2,1,1]]",
                explanation: `Two valid triplets:
- -2 + 0 + 2 = 0
- -2 + 1 + 1 = 0`
            }
        ],
        constraints: [
            "<code>3 <= nums.length <= 3000</code>",
            "<code>-10<sup>5</sup> <= nums[i] <= 10<sup>5</sup></code>"
        ],
        solutions: {
            brute: {
                intuition: "The brute force approach examines every possible combination of three numbers in the array. We use three nested loops to generate all triplets, check if their sum equals zero, and use a set to avoid duplicate triplets. Sorting helps with deduplication.",
                algorithm: [
                    "Sort the array first to handle duplicates easily",
                    "Use three nested loops with indices i, j, k where i < j < k",
                    "For each triplet, check if nums[i] + nums[j] + nums[k] == 0",
                    "Use a set to store unique triplets (avoiding duplicates)",
                    "Convert the set to a list and return the result"
                ],
                complexity: {
                    time: "O(n¬≥) where n is the length of the array. We examine every possible triplet with three nested loops.",
                    space: "O(n) for storing the result set. In the worst case, we might have O(n¬≤) triplets, but typically much fewer."
                },
                code: {
                    python: `def threeSum(nums):
    nums.sort()
    n = len(nums)
    result = set()
    
    # Check all possible triplets
    for i in range(n - 2):
        for j in range(i + 1, n - 1):
            for k in range(j + 1, n):
                if nums[i] + nums[j] + nums[k] == 0:
                    result.add((nums[i], nums[j], nums[k]))
    
    # Convert set of tuples to list of lists
    return [list(triplet) for triplet in result]`,
                    java: `class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums);
        Set<List<Integer>> result = new HashSet<>();
        int n = nums.length;
        
        // Check all possible triplets
        for (int i = 0; i < n - 2; i++) {
            for (int j = i + 1; j < n - 1; j++) {
                for (int k = j + 1; k < n; k++) {
                    if (nums[i] + nums[j] + nums[k] == 0) {
                        result.add(Arrays.asList(nums[i], nums[j], nums[k]));
                    }
                }
            }
        }
        
        return new ArrayList<>(result);
    }
}`,
                    cpp: `class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        set<vector<int>> result;
        int n = nums.size();
        
        // Check all possible triplets
        for (int i = 0; i < n - 2; i++) {
            for (int j = i + 1; j < n - 1; j++) {
                for (int k = j + 1; k < n; k++) {
                    if (nums[i] + nums[j] + nums[k] == 0) {
                        result.insert({nums[i], nums[j], nums[k]});
                    }
                }
            }
        }
        
        return vector<vector<int>>(result.begin(), result.end());
    }
};`,
                    javascript: `function threeSum(nums) {
    nums.sort((a, b) => a - b);
    const result = new Set();
    const n = nums.length;
    
    // Check all possible triplets
    for (let i = 0; i < n - 2; i++) {
        for (let j = i + 1; j < n - 1; j++) {
            for (let k = j + 1; k < n; k++) {
                if (nums[i] + nums[j] + nums[k] === 0) {
                    result.add(JSON.stringify([nums[i], nums[j], nums[k]]));
                }
            }
        }
    }
    
    // Convert set back to array of arrays
    return Array.from(result).map(str => JSON.parse(str));
}`
                }
            },
            optimized: {
                intuition: "Sort the array, then for each number, use two pointers to find pairs that sum to its negative. This reduces the problem to multiple two-sum problems. Skip duplicate values to avoid duplicate triplets, achieving O(n¬≤) time complexity.",
                algorithm: [
                    "Sort the array in ascending order",
                    "Iterate through the array with index i (this will be our first number)",
                    "Skip duplicate values for i to avoid duplicate triplets",
                    "For each i, use two pointers: left = i + 1, right = n - 1",
                    "Calculate sum = nums[i] + nums[left] + nums[right]",
                    "If sum < 0, increment left pointer (need larger numbers)",
                    "If sum > 0, decrement right pointer (need smaller numbers)",
                    "If sum == 0, add triplet to result and move both pointers",
                    "Skip duplicate values for left and right pointers",
                    "Return the result array"
                ],
                complexity: {
                    time: "O(n¬≤) where n is the length of the array. Sorting takes O(n log n), and for each element, we run a two-pointer scan which is O(n). Overall: O(n log n) + O(n¬≤) = O(n¬≤).",
                    space: "O(1) or O(n) depending on the sorting algorithm. The result space is not counted in complexity analysis. We use only constant extra space for pointers."
                },
                code: {
                    python: `def threeSum(nums):
    nums.sort()
    result = []
    
    for i in range(len(nums) - 2):
        # Skip duplicate values for first number
        if i > 0 and nums[i] == nums[i - 1]:
            continue
        
        left, right = i + 1, len(nums) - 1
        
        while left < right:
            total = nums[i] + nums[left] + nums[right]
            
            if total < 0:
                left += 1
            elif total > 0:
                right -= 1
            else:
                # Found a triplet
                result.append([nums[i], nums[left], nums[right]])
                
                # Skip duplicates for left pointer
                while left < right and nums[left] == nums[left + 1]:
                    left += 1
                # Skip duplicates for right pointer
                while left < right and nums[right] == nums[right - 1]:
                    right -= 1
                
                left += 1
                right -= 1
    
    return result`,
                    java: `class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums);
        List<List<Integer>> result = new ArrayList<>();
        
        for (int i = 0; i < nums.length - 2; i++) {
            // Skip duplicate values for first number
            if (i > 0 && nums[i] == nums[i - 1]) {
                continue;
            }
            
            int left = i + 1, right = nums.length - 1;
            
            while (left < right) {
                int sum = nums[i] + nums[left] + nums[right];
                
                if (sum < 0) {
                    left++;
                } else if (sum > 0) {
                    right--;
                } else {
                    // Found a triplet
                    result.add(Arrays.asList(nums[i], nums[left], nums[right]));
                    
                    // Skip duplicates for left pointer
                    while (left < right && nums[left] == nums[left + 1]) {
                        left++;
                    }
                    // Skip duplicates for right pointer
                    while (left < right && nums[right] == nums[right - 1]) {
                        right--;
                    }
                    
                    left++;
                    right--;
                }
            }
        }
        
        return result;
    }
}`,
                    cpp: `class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        vector<vector<int>> result;
        
        for (int i = 0; i < nums.size() - 2; i++) {
            // Skip duplicate values for first number
            if (i > 0 && nums[i] == nums[i - 1]) {
                continue;
            }
            
            int left = i + 1, right = nums.size() - 1;
            
            while (left < right) {
                int sum = nums[i] + nums[left] + nums[right];
                
                if (sum < 0) {
                    left++;
                } else if (sum > 0) {
                    right--;
                } else {
                    // Found a triplet
                    result.push_back({nums[i], nums[left], nums[right]});
                    
                    // Skip duplicates for left pointer
                    while (left < right && nums[left] == nums[left + 1]) {
                        left++;
                    }
                    // Skip duplicates for right pointer
                    while (left < right && nums[right] == nums[right - 1]) {
                        right--;
                    }
                    
                    left++;
                    right--;
                }
            }
        }
        
        return result;
    }
};`,
                    javascript: `function threeSum(nums) {
    nums.sort((a, b) => a - b);
    const result = [];
    
    for (let i = 0; i < nums.length - 2; i++) {
        // Skip duplicate values for first number
        if (i > 0 && nums[i] === nums[i - 1]) {
            continue;
        }
        
        let left = i + 1, right = nums.length - 1;
        
        while (left < right) {
            const sum = nums[i] + nums[left] + nums[right];
            
            if (sum < 0) {
                left++;
            } else if (sum > 0) {
                right--;
            } else {
                // Found a triplet
                result.push([nums[i], nums[left], nums[right]]);
                
                // Skip duplicates for left pointer
                while (left < right && nums[left] === nums[left + 1]) {
                    left++;
                }
                // Skip duplicates for right pointer
                while (left < right && nums[right] === nums[right - 1]) {
                    right--;
                }
                
                left++;
                right--;
            }
        }
    }
    
    return result;
}`
                }
            }
        }
    },
    "4sum": {
        "description": `<p>Given an array <code>nums</code> of <code>n</code> integers, return <em>an array of all the <strong>unique</strong> quadruplets</em> <code>[nums[a], nums[b], nums[c], nums[d]]</code> such that:</p><ul><li><code>0 <= a, b, c, d < n</code></li><li><code>a</code>, <code>b</code>, <code>c</code>, and <code>d</code> are <strong>distinct</strong>.</li><li><code>nums[a] + nums[b] + nums[c] + nums[d] == target</code></li></ul><p>You may return the answer in <strong>any order</strong>.</p><p><strong>Approach:</strong> This is an extension of 3Sum. Sort the array first, then use two nested loops to fix two numbers, and use two pointers for the remaining two. Skip duplicates carefully to avoid duplicate quadruplets. Time complexity: O(n¬≥).</p><p><strong>Important:</strong> Use <code>long</code> for sum calculation to avoid integer overflow when dealing with large numbers.</p>`,
        "examples": [
            {
                "input": "nums = [1,0,-1,0,-2,2], target = 0",
                "output": "[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]",
                "explanation": "Three unique quadruplets sum to 0."
            },
            {
                "input": "nums = [2,2,2,2,2], target = 8",
                "output": "[[2,2,2,2]]",
                "explanation": "The only quadruplet that sums to 8."
            },
            {
                "input": "nums = [1,0,-1,0,-2,2], target = 1",
                "output": "[[-2,-1,2,2],[-1,0,0,2]]",
                "explanation": "Two quadruplets sum to 1."
            }
        ],
        "constraints": [
            "<code>1 <= nums.length <= 200</code>",
            "<code>-10<sup>9</sup> <= nums[i] <= 10<sup>9</sup></code>",
            "<code>-10<sup>9</sup> <= target <= 10<sup>9</sup></code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "Four nested loops.",
                "algorithm": "O(n‚Å¥) brute force",
                "complexity": {
                    "time": "O(n‚Å¥)",
                    "space": "O(1)"
                },
                "code": {
                    "python": "class Solution:\n    def fourSum(self, nums, target):\n        nums.sort()\n        n = len(nums)\n        result = set()\n        for i in range(n - 3):\n            for j in range(i + 1, n - 2):\n                for k in range(j + 1, n - 1):\n                    for l in range(k + 1, n):\n                        if nums[i] + nums[j] + nums[k] + nums[l] == target:\n                            result.add((nums[i], nums[j], nums[k], nums[l]))\n        return [list(t) for t in result]",
                    "java": "class Solution { public List<List<Integer>> fourSum(int[] nums, int target) { Arrays.sort(nums); Set<List<Integer>> result = new HashSet<>(); int n = nums.length; for (int i = 0; i < n - 3; i++) { for (int j = i + 1; j < n - 2; j++) { for (int k = j + 1; k < n - 1; k++) { for (int l = k + 1; l < n; l++) { if ((long)nums[i] + nums[j] + nums[k] + nums[l] == target) result.add(Arrays.asList(nums[i], nums[j], nums[k], nums[l])); } } } } return new ArrayList<>(result); } }",
                    "cpp": "class Solution { public: vector<vector<int>> fourSum(vector<int>& nums, int target) { sort(nums.begin(), nums.end()); set<vector<int>> result; int n = nums.size(); for (int i = 0; i < n - 3; i++) { for (int j = i + 1; j < n - 2; j++) { for (int k = j + 1; k < n - 1; k++) { for (int l = k + 1; l < n; l++) { if ((long)nums[i] + nums[j] + nums[k] + nums[l] == target) result.insert({nums[i], nums[j], nums[k], nums[l]}); } } } } return vector<vector<int>>(result.begin(), result.end()); } };"
                }
            },
            "optimized": {
                "intuition": "Two pointers with two fixed.",
                "algorithm": "O(n¬≥) with two pointers",
                "complexity": {
                    "time": "O(n¬≥)",
                    "space": "O(1)"
                },
                "code": {
                    "python": "class Solution:\n    def fourSum(self, nums, target):\n        nums.sort()\n        n = len(nums)\n        result = []\n        for i in range(n - 3):\n            if i > 0 and nums[i] == nums[i - 1]: continue\n            for j in range(i + 1, n - 2):\n                if j > i + 1 and nums[j] == nums[j - 1]: continue\n                l, r = j + 1, n - 1\n                while l < r:\n                    total = nums[i] + nums[j] + nums[l] + nums[r]\n                    if total < target: l += 1\n                    elif total > target: r -= 1\n                    else:\n                        result.append([nums[i], nums[j], nums[l], nums[r]])\n                        while l < r and nums[l] == nums[l + 1]: l += 1\n                        while l < r and nums[r] == nums[r - 1]: r -= 1\n                        l += 1\n                        r -= 1\n        return result",
                    "java": "class Solution { public List<List<Integer>> fourSum(int[] nums, int target) { Arrays.sort(nums); List<List<Integer>> result = new ArrayList<>(); int n = nums.length; for (int i = 0; i < n - 3; i++) { if (i > 0 && nums[i] == nums[i - 1]) continue; for (int j = i + 1; j < n - 2; j++) { if (j > i + 1 && nums[j] == nums[j - 1]) continue; int l = j + 1, r = n - 1; while (l < r) { long sum = (long)nums[i] + nums[j] + nums[l] + nums[r]; if (sum < target) l++; else if (sum > target) r--; else { result.add(Arrays.asList(nums[i], nums[j], nums[l], nums[r])); while (l < r && nums[l] == nums[l + 1]) l++; while (l < r && nums[r] == nums[r - 1]) r--; l++; r--; } } } } return result; } }",
                    "cpp": "class Solution { public: vector<vector<int>> fourSum(vector<int>& nums, int target) { sort(nums.begin(), nums.end()); vector<vector<int>> result; int n = nums.size(); for (int i = 0; i < n - 3; i++) { if (i > 0 && nums[i] == nums[i - 1]) continue; for (int j = i + 1; j < n - 2; j++) { if (j > i + 1 && nums[j] == nums[j - 1]) continue; int l = j + 1, r = n - 1; while (l < r) { long sum = (long)nums[i] + nums[j] + nums[l] + nums[r]; if (sum < target) l++; else if (sum > target) r--; else { result.push_back({nums[i], nums[j], nums[l], nums[r]}); while (l < r && nums[l] == nums[l + 1]) l++; while (l < r && nums[r] == nums[r - 1]) r--; l++; r--; } } } } return result; } };"
                }
            }
        }
    },
    "remove-nth-node-from-end-of-list": {
        "description": `<p>Given the <code>head</code> of a linked list, remove the <code>n<sup>th</sup></code> node from the end of the list and return its head.</p><p><strong>Optimal Approach:</strong> Use the <strong>two-pointer technique</strong> with a <strong>dummy node</strong>. The fast pointer moves <code>n+1</code> steps ahead first, creating a gap of n nodes. Then both pointers move together until fast reaches the end. Now slow is positioned right before the node to delete.</p><p>The dummy node simplifies edge cases, especially when removing the head node.</p>`,
        "examples": [
            {
                "input": "head = [1,2,3,4,5], n = 2",
                "output": "[1,2,3,5]",
                "explanation": "Remove the 2nd node from the end (node with value 4)."
            },
            {
                "input": "head = [1], n = 1",
                "output": "[]",
                "explanation": "Remove the only node, resulting in an empty list."
            },
            {
                "input": "head = [1,2], n = 1",
                "output": "[1]",
                "explanation": "Remove the last node."
            }
        ],
        "constraints": [
            "<code>The number of nodes in the list is sz.</code>",
            "<code>1 <= sz <= 30</code>",
            "<code>0 <= Node.val <= 100</code>",
            "<code>1 <= n <= sz</code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "Two passes - count then remove.",
                "algorithm": "Find length first",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)"
                },
                "code": {
                    "python": "class Solution:\n    def removeNthFromEnd(self, head, n):\n        length = 0\n        curr = head\n        while curr:\n            length += 1\n            curr = curr.next\n        if length == n:\n            return head.next\n        curr = head\n        for _ in range(length - n - 1):\n            curr = curr.next\n        curr.next = curr.next.next\n        return head",
                    "java": "class Solution { public ListNode removeNthFromEnd(ListNode head, int n) { int len = 0; ListNode curr = head; while (curr != null) { len++; curr = curr.next; } if (len == n) return head.next; curr = head; for (int i = 0; i < len - n - 1; i++) curr = curr.next; curr.next = curr.next.next; return head; } }",
                    "cpp": "class Solution { public: ListNode* removeNthFromEnd(ListNode* head, int n) { int len = 0; ListNode* curr = head; while (curr) { len++; curr = curr->next; } if (len == n) return head->next; curr = head; for (int i = 0; i < len - n - 1; i++) curr = curr->next; curr->next = curr->next->next; return head; } };"
                }
            },
            "optimized": {
                "intuition": "Two pointers - one pass.",
                "algorithm": "Fast pointer n ahead",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)"
                },
                "code": {
                    "python": "class Solution:\n    def removeNthFromEnd(self, head, n):\n        dummy = ListNode(0, head)\n        slow = fast = dummy\n        for _ in range(n + 1):\n            fast = fast.next\n        while fast:\n            slow = slow.next\n            fast = fast.next\n        slow.next = slow.next.next\n        return dummy.next",
                    "java": "class Solution { public ListNode removeNthFromEnd(ListNode head, int n) { ListNode dummy = new ListNode(0, head); ListNode slow = dummy, fast = dummy; for (int i = 0; i <= n; i++) fast = fast.next; while (fast != null) { slow = slow.next; fast = fast.next; } slow.next = slow.next.next; return dummy.next; } }",
                    "cpp": "class Solution { public: ListNode* removeNthFromEnd(ListNode* head, int n) { ListNode* dummy = new ListNode(0, head); ListNode* slow = dummy, *fast = dummy; for (int i = 0; i <= n; i++) fast = fast->next; while (fast) { slow = slow->next; fast = fast->next; } slow->next = slow->next->next; return dummy->next; } };"
                }
            }
        }
    },
    "merge-two-sorted-lists": {
        "description": `<p>You are given the heads of two sorted linked lists <code>list1</code> and <code>list2</code>.</p>
<p>Merge the two lists into one <strong>sorted</strong> list. The list should be made by splicing together the nodes of the first two lists.</p>
<p>Return <em>the head of the merged linked list</em>.</p>
<p>This is a classic <strong>two-pointer merge</strong> problem. Since both lists are already sorted, we can compare the current nodes of each list and always choose the smaller one to add to our result. This is similar to the merge step in merge sort, but operating on linked lists instead of arrays.</p>
<p>A dummy node simplifies edge cases by providing a consistent starting point.</p>`,
        "examples": [
            {
                "input": "list1 = [1,2,4], list2 = [1,3,4]",
                "output": "[1,1,2,3,4,4]",
                "explanation": "Merge process: compare 1 and 1 (take either), compare 2 and 3 (take 2), compare 4 and 3 (take 3), compare 4 and 4 (take either), take remaining 4."
            },
            {
                "input": "list1 = [], list2 = []",
                "output": "[]",
                "explanation": "Both lists are empty."
            },
            {
                "input": "list1 = [], list2 = [0]",
                "output": "[0]",
                "explanation": "First list is empty, return the second list."
            }
        ],
        "constraints": [
            "The number of nodes in both lists is in the range <code>[0, 50]</code>.",
            "<code>-100 <= Node.val <= 100</code>",
            "Both <code>list1</code> and <code>list2</code> are sorted in <strong>non-decreasing</strong> order."
        ],
        "solutions": {
            "brute": {
                "intuition": "Collect and sort.",
                "algorithm": "O(n log n) sorting",
                "complexity": {
                    "time": "O(n log n)",
                    "space": "O(n)"
                },
                "code": {
                    "python": "class Solution:\n    def mergeTwoLists(self, list1, list2):\n        vals = []\n        curr = list1\n        while curr:\n            vals.append(curr.val)\n            curr = curr.next\n        curr = list2\n        while curr:\n            vals.append(curr.val)\n            curr = curr.next\n        vals.sort()\n        dummy = ListNode(0)\n        curr = dummy\n        for v in vals:\n            curr.next = ListNode(v)\n            curr = curr.next\n        return dummy.next",
                    "java": "class Solution { public ListNode mergeTwoLists(ListNode l1, ListNode l2) { List<Integer> vals = new ArrayList<>(); while (l1 != null) { vals.add(l1.val); l1 = l1.next; } while (l2 != null) { vals.add(l2.val); l2 = l2.next; } Collections.sort(vals); ListNode dummy = new ListNode(0); ListNode curr = dummy; for (int v : vals) { curr.next = new ListNode(v); curr = curr.next; } return dummy.next; } }",
                    "cpp": "class Solution { public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) { vector<int> vals; while (l1) { vals.push_back(l1->val); l1 = l1->next; } while (l2) { vals.push_back(l2->val); l2 = l2->next; } sort(vals.begin(), vals.end()); ListNode* dummy = new ListNode(0); ListNode* curr = dummy; for (int v : vals) { curr->next = new ListNode(v); curr = curr->next; } return dummy->next; } };"
                }
            },
            "optimized": {
                "intuition": "Merge in place.",
                "algorithm": "Two pointer merge",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)"
                },
                "code": {
                    "python": "class Solution:\n    def mergeTwoLists(self, list1, list2):\n        dummy = ListNode(0)\n        curr = dummy\n        while list1 and list2:\n            if list1.val <= list2.val:\n                curr.next = list1\n                list1 = list1.next\n            else:\n                curr.next = list2\n                list2 = list2.next\n            curr = curr.next\n        curr.next = list1 or list2\n        return dummy.next",
                    "java": "class Solution { public ListNode mergeTwoLists(ListNode l1, ListNode l2) { ListNode dummy = new ListNode(0); ListNode curr = dummy; while (l1 != null && l2 != null) { if (l1.val <= l2.val) { curr.next = l1; l1 = l1.next; } else { curr.next = l2; l2 = l2.next; } curr = curr.next; } curr.next = l1 != null ? l1 : l2; return dummy.next; } }",
                    "cpp": "class Solution { public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) { ListNode* dummy = new ListNode(0); ListNode* curr = dummy; while (l1 && l2) { if (l1->val <= l2->val) { curr->next = l1; l1 = l1->next; } else { curr->next = l2; l2 = l2->next; } curr = curr->next; } curr->next = l1 ? l1 : l2; return dummy->next; } };"
                }
            }
        }
    },
    "reorder-list": {
        "description": `<p>You are given the head of a singly linked-list. The list can be represented as:</p>
<p><code>L<sub>0</sub> ‚Üí L<sub>1</sub> ‚Üí ‚Ä¶ ‚Üí L<sub>n - 1</sub> ‚Üí L<sub>n</sub></code></p>
<p><em>Reorder the list to be on the following form:</em></p>
<p><code>L<sub>0</sub> ‚Üí L<sub>n</sub> ‚Üí L<sub>1</sub> ‚Üí L<sub>n - 1</sub> ‚Üí L<sub>2</sub> ‚Üí L<sub>n - 2</sub> ‚Üí ‚Ä¶</code></p>
<p>You may not modify the values in the list's nodes. Only nodes themselves may be changed.</p>
<p>The optimal O(1) space solution involves three steps: <strong>(1)</strong> Find the middle of the list using slow/fast pointers. <strong>(2)</strong> Reverse the second half of the list. <strong>(3)</strong> Merge the two halves by alternating nodes.</p>`,
        "examples": [
            {
                "input": "head = [1,2,3,4]",
                "output": "[1,4,2,3]",
                "explanation": "Reorder: 1‚Üí2‚Üí3‚Üí4 becomes 1‚Üí4‚Üí2‚Üí3."
            },
            {
                "input": "head = [1,2,3,4,5]",
                "output": "[1,5,2,4,3]",
                "explanation": "Reorder: 1‚Üí2‚Üí3‚Üí4‚Üí5 becomes 1‚Üí5‚Üí2‚Üí4‚Üí3."
            },
            {
                "input": "head = [1,2]",
                "output": "[1,2]",
                "explanation": "Two node list stays the same."
            }
        ],
        "constraints": [
            "The number of nodes in the list is in the range <code>[1, 5 * 10<sup>4</sup>]</code>.",
            "<code>1 <= Node.val <= 1000</code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "Store in array.",
                "algorithm": "Use deque",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(n)"
                },
                "code": {
                    "python": "class Solution:\n    def reorderList(self, head):\n        from collections import deque\n        nodes = deque()\n        curr = head\n        while curr:\n            nodes.append(curr)\n            curr = curr.next\n        curr = nodes.popleft()\n        toggle = True\n        while nodes:\n            if toggle:\n                curr.next = nodes.pop()\n            else:\n                curr.next = nodes.popleft()\n            curr = curr.next\n            toggle = not toggle\n        curr.next = None",
                    "java": "class Solution { public void reorderList(ListNode head) { Deque<ListNode> dq = new ArrayDeque<>(); ListNode curr = head; while (curr != null) { dq.add(curr); curr = curr.next; } curr = dq.pollFirst(); boolean toggle = true; while (!dq.isEmpty()) { if (toggle) curr.next = dq.pollLast(); else curr.next = dq.pollFirst(); curr = curr.next; toggle = !toggle; } curr.next = null; } }",
                    "cpp": "class Solution { public: void reorderList(ListNode* head) { deque<ListNode*> dq; ListNode* curr = head; while (curr) { dq.push_back(curr); curr = curr->next; } curr = dq.front(); dq.pop_front(); bool toggle = true; while (!dq.empty()) { if (toggle) { curr->next = dq.back(); dq.pop_back(); } else { curr->next = dq.front(); dq.pop_front(); } curr = curr->next; toggle = !toggle; } curr->next = nullptr; } };"
                }
            },
            "optimized": {
                "intuition": "Find middle, reverse second half, merge.",
                "algorithm": "Three steps",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)"
                },
                "code": {
                    "python": "class Solution:\n    def reorderList(self, head):\n        slow = fast = head\n        while fast.next and fast.next.next:\n            slow = slow.next\n            fast = fast.next.next\n        second = slow.next\n        slow.next = None\n        prev = None\n        while second:\n            temp = second.next\n            second.next = prev\n            prev = second\n            second = temp\n        first, second = head, prev\n        while second:\n            t1, t2 = first.next, second.next\n            first.next = second\n            second.next = t1\n            first = t1\n            second = t2",
                    "java": "class Solution { public void reorderList(ListNode head) { ListNode slow = head, fast = head; while (fast.next != null && fast.next.next != null) { slow = slow.next; fast = fast.next.next; } ListNode second = slow.next; slow.next = null; ListNode prev = null; while (second != null) { ListNode t = second.next; second.next = prev; prev = second; second = t; } ListNode first = head; second = prev; while (second != null) { ListNode t1 = first.next, t2 = second.next; first.next = second; second.next = t1; first = t1; second = t2; } } }",
                    "cpp": "class Solution { public: void reorderList(ListNode* head) { ListNode* slow = head, *fast = head; while (fast->next && fast->next->next) { slow = slow->next; fast = fast->next->next; } ListNode* second = slow->next; slow->next = nullptr; ListNode* prev = nullptr; while (second) { ListNode* t = second->next; second->next = prev; prev = second; second = t; } ListNode* first = head; second = prev; while (second) { ListNode* t1 = first->next, *t2 = second->next; first->next = second; second->next = t1; first = t1; second = t2; } } };"
                }
            }
        }
    },
    "copy-list-with-random-pointer": {
        "description": `<p>A linked list of length <code>n</code> is given such that each node contains an additional random pointer, which could point to any node in the list, or <code>null</code>.</p><p>Construct a <strong>deep copy</strong> of the list. The deep copy should consist of exactly <code>n</code> <strong>brand new</strong> nodes, where each new node has its value set to the value of its corresponding original node. Both the <code>next</code> and <code>random</code> pointer of the new nodes should point to new nodes in the copied list such that the pointers in the original list and copied list represent the same list state. <strong>None of the pointers in the new list should point to nodes in the original list</strong>.</p><p><strong>Approach 1 (O(n) space):</strong> Use a hash map to map each original node to its copy. First pass creates all new nodes, second pass sets up next and random pointers.</p><p><strong>Approach 2 (O(1) space):</strong> Interleave copied nodes with original nodes: <code>A‚ÜíA'‚ÜíB‚ÜíB'‚ÜíC‚ÜíC'</code>. Set random pointers using the interleaved structure, then separate the two lists.</p>`,
        "examples": [
            {
                "input": "head = [[7,null],[13,0],[11,4],[10,2],[1,0]]",
                "output": "[[7,null],[13,0],[11,4],[10,2],[1,0]]",
                "explanation": "Deep copy maintains the same structure with all new nodes."
            },
            {
                "input": "head = [[1,1],[2,1]]",
                "output": "[[1,1],[2,1]]",
                "explanation": "Both nodes' random pointers point to the second node."
            },
            {
                "input": "head = [[3,null],[3,0],[3,null]]",
                "output": "[[3,null],[3,0],[3,null]]",
                "explanation": "Middle node's random pointer points to the first node."
            }
        ],
        "constraints": [
            "<code>0 <= n <= 1000</code>",
            "<code>-10<sup>4</sup> <= Node.val <= 10<sup>4</sup></code>",
            "<code>Node.random</code> is <code>null</code> or points to some node in the linked list."
        ],
        "solutions": {
            "brute": {
                "intuition": "Hash map to map old to new.",
                "algorithm": "Two passes",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(n)"
                },
                "code": {
                    "python": "class Solution:\n    def copyRandomList(self, head):\n        if not head: return None\n        oldToNew = {}\n        curr = head\n        while curr:\n            oldToNew[curr] = Node(curr.val)\n            curr = curr.next\n        curr = head\n        while curr:\n            oldToNew[curr].next = oldToNew.get(curr.next)\n            oldToNew[curr].random = oldToNew.get(curr.random)\n            curr = curr.next\n        return oldToNew[head]",
                    "java": "class Solution { public Node copyRandomList(Node head) { if (head == null) return null; Map<Node, Node> map = new HashMap<>(); Node curr = head; while (curr != null) { map.put(curr, new Node(curr.val)); curr = curr.next; } curr = head; while (curr != null) { map.get(curr).next = map.get(curr.next); map.get(curr).random = map.get(curr.random); curr = curr.next; } return map.get(head); } }",
                    "cpp": "class Solution { public: Node* copyRandomList(Node* head) { if (!head) return nullptr; unordered_map<Node*, Node*> mp; Node* curr = head; while (curr) { mp[curr] = new Node(curr->val); curr = curr->next; } curr = head; while (curr) { mp[curr]->next = mp[curr->next]; mp[curr]->random = mp[curr->random]; curr = curr->next; } return mp[head]; } };"
                }
            },
            "optimized": {
                "intuition": "Interleave copies.",
                "algorithm": "O(1) space with interleaving",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)"
                },
                "code": {
                    "python": "class Solution:\n    def copyRandomList(self, head):\n        if not head: return None\n        curr = head\n        while curr:\n            copy = Node(curr.val, curr.next)\n            curr.next = copy\n            curr = copy.next\n        curr = head\n        while curr:\n            if curr.random:\n                curr.next.random = curr.random.next\n            curr = curr.next.next\n        oldHead = head\n        newHead = head.next\n        curr = head\n        while curr:\n            copy = curr.next\n            curr.next = copy.next\n            if copy.next:\n                copy.next = copy.next.next\n            curr = curr.next\n        return newHead",
                    "java": "class Solution { public Node copyRandomList(Node head) { if (head == null) return null; Node curr = head; while (curr != null) { Node copy = new Node(curr.val); copy.next = curr.next; curr.next = copy; curr = copy.next; } curr = head; while (curr != null) { if (curr.random != null) curr.next.random = curr.random.next; curr = curr.next.next; } Node newHead = head.next; curr = head; while (curr != null) { Node copy = curr.next; curr.next = copy.next; if (copy.next != null) copy.next = copy.next.next; curr = curr.next; } return newHead; } }",
                    "cpp": "class Solution { public: Node* copyRandomList(Node* head) { if (!head) return nullptr; Node* curr = head; while (curr) { Node* copy = new Node(curr->val); copy->next = curr->next; curr->next = copy; curr = copy->next; } curr = head; while (curr) { if (curr->random) curr->next->random = curr->random->next; curr = curr->next->next; } Node* newHead = head->next; curr = head; while (curr) { Node* copy = curr->next; curr->next = copy->next; if (copy->next) copy->next = copy->next->next; curr = curr->next; } return newHead; } };"
                }
            }
        }
    },
    "add-two-numbers": {
        "description": `<p>You are given two <strong>non-empty</strong> linked lists representing two non-negative integers. The digits are stored in <strong>reverse order</strong>, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.</p><p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p><p><strong>Approach:</strong> Traverse both lists simultaneously, adding corresponding digits along with any carry from the previous step. Create new nodes for the result. Handle cases where lists have different lengths and when there's a final carry to add.</p><p><strong>Key Insight:</strong> Because digits are stored in reverse order, we can add them from left to right naturally, propagating the carry forward.</p>`,
        "examples": [
            {
                "input": "l1 = [2,4,3], l2 = [5,6,4]",
                "output": "[7,0,8]",
                "explanation": "342 + 465 = 807. Result is stored in reverse: [7,0,8]."
            },
            {
                "input": "l1 = [0], l2 = [0]",
                "output": "[0]",
                "explanation": "0 + 0 = 0."
            },
            {
                "input": "l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]",
                "output": "[8,9,9,9,0,0,0,1]",
                "explanation": "9999999 + 9999 = 10009998."
            }
        ],
        "constraints": [
            "<code>The number of nodes in each linked list is in the range [1, 100].</code>",
            "<code>0 <= Node.val <= 9</code>",
            "<code>It is guaranteed that the list represents a number that does not have leading zeros.</code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "Convert to numbers, add, convert back.",
                "algorithm": "May overflow",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(n)"
                },
                "code": {
                    "python": "class Solution:\n    def addTwoNumbers(self, l1, l2):\n        num1 = num2 = 0\n        mul = 1\n        while l1:\n            num1 += l1.val * mul\n            mul *= 10\n            l1 = l1.next\n        mul = 1\n        while l2:\n            num2 += l2.val * mul\n            mul *= 10\n            l2 = l2.next\n        total = num1 + num2\n        dummy = ListNode(0)\n        curr = dummy\n        if total == 0: return ListNode(0)\n        while total:\n            curr.next = ListNode(total % 10)\n            curr = curr.next\n            total //= 10\n        return dummy.next",
                    "java": "class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { java.math.BigInteger n1 = java.math.BigInteger.ZERO, n2 = java.math.BigInteger.ZERO; java.math.BigInteger mul = java.math.BigInteger.ONE; while (l1 != null) { n1 = n1.add(mul.multiply(BigInteger.valueOf(l1.val))); mul = mul.multiply(BigInteger.TEN); l1 = l1.next; } mul = java.math.BigInteger.ONE; while (l2 != null) { n2 = n2.add(mul.multiply(BigInteger.valueOf(l2.val))); mul = mul.multiply(BigInteger.TEN); l2 = l2.next; } java.math.BigInteger total = n1.add(n2); ListNode dummy = new ListNode(0); ListNode curr = dummy; if (total.equals(BigInteger.ZERO)) return new ListNode(0); while (!total.equals(BigInteger.ZERO)) { curr.next = new ListNode(total.mod(BigInteger.TEN).intValue()); curr = curr.next; total = total.divide(BigInteger.TEN); } return dummy.next; } }",
                    "cpp": "class Solution { public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) { ListNode* dummy = new ListNode(0); ListNode* curr = dummy; int carry = 0; while (l1 || l2 || carry) { int sum = carry; if (l1) { sum += l1->val; l1 = l1->next; } if (l2) { sum += l2->val; l2 = l2->next; } curr->next = new ListNode(sum % 10); curr = curr->next; carry = sum / 10; } return dummy->next; } };"
                }
            },
            "optimized": {
                "intuition": "Add digit by digit with carry.",
                "algorithm": "Proper linked list addition",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(n)"
                },
                "code": {
                    "python": "class Solution:\n    def addTwoNumbers(self, l1, l2):\n        dummy = ListNode(0)\n        curr = dummy\n        carry = 0\n        while l1 or l2 or carry:\n            val1 = l1.val if l1 else 0\n            val2 = l2.val if l2 else 0\n            total = val1 + val2 + carry\n            carry = total // 10\n            curr.next = ListNode(total % 10)\n            curr = curr.next\n            if l1: l1 = l1.next\n            if l2: l2 = l2.next\n        return dummy.next",
                    "java": "class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { ListNode dummy = new ListNode(0); ListNode curr = dummy; int carry = 0; while (l1 != null || l2 != null || carry != 0) { int v1 = l1 != null ? l1.val : 0; int v2 = l2 != null ? l2.val : 0; int sum = v1 + v2 + carry; carry = sum / 10; curr.next = new ListNode(sum % 10); curr = curr.next; if (l1 != null) l1 = l1.next; if (l2 != null) l2 = l2.next; } return dummy.next; } }",
                    "cpp": "class Solution { public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) { ListNode* dummy = new ListNode(0); ListNode* curr = dummy; int carry = 0; while (l1 || l2 || carry) { int v1 = l1 ? l1->val : 0; int v2 = l2 ? l2->val : 0; int sum = v1 + v2 + carry; carry = sum / 10; curr->next = new ListNode(sum % 10); curr = curr->next; if (l1) l1 = l1->next; if (l2) l2 = l2->next; } return dummy->next; } };"
                }
            }
        }
    },
    "lru-cache": {
        "description": `<p>Design a data structure that follows the constraints of a <strong>Least Recently Used (LRU) cache</strong>.</p><p>Implement the <code>LRUCache</code> class:</p><ul><li><code>LRUCache(int capacity)</code> Initialize the LRU cache with <strong>positive</strong> size <code>capacity</code>.</li><li><code>int get(int key)</code> Return the value of the <code>key</code> if the key exists, otherwise return <code>-1</code>.</li><li><code>void put(int key, int value)</code> Update the value of the <code>key</code> if the <code>key</code> exists. Otherwise, add the <code>key-value</code> pair to the cache. If the number of keys exceeds the <code>capacity</code> from this operation, <strong>evict</strong> the least recently used key.</li></ul><p>The functions <code>get</code> and <code>put</code> must each run in <code>O(1)</code> average time complexity.</p><p><strong>Optimal Approach:</strong> Use a <strong>doubly linked list</strong> + <strong>hash map</strong>. The hash map provides O(1) lookup, and the doubly linked list maintains the order of usage (most recent at head, least recent at tail). When accessing/updating a key, move it to the head. When evicting, remove from tail.</p>`,
        "examples": [
            {
                "input": "[\"LRUCache\",\"put\",\"put\",\"get\",\"put\",\"get\",\"put\",\"get\",\"get\",\"get\"]",
                "output": "[null,null,null,1,null,-1,null,-1,3,4]",
                "explanation": "LRUCache lRUCache = new LRUCache(2); lRUCache.put(1, 1); lRUCache.put(2, 2); lRUCache.get(1); returns 1; lRUCache.put(3, 3); evicts key 2; lRUCache.get(2); returns -1; lRUCache.put(4, 4); evicts key 1; lRUCache.get(1); returns -1; lRUCache.get(3); returns 3; lRUCache.get(4); returns 4"
            }
        ],
        "constraints": [
            "<code>1 <= capacity <= 3000</code>",
            "<code>0 <= key <= 10<sup>4</sup></code>",
            "<code>0 <= value <= 10<sup>5</sup></code>",
            "<code>At most 2 * 10<sup>5</sup> calls will be made to get and put.</code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "Use ordered dict.",
                "algorithm": "Move to end on access",
                "complexity": {
                    "time": "O(1)",
                    "space": "O(n)"
                },
                "code": {
                    "python": "class LRUCache:\n    def __init__(self, capacity):\n        from collections import OrderedDict\n        self.cache = OrderedDict()\n        self.cap = capacity\n    def get(self, key):\n        if key not in self.cache: return -1\n        self.cache.move_to_end(key)\n        return self.cache[key]\n    def put(self, key, value):\n        if key in self.cache:\n            self.cache.move_to_end(key)\n        self.cache[key] = value\n        if len(self.cache) > self.cap:\n            self.cache.popitem(last=False)",
                    "java": "class LRUCache extends LinkedHashMap<Integer, Integer> { private int capacity; public LRUCache(int capacity) { super(capacity, 0.75f, true); this.capacity = capacity; } public int get(int key) { return super.getOrDefault(key, -1); } public void put(int key, int value) { super.put(key, value); } @Override protected boolean removeEldestEntry(Map.Entry<Integer, Integer> eldest) { return size() > capacity; } }",
                    "cpp": "class LRUCache { list<pair<int,int>> cache; unordered_map<int, list<pair<int,int>>::iterator> mp; int cap; public: LRUCache(int capacity) : cap(capacity) {} int get(int key) { if (mp.find(key) == mp.end()) return -1; cache.splice(cache.begin(), cache, mp[key]); return mp[key]->second; } void put(int key, int value) { if (mp.find(key) != mp.end()) { cache.splice(cache.begin(), cache, mp[key]); mp[key]->second = value; return; } if (cache.size() == cap) { int del = cache.back().first; cache.pop_back(); mp.erase(del); } cache.push_front({key, value}); mp[key] = cache.begin(); } };"
                }
            },
            "optimized": {
                "intuition": "Hash map + doubly linked list.",
                "algorithm": "Manual implementation",
                "complexity": {
                    "time": "O(1)",
                    "space": "O(n)"
                },
                "code": {
                    "python": "class Node:\n    def __init__(self, key=0, val=0):\n        self.key, self.val = key, val\n        self.prev = self.next = None\n\nclass LRUCache:\n    def __init__(self, capacity):\n        self.cap = capacity\n        self.cache = {}\n        self.head, self.tail = Node(), Node()\n        self.head.next, self.tail.prev = self.tail, self.head\n    \n    def _remove(self, node):\n        node.prev.next, node.next.prev = node.next, node.prev\n    \n    def _add(self, node):\n        node.next, node.prev = self.head.next, self.head\n        self.head.next.prev = node\n        self.head.next = node\n    \n    def get(self, key):\n        if key not in self.cache: return -1\n        node = self.cache[key]\n        self._remove(node)\n        self._add(node)\n        return node.val\n    \n    def put(self, key, value):\n        if key in self.cache:\n            self._remove(self.cache[key])\n        node = Node(key, value)\n        self.cache[key] = node\n        self._add(node)\n        if len(self.cache) > self.cap:\n            lru = self.tail.prev\n            self._remove(lru)\n            del self.cache[lru.key]",
                    "java": "class LRUCache { class Node { int key, val; Node prev, next; Node(int k, int v) { key = k; val = v; } } private Map<Integer, Node> cache = new HashMap<>(); private Node head = new Node(0, 0), tail = new Node(0, 0); private int cap; public LRUCache(int capacity) { cap = capacity; head.next = tail; tail.prev = head; } private void remove(Node n) { n.prev.next = n.next; n.next.prev = n.prev; } private void add(Node n) { n.next = head.next; n.prev = head; head.next.prev = n; head.next = n; } public int get(int key) { if (!cache.containsKey(key)) return -1; Node n = cache.get(key); remove(n); add(n); return n.val; } public void put(int key, int value) { if (cache.containsKey(key)) remove(cache.get(key)); Node n = new Node(key, value); cache.put(key, n); add(n); if (cache.size() > cap) { Node lru = tail.prev; remove(lru); cache.remove(lru.key); } } }",
                    "cpp": "class LRUCache { struct Node { int key, val; Node *prev, *next; Node(int k = 0, int v = 0) : key(k), val(v), prev(nullptr), next(nullptr) {} }; unordered_map<int, Node*> cache; Node *head, *tail; int cap; void remove(Node* n) { n->prev->next = n->next; n->next->prev = n->prev; } void add(Node* n) { n->next = head->next; n->prev = head; head->next->prev = n; head->next = n; } public: LRUCache(int capacity) : cap(capacity) { head = new Node(); tail = new Node(); head->next = tail; tail->prev = head; } int get(int key) { if (cache.find(key) == cache.end()) return -1; Node* n = cache[key]; remove(n); add(n); return n->val; } void put(int key, int value) { if (cache.count(key)) remove(cache[key]); Node* n = new Node(key, value); cache[key] = n; add(n); if (cache.size() > cap) { Node* lru = tail->prev; remove(lru); cache.erase(lru->key); delete lru; } } };"
                }
            }
        }
    },
    "design-twitter": {
        "description": `<p>Design a simplified version of Twitter where users can post tweets, follow/unfollow another user, and see the <code>10</code> most recent tweets in their news feed.</p><p>Implement the <code>Twitter</code> class:</p><ul><li><code>Twitter()</code> Initializes your twitter object.</li><li><code>void postTweet(int userId, int tweetId)</code> Composes a new tweet with ID <code>tweetId</code> by the user <code>userId</code>. Each call to this function will be made with a unique <code>tweetId</code>.</li><li><code>List&lt;Integer&gt; getNewsFeed(int userId)</code> Retrieves the <code>10</code> most recent tweet IDs in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user themself. Tweets must be <strong>ordered from most recent to least recent</strong>.</li><li><code>void follow(int followerId, int followeeId)</code> The user with ID <code>followerId</code> started following the user with ID <code>followeeId</code>.</li><li><code>void unfollow(int followerId, int followeeId)</code> The user with ID <code>followerId</code> started unfollowing the user with ID <code>followeeId</code>.</li></ul><p><strong>Optimal Approach:</strong> Store tweets with timestamps. For <code>getNewsFeed</code>, use a <strong>max-heap</strong> to efficiently merge the k most recent tweets from all followed users. This avoids sorting all tweets, achieving O(k log n) complexity where k=10.</p>`,
        "examples": [
            {
                "input": "[\"Twitter\",\"postTweet\",\"getNewsFeed\",\"follow\",\"postTweet\",\"getNewsFeed\",\"unfollow\",\"getNewsFeed\"]",
                "output": "[null,null,[5],null,null,[6,5],null,[5]]",
                "explanation": "Twitter twitter = new Twitter(); twitter.postTweet(1, 5); twitter.getNewsFeed(1); returns [5]; twitter.follow(1, 2); twitter.postTweet(2, 6); twitter.getNewsFeed(1); returns [6, 5]; twitter.unfollow(1, 2); twitter.getNewsFeed(1); returns [5];"
            }
        ],
        "constraints": [
            "<code>1 <= userId, followerId, followeeId <= 500</code>",
            "<code>0 <= tweetId <= 10<sup>4</sup></code>",
            "<code>All the tweets have unique IDs.</code>",
            "<code>At most 3 * 10<sup>4</sup> calls will be made to postTweet, getNewsFeed, follow, and unfollow.</code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "Store tweets and follows.",
                "algorithm": "Simple data structures",
                "complexity": {
                    "time": "O(n log n)",
                    "space": "O(n)"
                },
                "code": {
                    "python": "class Twitter:\n    def __init__(self):\n        self.time = 0\n        self.tweets = defaultdict(list)\n        self.follows = defaultdict(set)\n    \n    def postTweet(self, userId, tweetId):\n        self.tweets[userId].append((self.time, tweetId))\n        self.time += 1\n    \n    def getNewsFeed(self, userId):\n        feed = list(self.tweets[userId])\n        for followee in self.follows[userId]:\n            feed.extend(self.tweets[followee])\n        feed.sort(reverse=True)\n        return [t[1] for t in feed[:10]]\n    \n    def follow(self, followerId, followeeId):\n        if followerId != followeeId:\n            self.follows[followerId].add(followeeId)\n    \n    def unfollow(self, followerId, followeeId):\n        self.follows[followerId].discard(followeeId)",
                    "java": "class Twitter { int time = 0; Map<Integer, List<int[]>> tweets = new HashMap<>(); Map<Integer, Set<Integer>> follows = new HashMap<>(); public void postTweet(int userId, int tweetId) { tweets.computeIfAbsent(userId, k -> new ArrayList<>()).add(new int[]{time++, tweetId}); } public List<Integer> getNewsFeed(int userId) { List<int[]> feed = new ArrayList<>(tweets.getOrDefault(userId, new ArrayList<>())); for (int f : follows.getOrDefault(userId, new HashSet<>())) feed.addAll(tweets.getOrDefault(f, new ArrayList<>())); feed.sort((a, b) -> b[0] - a[0]); List<Integer> res = new ArrayList<>(); for (int i = 0; i < Math.min(10, feed.size()); i++) res.add(feed.get(i)[1]); return res; } public void follow(int followerId, int followeeId) { if (followerId != followeeId) follows.computeIfAbsent(followerId, k -> new HashSet<>()).add(followeeId); } public void unfollow(int followerId, int followeeId) { if (follows.containsKey(followerId)) follows.get(followerId).remove(followeeId); } }",
                    "cpp": "class Twitter { int time = 0; unordered_map<int, vector<pair<int,int>>> tweets; unordered_map<int, unordered_set<int>> follows; public: void postTweet(int userId, int tweetId) { tweets[userId].push_back({time++, tweetId}); } vector<int> getNewsFeed(int userId) { vector<pair<int,int>> feed(tweets[userId].begin(), tweets[userId].end()); for (int f : follows[userId]) { auto& t = tweets[f]; feed.insert(feed.end(), t.begin(), t.end()); } sort(feed.rbegin(), feed.rend()); vector<int> res; for (int i = 0; i < min(10, (int)feed.size()); i++) res.push_back(feed[i].second); return res; } void follow(int followerId, int followeeId) { if (followerId != followeeId) follows[followerId].insert(followeeId); } void unfollow(int followerId, int followeeId) { follows[followerId].erase(followeeId); } };"
                }
            },
            "optimized": {
                "intuition": "Use heap for efficient merge.",
                "algorithm": "Min-heap for top 10",
                "complexity": {
                    "time": "O(k log n)",
                    "space": "O(n)"
                },
                "code": {
                    "python": "class Twitter:\n    def __init__(self):\n        self.time = 0\n        self.tweets = defaultdict(list)\n        self.follows = defaultdict(set)\n    \n    def postTweet(self, userId, tweetId):\n        self.tweets[userId].append((self.time, tweetId))\n        self.time += 1\n    \n    def getNewsFeed(self, userId):\n        import heapq\n        heap = []\n        self.follows[userId].add(userId)\n        for followee in self.follows[userId]:\n            if self.tweets[followee]:\n                idx = len(self.tweets[followee]) - 1\n                t, tid = self.tweets[followee][idx]\n                heapq.heappush(heap, (-t, tid, followee, idx))\n        self.follows[userId].discard(userId)\n        feed = []\n        while heap and len(feed) < 10:\n            t, tid, followee, idx = heapq.heappop(heap)\n            feed.append(tid)\n            if idx > 0:\n                t, tid = self.tweets[followee][idx - 1]\n                heapq.heappush(heap, (-t, tid, followee, idx - 1))\n        return feed\n    \n    def follow(self, followerId, followeeId):\n        if followerId != followeeId:\n            self.follows[followerId].add(followeeId)\n    \n    def unfollow(self, followerId, followeeId):\n        self.follows[followerId].discard(followeeId)",
                    "java": "class Twitter { int time = 0; Map<Integer, List<int[]>> tweets = new HashMap<>(); Map<Integer, Set<Integer>> follows = new HashMap<>(); public void postTweet(int userId, int tweetId) { tweets.computeIfAbsent(userId, k -> new ArrayList<>()).add(new int[]{time++, tweetId}); } public List<Integer> getNewsFeed(int userId) { PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> b[0] - a[0]); Set<Integer> users = new HashSet<>(follows.getOrDefault(userId, new HashSet<>())); users.add(userId); for (int u : users) { List<int[]> t = tweets.getOrDefault(u, new ArrayList<>()); if (!t.isEmpty()) { int idx = t.size() - 1; pq.offer(new int[]{t.get(idx)[0], t.get(idx)[1], u, idx}); } } List<Integer> res = new ArrayList<>(); while (!pq.isEmpty() && res.size() < 10) { int[] top = pq.poll(); res.add(top[1]); if (top[3] > 0) { int[] prev = tweets.get(top[2]).get(top[3] - 1); pq.offer(new int[]{prev[0], prev[1], top[2], top[3] - 1}); } } return res; } public void follow(int followerId, int followeeId) { if (followerId != followeeId) follows.computeIfAbsent(followerId, k -> new HashSet<>()).add(followeeId); } public void unfollow(int followerId, int followeeId) { if (follows.containsKey(followerId)) follows.get(followerId).remove(followeeId); } }",
                    "cpp": "class Twitter { int time = 0; unordered_map<int, vector<pair<int,int>>> tweets; unordered_map<int, unordered_set<int>> follows; public: void postTweet(int userId, int tweetId) { tweets[userId].push_back({time++, tweetId}); } vector<int> getNewsFeed(int userId) { auto cmp = [](auto& a, auto& b) { return get<0>(a) < get<0>(b); }; priority_queue<tuple<int,int,int,int>, vector<tuple<int,int,int,int>>, decltype(cmp)> pq(cmp); auto users = follows[userId]; users.insert(userId); for (int u : users) { if (!tweets[u].empty()) { int idx = tweets[u].size() - 1; pq.push({tweets[u][idx].first, tweets[u][idx].second, u, idx}); } } vector<int> res; while (!pq.empty() && res.size() < 10) { auto [t, tid, u, idx] = pq.top(); pq.pop(); res.push_back(tid); if (idx > 0) pq.push({tweets[u][idx-1].first, tweets[u][idx-1].second, u, idx-1}); } return res; } void follow(int followerId, int followeeId) { if (followerId != followeeId) follows[followerId].insert(followeeId); } void unfollow(int followerId, int followeeId) { follows[followerId].erase(followeeId); } };"
                }
            }
        }
    },
    "kth-largest-element-in-an-array": {
        "description": `<p>Given an integer array <code>nums</code> and an integer <code>k</code>, return <em>the</em> <code>k<sup>th</sup></code> <em>largest element in the array</em>.</p><p>Note that it is the <code>k<sup>th</sup></code> largest element in the sorted order, not the <code>k<sup>th</sup></code> distinct element.</p><p>Can you solve it without sorting?</p><p><strong>Approach 1 (O(n log k)):</strong> Use a <strong>min-heap of size k</strong>. Maintain the k largest elements seen so far. The root of the heap is the kth largest.</p><p><strong>Approach 2 (O(n) average):</strong> Use <strong>Quickselect</strong>, a selection algorithm similar to quicksort. Partition the array and recursively search only the relevant half. Average case O(n), worst case O(n¬≤) but can be optimized with random pivot selection.</p>`,
        "examples": [
            {
                "input": "nums = [3,2,1,5,6,4], k = 2",
                "output": "5",
                "explanation": "The 2nd largest element is 5 (sorted: [1,2,3,4,5,6])."
            },
            {
                "input": "nums = [3,2,3,1,2,4,5,5,6], k = 4",
                "output": "4",
                "explanation": "The 4th largest element is 4 (sorted: [1,2,2,3,3,4,5,5,6])."
            },
            {
                "input": "nums = [1], k = 1",
                "output": "1",
                "explanation": "Single element is the 1st largest."
            }
        ],
        "constraints": [
            "<code>1 <= k <= nums.length <= 10<sup>5</sup></code>",
            "<code>-10<sup>4</sup> <= nums[i] <= 10<sup>4</sup></code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "Sort and return.",
                "algorithm": "Full sort",
                "complexity": {
                    "time": "O(n log n)",
                    "space": "O(1)"
                },
                "code": {
                    "python": "class Solution:\n    def findKthLargest(self, nums, k):\n        nums.sort(reverse=True)\n        return nums[k - 1]",
                    "java": "class Solution { public int findKthLargest(int[] nums, int k) { Arrays.sort(nums); return nums[nums.length - k]; } }",
                    "cpp": "class Solution { public: int findKthLargest(vector<int>& nums, int k) { sort(nums.rbegin(), nums.rend()); return nums[k - 1]; } };"
                }
            },
            "optimized": {
                "intuition": "Min heap of size k.",
                "algorithm": "Heap",
                "complexity": {
                    "time": "O(n log k)",
                    "space": "O(k)"
                },
                "code": {
                    "python": "class Solution:\n    def findKthLargest(self, nums, k):\n        import heapq\n        heap = []\n        for num in nums:\n            heapq.heappush(heap, num)\n            if len(heap) > k:\n                heapq.heappop(heap)\n        return heap[0]",
                    "java": "class Solution { public int findKthLargest(int[] nums, int k) { PriorityQueue<Integer> pq = new PriorityQueue<>(); for (int n : nums) { pq.offer(n); if (pq.size() > k) pq.poll(); } return pq.peek(); } }",
                    "cpp": "class Solution { public: int findKthLargest(vector<int>& nums, int k) { priority_queue<int, vector<int>, greater<int>> pq; for (int n : nums) { pq.push(n); if (pq.size() > k) pq.pop(); } return pq.top(); } };"
                }
            }
        }
    },
    "task-scheduler": {
        "description": "Minimum units of time for CPU tasks with cooldown.",
        "examples": [
            {
                "input": "tasks = [\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"], n = 2",
                "output": "8"
            }
        ],
        "constraints": [
            "1 <= tasks.length <= 10^4"
        ],
        "solutions": {
            "brute": {
                "intuition": "Simulate the scheduling.",
                "algorithm": "Greedy with cooldown tracking",
                "complexity": {
                    "time": "O(time)",
                    "space": "O(1)"
                },
                "code": {
                    "python": "class Solution:\n    def leastInterval(self, tasks, n):\n        from collections import Counter\n        count = Counter(tasks)\n        time = 0\n        cooldown = {}\n        while count:\n            available = [(c, t) for t, c in count.items() if cooldown.get(t, 0) <= time]\n            if available:\n                c, t = max(available)\n                count[t] -= 1\n                if count[t] == 0:\n                    del count[t]\n                cooldown[t] = time + n + 1\n            time += 1\n        return time",
                    "java": "class Solution { public int leastInterval(char[] tasks, int n) { int[] count = new int[26]; for (char c : tasks) count[c - 'A']++; int maxCount = 0, maxTasks = 0; for (int c : count) { if (c > maxCount) { maxCount = c; maxTasks = 1; } else if (c == maxCount) maxTasks++; } return Math.max(tasks.length, (maxCount - 1) * (n + 1) + maxTasks); } }",
                    "cpp": "class Solution { public: int leastInterval(vector<char>& tasks, int n) { vector<int> count(26); for (char c : tasks) count[c - 'A']++; int maxCount = *max_element(count.begin(), count.end()); int maxTasks = count_if(count.begin(), count.end(), [maxCount](int c) { return c == maxCount; }); return max((int)tasks.size(), (maxCount - 1) * (n + 1) + maxTasks); } };"
                }
            },
            "optimized": {
                "intuition": "Math formula.",
                "algorithm": "(maxFreq - 1) * (n + 1) + numMaxFreq",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)"
                },
                "code": {
                    "python": "class Solution:\n    def leastInterval(self, tasks, n):\n        from collections import Counter\n        count = Counter(tasks)\n        maxFreq = max(count.values())\n        numMaxFreq = sum(1 for v in count.values() if v == maxFreq)\n        return max(len(tasks), (maxFreq - 1) * (n + 1) + numMaxFreq)",
                    "java": "class Solution { public int leastInterval(char[] tasks, int n) { int[] count = new int[26]; for (char c : tasks) count[c - 'A']++; int maxFreq = 0, numMaxFreq = 0; for (int c : count) { if (c > maxFreq) { maxFreq = c; numMaxFreq = 1; } else if (c == maxFreq) numMaxFreq++; } return Math.max(tasks.length, (maxFreq - 1) * (n + 1) + numMaxFreq); } }",
                    "cpp": "class Solution { public: int leastInterval(vector<char>& tasks, int n) { vector<int> count(26); for (char c : tasks) count[c - 'A']++; int maxFreq = *max_element(count.begin(), count.end()); int numMaxFreq = count_if(count.begin(), count.end(), [maxFreq](int c) { return c == maxFreq; }); return max((int)tasks.size(), (maxFreq - 1) * (n + 1) + numMaxFreq); } };"
                }
            }
        }
    },
    "find-median-from-data-stream": {
        "description": "Find median from streaming data.",
        "examples": [
            {
                "input": "[\"MedianFinder\",\"addNum\",\"findMedian\"]",
                "output": "[null,null,1.0]"
            }
        ],
        "constraints": [
            "-10^5 <= num <= 10^5"
        ],
        "solutions": {
            "brute": {
                "intuition": "Keep sorted list.",
                "algorithm": "Insert and sort",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(n)"
                },
                "code": {
                    "python": "class MedianFinder:\n    def __init__(self):\n        self.nums = []\n    def addNum(self, num):\n        import bisect\n        bisect.insort(self.nums, num)\n    def findMedian(self):\n        n = len(self.nums)\n        if n % 2 == 1:\n            return self.nums[n // 2]\n        return (self.nums[n // 2 - 1] + self.nums[n // 2]) / 2",
                    "java": "class MedianFinder { List<Integer> nums = new ArrayList<>(); public void addNum(int num) { int idx = Collections.binarySearch(nums, num); if (idx < 0) idx = -(idx + 1); nums.add(idx, num); } public double findMedian() { int n = nums.size(); if (n % 2 == 1) return nums.get(n / 2); return (nums.get(n / 2 - 1) + nums.get(n / 2)) / 2.0; } }",
                    "cpp": "class MedianFinder { vector<int> nums; public: void addNum(int num) { nums.insert(lower_bound(nums.begin(), nums.end(), num), num); } double findMedian() { int n = nums.size(); if (n % 2 == 1) return nums[n / 2]; return (nums[n / 2 - 1] + nums[n / 2]) / 2.0; } };"
                }
            },
            "optimized": {
                "intuition": "Two heaps.",
                "algorithm": "Max heap for lower, min heap for upper",
                "complexity": {
                    "time": "O(log n)",
                    "space": "O(n)"
                },
                "code": {
                    "python": "class MedianFinder:\n    def __init__(self):\n        import heapq\n        self.small = []  # max heap (negated)\n        self.large = []  # min heap\n    def addNum(self, num):\n        import heapq\n        heapq.heappush(self.small, -num)\n        heapq.heappush(self.large, -heapq.heappop(self.small))\n        if len(self.large) > len(self.small):\n            heapq.heappush(self.small, -heapq.heappop(self.large))\n    def findMedian(self):\n        if len(self.small) > len(self.large):\n            return -self.small[0]\n        return (-self.small[0] + self.large[0]) / 2",
                    "java": "class MedianFinder { PriorityQueue<Integer> small = new PriorityQueue<>(Collections.reverseOrder()); PriorityQueue<Integer> large = new PriorityQueue<>(); public void addNum(int num) { small.offer(num); large.offer(small.poll()); if (large.size() > small.size()) small.offer(large.poll()); } public double findMedian() { if (small.size() > large.size()) return small.peek(); return (small.peek() + large.peek()) / 2.0; } }",
                    "cpp": "class MedianFinder { priority_queue<int> small; priority_queue<int, vector<int>, greater<int>> large; public: void addNum(int num) { small.push(num); large.push(small.top()); small.pop(); if (large.size() > small.size()) { small.push(large.top()); large.pop(); } } double findMedian() { if (small.size() > large.size()) return small.top(); return (small.top() + large.top()) / 2.0; } };"
                }
            }
        }
    },
    "design-add-and-search-words-data-structure": {
        "description": "Design word dictionary with wildcard search.",
        "examples": [
            {
                "input": "[\"WordDictionary\",\"addWord\",\"search\"]",
                "output": "[null,null,true]"
            }
        ],
        "constraints": [
            "1 <= word.length <= 25"
        ],
        "solutions": {
            "brute": {
                "intuition": "Store words in list.",
                "algorithm": "Linear search with regex",
                "complexity": {
                    "time": "O(n * m)",
                    "space": "O(n)"
                },
                "code": {
                    "python": "class WordDictionary:\n    def __init__(self):\n        self.words = []\n    def addWord(self, word):\n        self.words.append(word)\n    def search(self, word):\n        import re\n        pattern = '^' + word.replace('.', '.') + '$'\n        return any(re.match(pattern, w) for w in self.words)",
                    "java": "class WordDictionary { List<String> words = new ArrayList<>(); public void addWord(String word) { words.add(word); } public boolean search(String word) { String pattern = \"^\" + word + \"$\"; for (String w : words) { if (w.length() == word.length() && w.matches(pattern)) return true; } return false; } }",
                    "cpp": "class WordDictionary { vector<string> words; public: void addWord(string word) { words.push_back(word); } bool search(string word) { for (auto& w : words) { if (w.size() != word.size()) continue; bool match = true; for (int i = 0; i < w.size() && match; i++) { if (word[i] != '.' && w[i] != word[i]) match = false; } if (match) return true; } return false; } };"
                }
            },
            "optimized": {
                "intuition": "Trie with DFS for wildcards.",
                "algorithm": "Trie-based search",
                "complexity": {
                    "time": "O(m)",
                    "space": "O(n*m)"
                },
                "code": {
                    "python": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.end = False\n\nclass WordDictionary:\n    def __init__(self):\n        self.root = TrieNode()\n    def addWord(self, word):\n        node = self.root\n        for c in word:\n            if c not in node.children:\n                node.children[c] = TrieNode()\n            node = node.children[c]\n        node.end = True\n    def search(self, word):\n        def dfs(node, i):\n            if i == len(word):\n                return node.end\n            if word[i] == '.':\n                return any(dfs(child, i + 1) for child in node.children.values())\n            if word[i] not in node.children:\n                return False\n            return dfs(node.children[word[i]], i + 1)\n        return dfs(self.root, 0)",
                    "java": "class WordDictionary { class TrieNode { TrieNode[] children = new TrieNode[26]; boolean end; } TrieNode root = new TrieNode(); public void addWord(String word) { TrieNode node = root; for (char c : word.toCharArray()) { if (node.children[c - 'a'] == null) node.children[c - 'a'] = new TrieNode(); node = node.children[c - 'a']; } node.end = true; } public boolean search(String word) { return dfs(root, word, 0); } boolean dfs(TrieNode node, String word, int i) { if (i == word.length()) return node.end; char c = word.charAt(i); if (c == '.') { for (TrieNode child : node.children) if (child != null && dfs(child, word, i + 1)) return true; return false; } if (node.children[c - 'a'] == null) return false; return dfs(node.children[c - 'a'], word, i + 1); } }",
                    "cpp": "class WordDictionary { struct TrieNode { TrieNode* children[26] = {}; bool end = false; }; TrieNode* root = new TrieNode(); public: void addWord(string word) { TrieNode* node = root; for (char c : word) { if (!node->children[c - 'a']) node->children[c - 'a'] = new TrieNode(); node = node->children[c - 'a']; } node->end = true; } bool search(string word) { return dfs(root, word, 0); } bool dfs(TrieNode* node, string& word, int i) { if (i == word.size()) return node->end; if (word[i] == '.') { for (auto child : node->children) if (child && dfs(child, word, i + 1)) return true; return false; } if (!node->children[word[i] - 'a']) return false; return dfs(node->children[word[i] - 'a'], word, i + 1); } };"
                }
            }
        }
    },
    "word-search-ii": {
        "description": "Find all words from dictionary in grid.",
        "examples": [
            {
                "input": "board = [[\"o\",\"a\",\"a\",\"n\"],...], words = [\"oath\",\"pea\",\"eat\",\"rain\"]",
                "output": "[\"eat\",\"oath\"]"
            }
        ],
        "constraints": [
            "m == board.length",
            "n == board[i].length"
        ],
        "solutions": {
            "brute": {
                "intuition": "Run word search for each word.",
                "algorithm": "DFS for each word",
                "complexity": {
                    "time": "O(W * m*n * 4^L)",
                    "space": "O(L)"
                },
                "code": {
                    "python": "class Solution:\n    def findWords(self, board, words):\n        result = []\n        for word in words:\n            if self.exist(board, word):\n                result.append(word)\n        return result\n    def exist(self, board, word):\n        m, n = len(board), len(board[0])\n        def dfs(i, j, k):\n            if k == len(word): return True\n            if i < 0 or i >= m or j < 0 or j >= n or board[i][j] != word[k]: return False\n            temp, board[i][j] = board[i][j], '#'\n            found = any(dfs(i+di, j+dj, k+1) for di, dj in [(0,1),(0,-1),(1,0),(-1,0)])\n            board[i][j] = temp\n            return found\n        return any(dfs(i, j, 0) for i in range(m) for j in range(n))",
                    "java": "class Solution { public List<String> findWords(char[][] board, String[] words) { List<String> res = new ArrayList<>(); for (String w : words) if (exist(board, w)) res.add(w); return res; } boolean exist(char[][] b, String w) { for (int i = 0; i < b.length; i++) for (int j = 0; j < b[0].length; j++) if (dfs(b, w, i, j, 0)) return true; return false; } boolean dfs(char[][] b, String w, int i, int j, int k) { if (k == w.length()) return true; if (i < 0 || i >= b.length || j < 0 || j >= b[0].length || b[i][j] != w.charAt(k)) return false; char t = b[i][j]; b[i][j] = '#'; boolean f = dfs(b,w,i+1,j,k+1) || dfs(b,w,i-1,j,k+1) || dfs(b,w,i,j+1,k+1) || dfs(b,w,i,j-1,k+1); b[i][j] = t; return f; } }",
                    "cpp": "class Solution { public: vector<string> findWords(vector<vector<char>>& board, vector<string>& words) { vector<string> res; for (auto& w : words) if (exist(board, w)) res.push_back(w); return res; } bool exist(vector<vector<char>>& b, string& w) { for (int i = 0; i < b.size(); i++) for (int j = 0; j < b[0].size(); j++) if (dfs(b, w, i, j, 0)) return true; return false; } bool dfs(vector<vector<char>>& b, string& w, int i, int j, int k) { if (k == w.size()) return true; if (i < 0 || i >= b.size() || j < 0 || j >= b[0].size() || b[i][j] != w[k]) return false; char t = b[i][j]; b[i][j] = '#'; bool f = dfs(b,w,i+1,j,k+1) || dfs(b,w,i-1,j,k+1) || dfs(b,w,i,j+1,k+1) || dfs(b,w,i,j-1,k+1); b[i][j] = t; return f; } };"
                }
            },
            "optimized": {
                "intuition": "Build trie from words, DFS once.",
                "algorithm": "Trie + DFS",
                "complexity": {
                    "time": "O(m*n * 4^L)",
                    "space": "O(W*L)"
                },
                "code": {
                    "python": "class Solution:\n    def findWords(self, board, words):\n        trie = {}\n        for w in words:\n            node = trie\n            for c in w:\n                node = node.setdefault(c, {})\n            node['$'] = w\n        m, n = len(board), len(board[0])\n        result = []\n        def dfs(i, j, node):\n            c = board[i][j]\n            if c not in node: return\n            nxt = node[c]\n            if '$' in nxt:\n                result.append(nxt['$'])\n                del nxt['$']\n            board[i][j] = '#'\n            for di, dj in [(0,1),(0,-1),(1,0),(-1,0)]:\n                ni, nj = i+di, j+dj\n                if 0 <= ni < m and 0 <= nj < n and board[ni][nj] != '#':\n                    dfs(ni, nj, nxt)\n            board[i][j] = c\n        for i in range(m):\n            for j in range(n):\n                dfs(i, j, trie)\n        return result",
                    "java": "class Solution { class TrieNode { TrieNode[] children = new TrieNode[26]; String word; } public List<String> findWords(char[][] board, String[] words) { TrieNode root = new TrieNode(); for (String w : words) { TrieNode node = root; for (char c : w.toCharArray()) { if (node.children[c-'a'] == null) node.children[c-'a'] = new TrieNode(); node = node.children[c-'a']; } node.word = w; } List<String> res = new ArrayList<>(); for (int i = 0; i < board.length; i++) for (int j = 0; j < board[0].length; j++) dfs(board, i, j, root, res); return res; } void dfs(char[][] b, int i, int j, TrieNode node, List<String> res) { if (i < 0 || i >= b.length || j < 0 || j >= b[0].length || b[i][j] == '#') return; char c = b[i][j]; if (node.children[c-'a'] == null) return; node = node.children[c-'a']; if (node.word != null) { res.add(node.word); node.word = null; } b[i][j] = '#'; dfs(b,i+1,j,node,res); dfs(b,i-1,j,node,res); dfs(b,i,j+1,node,res); dfs(b,i,j-1,node,res); b[i][j] = c; } }",
                    "cpp": "class Solution { struct TrieNode { TrieNode* children[26] = {}; string word; }; public: vector<string> findWords(vector<vector<char>>& board, vector<string>& words) { TrieNode* root = new TrieNode(); for (auto& w : words) { TrieNode* node = root; for (char c : w) { if (!node->children[c-'a']) node->children[c-'a'] = new TrieNode(); node = node->children[c-'a']; } node->word = w; } vector<string> res; for (int i = 0; i < board.size(); i++) for (int j = 0; j < board[0].size(); j++) dfs(board, i, j, root, res); return res; } void dfs(vector<vector<char>>& b, int i, int j, TrieNode* node, vector<string>& res) { if (i < 0 || i >= b.size() || j < 0 || j >= b[0].size() || b[i][j] == '#') return; char c = b[i][j]; if (!node->children[c-'a']) return; node = node->children[c-'a']; if (!node->word.empty()) { res.push_back(node->word); node->word = \"\"; } b[i][j] = '#'; dfs(b,i+1,j,node,res); dfs(b,i-1,j,node,res); dfs(b,i,j+1,node,res); dfs(b,i,j-1,node,res); b[i][j] = c; } };"
                }
            }
        }
    },
    "serialize-and-deserialize-binary-tree": {
        "description": `<p>Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.</p><p>Design an algorithm to <strong>serialize and deserialize a binary tree</strong>. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.</p><p><strong>Approach 1 (BFS):</strong> Use <strong>level-order traversal</strong> to serialize, including null nodes. Deserialize by reconstructing level by level using a queue.</p><p><strong>Approach 2 (DFS - Preferred):</strong> Use <strong>preorder traversal</strong> with markers for null nodes. This is more compact and easier to deserialize recursively.</p>`,
        "examples": [
            {
                "input": "root = [1,2,3,null,null,4,5]",
                "output": "[1,2,3,null,null,4,5]",
                "explanation": "Serialize the tree to a string representation, then deserialize back to the original structure."
            },
            {
                "input": "root = []",
                "output": "[]",
                "explanation": "Empty tree serializes to empty representation."
            },
            {
                "input": "root = [1]",
                "output": "[1]",
                "explanation": "Single node tree."
            }
        ],
        "constraints": [
            "<code>The number of nodes in the tree is in the range [0, 10<sup>4</sup>].</code>",
            "<code>-1000 <= Node.val <= 1000</code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "Level order traversal.",
                "algorithm": "BFS serialization",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(n)"
                },
                "code": {
                    "python": "class Codec:\n    def serialize(self, root):\n        if not root: return '[]'\n        from collections import deque\n        q = deque([root])\n        result = []\n        while q:\n            node = q.popleft()\n            if node:\n                result.append(str(node.val))\n                q.append(node.left)\n                q.append(node.right)\n            else:\n                result.append('null')\n        return '[' + ','.join(result) + ']'\n    def deserialize(self, data):\n        if data == '[]': return None\n        vals = data[1:-1].split(',')\n        root = TreeNode(int(vals[0]))\n        from collections import deque\n        q = deque([root])\n        i = 1\n        while q:\n            node = q.popleft()\n            if vals[i] != 'null':\n                node.left = TreeNode(int(vals[i]))\n                q.append(node.left)\n            i += 1\n            if vals[i] != 'null':\n                node.right = TreeNode(int(vals[i]))\n                q.append(node.right)\n            i += 1\n        return root",
                    "java": "public class Codec { public String serialize(TreeNode root) { if (root == null) return \"[]\"; StringBuilder sb = new StringBuilder(\"[\"); Queue<TreeNode> q = new LinkedList<>(); q.offer(root); while (!q.isEmpty()) { TreeNode n = q.poll(); if (n != null) { sb.append(n.val).append(\",\"); q.offer(n.left); q.offer(n.right); } else sb.append(\"null,\"); } sb.setLength(sb.length() - 1); return sb.append(\"]\").toString(); } public TreeNode deserialize(String data) { if (data.equals(\"[]\")) return null; String[] vals = data.substring(1, data.length()-1).split(\",\"); TreeNode root = new TreeNode(Integer.parseInt(vals[0])); Queue<TreeNode> q = new LinkedList<>(); q.offer(root); int i = 1; while (!q.isEmpty()) { TreeNode n = q.poll(); if (!vals[i].equals(\"null\")) { n.left = new TreeNode(Integer.parseInt(vals[i])); q.offer(n.left); } i++; if (!vals[i].equals(\"null\")) { n.right = new TreeNode(Integer.parseInt(vals[i])); q.offer(n.right); } i++; } return root; } }",
                    "cpp": "class Codec { public: string serialize(TreeNode* root) { if (!root) return \"[]\"; string res = \"[\"; queue<TreeNode*> q; q.push(root); while (!q.empty()) { auto n = q.front(); q.pop(); if (n) { res += to_string(n->val) + \",\"; q.push(n->left); q.push(n->right); } else res += \"null,\"; } res.back() = ']'; return res; } TreeNode* deserialize(string data) { if (data == \"[]\") return nullptr; data = data.substr(1, data.size()-2); vector<string> vals; stringstream ss(data); string item; while (getline(ss, item, ',')) vals.push_back(item); TreeNode* root = new TreeNode(stoi(vals[0])); queue<TreeNode*> q; q.push(root); int i = 1; while (!q.empty()) { auto n = q.front(); q.pop(); if (vals[i] != \"null\") { n->left = new TreeNode(stoi(vals[i])); q.push(n->left); } i++; if (vals[i] != \"null\") { n->right = new TreeNode(stoi(vals[i])); q.push(n->right); } i++; } return root; } };"
                }
            },
            "optimized": {
                "intuition": "Preorder traversal.",
                "algorithm": "DFS serialization",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(n)"
                },
                "code": {
                    "python": "class Codec:\n    def serialize(self, root):\n        result = []\n        def dfs(node):\n            if not node:\n                result.append('N')\n                return\n            result.append(str(node.val))\n            dfs(node.left)\n            dfs(node.right)\n        dfs(root)\n        return ','.join(result)\n    def deserialize(self, data):\n        vals = data.split(',')\n        self.i = 0\n        def dfs():\n            if vals[self.i] == 'N':\n                self.i += 1\n                return None\n            node = TreeNode(int(vals[self.i]))\n            self.i += 1\n            node.left = dfs()\n            node.right = dfs()\n            return node\n        return dfs()",
                    "java": "public class Codec { public String serialize(TreeNode root) { StringBuilder sb = new StringBuilder(); dfs(root, sb); return sb.toString(); } void dfs(TreeNode node, StringBuilder sb) { if (node == null) { sb.append(\"N,\"); return; } sb.append(node.val).append(\",\"); dfs(node.left, sb); dfs(node.right, sb); } int i = 0; public TreeNode deserialize(String data) { String[] vals = data.split(\",\"); i = 0; return build(vals); } TreeNode build(String[] vals) { if (vals[i].equals(\"N\")) { i++; return null; } TreeNode node = new TreeNode(Integer.parseInt(vals[i++])); node.left = build(vals); node.right = build(vals); return node; } }",
                    "cpp": "class Codec { public: string serialize(TreeNode* root) { string res; dfs(root, res); return res; } void dfs(TreeNode* node, string& res) { if (!node) { res += \"N,\"; return; } res += to_string(node->val) + \",\"; dfs(node->left, res); dfs(node->right, res); } int i = 0; TreeNode* deserialize(string data) { vector<string> vals; stringstream ss(data); string item; while (getline(ss, item, ',')) vals.push_back(item); i = 0; return build(vals); } TreeNode* build(vector<string>& vals) { if (vals[i] == \"N\") { i++; return nullptr; } TreeNode* node = new TreeNode(stoi(vals[i++])); node->left = build(vals); node->right = build(vals); return node; } };"
                }
            }
        }
    },
    "construct-binary-tree-from-preorder-and-inorder-traversal": {
        "description": `<p>Given two integer arrays <code>preorder</code> and <code>inorder</code> where <code>preorder</code> is the preorder traversal of a binary tree and <code>inorder</code> is the inorder traversal of the same tree, construct and return <em>the binary tree</em>.</p><p><strong>Key Insights:</strong></p><ul><li>The <strong>first element</strong> of preorder is always the root</li><li>Find this root in inorder array - everything to its <strong>left</strong> is the left subtree, everything to its <strong>right</strong> is the right subtree</li><li>Recursively build left and right subtrees using the same logic</li></ul><p><strong>Optimization:</strong> Use a hash map to store inorder indices for O(1) lookup, reducing time complexity from O(n¬≤) to O(n).</p>`,
        "examples": [
            {
                "input": "preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]",
                "output": "[3,9,20,null,null,15,7]",
                "explanation": "Root is 3 (first in preorder). In inorder, 9 is left subtree, [15,20,7] is right subtree."
            },
            {
                "input": "preorder = [-1], inorder = [-1]",
                "output": "[-1]",
                "explanation": "Single node tree."
            },
            {
                "input": "preorder = [1,2], inorder = [2,1]",
                "output": "[1,2]",
                "explanation": "Root is 1, left child is 2."
            }
        ],
        "constraints": [
            "<code>1 <= preorder.length <= 3000</code>",
            "<code>inorder.length == preorder.length</code>",
            "<code>-3000 <= preorder[i], inorder[i] <= 3000</code>",
            "<code>preorder</code> and <code>inorder</code> consist of <strong>unique</strong> values.",
            "<code>Each value of inorder also appears in preorder.</code>",
            "<code>preorder</code> is <strong>guaranteed</strong> to be the preorder traversal of the tree.",
            "<code>inorder</code> is <strong>guaranteed</strong> to be the inorder traversal of the tree."
        ],
        "solutions": {
            "brute": {
                "intuition": "First of preorder is root.",
                "algorithm": "Recursive construction",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)"
                },
                "code": {
                    "python": "class Solution:\n    def buildTree(self, preorder, inorder):\n        if not preorder: return None\n        root = TreeNode(preorder[0])\n        mid = inorder.index(preorder[0])\n        root.left = self.buildTree(preorder[1:mid+1], inorder[:mid])\n        root.right = self.buildTree(preorder[mid+1:], inorder[mid+1:])\n        return root",
                    "java": "class Solution { public TreeNode buildTree(int[] preorder, int[] inorder) { return build(preorder, inorder, 0, 0, inorder.length - 1); } TreeNode build(int[] pre, int[] in, int pStart, int iStart, int iEnd) { if (pStart > pre.length - 1 || iStart > iEnd) return null; TreeNode root = new TreeNode(pre[pStart]); int mid = 0; for (int i = iStart; i <= iEnd; i++) if (in[i] == root.val) { mid = i; break; } root.left = build(pre, in, pStart + 1, iStart, mid - 1); root.right = build(pre, in, pStart + mid - iStart + 1, mid + 1, iEnd); return root; } }",
                    "cpp": "class Solution { public: TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) { return build(preorder, inorder, 0, 0, inorder.size() - 1); } TreeNode* build(vector<int>& pre, vector<int>& in, int pStart, int iStart, int iEnd) { if (pStart > pre.size() - 1 || iStart > iEnd) return nullptr; TreeNode* root = new TreeNode(pre[pStart]); int mid = 0; for (int i = iStart; i <= iEnd; i++) if (in[i] == root->val) { mid = i; break; } root->left = build(pre, in, pStart + 1, iStart, mid - 1); root->right = build(pre, in, pStart + mid - iStart + 1, mid + 1, iEnd); return root; } };"
                }
            },
            "optimized": {
                "intuition": "Use hash map for O(1) index lookup.",
                "algorithm": "HashMap optimization",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(n)"
                },
                "code": {
                    "python": "class Solution:\n    def buildTree(self, preorder, inorder):\n        inorderIdx = {v: i for i, v in enumerate(inorder)}\n        self.preIdx = 0\n        def build(left, right):\n            if left > right: return None\n            rootVal = preorder[self.preIdx]\n            self.preIdx += 1\n            root = TreeNode(rootVal)\n            mid = inorderIdx[rootVal]\n            root.left = build(left, mid - 1)\n            root.right = build(mid + 1, right)\n            return root\n        return build(0, len(inorder) - 1)",
                    "java": "class Solution { Map<Integer, Integer> inorderIdx = new HashMap<>(); int preIdx = 0; public TreeNode buildTree(int[] preorder, int[] inorder) { for (int i = 0; i < inorder.length; i++) inorderIdx.put(inorder[i], i); return build(preorder, 0, inorder.length - 1); } TreeNode build(int[] pre, int left, int right) { if (left > right) return null; int rootVal = pre[preIdx++]; TreeNode root = new TreeNode(rootVal); int mid = inorderIdx.get(rootVal); root.left = build(pre, left, mid - 1); root.right = build(pre, mid + 1, right); return root; } }",
                    "cpp": "class Solution { unordered_map<int, int> inorderIdx; int preIdx = 0; public: TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) { for (int i = 0; i < inorder.size(); i++) inorderIdx[inorder[i]] = i; return build(preorder, 0, inorder.size() - 1); } TreeNode* build(vector<int>& pre, int left, int right) { if (left > right) return nullptr; int rootVal = pre[preIdx++]; TreeNode* root = new TreeNode(rootVal); int mid = inorderIdx[rootVal]; root->left = build(pre, left, mid - 1); root->right = build(pre, mid + 1, right); return root; } };"
                }
            }
        }
    },
    "binary-tree-maximum-path-sum": {
        "description": `<p>A <strong>path</strong> in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence <strong>at most once</strong>. Note that the path does not need to pass through the root.</p><p>The <strong>path sum</strong> of a path is the sum of the node's values in the path.</p><p>Given the <code>root</code> of a binary tree, return <em>the maximum <strong>path sum</strong> of any <strong>non-empty</strong> path</em>.</p><p><strong>Approach:</strong> Use DFS to compute the maximum <strong>gain</strong> from each subtree. At each node, the maximum path sum through that node is <code>node.val + leftGain + rightGain</code>. However, when returning to the parent, we can only include one branch: <code>node.val + max(leftGain, rightGain)</code>. Use a global variable to track the maximum path sum seen.</p><p><strong>Key Insight:</strong> Take <code>max(gain, 0)</code> to handle negative values - we can choose not to include a negative subtree.</p>`,
        "examples": [
            {
                "input": "root = [1,2,3]",
                "output": "6",
                "explanation": "The optimal path is 2 -> 1 -> 3 with sum 2 + 1 + 3 = 6."
            },
            {
                "input": "root = [-10,9,20,null,null,15,7]",
                "output": "42",
                "explanation": "The optimal path is 15 -> 20 -> 7 with sum 15 + 20 + 7 = 42."
            },
            {
                "input": "root = [1,-2,-3]",
                "output": "1",
                "explanation": "The optimal path is just the root node itself."
            }
        ],
        "constraints": [
            "<code>The number of nodes in the tree is in the range [1, 3 * 10<sup>4</sup>].</code>",
            "<code>-1000 <= Node.val <= 1000</code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "Check all paths.",
                "algorithm": "DFS with global max",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(h)"
                },
                "code": {
                    "python": "class Solution:\n    def maxPathSum(self, root):\n        self.maxSum = float('-inf')\n        def dfs(node):\n            if not node: return 0\n            left = max(0, dfs(node.left))\n            right = max(0, dfs(node.right))\n            self.maxSum = max(self.maxSum, left + right + node.val)\n            return max(left, right) + node.val\n        dfs(root)\n        return self.maxSum",
                    "java": "class Solution { int maxSum = Integer.MIN_VALUE; public int maxPathSum(TreeNode root) { dfs(root); return maxSum; } int dfs(TreeNode node) { if (node == null) return 0; int left = Math.max(0, dfs(node.left)); int right = Math.max(0, dfs(node.right)); maxSum = Math.max(maxSum, left + right + node.val); return Math.max(left, right) + node.val; } }",
                    "cpp": "class Solution { int maxSum = INT_MIN; public: int maxPathSum(TreeNode* root) { dfs(root); return maxSum; } int dfs(TreeNode* node) { if (!node) return 0; int left = max(0, dfs(node->left)); int right = max(0, dfs(node->right)); maxSum = max(maxSum, left + right + node->val); return max(left, right) + node->val; } };"
                }
            },
            "optimized": {
                "intuition": "Same approach is optimal.",
                "algorithm": "Single DFS",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(h)"
                },
                "code": {
                    "python": "class Solution:\n    def maxPathSum(self, root):\n        result = [float('-inf')]\n        def gain(node):\n            if not node: return 0\n            leftGain = max(gain(node.left), 0)\n            rightGain = max(gain(node.right), 0)\n            pathSum = node.val + leftGain + rightGain\n            result[0] = max(result[0], pathSum)\n            return node.val + max(leftGain, rightGain)\n        gain(root)\n        return result[0]",
                    "java": "class Solution { int result = Integer.MIN_VALUE; public int maxPathSum(TreeNode root) { gain(root); return result; } int gain(TreeNode node) { if (node == null) return 0; int leftGain = Math.max(gain(node.left), 0); int rightGain = Math.max(gain(node.right), 0); int pathSum = node.val + leftGain + rightGain; result = Math.max(result, pathSum); return node.val + Math.max(leftGain, rightGain); } }",
                    "cpp": "class Solution { int result = INT_MIN; public: int maxPathSum(TreeNode* root) { gain(root); return result; } int gain(TreeNode* node) { if (!node) return 0; int leftGain = max(gain(node->left), 0); int rightGain = max(gain(node->right), 0); int pathSum = node->val + leftGain + rightGain; result = max(result, pathSum); return node->val + max(leftGain, rightGain); } };"
                }
            }
        }
    },
    "lowest-common-ancestor-of-a-binary-tree": {
        "description": `<p>Given a binary tree, find the <strong>lowest common ancestor (LCA)</strong> of two given nodes in the tree.</p><p>According to the definition of LCA on Wikipedia: The lowest common ancestor is defined between two nodes <code>p</code> and <code>q</code> as the lowest node in <code>T</code> that has both <code>p</code> and <code>q</code> as descendants (where we allow <strong>a node to be a descendant of itself</strong>).</p><p><strong>Optimal Approach:</strong> Use recursive DFS. If the current node is <code>null</code>, <code>p</code>, or <code>q</code>, return it. Recursively search left and right subtrees. If both return non-null, the current node is the LCA. Otherwise, return the non-null child (the one containing both p and q).</p><p><strong>Key Insight:</strong> The LCA is the first node where paths to p and q diverge, or one of the nodes if it's an ancestor of the other.</p>`,
        "examples": [
            {
                "input": "root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1",
                "output": "3",
                "explanation": "The LCA of nodes 5 and 1 is 3."
            },
            {
                "input": "root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4",
                "output": "5",
                "explanation": "The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself."
            },
            {
                "input": "root = [1,2], p = 1, q = 2",
                "output": "1",
                "explanation": "The LCA of 1 and 2 is 1."
            }
        ],
        "constraints": [
            "<code>The number of nodes in the tree is in the range [2, 10<sup>5</sup>].</code>",
            "<code>-10<sup>9</sup> <= Node.val <= 10<sup>9</sup></code>",
            "<code>All Node.val are unique.</code>",
            "<code>p != q</code>",
            "<code>p and q will exist in the tree.</code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "Find paths to both nodes.",
                "algorithm": "Store ancestors",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(n)"
                },
                "code": {
                    "python": "class Solution:\n    def lowestCommonAncestor(self, root, p, q):\n        def findPath(node, target, path):\n            if not node: return False\n            path.append(node)\n            if node == target: return True\n            if findPath(node.left, target, path) or findPath(node.right, target, path):\n                return True\n            path.pop()\n            return False\n        pathP, pathQ = [], []\n        findPath(root, p, pathP)\n        findPath(root, q, pathQ)\n        lca = None\n        for i in range(min(len(pathP), len(pathQ))):\n            if pathP[i] == pathQ[i]:\n                lca = pathP[i]\n        return lca",
                    "java": "class Solution { public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { List<TreeNode> pathP = new ArrayList<>(), pathQ = new ArrayList<>(); findPath(root, p, pathP); findPath(root, q, pathQ); TreeNode lca = null; for (int i = 0; i < Math.min(pathP.size(), pathQ.size()); i++) { if (pathP.get(i) == pathQ.get(i)) lca = pathP.get(i); } return lca; } boolean findPath(TreeNode node, TreeNode target, List<TreeNode> path) { if (node == null) return false; path.add(node); if (node == target) return true; if (findPath(node.left, target, path) || findPath(node.right, target, path)) return true; path.remove(path.size() - 1); return false; } }",
                    "cpp": "class Solution { public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { vector<TreeNode*> pathP, pathQ; findPath(root, p, pathP); findPath(root, q, pathQ); TreeNode* lca = nullptr; for (int i = 0; i < min(pathP.size(), pathQ.size()); i++) { if (pathP[i] == pathQ[i]) lca = pathP[i]; } return lca; } bool findPath(TreeNode* node, TreeNode* target, vector<TreeNode*>& path) { if (!node) return false; path.push_back(node); if (node == target) return true; if (findPath(node->left, target, path) || findPath(node->right, target, path)) return true; path.pop_back(); return false; } };"
                }
            },
            "optimized": {
                "intuition": "Single DFS traversal.",
                "algorithm": "Return node when found",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(h)"
                },
                "code": {
                    "python": "class Solution:\n    def lowestCommonAncestor(self, root, p, q):\n        if not root or root == p or root == q:\n            return root\n        left = self.lowestCommonAncestor(root.left, p, q)\n        right = self.lowestCommonAncestor(root.right, p, q)\n        if left and right:\n            return root\n        return left or right",
                    "java": "class Solution { public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { if (root == null || root == p || root == q) return root; TreeNode left = lowestCommonAncestor(root.left, p, q); TreeNode right = lowestCommonAncestor(root.right, p, q); if (left != null && right != null) return root; return left != null ? left : right; } }",
                    "cpp": "class Solution { public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { if (!root || root == p || root == q) return root; TreeNode* left = lowestCommonAncestor(root->left, p, q); TreeNode* right = lowestCommonAncestor(root->right, p, q); if (left && right) return root; return left ? left : right; } };"
                }
            }
        }
    },
    "kth-smallest-element-in-a-bst": {
        "description": `<p>Given the <code>root</code> of a binary search tree, and an integer <code>k</code>, return <em>the</em> <code>k<sup>th</sup></code> <em>smallest value (<strong>1-indexed</strong>) of all the values of the nodes in the tree</em>.</p><p><strong>Key Insight:</strong> <strong>Inorder traversal of a BST produces values in sorted order</strong>. We can perform inorder traversal and return the kth element.</p><p><strong>Optimal Approach:</strong> Use <strong>iterative inorder traversal</strong> with a stack. Stop as soon as we've visited k nodes, avoiding processing the entire tree. This gives O(H + k) time complexity where H is the tree height.</p>`,
        "examples": [
            {
                "input": "root = [3,1,4,null,2], k = 1",
                "output": "1",
                "explanation": "Inorder traversal: [1,2,3,4]. The 1st smallest is 1."
            },
            {
                "input": "root = [5,3,6,2,4,null,null,1], k = 3",
                "output": "3",
                "explanation": "Inorder traversal: [1,2,3,4,5,6]. The 3rd smallest is 3."
            },
            {
                "input": "root = [1], k = 1",
                "output": "1",
                "explanation": "Single node BST."
            }
        ],
        "constraints": [
            "<code>The number of nodes in the tree is n.</code>",
            "<code>1 <= k <= n <= 10<sup>4</sup></code>",
            "<code>0 <= Node.val <= 10<sup>4</sup></code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "Inorder traversal to list.",
                "algorithm": "Collect and index",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(n)"
                },
                "code": {
                    "python": "class Solution:\n    def kthSmallest(self, root, k):\n        result = []\n        def inorder(node):\n            if node:\n                inorder(node.left)\n                result.append(node.val)\n                inorder(node.right)\n        inorder(root)\n        return result[k - 1]",
                    "java": "class Solution { List<Integer> result = new ArrayList<>(); public int kthSmallest(TreeNode root, int k) { inorder(root); return result.get(k - 1); } void inorder(TreeNode node) { if (node == null) return; inorder(node.left); result.add(node.val); inorder(node.right); } }",
                    "cpp": "class Solution { vector<int> result; public: int kthSmallest(TreeNode* root, int k) { inorder(root); return result[k - 1]; } void inorder(TreeNode* node) { if (!node) return; inorder(node->left); result.push_back(node->val); inorder(node->right); } };"
                }
            },
            "optimized": {
                "intuition": "Stop at kth element.",
                "algorithm": "Iterative inorder",
                "complexity": {
                    "time": "O(H + k)",
                    "space": "O(H)"
                },
                "code": {
                    "python": "class Solution:\n    def kthSmallest(self, root, k):\n        stack = []\n        curr = root\n        while stack or curr:\n            while curr:\n                stack.append(curr)\n                curr = curr.left\n            curr = stack.pop()\n            k -= 1\n            if k == 0:\n                return curr.val\n            curr = curr.right",
                    "java": "class Solution { public int kthSmallest(TreeNode root, int k) { Stack<TreeNode> stack = new Stack<>(); TreeNode curr = root; while (!stack.isEmpty() || curr != null) { while (curr != null) { stack.push(curr); curr = curr.left; } curr = stack.pop(); k--; if (k == 0) return curr.val; curr = curr.right; } return -1; } }",
                    "cpp": "class Solution { public: int kthSmallest(TreeNode* root, int k) { stack<TreeNode*> st; TreeNode* curr = root; while (!st.empty() || curr) { while (curr) { st.push(curr); curr = curr->left; } curr = st.top(); st.pop(); k--; if (k == 0) return curr->val; curr = curr->right; } return -1; } };"
                }
            }
        }
    },
    "count-good-nodes-in-binary-tree": {
        "description": `<p>Given a binary tree <code>root</code>, a node <em>X</em> in the tree is named <strong>good</strong> if in the path from root to <em>X</em> there are no nodes with a value <em>greater than</em> X.</p><p>Return the number of <strong>good</strong> nodes in the binary tree.</p><p><strong>Approach:</strong> Use DFS and pass down the maximum value seen so far on the path from the root. A node is good if its value is greater than or equal to this maximum. Update the maximum and recurse to children.</p>`,
        "examples": [
            {
                "input": "root = [3,1,4,3,null,1,5]",
                "output": "4",
                "explanation": "Good nodes are: root 3, node 4, node 5, and node 3 (in left subtree). Path to left 3: [3,1,3] - 3 >= max(3,1)."
            },
            {
                "input": "root = [3,3,null,4,2]",
                "output": "3",
                "explanation": "Good nodes are: root 3, left 3, and 4. Node 2 is not good because 2 < max(3,3)."
            },
            {
                "input": "root = [1]",
                "output": "1",
                "explanation": "Root is always a good node."
            }
        ],
        "constraints": [
            "<code>The number of nodes in the binary tree is in the range [1, 10<sup>5</sup>].</code>",
            "<code>Each node's value is between [-10<sup>4</sup>, 10<sup>4</sup>].</code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "DFS with max tracking.",
                "algorithm": "Pass max value down",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(h)"
                },
                "code": {
                    "python": "class Solution:\n    def goodNodes(self, root):\n        def dfs(node, maxVal):\n            if not node: return 0\n            count = 1 if node.val >= maxVal else 0\n            maxVal = max(maxVal, node.val)\n            count += dfs(node.left, maxVal)\n            count += dfs(node.right, maxVal)\n            return count\n        return dfs(root, root.val)",
                    "java": "class Solution { public int goodNodes(TreeNode root) { return dfs(root, root.val); } int dfs(TreeNode node, int maxVal) { if (node == null) return 0; int count = node.val >= maxVal ? 1 : 0; maxVal = Math.max(maxVal, node.val); count += dfs(node.left, maxVal); count += dfs(node.right, maxVal); return count; } }",
                    "cpp": "class Solution { public: int goodNodes(TreeNode* root) { return dfs(root, root->val); } int dfs(TreeNode* node, int maxVal) { if (!node) return 0; int count = node->val >= maxVal ? 1 : 0; maxVal = max(maxVal, node->val); count += dfs(node->left, maxVal); count += dfs(node->right, maxVal); return count; } };"
                }
            },
            "optimized": {
                "intuition": "Same approach is optimal.",
                "algorithm": "DFS",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(h)"
                },
                "code": {
                    "python": "class Solution:\n    def goodNodes(self, root):\n        count = 0\n        stack = [(root, float('-inf'))]\n        while stack:\n            node, maxVal = stack.pop()\n            if node.val >= maxVal:\n                count += 1\n            newMax = max(maxVal, node.val)\n            if node.left: stack.append((node.left, newMax))\n            if node.right: stack.append((node.right, newMax))\n        return count",
                    "java": "class Solution { public int goodNodes(TreeNode root) { int count = 0; Stack<Object[]> stack = new Stack<>(); stack.push(new Object[]{root, Integer.MIN_VALUE}); while (!stack.isEmpty()) { Object[] pair = stack.pop(); TreeNode node = (TreeNode)pair[0]; int maxVal = (int)pair[1]; if (node.val >= maxVal) count++; int newMax = Math.max(maxVal, node.val); if (node.left != null) stack.push(new Object[]{node.left, newMax}); if (node.right != null) stack.push(new Object[]{node.right, newMax}); } return count; } }",
                    "cpp": "class Solution { public: int goodNodes(TreeNode* root) { int count = 0; stack<pair<TreeNode*, int>> st; st.push({root, INT_MIN}); while (!st.empty()) { auto [node, maxVal] = st.top(); st.pop(); if (node->val >= maxVal) count++; int newMax = max(maxVal, node->val); if (node->left) st.push({node->left, newMax}); if (node->right) st.push({node->right, newMax}); } return count; } };"
                }
            }
        }
    },
    "validate-binary-search-tree": {
        "description": `<p>Given the <code>root</code> of a binary tree, <em>determine if it is a valid binary search tree (BST)</em>.</p><p>A <strong>valid BST</strong> is defined as follows:</p><ul><li>The left subtree of a node contains only nodes with keys <strong>less than</strong> the node's key.</li><li>The right subtree of a node contains only nodes with keys <strong>greater than</strong> the node's key.</li><li>Both the left and right subtrees must also be binary search trees.</li></ul><p><strong>Approach 1 (Inorder):</strong> Inorder traversal of a BST produces sorted values. Check if the traversal is strictly increasing.</p><p><strong>Approach 2 (Range - Optimal):</strong> Pass valid range [min, max] down the tree. Each node must be in its valid range, and we tighten the range for children: left gets [min, node.val), right gets (node.val, max].</p>`,
        "examples": [
            {
                "input": "root = [2,1,3]",
                "output": "true",
                "explanation": "Left child 1 < root 2 < right child 3. Valid BST."
            },
            {
                "input": "root = [5,1,4,null,null,3,6]",
                "output": "false",
                "explanation": "Root is 5, right child is 4. Since 4 < 5, this violates BST property."
            },
            {
                "input": "root = [5,4,6,null,null,3,7]",
                "output": "false",
                "explanation": "Node 3 is in the right subtree of 5, but 3 < 5."
            }
        ],
        "constraints": [
            "<code>The number of nodes in the tree is in the range [1, 10<sup>4</sup>].</code>",
            "<code>-2<sup>31</sup> <= Node.val <= 2<sup>31</sup> - 1</code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "Inorder should be sorted.",
                "algorithm": "Collect and check sorted",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(n)"
                },
                "code": {
                    "python": "class Solution:\n    def isValidBST(self, root):\n        result = []\n        def inorder(node):\n            if node:\n                inorder(node.left)\n                result.append(node.val)\n                inorder(node.right)\n        inorder(root)\n        for i in range(1, len(result)):\n            if result[i] <= result[i - 1]: return False\n        return True",
                    "java": "class Solution { List<Integer> result = new ArrayList<>(); public boolean isValidBST(TreeNode root) { inorder(root); for (int i = 1; i < result.size(); i++) if (result.get(i) <= result.get(i - 1)) return false; return true; } void inorder(TreeNode node) { if (node == null) return; inorder(node.left); result.add(node.val); inorder(node.right); } }",
                    "cpp": "class Solution { vector<int> result; public: bool isValidBST(TreeNode* root) { inorder(root); for (int i = 1; i < result.size(); i++) if (result[i] <= result[i - 1]) return false; return true; } void inorder(TreeNode* node) { if (!node) return; inorder(node->left); result.push_back(node->val); inorder(node->right); } };"
                }
            },
            "optimized": {
                "intuition": "Pass valid range.",
                "algorithm": "DFS with bounds",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(h)"
                },
                "code": {
                    "python": "class Solution:\n    def isValidBST(self, root):\n        def valid(node, minVal, maxVal):\n            if not node: return True\n            if node.val <= minVal or node.val >= maxVal: return False\n            return valid(node.left, minVal, node.val) and valid(node.right, node.val, maxVal)\n        return valid(root, float('-inf'), float('inf'))",
                    "java": "class Solution { public boolean isValidBST(TreeNode root) { return valid(root, Long.MIN_VALUE, Long.MAX_VALUE); } boolean valid(TreeNode node, long min, long max) { if (node == null) return true; if (node.val <= min || node.val >= max) return false; return valid(node.left, min, node.val) && valid(node.right, node.val, max); } }",
                    "cpp": "class Solution { public: bool isValidBST(TreeNode* root) { return valid(root, LONG_MIN, LONG_MAX); } bool valid(TreeNode* node, long minVal, long maxVal) { if (!node) return true; if (node->val <= minVal || node->val >= maxVal) return false; return valid(node->left, minVal, node->val) && valid(node->right, node->val, maxVal); } };"
                }
            }
        }
    },
    "same-tree": {
        "description": `<p>Given the roots of two binary trees <code>p</code> and <code>q</code>, write a function to check if they are the same or not.</p>
<p>Two binary trees are considered the same if they are structurally identical, and the nodes have the same value.</p>
<p>This is a classic tree problem that can be solved recursively. Two trees are the same if: <strong>(1)</strong> Their root values are equal, <strong>(2)</strong> Their left subtrees are the same, and <strong>(3)</strong> Their right subtrees are the same. Base case: two null trees are considered the same.</p>`,
        "examples": [
            {
                "input": "p = [1,2,3], q = [1,2,3]",
                "output": "true",
                "explanation": "Both trees have the same structure and values."
            },
            {
                "input": "p = [1,2], q = [1,null,2]",
                "output": "false",
                "explanation": "The structure is different: p has left child, q has right child."
            },
            {
                "input": "p = [1,2,1], q = [1,1,2]",
                "output": "false",
                "explanation": "The structure is the same but values are different."
            }
        ],
        "constraints": [
            "The number of nodes in both trees is in the range <code>[0, 100]</code>.",
            "<code>-10<sup>4</sup> <= Node.val <= 10<sup>4</sup></code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "Recursive comparison.",
                "algorithm": "Compare node by node",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(h)"
                },
                "code": {
                    "python": "class Solution:\n    def isSameTree(self, p, q):\n        if not p and not q: return True\n        if not p or not q: return False\n        if p.val != q.val: return False\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)",
                    "java": "class Solution { public boolean isSameTree(TreeNode p, TreeNode q) { if (p == null && q == null) return true; if (p == null || q == null) return false; if (p.val != q.val) return false; return isSameTree(p.left, q.left) && isSameTree(p.right, q.right); } }",
                    "cpp": "class Solution { public: bool isSameTree(TreeNode* p, TreeNode* q) { if (!p && !q) return true; if (!p || !q) return false; if (p->val != q->val) return false; return isSameTree(p->left, q->left) && isSameTree(p->right, q->right); } };"
                }
            },
            "optimized": {
                "intuition": "Iterative BFS.",
                "algorithm": "Level order comparison",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(n)"
                },
                "code": {
                    "python": "class Solution:\n    def isSameTree(self, p, q):\n        from collections import deque\n        queue = deque([(p, q)])\n        while queue:\n            n1, n2 = queue.popleft()\n            if not n1 and not n2: continue\n            if not n1 or not n2 or n1.val != n2.val: return False\n            queue.append((n1.left, n2.left))\n            queue.append((n1.right, n2.right))\n        return True",
                    "java": "class Solution { public boolean isSameTree(TreeNode p, TreeNode q) { Queue<TreeNode[]> queue = new LinkedList<>(); queue.offer(new TreeNode[]{p, q}); while (!queue.isEmpty()) { TreeNode[] pair = queue.poll(); TreeNode n1 = pair[0], n2 = pair[1]; if (n1 == null && n2 == null) continue; if (n1 == null || n2 == null || n1.val != n2.val) return false; queue.offer(new TreeNode[]{n1.left, n2.left}); queue.offer(new TreeNode[]{n1.right, n2.right}); } return true; } }",
                    "cpp": "class Solution { public: bool isSameTree(TreeNode* p, TreeNode* q) { queue<pair<TreeNode*, TreeNode*>> que; que.push({p, q}); while (!que.empty()) { auto [n1, n2] = que.front(); que.pop(); if (!n1 && !n2) continue; if (!n1 || !n2 || n1->val != n2->val) return false; que.push({n1->left, n2->left}); que.push({n1->right, n2->right}); } return true; } };"
                }
            }
        }
    },
    "subtree-of-another-tree": {
        "description": `<p>Given the roots of two binary trees <code>root</code> and <code>subRoot</code>, return <code>true</code> if there is a subtree of <code>root</code> with the same structure and node values of <code>subRoot</code> and <code>false</code> otherwise.</p>
<p>A subtree of a binary tree <code>tree</code> is a tree that consists of a node in <code>tree</code> and all of this node's descendants. The tree <code>tree</code> could also be considered as a subtree of itself.</p>
<p>The approach is to traverse the main tree and check if any node has an identical subtree to <code>subRoot</code>. We reuse the "same tree" logic to check for equality at each potential starting node.</p>`,
        "examples": [
            {
                "input": "root = [3,4,5,1,2], subRoot = [4,1,2]",
                "output": "true",
                "explanation": "The subtree rooted at node 4 in root is identical to subRoot."
            },
            {
                "input": "root = [3,4,5,1,2,null,null,null,null,0], subRoot = [4,1,2]",
                "output": "false",
                "explanation": "The subtree [4,1,2,0] doesn't match subRoot [4,1,2]."
            },
            {
                "input": "root = [1,1], subRoot = [1]",
                "output": "true",
                "explanation": "The entire subRoot is found in root."
            }
        ],
        "constraints": [
            "The number of nodes in the <code>root</code> tree is in the range <code>[1, 2000]</code>.",
            "The number of nodes in the <code>subRoot</code> tree is in the range <code>[1, 1000]</code>.",
            "<code>-10<sup>4</sup> <= root.val <= 10<sup>4</sup></code>",
            "<code>-10<sup>4</sup> <= subRoot.val <= 10<sup>4</sup></code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "Check every node as potential root.",
                "algorithm": "DFS + isSameTree",
                "complexity": {
                    "time": "O(m*n)",
                    "space": "O(h)"
                },
                "code": {
                    "python": "class Solution:\n    def isSubtree(self, root, subRoot):\n        if not root: return False\n        if self.isSameTree(root, subRoot): return True\n        return self.isSubtree(root.left, subRoot) or self.isSubtree(root.right, subRoot)\n    def isSameTree(self, p, q):\n        if not p and not q: return True\n        if not p or not q or p.val != q.val: return False\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)",
                    "java": "class Solution { public boolean isSubtree(TreeNode root, TreeNode subRoot) { if (root == null) return false; if (isSameTree(root, subRoot)) return true; return isSubtree(root.left, subRoot) || isSubtree(root.right, subRoot); } boolean isSameTree(TreeNode p, TreeNode q) { if (p == null && q == null) return true; if (p == null || q == null || p.val != q.val) return false; return isSameTree(p.left, q.left) && isSameTree(p.right, q.right); } }",
                    "cpp": "class Solution { public: bool isSubtree(TreeNode* root, TreeNode* subRoot) { if (!root) return false; if (isSameTree(root, subRoot)) return true; return isSubtree(root->left, subRoot) || isSubtree(root->right, subRoot); } bool isSameTree(TreeNode* p, TreeNode* q) { if (!p && !q) return true; if (!p || !q || p->val != q->val) return false; return isSameTree(p->left, q->left) && isSameTree(p->right, q->right); } };"
                }
            },
            "optimized": {
                "intuition": "Serialize trees and use string matching.",
                "algorithm": "Serialization",
                "complexity": {
                    "time": "O(m+n)",
                    "space": "O(m+n)"
                },
                "code": {
                    "python": "class Solution:\n    def isSubtree(self, root, subRoot):\n        def serialize(node):\n            if not node: return '#'\n            return f',{node.val},{serialize(node.left)},{serialize(node.right)}'\n        return serialize(subRoot) in serialize(root)",
                    "java": "class Solution { public boolean isSubtree(TreeNode root, TreeNode subRoot) { return serialize(root).contains(serialize(subRoot)); } String serialize(TreeNode node) { if (node == null) return \"#\"; return \",\" + node.val + \",\" + serialize(node.left) + \",\" + serialize(node.right); } }",
                    "cpp": "class Solution { public: bool isSubtree(TreeNode* root, TreeNode* subRoot) { return serialize(root).find(serialize(subRoot)) != string::npos; } string serialize(TreeNode* node) { if (!node) return \"#\"; return \",\" + to_string(node->val) + \",\" + serialize(node->left) + \",\" + serialize(node->right); } };"
                }
            }
        }
    },
    "diameter-of-binary-tree": {
        "description": `<p>Given the <code>root</code> of a binary tree, return <em>the length of the <strong>diameter</strong> of the tree</em>.</p>
<p>The <strong>diameter</strong> of a binary tree is the <strong>length</strong> of the longest path between any two nodes in a tree. This path may or may not pass through the <code>root</code>.</p>
<p>The <strong>length</strong> of a path between two nodes is represented by the number of edges between them.</p>
<p>The key insight is that the diameter at any node is the sum of the heights of its left and right subtrees. We track the maximum diameter seen while computing heights in a single DFS traversal.</p>`,
        "examples": [
            {
                "input": "root = [1,2,3,4,5]",
                "output": "3",
                "explanation": "The longest path is [4,2,1,3] or [5,2,1,3] with length 3."
            },
            {
                "input": "root = [1,2]",
                "output": "1",
                "explanation": "The only path has length 1."
            },
            {
                "input": "root = [1]",
                "output": "0",
                "explanation": "Single node tree has diameter 0."
            }
        ],
        "constraints": [
            "The number of nodes in the tree is in the range <code>[1, 10<sup>4</sup>]</code>.",
            "<code>-100 <= Node.val <= 100</code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "For each node, check path through it.",
                "algorithm": "DFS with diameter tracking",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(h)"
                },
                "code": {
                    "python": "class Solution:\n    def diameterOfBinaryTree(self, root):\n        self.diameter = 0\n        def depth(node):\n            if not node: return 0\n            left = depth(node.left)\n            right = depth(node.right)\n            self.diameter = max(self.diameter, left + right)\n            return max(left, right) + 1\n        depth(root)\n        return self.diameter",
                    "java": "class Solution { int diameter = 0; public int diameterOfBinaryTree(TreeNode root) { depth(root); return diameter; } int depth(TreeNode node) { if (node == null) return 0; int left = depth(node.left); int right = depth(node.right); diameter = Math.max(diameter, left + right); return Math.max(left, right) + 1; } }",
                    "cpp": "class Solution { int diameter = 0; public: int diameterOfBinaryTree(TreeNode* root) { depth(root); return diameter; } int depth(TreeNode* node) { if (!node) return 0; int left = depth(node->left); int right = depth(node->right); diameter = max(diameter, left + right); return max(left, right) + 1; } };"
                }
            },
            "optimized": {
                "intuition": "Same approach is optimal.",
                "algorithm": "Single DFS",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(h)"
                },
                "code": {
                    "python": "class Solution:\n    def diameterOfBinaryTree(self, root):\n        result = [0]\n        def dfs(node):\n            if not node: return 0\n            left = dfs(node.left)\n            right = dfs(node.right)\n            result[0] = max(result[0], left + right)\n            return max(left, right) + 1\n        dfs(root)\n        return result[0]",
                    "java": "class Solution { int result = 0; public int diameterOfBinaryTree(TreeNode root) { dfs(root); return result; } int dfs(TreeNode node) { if (node == null) return 0; int left = dfs(node.left); int right = dfs(node.right); result = Math.max(result, left + right); return Math.max(left, right) + 1; } }",
                    "cpp": "class Solution { int result = 0; public: int diameterOfBinaryTree(TreeNode* root) { dfs(root); return result; } int dfs(TreeNode* node) { if (!node) return 0; int left = dfs(node->left); int right = dfs(node->right); result = max(result, left + right); return max(left, right) + 1; } };"
                }
            }
        }
    },
    "balanced-binary-tree": {
        "description": `<p>Given a binary tree, determine if it is <strong>height-balanced</strong>.</p>
<p>A <strong>height-balanced</strong> binary tree is a binary tree in which the depth of the two subtrees of <em>every</em> node never differs by more than one.</p>
<p>The naive approach checks balance at each node by computing heights repeatedly, leading to O(n¬≤) time. The optimal solution computes height and checks balance in a single pass by returning -1 to indicate an unbalanced subtree, achieving O(n) time.</p>`,
        "examples": [
            {
                "input": "root = [3,9,20,null,null,15,7]",
                "output": "true",
                "explanation": "Left subtree has height 1, right subtree has height 2. Difference is 1, which is ‚â§ 1."
            },
            {
                "input": "root = [1,2,2,3,3,null,null,4,4]",
                "output": "false",
                "explanation": "The left subtree of root has height 3, while the right has height 1. Unbalanced."
            },
            {
                "input": "root = []",
                "output": "true",
                "explanation": "Empty tree is balanced."
            }
        ],
        "constraints": [
            "The number of nodes in the tree is in the range <code>[0, 5000]</code>.",
            "<code>-10<sup>4</sup> <= Node.val <= 10<sup>4</sup></code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "Check each node.",
                "algorithm": "Top-down recursion",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(h)"
                },
                "code": {
                    "python": "class Solution:\n    def isBalanced(self, root):\n        if not root: return True\n        def height(node):\n            if not node: return 0\n            return 1 + max(height(node.left), height(node.right))\n        return abs(height(root.left) - height(root.right)) <= 1 and self.isBalanced(root.left) and self.isBalanced(root.right)",
                    "java": "class Solution { public boolean isBalanced(TreeNode root) { if (root == null) return true; return Math.abs(height(root.left) - height(root.right)) <= 1 && isBalanced(root.left) && isBalanced(root.right); } int height(TreeNode node) { if (node == null) return 0; return 1 + Math.max(height(node.left), height(node.right)); } }",
                    "cpp": "class Solution { public: bool isBalanced(TreeNode* root) { if (!root) return true; return abs(height(root->left) - height(root->right)) <= 1 && isBalanced(root->left) && isBalanced(root->right); } int height(TreeNode* node) { if (!node) return 0; return 1 + max(height(node->left), height(node->right)); } };"
                }
            },
            "optimized": {
                "intuition": "Bottom-up check.",
                "algorithm": "Return -1 for unbalanced",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(h)"
                },
                "code": {
                    "python": "class Solution:\n    def isBalanced(self, root):\n        def check(node):\n            if not node: return 0\n            left = check(node.left)\n            if left == -1: return -1\n            right = check(node.right)\n            if right == -1: return -1\n            if abs(left - right) > 1: return -1\n            return max(left, right) + 1\n        return check(root) != -1",
                    "java": "class Solution { public boolean isBalanced(TreeNode root) { return check(root) != -1; } int check(TreeNode node) { if (node == null) return 0; int left = check(node.left); if (left == -1) return -1; int right = check(node.right); if (right == -1) return -1; if (Math.abs(left - right) > 1) return -1; return Math.max(left, right) + 1; } }",
                    "cpp": "class Solution { public: bool isBalanced(TreeNode* root) { return check(root) != -1; } int check(TreeNode* node) { if (!node) return 0; int left = check(node->left); if (left == -1) return -1; int right = check(node->right); if (right == -1) return -1; if (abs(left - right) > 1) return -1; return max(left, right) + 1; } };"
                }
            }
        }
    },
    "binary-tree-level-order-traversal": {
        "description": `<p>Given the <code>root</code> of a binary tree, return <em>the level order traversal of its nodes' values</em>. (i.e., from left to right, level by level).</p><p><strong>Approach 1 (BFS - Standard):</strong> Use a <strong>queue</strong>. Process nodes level by level, tracking the size of each level to group nodes together.</p><p><strong>Approach 2 (DFS):</strong> Use recursive DFS with a depth parameter. Add nodes to <code>result[depth]</code>, creating new sublists as needed. This is less intuitive but avoids using a queue.</p>`,
        "examples": [
            {
                "input": "root = [3,9,20,null,null,15,7]",
                "output": "[[3],[9,20],[15,7]]",
                "explanation": "Level 0: [3], Level 1: [9,20], Level 2: [15,7]."
            },
            {
                "input": "root = [1]",
                "output": "[[1]]",
                "explanation": "Single node at level 0."
            },
            {
                "input": "root = []",
                "output": "[]",
                "explanation": "Empty tree."
            }
        ],
        "constraints": [
            "<code>The number of nodes in the tree is in the range [0, 2000].</code>",
            "<code>-1000 <= Node.val <= 1000</code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "BFS with queue.",
                "algorithm": "Level by level",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(n)"
                },
                "code": {
                    "python": "class Solution:\n    def levelOrder(self, root):\n        if not root: return []\n        from collections import deque\n        result = []\n        queue = deque([root])\n        while queue:\n            level = []\n            for _ in range(len(queue)):\n                node = queue.popleft()\n                level.append(node.val)\n                if node.left: queue.append(node.left)\n                if node.right: queue.append(node.right)\n            result.append(level)\n        return result",
                    "java": "class Solution { public List<List<Integer>> levelOrder(TreeNode root) { List<List<Integer>> result = new ArrayList<>(); if (root == null) return result; Queue<TreeNode> queue = new LinkedList<>(); queue.offer(root); while (!queue.isEmpty()) { List<Integer> level = new ArrayList<>(); for (int i = queue.size(); i > 0; i--) { TreeNode node = queue.poll(); level.add(node.val); if (node.left != null) queue.offer(node.left); if (node.right != null) queue.offer(node.right); } result.add(level); } return result; } }",
                    "cpp": "class Solution { public: vector<vector<int>> levelOrder(TreeNode* root) { vector<vector<int>> result; if (!root) return result; queue<TreeNode*> q; q.push(root); while (!q.empty()) { vector<int> level; for (int i = q.size(); i > 0; i--) { TreeNode* node = q.front(); q.pop(); level.push_back(node->val); if (node->left) q.push(node->left); if (node->right) q.push(node->right); } result.push_back(level); } return result; } };"
                }
            },
            "optimized": {
                "intuition": "DFS with depth tracking.",
                "algorithm": "Recursive DFS",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(n)"
                },
                "code": {
                    "python": "class Solution:\n    def levelOrder(self, root):\n        result = []\n        def dfs(node, depth):\n            if not node: return\n            if depth == len(result):\n                result.append([])\n            result[depth].append(node.val)\n            dfs(node.left, depth + 1)\n            dfs(node.right, depth + 1)\n        dfs(root, 0)\n        return result",
                    "java": "class Solution { List<List<Integer>> result = new ArrayList<>(); public List<List<Integer>> levelOrder(TreeNode root) { dfs(root, 0); return result; } void dfs(TreeNode node, int depth) { if (node == null) return; if (depth == result.size()) result.add(new ArrayList<>()); result.get(depth).add(node.val); dfs(node.left, depth + 1); dfs(node.right, depth + 1); } }",
                    "cpp": "class Solution { vector<vector<int>> result; public: vector<vector<int>> levelOrder(TreeNode* root) { dfs(root, 0); return result; } void dfs(TreeNode* node, int depth) { if (!node) return; if (depth == result.size()) result.push_back({}); result[depth].push_back(node->val); dfs(node->left, depth + 1); dfs(node->right, depth + 1); } };"
                }
            }
        }
    },
    "binary-tree-right-side-view": {
        "description": `<p>Given the <code>root</code> of a binary tree, imagine yourself standing on the <strong>right side</strong> of it, return <em>the values of the nodes you can see ordered from top to bottom</em>.</p><p><strong>Approach 1 (BFS):</strong> Level order traversal, taking the <strong>last node</strong> at each level.</p><p><strong>Approach 2 (DFS - Optimal):</strong> DFS traversing <strong>right subtree first</strong>. At each depth, if we haven't seen this depth before, add the current node (which is the rightmost at this depth since we go right first).</p>`,
        "examples": [
            {
                "input": "root = [1,2,3,null,5,null,4]",
                "output": "[1,3,4]",
                "explanation": "From the right side: see 1, then 3, then 4."
            },
            {
                "input": "root = [1,null,3]",
                "output": "[1,3]",
                "explanation": "See 1 and 3 from the right."
            },
            {
                "input": "root = []",
                "output": "[]",
                "explanation": "Empty tree."
            }
        ],
        "constraints": [
            "<code>The number of nodes in the tree is in the range [0, 100].</code>",
            "<code>-100 <= Node.val <= 100</code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "Level order, take last.",
                "algorithm": "BFS",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(n)"
                },
                "code": {
                    "python": "class Solution:\n    def rightSideView(self, root):\n        if not root: return []\n        from collections import deque\n        result = []\n        queue = deque([root])\n        while queue:\n            size = len(queue)\n            for i in range(size):\n                node = queue.popleft()\n                if i == size - 1:\n                    result.append(node.val)\n                if node.left: queue.append(node.left)\n                if node.right: queue.append(node.right)\n        return result",
                    "java": "class Solution { public List<Integer> rightSideView(TreeNode root) { List<Integer> result = new ArrayList<>(); if (root == null) return result; Queue<TreeNode> queue = new LinkedList<>(); queue.offer(root); while (!queue.isEmpty()) { int size = queue.size(); for (int i = 0; i < size; i++) { TreeNode node = queue.poll(); if (i == size - 1) result.add(node.val); if (node.left != null) queue.offer(node.left); if (node.right != null) queue.offer(node.right); } } return result; } }",
                    "cpp": "class Solution { public: vector<int> rightSideView(TreeNode* root) { vector<int> result; if (!root) return result; queue<TreeNode*> q; q.push(root); while (!q.empty()) { int size = q.size(); for (int i = 0; i < size; i++) { TreeNode* node = q.front(); q.pop(); if (i == size - 1) result.push_back(node->val); if (node->left) q.push(node->left); if (node->right) q.push(node->right); } } return result; } };"
                }
            },
            "optimized": {
                "intuition": "DFS right first.",
                "algorithm": "Visit right, record first at each level",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(h)"
                },
                "code": {
                    "python": "class Solution:\n    def rightSideView(self, root):\n        result = []\n        def dfs(node, depth):\n            if not node: return\n            if depth == len(result):\n                result.append(node.val)\n            dfs(node.right, depth + 1)\n            dfs(node.left, depth + 1)\n        dfs(root, 0)\n        return result",
                    "java": "class Solution { List<Integer> result = new ArrayList<>(); public List<Integer> rightSideView(TreeNode root) { dfs(root, 0); return result; } void dfs(TreeNode node, int depth) { if (node == null) return; if (depth == result.size()) result.add(node.val); dfs(node.right, depth + 1); dfs(node.left, depth + 1); } }",
                    "cpp": "class Solution { vector<int> result; public: vector<int> rightSideView(TreeNode* root) { dfs(root, 0); return result; } void dfs(TreeNode* node, int depth) { if (!node) return; if (depth == result.size()) result.push_back(node->val); dfs(node->right, depth + 1); dfs(node->left, depth + 1); } };"
                }
            }
        }
    },
    "invert-binary-tree": {
        "description": `<p>Given the <code>root</code> of a binary tree, invert the tree, and return <em>its root</em>.</p>
<p>Inverting a binary tree means swapping the left and right children of every node in the tree. This is a classic tree problem that can be solved both recursively and iteratively.</p>
<p>The recursive approach is elegant: invert the left subtree, invert the right subtree, then swap them. The iterative approach uses a queue (BFS) or stack (DFS) to process each node and swap its children.</p>
<p>This problem became famous when <strong>Max Howell</strong> (creator of Homebrew) was rejected by Google after failing to solve it on a whiteboard interview, despite his impressive open-source contributions!</p>`,
        "examples": [
            {
                "input": "root = [4,2,7,1,3,6,9]",
                "output": "[4,7,2,9,6,3,1]",
                "explanation": "The tree is inverted. Every left child becomes the right child and vice versa."
            },
            {
                "input": "root = [2,1,3]",
                "output": "[2,3,1]",
                "explanation": "Simple three-node tree: swap the children of root."
            },
            {
                "input": "root = []",
                "output": "[]",
                "explanation": "Empty tree remains empty."
            }
        ],
        "constraints": [
            "The number of nodes in the tree is in the range <code>[0, 100]</code>.",
            "<code>-100 <= Node.val <= 100</code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "Swap children recursively.",
                "algorithm": "DFS",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(h)"
                },
                "code": {
                    "python": "class Solution:\n    def invertTree(self, root):\n        if not root: return None\n        root.left, root.right = root.right, root.left\n        self.invertTree(root.left)\n        self.invertTree(root.right)\n        return root",
                    "java": "class Solution { public TreeNode invertTree(TreeNode root) { if (root == null) return null; TreeNode temp = root.left; root.left = root.right; root.right = temp; invertTree(root.left); invertTree(root.right); return root; } }",
                    "cpp": "class Solution { public: TreeNode* invertTree(TreeNode* root) { if (!root) return nullptr; swap(root->left, root->right); invertTree(root->left); invertTree(root->right); return root; } };"
                }
            },
            "optimized": {
                "intuition": "Iterative BFS.",
                "algorithm": "Level order swap",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(n)"
                },
                "code": {
                    "python": "class Solution:\n    def invertTree(self, root):\n        if not root: return None\n        from collections import deque\n        queue = deque([root])\n        while queue:\n            node = queue.popleft()\n            node.left, node.right = node.right, node.left\n            if node.left: queue.append(node.left)\n            if node.right: queue.append(node.right)\n        return root",
                    "java": "class Solution { public TreeNode invertTree(TreeNode root) { if (root == null) return null; Queue<TreeNode> queue = new LinkedList<>(); queue.offer(root); while (!queue.isEmpty()) { TreeNode node = queue.poll(); TreeNode temp = node.left; node.left = node.right; node.right = temp; if (node.left != null) queue.offer(node.left); if (node.right != null) queue.offer(node.right); } return root; } }",
                    "cpp": "class Solution { public: TreeNode* invertTree(TreeNode* root) { if (!root) return nullptr; queue<TreeNode*> q; q.push(root); while (!q.empty()) { TreeNode* node = q.front(); q.pop(); swap(node->left, node->right); if (node->left) q.push(node->left); if (node->right) q.push(node->right); } return root; } };"
                }
            }
        }
    },
    "maximum-depth-of-binary-tree": {
        "description": `<p>Given the <code>root</code> of a binary tree, return <em>its maximum depth</em>.</p>
<p>A binary tree's <strong>maximum depth</strong> is the number of nodes along the longest path from the root node down to the farthest leaf node.</p>
<p>This is one of the most fundamental tree problems. The recursive solution is elegant: the depth of a tree is 1 + the maximum depth of its subtrees. The iterative solution uses <strong>level-order traversal</strong> (BFS) or DFS with a stack.</p>
<p>Base case: an empty tree has depth 0, a single node has depth 1.</p>`,
        "examples": [
            {
                "input": "root = [3,9,20,null,null,15,7]",
                "output": "3",
                "explanation": "The maximum depth is 3, along the path 3 ‚Üí 20 ‚Üí 15 or 3 ‚Üí 20 ‚Üí 7."
            },
            {
                "input": "root = [1,null,2]",
                "output": "2",
                "explanation": "The tree has depth 2: 1 ‚Üí 2."
            },
            {
                "input": "root = []",
                "output": "0",
                "explanation": "Empty tree has depth 0."
            }
        ],
        "constraints": [
            "The number of nodes in the tree is in the range <code>[0, 10<sup>4</sup>]</code>.",
            "<code>-100 <= Node.val <= 100</code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "Recursive depth calculation.",
                "algorithm": "DFS",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(h)"
                },
                "code": {
                    "python": "class Solution:\n    def maxDepth(self, root):\n        if not root: return 0\n        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))",
                    "java": "class Solution { public int maxDepth(TreeNode root) { if (root == null) return 0; return 1 + Math.max(maxDepth(root.left), maxDepth(root.right)); } }",
                    "cpp": "class Solution { public: int maxDepth(TreeNode* root) { if (!root) return 0; return 1 + max(maxDepth(root->left), maxDepth(root->right)); } };"
                }
            },
            "optimized": {
                "intuition": "Iterative BFS.",
                "algorithm": "Level order",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(n)"
                },
                "code": {
                    "python": "class Solution:\n    def maxDepth(self, root):\n        if not root: return 0\n        from collections import deque\n        queue = deque([root])\n        depth = 0\n        while queue:\n            depth += 1\n            for _ in range(len(queue)):\n                node = queue.popleft()\n                if node.left: queue.append(node.left)\n                if node.right: queue.append(node.right)\n        return depth",
                    "java": "class Solution { public int maxDepth(TreeNode root) { if (root == null) return 0; Queue<TreeNode> queue = new LinkedList<>(); queue.offer(root); int depth = 0; while (!queue.isEmpty()) { depth++; for (int i = queue.size(); i > 0; i--) { TreeNode node = queue.poll(); if (node.left != null) queue.offer(node.left); if (node.right != null) queue.offer(node.right); } } return depth; } }",
                    "cpp": "class Solution { public: int maxDepth(TreeNode* root) { if (!root) return 0; queue<TreeNode*> q; q.push(root); int depth = 0; while (!q.empty()) { depth++; for (int i = q.size(); i > 0; i--) { TreeNode* node = q.front(); q.pop(); if (node->left) q.push(node->left); if (node->right) q.push(node->right); } } return depth; } };"
                }
            }
        }
    },
    "number-of-islands": {
        "description": `<p>Given an <code>m x n</code> 2D binary grid <code>grid</code> which represents a map of <code>'1'</code>s (land) and <code>'0'</code>s (water), return <em>the number of islands</em>.</p><p>An <strong>island</strong> is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</p><p><strong>Approach:</strong> Use <strong>DFS</strong> or <strong>BFS</strong> to mark connected components. For each unvisited land cell, increment the island count and mark all connected land cells as visited (by setting them to '0' or using a separate visited set).</p>`,
        "examples": [
            {
                "input": "grid = [[\"1\",\"1\",\"1\",\"1\",\"0\"],[\"1\",\"1\",\"0\",\"1\",\"0\"],[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"0\",\"0\"]]",
                "output": "1",
                "explanation": "All the 1s are connected, forming one island."
            },
            {
                "input": "grid = [[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"1\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"1\",\"1\"]]",
                "output": "3",
                "explanation": "Three separate islands."
            },
            {
                "input": "grid = [[\"0\"]]",
                "output": "0",
                "explanation": "No land, no islands."
            }
        ],
        "constraints": [
            "<code>m == grid.length</code>",
            "<code>n == grid[i].length</code>",
            "<code>1 <= m, n <= 300</code>",
            "<code>grid[i][j] is '0' or '1'.</code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "DFS for each island.",
                "algorithm": "Mark visited cells",
                "complexity": {
                    "time": "O(m*n)",
                    "space": "O(m*n)"
                },
                "code": {
                    "python": "class Solution:\n    def numIslands(self, grid):\n        if not grid: return 0\n        m, n = len(grid), len(grid[0])\n        count = 0\n        def dfs(i, j):\n            if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] != '1': return\n            grid[i][j] = '0'\n            dfs(i+1, j)\n            dfs(i-1, j)\n            dfs(i, j+1)\n            dfs(i, j-1)\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == '1':\n                    dfs(i, j)\n                    count += 1\n        return count",
                    "java": "class Solution { public int numIslands(char[][] grid) { if (grid == null || grid.length == 0) return 0; int m = grid.length, n = grid[0].length, count = 0; for (int i = 0; i < m; i++) { for (int j = 0; j < n; j++) { if (grid[i][j] == '1') { dfs(grid, i, j); count++; } } } return count; } void dfs(char[][] grid, int i, int j) { if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] != '1') return; grid[i][j] = '0'; dfs(grid, i+1, j); dfs(grid, i-1, j); dfs(grid, i, j+1); dfs(grid, i, j-1); } }",
                    "cpp": "class Solution { public: int numIslands(vector<vector<char>>& grid) { if (grid.empty()) return 0; int m = grid.size(), n = grid[0].size(), count = 0; for (int i = 0; i < m; i++) { for (int j = 0; j < n; j++) { if (grid[i][j] == '1') { dfs(grid, i, j); count++; } } } return count; } void dfs(vector<vector<char>>& grid, int i, int j) { if (i < 0 || i >= grid.size() || j < 0 || j >= grid[0].size() || grid[i][j] != '1') return; grid[i][j] = '0'; dfs(grid, i+1, j); dfs(grid, i-1, j); dfs(grid, i, j+1); dfs(grid, i, j-1); } };"
                }
            },
            "optimized": {
                "intuition": "BFS alternative.",
                "algorithm": "Queue-based traversal",
                "complexity": {
                    "time": "O(m*n)",
                    "space": "O(min(m,n))"
                },
                "code": {
                    "python": "class Solution:\n    def numIslands(self, grid):\n        if not grid: return 0\n        from collections import deque\n        m, n = len(grid), len(grid[0])\n        count = 0\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == '1':\n                    count += 1\n                    queue = deque([(i, j)])\n                    grid[i][j] = '0'\n                    while queue:\n                        r, c = queue.popleft()\n                        for dr, dc in [(1,0),(-1,0),(0,1),(0,-1)]:\n                            nr, nc = r+dr, c+dc\n                            if 0 <= nr < m and 0 <= nc < n and grid[nr][nc] == '1':\n                                grid[nr][nc] = '0'\n                                queue.append((nr, nc))\n        return count",
                    "java": "class Solution { public int numIslands(char[][] grid) { if (grid == null || grid.length == 0) return 0; int m = grid.length, n = grid[0].length, count = 0; int[][] dirs = {{1,0},{-1,0},{0,1},{0,-1}}; for (int i = 0; i < m; i++) { for (int j = 0; j < n; j++) { if (grid[i][j] == '1') { count++; Queue<int[]> q = new LinkedList<>(); q.offer(new int[]{i, j}); grid[i][j] = '0'; while (!q.isEmpty()) { int[] cell = q.poll(); for (int[] d : dirs) { int nr = cell[0]+d[0], nc = cell[1]+d[1]; if (nr >= 0 && nr < m && nc >= 0 && nc < n && grid[nr][nc] == '1') { grid[nr][nc] = '0'; q.offer(new int[]{nr, nc}); } } } } } } return count; } }",
                    "cpp": "class Solution { public: int numIslands(vector<vector<char>>& grid) { if (grid.empty()) return 0; int m = grid.size(), n = grid[0].size(), count = 0; vector<pair<int,int>> dirs = {{1,0},{-1,0},{0,1},{0,-1}}; for (int i = 0; i < m; i++) { for (int j = 0; j < n; j++) { if (grid[i][j] == '1') { count++; queue<pair<int,int>> q; q.push({i, j}); grid[i][j] = '0'; while (!q.empty()) { auto [r, c] = q.front(); q.pop(); for (auto [dr, dc] : dirs) { int nr = r+dr, nc = c+dc; if (nr >= 0 && nr < m && nc >= 0 && nc < n && grid[nr][nc] == '1') { grid[nr][nc] = '0'; q.push({nr, nc}); } } } } } } return count; } };"
                }
            }
        }
    },
    "max-area-of-island": {
        "description": `<p>You are given an <code>m x n</code> binary matrix <code>grid</code>. An island is a group of <code>1</code>'s (representing land) connected <strong>4-directionally</strong> (horizontal or vertical). You may assume all four edges of the grid are surrounded by water.</p><p>The <strong>area</strong> of an island is the number of cells with a value <code>1</code> in the island.</p><p>Return <em>the maximum <strong>area</strong> of an island in</em> <code>grid</code>. If there is no island, return <code>0</code>.</p><p><strong>Approach:</strong> Similar to Number of Islands, but instead of just counting islands, we compute the area of each island during DFS/BFS. Track the maximum area seen across all islands.</p>`,
        "examples": [
            {
                "input": "grid = [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]]",
                "output": "6",
                "explanation": "The maximum area island has 6 cells."
            },
            {
                "input": "grid = [[0,0,0,0,0,0,0,0]]",
                "output": "0",
                "explanation": "No islands, return 0."
            },
            {
                "input": "grid = [[1,1],[1,1]]",
                "output": "4",
                "explanation": "Single island with area 4."
            }
        ],
        "constraints": [
            "<code>m == grid.length</code>",
            "<code>n == grid[i].length</code>",
            "<code>1 <= m, n <= 50</code>",
            "<code>grid[i][j]</code> is either <code>0</code> or <code>1</code>."
        ],
        "solutions": {
            "brute": {
                "intuition": "DFS counting.",
                "algorithm": "Count cells in each island",
                "complexity": {
                    "time": "O(m*n)",
                    "space": "O(m*n)"
                },
                "code": {
                    "python": "class Solution:\n    def maxAreaOfIsland(self, grid):\n        m, n = len(grid), len(grid[0])\n        maxArea = 0\n        def dfs(i, j):\n            if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] != 1: return 0\n            grid[i][j] = 0\n            return 1 + dfs(i+1,j) + dfs(i-1,j) + dfs(i,j+1) + dfs(i,j-1)\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 1:\n                    maxArea = max(maxArea, dfs(i, j))\n        return maxArea",
                    "java": "class Solution { public int maxAreaOfIsland(int[][] grid) { int m = grid.length, n = grid[0].length, maxArea = 0; for (int i = 0; i < m; i++) for (int j = 0; j < n; j++) if (grid[i][j] == 1) maxArea = Math.max(maxArea, dfs(grid, i, j)); return maxArea; } int dfs(int[][] grid, int i, int j) { if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] != 1) return 0; grid[i][j] = 0; return 1 + dfs(grid,i+1,j) + dfs(grid,i-1,j) + dfs(grid,i,j+1) + dfs(grid,i,j-1); } }",
                    "cpp": "class Solution { public: int maxAreaOfIsland(vector<vector<int>>& grid) { int m = grid.size(), n = grid[0].size(), maxArea = 0; for (int i = 0; i < m; i++) for (int j = 0; j < n; j++) if (grid[i][j] == 1) maxArea = max(maxArea, dfs(grid, i, j)); return maxArea; } int dfs(vector<vector<int>>& grid, int i, int j) { if (i < 0 || i >= grid.size() || j < 0 || j >= grid[0].size() || grid[i][j] != 1) return 0; grid[i][j] = 0; return 1 + dfs(grid,i+1,j) + dfs(grid,i-1,j) + dfs(grid,i,j+1) + dfs(grid,i,j-1); } };"
                }
            },
            "optimized": {
                "intuition": "Same approach is optimal.",
                "algorithm": "DFS",
                "complexity": {
                    "time": "O(m*n)",
                    "space": "O(m*n)"
                },
                "code": {
                    "python": "class Solution:\n    def maxAreaOfIsland(self, grid):\n        m, n = len(grid), len(grid[0])\n        def dfs(i, j):\n            if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] != 1:\n                return 0\n            grid[i][j] = 0\n            area = 1\n            for di, dj in [(1,0),(-1,0),(0,1),(0,-1)]:\n                area += dfs(i+di, j+dj)\n            return area\n        return max((dfs(i, j) for i in range(m) for j in range(n) if grid[i][j] == 1), default=0)",
                    "java": "class Solution { int[][] grid; int m, n; public int maxAreaOfIsland(int[][] grid) { this.grid = grid; m = grid.length; n = grid[0].length; int max = 0; for (int i = 0; i < m; i++) for (int j = 0; j < n; j++) max = Math.max(max, dfs(i, j)); return max; } int dfs(int i, int j) { if (i < 0 || i >= m || j < 0 || j >= n || grid[i][j] != 1) return 0; grid[i][j] = 0; return 1 + dfs(i+1,j) + dfs(i-1,j) + dfs(i,j+1) + dfs(i,j-1); } }",
                    "cpp": "class Solution { public: int maxAreaOfIsland(vector<vector<int>>& grid) { int m = grid.size(), n = grid[0].size(), result = 0; function<int(int,int)> dfs = [&](int i, int j) -> int { if (i < 0 || i >= m || j < 0 || j >= n || grid[i][j] != 1) return 0; grid[i][j] = 0; return 1 + dfs(i+1,j) + dfs(i-1,j) + dfs(i,j+1) + dfs(i,j-1); }; for (int i = 0; i < m; i++) for (int j = 0; j < n; j++) result = max(result, dfs(i,j)); return result; } };"
                }
            }
        }
    },
    "clone-graph": {
        "description": `<p>Given a reference of a node in a <strong>connected</strong> undirected graph.</p><p>Return a <strong>deep copy</strong> (clone) of the graph.</p><p>Each node in the graph contains a value (<code>int</code>) and a list (<code>List[Node]</code>) of its neighbors.</p><p><strong>Approach:</strong> Use a hash map to track <code>original -> clone</code> mapping. Perform <strong>DFS</strong> or <strong>BFS</strong>. For each node, create its clone if not already created, then recursively clone its neighbors. The hash map prevents infinite loops and ensures we create each node exactly once.</p>`,
        "examples": [
            {
                "input": "adjList = [[2,4],[1,3],[2,4],[1,3]]",
                "output": "[[2,4],[1,3],[2,4],[1,3]]",
                "explanation": "There are 4 nodes. Node 1 is connected to nodes 2 and 4. Node 2 is connected to nodes 1 and 3. Node 3 is connected to nodes 2 and 4. Node 4 is connected to nodes 1 and 3."
            },
            {
                "input": "adjList = [[]]",
                "output": "[[]]",
                "explanation": "Single node with no neighbors."
            },
            {
                "input": "adjList = []",
                "output": "[]",
                "explanation": "Empty graph."
            }
        ],
        "constraints": [
            "<code>The number of nodes in the graph is in the range [0, 100].</code>",
            "<code>1 <= Node.val <= 100</code>",
            "<code>Node.val is unique for each node.</code>",
            "<code>There are no repeated edges and no self-loops in the graph.</code>",
            "<code>The Graph is connected and all nodes can be visited starting from the given node.</code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "DFS with hash map.",
                "algorithm": "Map old to new nodes",
                "complexity": {
                    "time": "O(V+E)",
                    "space": "O(V)"
                },
                "code": {
                    "python": "class Solution:\n    def cloneGraph(self, node):\n        if not node: return None\n        oldToNew = {}\n        def dfs(node):\n            if node in oldToNew:\n                return oldToNew[node]\n            copy = Node(node.val)\n            oldToNew[node] = copy\n            for neighbor in node.neighbors:\n                copy.neighbors.append(dfs(neighbor))\n            return copy\n        return dfs(node)",
                    "java": "class Solution { Map<Node, Node> oldToNew = new HashMap<>(); public Node cloneGraph(Node node) { if (node == null) return null; if (oldToNew.containsKey(node)) return oldToNew.get(node); Node copy = new Node(node.val); oldToNew.put(node, copy); for (Node n : node.neighbors) copy.neighbors.add(cloneGraph(n)); return copy; } }",
                    "cpp": "class Solution { unordered_map<Node*, Node*> oldToNew; public: Node* cloneGraph(Node* node) { if (!node) return nullptr; if (oldToNew.count(node)) return oldToNew[node]; Node* copy = new Node(node->val); oldToNew[node] = copy; for (Node* n : node->neighbors) copy->neighbors.push_back(cloneGraph(n)); return copy; } };"
                }
            },
            "optimized": {
                "intuition": "BFS alternative.",
                "algorithm": "Queue-based cloning",
                "complexity": {
                    "time": "O(V+E)",
                    "space": "O(V)"
                },
                "code": {
                    "python": "class Solution:\n    def cloneGraph(self, node):\n        if not node: return None\n        from collections import deque\n        oldToNew = {node: Node(node.val)}\n        queue = deque([node])\n        while queue:\n            curr = queue.popleft()\n            for neighbor in curr.neighbors:\n                if neighbor not in oldToNew:\n                    oldToNew[neighbor] = Node(neighbor.val)\n                    queue.append(neighbor)\n                oldToNew[curr].neighbors.append(oldToNew[neighbor])\n        return oldToNew[node]",
                    "java": "class Solution { public Node cloneGraph(Node node) { if (node == null) return null; Map<Node, Node> map = new HashMap<>(); map.put(node, new Node(node.val)); Queue<Node> queue = new LinkedList<>(); queue.offer(node); while (!queue.isEmpty()) { Node curr = queue.poll(); for (Node n : curr.neighbors) { if (!map.containsKey(n)) { map.put(n, new Node(n.val)); queue.offer(n); } map.get(curr).neighbors.add(map.get(n)); } } return map.get(node); } }",
                    "cpp": "class Solution { public: Node* cloneGraph(Node* node) { if (!node) return nullptr; unordered_map<Node*, Node*> mp; mp[node] = new Node(node->val); queue<Node*> q; q.push(node); while (!q.empty()) { Node* curr = q.front(); q.pop(); for (Node* n : curr->neighbors) { if (!mp.count(n)) { mp[n] = new Node(n->val); q.push(n); } mp[curr]->neighbors.push_back(mp[n]); } } return mp[node]; } };"
                }
            }
        }
    },
    "pacific-atlantic-water-flow": {
        "description": "<p>There is an <code>m x n</code> rectangular island that borders both the <strong>Pacific Ocean</strong> and <strong>Atlantic Ocean</strong>. The <strong>Pacific Ocean</strong> touches the island's left and top edges, and the <strong>Atlantic Ocean</strong> touches the island's right and bottom edges.</p><p>The island is partitioned into a grid of square cells. You are given an <code>m x n</code> integer matrix <code>heights</code> where <code>heights[r][c]</code> represents the <strong>height above sea level</strong> of the cell at coordinate <code>(r, c)</code>.</p><p>The island receives a lot of rain, and the rain water can flow to neighboring cells directly north, south, east, and west if the neighboring cell's height is <strong>less than or equal to</strong> the current cell's height. Water can flow from any cell adjacent to an ocean into the ocean.</p><p>Return <em>a <strong>2D list</strong> of grid coordinates</em> <code>result</code> <em>where</em> <code>result[i] = [r<sub>i</sub>, c<sub>i</sub>]</code> <em>denotes that rain water can flow from cell</em> <code>(r<sub>i</sub>, c<sub>i</sub>)</code> <em>to <strong>both</strong> the Pacific and Atlantic oceans</em>.</p><p><strong>Approach:</strong> Instead of checking from each cell whether it can reach both oceans (expensive), <strong>reverse the problem</strong>: perform DFS from ocean borders inward, marking cells that can flow <em>to</em> each ocean. Water flows from higher to lower, so reverse-flow means we traverse from lower to higher or equal. Find the intersection of cells reachable from both oceans.</p>",
        "examples": [
            {
                "input": "heights = [[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]",
                "output": "[[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]",
                "explanation": "The cells that can reach both oceans are marked. For example, cell (0,4) with height 5 is on the Pacific border (top row) and can flow down-right to Atlantic."
            },
            {
                "input": "heights = [[1]]",
                "output": "[[0,0]]",
                "explanation": "A single cell touches all four borders, so it can reach both oceans."
            },
            {
                "input": "heights = [[1,2],[2,1]]",
                "output": "[[0,0],[0,1],[1,0],[1,1]]",
                "explanation": "All cells can reach both oceans in this small grid."
            }
        ],
        "constraints": [
            "<code>m == heights.length</code>",
            "<code>n == heights[i].length</code>",
            "<code>1 <= m, n <= 200</code>",
            "<code>0 <= heights[r][c] <= 10<sup>5</sup></code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "DFS from each cell.",
                "algorithm": "Check both oceans for each cell",
                "complexity": {
                    "time": "O((m*n)¬≤)",
                    "space": "O(m*n)"
                },
                "code": {
                    "python": "class Solution:\n    def pacificAtlantic(self, heights):\n        m, n = len(heights), len(heights[0])\n        result = []\n        def canReach(i, j, ocean):\n            visited = set()\n            def dfs(r, c):\n                if (r, c) in visited: return False\n                if ocean == 'P' and (r < 0 or c < 0): return True\n                if ocean == 'A' and (r >= m or c >= n): return True\n                if r < 0 or r >= m or c < 0 or c >= n: return False\n                if heights[r][c] > heights[i][j] if (r,c) != (i,j) else False: return False\n                visited.add((r, c))\n                return any(dfs(r+dr, c+dc) for dr, dc in [(0,1),(0,-1),(1,0),(-1,0)])\n            return dfs(i, j)\n        for i in range(m):\n            for j in range(n):\n                if canReach(i,j,'P') and canReach(i,j,'A'):\n                    result.append([i, j])\n        return result",
                    "java": "class Solution { public List<List<Integer>> pacificAtlantic(int[][] heights) { int m = heights.length, n = heights[0].length; boolean[][] pacific = new boolean[m][n]; boolean[][] atlantic = new boolean[m][n]; for (int i = 0; i < m; i++) { dfs(heights, pacific, i, 0); dfs(heights, atlantic, i, n-1); } for (int j = 0; j < n; j++) { dfs(heights, pacific, 0, j); dfs(heights, atlantic, m-1, j); } List<List<Integer>> result = new ArrayList<>(); for (int i = 0; i < m; i++) for (int j = 0; j < n; j++) if (pacific[i][j] && atlantic[i][j]) result.add(Arrays.asList(i, j)); return result; } void dfs(int[][] h, boolean[][] v, int i, int j) { if (v[i][j]) return; v[i][j] = true; int[][] d = {{0,1},{0,-1},{1,0},{-1,0}}; for (int[] dir : d) { int ni = i+dir[0], nj = j+dir[1]; if (ni >= 0 && ni < h.length && nj >= 0 && nj < h[0].length && h[ni][nj] >= h[i][j]) dfs(h, v, ni, nj); } } }",
                    "cpp": "class Solution { public: vector<vector<int>> pacificAtlantic(vector<vector<int>>& heights) { int m = heights.size(), n = heights[0].size(); vector<vector<bool>> pacific(m, vector<bool>(n)), atlantic(m, vector<bool>(n)); for (int i = 0; i < m; i++) { dfs(heights, pacific, i, 0); dfs(heights, atlantic, i, n-1); } for (int j = 0; j < n; j++) { dfs(heights, pacific, 0, j); dfs(heights, atlantic, m-1, j); } vector<vector<int>> result; for (int i = 0; i < m; i++) for (int j = 0; j < n; j++) if (pacific[i][j] && atlantic[i][j]) result.push_back({i, j}); return result; } void dfs(vector<vector<int>>& h, vector<vector<bool>>& v, int i, int j) { if (v[i][j]) return; v[i][j] = true; vector<pair<int,int>> d = {{0,1},{0,-1},{1,0},{-1,0}}; for (auto [di, dj] : d) { int ni = i+di, nj = j+dj; if (ni >= 0 && ni < h.size() && nj >= 0 && nj < h[0].size() && h[ni][nj] >= h[i][j]) dfs(h, v, ni, nj); } } };"
                }
            },
            "optimized": {
                "intuition": "DFS from oceans.",
                "algorithm": "Reverse flow from borders",
                "complexity": {
                    "time": "O(m*n)",
                    "space": "O(m*n)"
                },
                "code": {
                    "python": "class Solution:\n    def pacificAtlantic(self, heights):\n        m, n = len(heights), len(heights[0])\n        pacific, atlantic = set(), set()\n        def dfs(r, c, visited, prevHeight):\n            if (r, c) in visited or r < 0 or r >= m or c < 0 or c >= n or heights[r][c] < prevHeight:\n                return\n            visited.add((r, c))\n            for dr, dc in [(0,1),(0,-1),(1,0),(-1,0)]:\n                dfs(r+dr, c+dc, visited, heights[r][c])\n        for i in range(m):\n            dfs(i, 0, pacific, 0)\n            dfs(i, n-1, atlantic, 0)\n        for j in range(n):\n            dfs(0, j, pacific, 0)\n            dfs(m-1, j, atlantic, 0)\n        return list(pacific & atlantic)",
                    "java": "class Solution { int m, n; int[][] heights; int[][] dirs = {{0,1},{0,-1},{1,0},{-1,0}}; public List<List<Integer>> pacificAtlantic(int[][] heights) { this.heights = heights; m = heights.length; n = heights[0].length; boolean[][] pacific = new boolean[m][n], atlantic = new boolean[m][n]; for (int i = 0; i < m; i++) { dfs(i, 0, pacific); dfs(i, n-1, atlantic); } for (int j = 0; j < n; j++) { dfs(0, j, pacific); dfs(m-1, j, atlantic); } List<List<Integer>> result = new ArrayList<>(); for (int i = 0; i < m; i++) for (int j = 0; j < n; j++) if (pacific[i][j] && atlantic[i][j]) result.add(Arrays.asList(i, j)); return result; } void dfs(int r, int c, boolean[][] visited) { visited[r][c] = true; for (int[] d : dirs) { int nr = r+d[0], nc = c+d[1]; if (nr >= 0 && nr < m && nc >= 0 && nc < n && !visited[nr][nc] && heights[nr][nc] >= heights[r][c]) dfs(nr, nc, visited); } } }",
                    "cpp": "class Solution { public: vector<vector<int>> pacificAtlantic(vector<vector<int>>& heights) { int m = heights.size(), n = heights[0].size(); vector<vector<bool>> pacific(m, vector<bool>(n)), atlantic(m, vector<bool>(n)); function<void(int,int,vector<vector<bool>>&)> dfs = [&](int r, int c, vector<vector<bool>>& vis) { vis[r][c] = true; for (auto [dr,dc] : vector<pair<int,int>>{{0,1},{0,-1},{1,0},{-1,0}}) { int nr = r+dr, nc = c+dc; if (nr >= 0 && nr < m && nc >= 0 && nc < n && !vis[nr][nc] && heights[nr][nc] >= heights[r][c]) dfs(nr, nc, vis); } }; for (int i = 0; i < m; i++) { dfs(i, 0, pacific); dfs(i, n-1, atlantic); } for (int j = 0; j < n; j++) { dfs(0, j, pacific); dfs(m-1, j, atlantic); } vector<vector<int>> result; for (int i = 0; i < m; i++) for (int j = 0; j < n; j++) if (pacific[i][j] && atlantic[i][j]) result.push_back({i, j}); return result; } };"
                }
            }
        }
    },
    "course-schedule": {
        "description": "<p>There are a total of <code>numCourses</code> courses you have to take, labeled from <code>0</code> to <code>numCourses - 1</code>. You are given an array <code>prerequisites</code> where <code>prerequisites[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> indicates that you <strong>must</strong> take course <code>b<sub>i</sub></code> first if you want to take course <code>a<sub>i</sub></code>.</p><p>For example, the pair <code>[0, 1]</code>, indicates that to take course <code>0</code> you have to first take course <code>1</code>.</p><p>Return <code>true</code> if you can finish all courses. Otherwise, return <code>false</code>.</p><p><strong>Approach:</strong> This is a classic <strong>cycle detection in a directed graph</strong> problem. Build an adjacency list from prerequisites. Use <strong>DFS with 3 states</strong> (unvisited=0, visiting=1, visited=2) to detect cycles, or use <strong>Kahn's algorithm (BFS topological sort)</strong> with indegree tracking. If a cycle exists, courses cannot be completed.</p>",
        "examples": [
            {
                "input": "numCourses = 2, prerequisites = [[1,0]]",
                "output": "true",
                "explanation": "There are 2 courses. To take course 1 you should have finished course 0. So it is possible."
            },
            {
                "input": "numCourses = 2, prerequisites = [[1,0],[0,1]]",
                "output": "false",
                "explanation": "There are 2 courses. To take course 1 you need course 0, and to take course 0 you need course 1. This forms a cycle, so it's impossible."
            },
            {
                "input": "numCourses = 3, prerequisites = [[1,0],[2,1]]",
                "output": "true",
                "explanation": "Take course 0, then 1, then 2. No cycle exists."
            }
        ],
        "constraints": [
            "<code>1 <= numCourses <= 2000</code>",
            "<code>0 <= prerequisites.length <= 5000</code>",
            "<code>prerequisites[i].length == 2</code>",
            "<code>0 <= a<sub>i</sub>, b<sub>i</sub> < numCourses</code>",
            "<code>All the pairs prerequisites[i] are unique</code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "Detect cycle with DFS.",
                "algorithm": "Cycle detection",
                "complexity": {
                    "time": "O(V+E)",
                    "space": "O(V+E)"
                },
                "code": {
                    "python": "class Solution:\n    def canFinish(self, numCourses, prerequisites):\n        graph = [[] for _ in range(numCourses)]\n        for course, prereq in prerequisites:\n            graph[prereq].append(course)\n        visited = [0] * numCourses\n        def dfs(node):\n            if visited[node] == 1: return False\n            if visited[node] == 2: return True\n            visited[node] = 1\n            for neighbor in graph[node]:\n                if not dfs(neighbor): return False\n            visited[node] = 2\n            return True\n        return all(dfs(i) for i in range(numCourses))",
                    "java": "class Solution { public boolean canFinish(int n, int[][] prereqs) { List<List<Integer>> graph = new ArrayList<>(); for (int i = 0; i < n; i++) graph.add(new ArrayList<>()); for (int[] p : prereqs) graph.get(p[1]).add(p[0]); int[] visited = new int[n]; for (int i = 0; i < n; i++) if (!dfs(graph, visited, i)) return false; return true; } boolean dfs(List<List<Integer>> graph, int[] visited, int node) { if (visited[node] == 1) return false; if (visited[node] == 2) return true; visited[node] = 1; for (int nei : graph.get(node)) if (!dfs(graph, visited, nei)) return false; visited[node] = 2; return true; } }",
                    "cpp": "class Solution { public: bool canFinish(int n, vector<vector<int>>& prereqs) { vector<vector<int>> graph(n); for (auto& p : prereqs) graph[p[1]].push_back(p[0]); vector<int> visited(n); for (int i = 0; i < n; i++) if (!dfs(graph, visited, i)) return false; return true; } bool dfs(vector<vector<int>>& graph, vector<int>& visited, int node) { if (visited[node] == 1) return false; if (visited[node] == 2) return true; visited[node] = 1; for (int nei : graph[node]) if (!dfs(graph, visited, nei)) return false; visited[node] = 2; return true; } };"
                }
            },
            "optimized": {
                "intuition": "Kahn's algorithm.",
                "algorithm": "BFS topological sort",
                "complexity": {
                    "time": "O(V+E)",
                    "space": "O(V+E)"
                },
                "code": {
                    "python": "class Solution:\n    def canFinish(self, numCourses, prerequisites):\n        from collections import deque\n        graph = [[] for _ in range(numCourses)]\n        indegree = [0] * numCourses\n        for course, prereq in prerequisites:\n            graph[prereq].append(course)\n            indegree[course] += 1\n        queue = deque(i for i in range(numCourses) if indegree[i] == 0)\n        count = 0\n        while queue:\n            node = queue.popleft()\n            count += 1\n            for neighbor in graph[node]:\n                indegree[neighbor] -= 1\n                if indegree[neighbor] == 0:\n                    queue.append(neighbor)\n        return count == numCourses",
                    "java": "class Solution { public boolean canFinish(int n, int[][] prereqs) { List<List<Integer>> graph = new ArrayList<>(); int[] indegree = new int[n]; for (int i = 0; i < n; i++) graph.add(new ArrayList<>()); for (int[] p : prereqs) { graph.get(p[1]).add(p[0]); indegree[p[0]]++; } Queue<Integer> queue = new LinkedList<>(); for (int i = 0; i < n; i++) if (indegree[i] == 0) queue.offer(i); int count = 0; while (!queue.isEmpty()) { int node = queue.poll(); count++; for (int nei : graph.get(node)) { indegree[nei]--; if (indegree[nei] == 0) queue.offer(nei); } } return count == n; } }",
                    "cpp": "class Solution { public: bool canFinish(int n, vector<vector<int>>& prereqs) { vector<vector<int>> graph(n); vector<int> indegree(n); for (auto& p : prereqs) { graph[p[1]].push_back(p[0]); indegree[p[0]]++; } queue<int> q; for (int i = 0; i < n; i++) if (indegree[i] == 0) q.push(i); int count = 0; while (!q.empty()) { int node = q.front(); q.pop(); count++; for (int nei : graph[node]) { indegree[nei]--; if (indegree[nei] == 0) q.push(nei); } } return count == n; } };"
                }
            }
        }
    },
    "word-ladder": {
        "description": "<p>A <strong>transformation sequence</strong> from word <code>beginWord</code> to word <code>endWord</code> using a dictionary <code>wordList</code> is a sequence of words <code>beginWord -> s<sub>1</sub> -> s<sub>2</sub> -> ... -> s<sub>k</sub></code> such that:</p><ul><li>Every adjacent pair of words differs by a single letter.</li><li>Every <code>s<sub>i</sub></code> for <code>1 <= i <= k</code> is in <code>wordList</code>. Note that <code>beginWord</code> does not need to be in <code>wordList</code>.</li><li><code>s<sub>k</sub> == endWord</code></li></ul><p>Given two words, <code>beginWord</code> and <code>endWord</code>, and a dictionary <code>wordList</code>, return <em>the <strong>length of the shortest transformation sequence</strong> from</em> <code>beginWord</code> <em>to</em> <code>endWord</code>, <em>or</em> <code>0</code> <em>if no such sequence exists</em>.</p><p><strong>Approach:</strong> Use <strong>BFS</strong> to find the shortest path. For each word, generate all possible one-letter transformations and check if they exist in the word set. Track visited words. <strong>Bidirectional BFS</strong> (searching from both ends) can halve the search space for optimization.</p>",
        "examples": [
            {
                "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]",
                "output": "5",
                "explanation": "One shortest transformation sequence is: \"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> \"cog\", which is 5 words long."
            },
            {
                "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]",
                "output": "0",
                "explanation": "The endWord \"cog\" is not in wordList, therefore no transformation sequence exists."
            },
            {
                "input": "beginWord = \"a\", endWord = \"c\", wordList = [\"a\",\"b\",\"c\"]",
                "output": "2",
                "explanation": "\"a\" -> \"c\" (2 words)."
            }
        ],
        "constraints": [
            "<code>1 <= beginWord.length <= 10</code>",
            "<code>endWord.length == beginWord.length</code>",
            "<code>1 <= wordList.length <= 5000</code>",
            "<code>wordList[i].length == beginWord.length</code>",
            "<code>beginWord, endWord, and wordList[i] consist of lowercase English letters</code>",
            "<code>beginWord != endWord</code>",
            "<code>All the words in wordList are unique</code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "BFS to find shortest path.",
                "algorithm": "Level by level search",
                "complexity": {
                    "time": "O(M¬≤ * N)",
                    "space": "O(M * N)"
                },
                "code": {
                    "python": "class Solution:\n    def ladderLength(self, beginWord, endWord, wordList):\n        from collections import deque\n        wordSet = set(wordList)\n        if endWord not in wordSet: return 0\n        queue = deque([(beginWord, 1)])\n        visited = {beginWord}\n        while queue:\n            word, level = queue.popleft()\n            if word == endWord: return level\n            for i in range(len(word)):\n                for c in 'abcdefghijklmnopqrstuvwxyz':\n                    newWord = word[:i] + c + word[i+1:]\n                    if newWord in wordSet and newWord not in visited:\n                        visited.add(newWord)\n                        queue.append((newWord, level + 1))\n        return 0",
                    "java": "class Solution { public int ladderLength(String beginWord, String endWord, List<String> wordList) { Set<String> wordSet = new HashSet<>(wordList); if (!wordSet.contains(endWord)) return 0; Queue<String> queue = new LinkedList<>(); queue.offer(beginWord); Set<String> visited = new HashSet<>(); visited.add(beginWord); int level = 1; while (!queue.isEmpty()) { for (int i = queue.size(); i > 0; i--) { String word = queue.poll(); if (word.equals(endWord)) return level; char[] arr = word.toCharArray(); for (int j = 0; j < arr.length; j++) { char orig = arr[j]; for (char c = 'a'; c <= 'z'; c++) { arr[j] = c; String newWord = new String(arr); if (wordSet.contains(newWord) && !visited.contains(newWord)) { visited.add(newWord); queue.offer(newWord); } } arr[j] = orig; } } level++; } return 0; } }",
                    "cpp": "class Solution { public: int ladderLength(string beginWord, string endWord, vector<string>& wordList) { unordered_set<string> wordSet(wordList.begin(), wordList.end()); if (!wordSet.count(endWord)) return 0; queue<string> q; q.push(beginWord); unordered_set<string> visited; visited.insert(beginWord); int level = 1; while (!q.empty()) { for (int i = q.size(); i > 0; i--) { string word = q.front(); q.pop(); if (word == endWord) return level; for (int j = 0; j < word.size(); j++) { char orig = word[j]; for (char c = 'a'; c <= 'z'; c++) { word[j] = c; if (wordSet.count(word) && !visited.count(word)) { visited.insert(word); q.push(word); } } word[j] = orig; } } level++; } return 0; } };"
                }
            },
            "optimized": {
                "intuition": "Bidirectional BFS.",
                "algorithm": "Search from both ends",
                "complexity": {
                    "time": "O(M¬≤ * N)",
                    "space": "O(M * N)"
                },
                "code": {
                    "python": "class Solution:\n    def ladderLength(self, beginWord, endWord, wordList):\n        wordSet = set(wordList)\n        if endWord not in wordSet: return 0\n        beginSet, endSet = {beginWord}, {endWord}\n        visited = set()\n        level = 1\n        while beginSet and endSet:\n            if len(beginSet) > len(endSet):\n                beginSet, endSet = endSet, beginSet\n            nextSet = set()\n            for word in beginSet:\n                for i in range(len(word)):\n                    for c in 'abcdefghijklmnopqrstuvwxyz':\n                        newWord = word[:i] + c + word[i+1:]\n                        if newWord in endSet: return level + 1\n                        if newWord in wordSet and newWord not in visited:\n                            visited.add(newWord)\n                            nextSet.add(newWord)\n            beginSet = nextSet\n            level += 1\n        return 0",
                    "java": "class Solution { public int ladderLength(String beginWord, String endWord, List<String> wordList) { Set<String> wordSet = new HashSet<>(wordList); if (!wordSet.contains(endWord)) return 0; Set<String> beginSet = new HashSet<>(), endSet = new HashSet<>(); beginSet.add(beginWord); endSet.add(endWord); Set<String> visited = new HashSet<>(); int level = 1; while (!beginSet.isEmpty() && !endSet.isEmpty()) { if (beginSet.size() > endSet.size()) { Set<String> temp = beginSet; beginSet = endSet; endSet = temp; } Set<String> nextSet = new HashSet<>(); for (String word : beginSet) { char[] arr = word.toCharArray(); for (int i = 0; i < arr.length; i++) { char orig = arr[i]; for (char c = 'a'; c <= 'z'; c++) { arr[i] = c; String newWord = new String(arr); if (endSet.contains(newWord)) return level + 1; if (wordSet.contains(newWord) && !visited.contains(newWord)) { visited.add(newWord); nextSet.add(newWord); } } arr[i] = orig; } } beginSet = nextSet; level++; } return 0; } }",
                    "cpp": "class Solution { public: int ladderLength(string beginWord, string endWord, vector<string>& wordList) { unordered_set<string> wordSet(wordList.begin(), wordList.end()); if (!wordSet.count(endWord)) return 0; unordered_set<string> beginSet, endSet, visited; beginSet.insert(beginWord); endSet.insert(endWord); int level = 1; while (!beginSet.empty() && !endSet.empty()) { if (beginSet.size() > endSet.size()) swap(beginSet, endSet); unordered_set<string> nextSet; for (string word : beginSet) { for (int i = 0; i < word.size(); i++) { char orig = word[i]; for (char c = 'a'; c <= 'z'; c++) { word[i] = c; if (endSet.count(word)) return level + 1; if (wordSet.count(word) && !visited.count(word)) { visited.insert(word); nextSet.insert(word); } } word[i] = orig; } } beginSet = nextSet; level++; } return 0; } };"
                }
            }
        }
    },
    "longest-consecutive-sequence": {
        "description": "<p>Given an unsorted array of integers <code>nums</code>, return <em>the length of the longest consecutive elements sequence</em>.</p><p>You must write an algorithm that runs in <code>O(n)</code> time.</p><p><strong>Approach:</strong> The naive O(n log n) solution is to sort first, but we can achieve O(n) using a <strong>hash set</strong>. For each number, check if it's the <strong>start of a sequence</strong> (i.e., <code>num - 1</code> not in set). If so, count the consecutive sequence length from that starting point. This ensures each number is visited at most twice (once to check if it's a start, once when counting from a start).</p>",
        "examples": [
            {
                "input": "nums = [100,4,200,1,3,2]",
                "output": "4",
                "explanation": "The longest consecutive sequence is [1, 2, 3, 4]. Therefore its length is 4."
            },
            {
                "input": "nums = [0,3,7,2,5,8,4,6,0,1]",
                "output": "9",
                "explanation": "The longest consecutive sequence is [0,1,2,3,4,5,6,7,8], with length 9."
            },
            {
                "input": "nums = [9,1,4,7,3,-1,0,5,8,-2,6]",
                "output": "7",
                "explanation": "The longest consecutive sequence is [-2,-1,0,1,3,4,5,6,7,8,9], but since we are looking for consecutive, it's [3,4,5,6,7,8,9] with length 7."
            }
        ],
        "constraints": [
            "<code>0 <= nums.length <= 10<sup>5</sup></code>",
            "<code>-10<sup>9</sup> <= nums[i] <= 10<sup>9</sup></code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "Sort and count.",
                "algorithm": "O(n log n) sorting",
                "complexity": {
                    "time": "O(n log n)",
                    "space": "O(1)"
                },
                "code": {
                    "python": "class Solution:\n    def longestConsecutive(self, nums):\n        if not nums: return 0\n        nums.sort()\n        longest = 1\n        current = 1\n        for i in range(1, len(nums)):\n            if nums[i] == nums[i-1]: continue\n            if nums[i] == nums[i-1] + 1:\n                current += 1\n            else:\n                longest = max(longest, current)\n                current = 1\n        return max(longest, current)",
                    "java": "class Solution { public int longestConsecutive(int[] nums) { if (nums.length == 0) return 0; Arrays.sort(nums); int longest = 1, current = 1; for (int i = 1; i < nums.length; i++) { if (nums[i] == nums[i-1]) continue; if (nums[i] == nums[i-1] + 1) current++; else { longest = Math.max(longest, current); current = 1; } } return Math.max(longest, current); } }",
                    "cpp": "class Solution { public: int longestConsecutive(vector<int>& nums) { if (nums.empty()) return 0; sort(nums.begin(), nums.end()); int longest = 1, current = 1; for (int i = 1; i < nums.size(); i++) { if (nums[i] == nums[i-1]) continue; if (nums[i] == nums[i-1] + 1) current++; else { longest = max(longest, current); current = 1; } } return max(longest, current); } };"
                }
            },
            "optimized": {
                "intuition": "Use hash set.",
                "algorithm": "O(n) with set",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(n)"
                },
                "code": {
                    "python": "class Solution:\n    def longestConsecutive(self, nums):\n        numSet = set(nums)\n        longest = 0\n        for num in numSet:\n            if num - 1 not in numSet:\n                current = num\n                streak = 1\n                while current + 1 in numSet:\n                    current += 1\n                    streak += 1\n                longest = max(longest, streak)\n        return longest",
                    "java": "class Solution { public int longestConsecutive(int[] nums) { Set<Integer> numSet = new HashSet<>(); for (int n : nums) numSet.add(n); int longest = 0; for (int num : numSet) { if (!numSet.contains(num - 1)) { int current = num, streak = 1; while (numSet.contains(current + 1)) { current++; streak++; } longest = Math.max(longest, streak); } } return longest; } }",
                    "cpp": "class Solution { public: int longestConsecutive(vector<int>& nums) { unordered_set<int> numSet(nums.begin(), nums.end()); int longest = 0; for (int num : numSet) { if (!numSet.count(num - 1)) { int current = num, streak = 1; while (numSet.count(current + 1)) { current++; streak++; } longest = max(longest, streak); } } return longest; } };"
                }
            }
        }
    },
    "word-search": {
        "description": "<p>Given an <code>m x n</code> grid of characters <code>board</code> and a string <code>word</code>, return <code>true</code> <em>if</em> <code>word</code> <em>exists in the grid</em>.</p><p>The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell <strong>may not be used more than once</strong>.</p><p><strong>Approach:</strong> Use <strong>backtracking DFS</strong> from each cell. For each cell matching the first character, recursively explore all four directions for subsequent characters. Mark visited cells temporarily (e.g., by modifying the cell value) and restore after backtracking. Early termination when a path doesn't match.</p>",
        "examples": [
            {
                "input": "board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCCED\"",
                "output": "true",
                "explanation": "The word ABCCED exists in the grid starting from board[0][0]: A->B->C->C(down)->E(down)->D."
            },
            {
                "input": "board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"SEE\"",
                "output": "true",
                "explanation": "The word SEE exists: S->E->E."
            },
            {
                "input": "board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCB\"",
                "output": "false",
                "explanation": "The word ABCB cannot be formed because after using B at [0][1], we cannot reuse it."
            }
        ],
        "constraints": [
            "<code>m == board.length</code>",
            "<code>n == board[i].length</code>",
            "<code>1 <= m, n <= 6</code>",
            "<code>1 <= word.length <= 15</code>",
            "<code>board and word consists of only lowercase and uppercase English letters</code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "DFS from each cell.",
                "algorithm": "Backtracking",
                "complexity": {
                    "time": "O(m*n*4^L)",
                    "space": "O(L)"
                },
                "code": {
                    "python": "class Solution:\n    def exist(self, board, word):\n        m, n = len(board), len(board[0])\n        def dfs(i, j, k):\n            if k == len(word): return True\n            if i < 0 or i >= m or j < 0 or j >= n or board[i][j] != word[k]: return False\n            temp, board[i][j] = board[i][j], '#'\n            result = dfs(i+1,j,k+1) or dfs(i-1,j,k+1) or dfs(i,j+1,k+1) or dfs(i,j-1,k+1)\n            board[i][j] = temp\n            return result\n        for i in range(m):\n            for j in range(n):\n                if dfs(i, j, 0): return True\n        return False",
                    "java": "class Solution { public boolean exist(char[][] board, String word) { int m = board.length, n = board[0].length; for (int i = 0; i < m; i++) for (int j = 0; j < n; j++) if (dfs(board, word, i, j, 0)) return true; return false; } boolean dfs(char[][] board, String word, int i, int j, int k) { if (k == word.length()) return true; if (i < 0 || i >= board.length || j < 0 || j >= board[0].length || board[i][j] != word.charAt(k)) return false; char temp = board[i][j]; board[i][j] = '#'; boolean result = dfs(board,word,i+1,j,k+1) || dfs(board,word,i-1,j,k+1) || dfs(board,word,i,j+1,k+1) || dfs(board,word,i,j-1,k+1); board[i][j] = temp; return result; } }",
                    "cpp": "class Solution { public: bool exist(vector<vector<char>>& board, string word) { int m = board.size(), n = board[0].size(); for (int i = 0; i < m; i++) for (int j = 0; j < n; j++) if (dfs(board, word, i, j, 0)) return true; return false; } bool dfs(vector<vector<char>>& board, string& word, int i, int j, int k) { if (k == word.size()) return true; if (i < 0 || i >= board.size() || j < 0 || j >= board[0].size() || board[i][j] != word[k]) return false; char temp = board[i][j]; board[i][j] = '#'; bool result = dfs(board,word,i+1,j,k+1) || dfs(board,word,i-1,j,k+1) || dfs(board,word,i,j+1,k+1) || dfs(board,word,i,j-1,k+1); board[i][j] = temp; return result; } };"
                }
            },
            "optimized": {
                "intuition": "Same approach with pruning.",
                "algorithm": "Early termination",
                "complexity": {
                    "time": "O(m*n*4^L)",
                    "space": "O(L)"
                },
                "code": {
                    "python": "class Solution:\n    def exist(self, board, word):\n        from collections import Counter\n        m, n = len(board), len(board[0])\n        # Pruning: check if characters exist\n        board_counter = Counter(c for row in board for c in row)\n        word_counter = Counter(word)\n        for c, count in word_counter.items():\n            if board_counter[c] < count: return False\n        # Start from rarer end\n        if board_counter[word[0]] > board_counter[word[-1]]:\n            word = word[::-1]\n        def dfs(i, j, k):\n            if k == len(word): return True\n            if i < 0 or i >= m or j < 0 or j >= n or board[i][j] != word[k]: return False\n            board[i][j], temp = '#', board[i][j]\n            result = dfs(i+1,j,k+1) or dfs(i-1,j,k+1) or dfs(i,j+1,k+1) or dfs(i,j-1,k+1)\n            board[i][j] = temp\n            return result\n        return any(dfs(i, j, 0) for i in range(m) for j in range(n))",
                    "java": "class Solution { public boolean exist(char[][] board, String word) { int m = board.length, n = board[0].length; boolean[][] visited = new boolean[m][n]; for (int i = 0; i < m; i++) for (int j = 0; j < n; j++) if (dfs(board, word, i, j, 0, visited)) return true; return false; } boolean dfs(char[][] board, String word, int i, int j, int k, boolean[][] visited) { if (k == word.length()) return true; if (i < 0 || i >= board.length || j < 0 || j >= board[0].length || visited[i][j] || board[i][j] != word.charAt(k)) return false; visited[i][j] = true; boolean result = dfs(board,word,i+1,j,k+1,visited) || dfs(board,word,i-1,j,k+1,visited) || dfs(board,word,i,j+1,k+1,visited) || dfs(board,word,i,j-1,k+1,visited); visited[i][j] = false; return result; } }",
                    "cpp": "class Solution { public: bool exist(vector<vector<char>>& board, string word) { int m = board.size(), n = board[0].size(); function<bool(int,int,int)> dfs = [&](int i, int j, int k) -> bool { if (k == word.size()) return true; if (i < 0 || i >= m || j < 0 || j >= n || board[i][j] != word[k]) return false; char temp = board[i][j]; board[i][j] = '#'; bool result = dfs(i+1,j,k+1) || dfs(i-1,j,k+1) || dfs(i,j+1,k+1) || dfs(i,j-1,k+1); board[i][j] = temp; return result; }; for (int i = 0; i < m; i++) for (int j = 0; j < n; j++) if (dfs(i, j, 0)) return true; return false; } };"
                }
            }
        }
    },
    "climbing-stairs": {
        "description": `<p>You are climbing a staircase. It takes <code>n</code> steps to reach the top.</p>
<p>Each time you can either climb <code>1</code> or <code>2</code> steps. In how many distinct ways can you climb to the top?</p>
<p>This is a classic <strong>dynamic programming</strong> problem that follows the Fibonacci sequence. To reach step <code>n</code>, you can come from step <code>n-1</code> (taking 1 step) or step <code>n-2</code> (taking 2 steps). Therefore: <code>ways(n) = ways(n-1) + ways(n-2)</code>.</p>
<p>This can be solved with memoization (top-down) or tabulation (bottom-up), and optimized to O(1) space using only two variables.</p>`,
        "examples": [
            {
                "input": "n = 2",
                "output": "2",
                "explanation": "There are two ways to climb to the top: 1. 1 step + 1 step, 2. 2 steps."
            },
            {
                "input": "n = 3",
                "output": "3",
                "explanation": "There are three ways: 1+1+1, 1+2, 2+1."
            },
            {
                "input": "n = 5",
                "output": "8",
                "explanation": "There are 8 ways to reach step 5 (following the Fibonacci pattern)."
            }
        ],
        "constraints": [
            "<code>1 <= n <= 45</code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "Recursive with memoization.",
                "algorithm": "Top-down DP",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(n)"
                },
                "code": {
                    "python": "class Solution:\n    def climbStairs(self, n):\n        memo = {}\n        def dp(i):\n            if i <= 2: return i\n            if i in memo: return memo[i]\n            memo[i] = dp(i-1) + dp(i-2)\n            return memo[i]\n        return dp(n)",
                    "java": "class Solution { Map<Integer, Integer> memo = new HashMap<>(); public int climbStairs(int n) { if (n <= 2) return n; if (memo.containsKey(n)) return memo.get(n); int result = climbStairs(n-1) + climbStairs(n-2); memo.put(n, result); return result; } }",
                    "cpp": "class Solution { unordered_map<int, int> memo; public: int climbStairs(int n) { if (n <= 2) return n; if (memo.count(n)) return memo[n]; return memo[n] = climbStairs(n-1) + climbStairs(n-2); } };"
                }
            },
            "optimized": {
                "intuition": "Two variables.",
                "algorithm": "O(1) space",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)"
                },
                "code": {
                    "python": "class Solution:\n    def climbStairs(self, n):\n        if n <= 2: return n\n        prev, curr = 1, 2\n        for _ in range(3, n + 1):\n            prev, curr = curr, prev + curr\n        return curr",
                    "java": "class Solution { public int climbStairs(int n) { if (n <= 2) return n; int prev = 1, curr = 2; for (int i = 3; i <= n; i++) { int temp = curr; curr = prev + curr; prev = temp; } return curr; } }",
                    "cpp": "class Solution { public: int climbStairs(int n) { if (n <= 2) return n; int prev = 1, curr = 2; for (int i = 3; i <= n; i++) { int temp = curr; curr = prev + curr; prev = temp; } return curr; } };"
                }
            }
        }
    },
    "house-robber": {
        "description": `<p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and <strong>it will automatically contact the police if two adjacent houses were broken into on the same night</strong>.</p>
<p>Given an integer array <code>nums</code> representing the amount of money of each house, return <em>the maximum amount of money you can rob tonight <strong>without alerting the police</strong></em>.</p>
<p>This is a classic <strong>DP problem with constraints</strong>. At each house, you have two choices: rob it (and skip the previous house) or skip it (and keep the maximum from the previous house). The recurrence is: <code>dp[i] = max(nums[i] + dp[i-2], dp[i-1])</code>.</p>`,
        "examples": [
            {
                "input": "nums = [1,2,3,1]",
                "output": "4",
                "explanation": "Rob house 1 (money = 1) and then rob house 3 (money = 3). Total = 1 + 3 = 4."
            },
            {
                "input": "nums = [2,7,9,3,1]",
                "output": "12",
                "explanation": "Rob house 1 (money = 2), rob house 3 (money = 9), and rob house 5 (money = 1). Total = 2 + 9 + 1 = 12."
            },
            {
                "input": "nums = [2,1,1,2]",
                "output": "4",
                "explanation": "Rob house 1 (money = 2) and house 4 (money = 2). Total = 4."
            }
        ],
        "constraints": [
            "<code>1 <= nums.length <= 100</code>",
            "<code>0 <= nums[i] <= 400</code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "DP array.",
                "algorithm": "Bottom-up DP",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(n)"
                },
                "code": {
                    "python": "class Solution:\n    def rob(self, nums):\n        if len(nums) == 1: return nums[0]\n        dp = [0] * len(nums)\n        dp[0] = nums[0]\n        dp[1] = max(nums[0], nums[1])\n        for i in range(2, len(nums)):\n            dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n        return dp[-1]",
                    "java": "class Solution { public int rob(int[] nums) { if (nums.length == 1) return nums[0]; int[] dp = new int[nums.length]; dp[0] = nums[0]; dp[1] = Math.max(nums[0], nums[1]); for (int i = 2; i < nums.length; i++) dp[i] = Math.max(dp[i-1], dp[i-2] + nums[i]); return dp[nums.length-1]; } }",
                    "cpp": "class Solution { public: int rob(vector<int>& nums) { if (nums.size() == 1) return nums[0]; vector<int> dp(nums.size()); dp[0] = nums[0]; dp[1] = max(nums[0], nums[1]); for (int i = 2; i < nums.size(); i++) dp[i] = max(dp[i-1], dp[i-2] + nums[i]); return dp.back(); } };"
                }
            },
            "optimized": {
                "intuition": "Two variables.",
                "algorithm": "O(1) space",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)"
                },
                "code": {
                    "python": "class Solution:\n    def rob(self, nums):\n        rob1, rob2 = 0, 0\n        for num in nums:\n            temp = max(rob1 + num, rob2)\n            rob1 = rob2\n            rob2 = temp\n        return rob2",
                    "java": "class Solution { public int rob(int[] nums) { int rob1 = 0, rob2 = 0; for (int num : nums) { int temp = Math.max(rob1 + num, rob2); rob1 = rob2; rob2 = temp; } return rob2; } }",
                    "cpp": "class Solution { public: int rob(vector<int>& nums) { int rob1 = 0, rob2 = 0; for (int num : nums) { int temp = max(rob1 + num, rob2); rob1 = rob2; rob2 = temp; } return rob2; } };"
                }
            }
        }
    },
    "coin-change": {
        "description": `<p>You are given an integer array <code>coins</code> representing coins of different denominations and an integer <code>amount</code> representing a total amount of money.</p>
<p>Return <em>the fewest number of coins that you need to make up that amount</em>. If that amount of money cannot be made up by any combination of the coins, return <code>-1</code>.</p>
<p>You may assume that you have an infinite number of each kind of coin.</p>
<p>This is a classic <strong>unbounded knapsack</strong> dynamic programming problem. For each amount from 1 to target, we try each coin and take the minimum. The recurrence: <code>dp[amount] = min(dp[amount], dp[amount - coin] + 1)</code> for each valid coin.</p>`,
        "examples": [
            {
                "input": "coins = [1,2,5], amount = 11",
                "output": "3",
                "explanation": "11 = 5 + 5 + 1. Three coins is the minimum."
            },
            {
                "input": "coins = [2], amount = 3",
                "output": "-1",
                "explanation": "Amount 3 cannot be made with only coins of denomination 2."
            },
            {
                "input": "coins = [1], amount = 0",
                "output": "0",
                "explanation": "Zero coins needed for amount 0."
            }
        ],
        "constraints": [
            "<code>1 <= coins.length <= 12</code>",
            "<code>1 <= coins[i] <= 2<sup>31</sup> - 1</code>",
            "<code>0 <= amount <= 10<sup>4</sup></code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "Recursive with memoization.",
                "algorithm": "Top-down DP",
                "complexity": {
                    "time": "O(n*amount)",
                    "space": "O(amount)"
                },
                "code": {
                    "python": "class Solution:\n    def coinChange(self, coins, amount):\n        memo = {}\n        def dp(amt):\n            if amt == 0: return 0\n            if amt < 0: return float('inf')\n            if amt in memo: return memo[amt]\n            result = float('inf')\n            for coin in coins:\n                result = min(result, 1 + dp(amt - coin))\n            memo[amt] = result\n            return result\n        res = dp(amount)\n        return res if res != float('inf') else -1",
                    "java": "class Solution { int[] memo; public int coinChange(int[] coins, int amount) { memo = new int[amount + 1]; Arrays.fill(memo, -2); return dp(coins, amount); } int dp(int[] coins, int amt) { if (amt == 0) return 0; if (amt < 0) return -1; if (memo[amt] != -2) return memo[amt]; int result = Integer.MAX_VALUE; for (int coin : coins) { int sub = dp(coins, amt - coin); if (sub >= 0) result = Math.min(result, 1 + sub); } memo[amt] = result == Integer.MAX_VALUE ? -1 : result; return memo[amt]; } }",
                    "cpp": "class Solution { vector<int> memo; public: int coinChange(vector<int>& coins, int amount) { memo.assign(amount + 1, -2); return dp(coins, amount); } int dp(vector<int>& coins, int amt) { if (amt == 0) return 0; if (amt < 0) return -1; if (memo[amt] != -2) return memo[amt]; int result = INT_MAX; for (int coin : coins) { int sub = dp(coins, amt - coin); if (sub >= 0) result = min(result, 1 + sub); } return memo[amt] = (result == INT_MAX ? -1 : result); } };"
                }
            },
            "optimized": {
                "intuition": "Bottom-up DP.",
                "algorithm": "Iterative tabulation",
                "complexity": {
                    "time": "O(n*amount)",
                    "space": "O(amount)"
                },
                "code": {
                    "python": "class Solution:\n    def coinChange(self, coins, amount):\n        dp = [float('inf')] * (amount + 1)\n        dp[0] = 0\n        for a in range(1, amount + 1):\n            for coin in coins:\n                if coin <= a:\n                    dp[a] = min(dp[a], dp[a - coin] + 1)\n        return dp[amount] if dp[amount] != float('inf') else -1",
                    "java": "class Solution { public int coinChange(int[] coins, int amount) { int[] dp = new int[amount + 1]; Arrays.fill(dp, amount + 1); dp[0] = 0; for (int a = 1; a <= amount; a++) { for (int coin : coins) { if (coin <= a) dp[a] = Math.min(dp[a], dp[a - coin] + 1); } } return dp[amount] > amount ? -1 : dp[amount]; } }",
                    "cpp": "class Solution { public: int coinChange(vector<int>& coins, int amount) { vector<int> dp(amount + 1, amount + 1); dp[0] = 0; for (int a = 1; a <= amount; a++) { for (int coin : coins) { if (coin <= a) dp[a] = min(dp[a], dp[a - coin] + 1); } } return dp[amount] > amount ? -1 : dp[amount]; } };"
                }
            }
        }
    },
    "decode-ways": {
        "description": "<p>A message containing letters from <code>A-Z</code> can be <strong>encoded</strong> into numbers using the following mapping:</p><p><code>'A' -> \\\"1\\\"<br/>'B' -> \\\"2\\\"<br/>...<br/>'Z' -> \\\"26\\\"</code></p><p>To <strong>decode</strong> an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). For example, <code>\\\"11106\\\"</code> can be mapped into <code>\\\"AAJF\\\"</code> with the grouping <code>(1 1 10 6)</code> or <code>\\\"KJF\\\"</code> with the grouping <code>(11 10 6)</code>.</p><p>Note that the grouping <code>(1 11 06)</code> is invalid because <code>\\\"06\\\"</code> cannot be mapped into <code>'F'</code> since <code>\\\"6\\\"</code> is different from <code>\\\"06\\\"</code>.</p><p>Given a string <code>s</code> containing only digits, return <em>the <strong>number</strong> of ways to <strong>decode</strong> it</em>.</p><p><strong>Approach:</strong> This is a <strong>dynamic programming</strong> problem similar to climbing stairs with constraints. At position <code>i</code>, we can take 1 digit (if valid 1-9) or 2 digits (if valid 10-26). <code>dp[i] = dp[i-1] + dp[i-2]</code> with conditions. Leading zeros make decoding impossible. Can be optimized to O(1) space.</p>",
        "examples": [
            {
                "input": "s = \"12\"",
                "output": "2",
                "explanation": "It could be decoded as \"AB\" (1 2) or \"L\" (12)."
            },
            {
                "input": "s = \"226\"",
                "output": "3",
                "explanation": "It could be decoded as \"BZ\" (2 26), \"VF\" (22 6), or \"BBF\" (2 2 6)."
            },
            {
                "input": "s = \"06\"",
                "output": "0",
                "explanation": "\"06\" cannot be mapped to \"F\" because of the leading zero (\"6\" is different from \"06\")."
            }
        ],
        "constraints": [
            "<code>1 <= s.length <= 100</code>",
            "<code>s contains only digits and may contain leading zero(s)</code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "Recursive with memoization.",
                "algorithm": "Top-down DP",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(n)"
                },
                "code": {
                    "python": "class Solution:\n    def numDecodings(self, s):\n        memo = {len(s): 1}\n        def dp(i):\n            if i in memo: return memo[i]\n            if s[i] == '0': return 0\n            result = dp(i + 1)\n            if i + 1 < len(s) and (s[i] == '1' or (s[i] == '2' and s[i+1] <= '6')):\n                result += dp(i + 2)\n            memo[i] = result\n            return result\n        return dp(0)",
                    "java": "class Solution { int[] memo; public int numDecodings(String s) { memo = new int[s.length()]; Arrays.fill(memo, -1); return dp(s, 0); } int dp(String s, int i) { if (i == s.length()) return 1; if (s.charAt(i) == '0') return 0; if (memo[i] != -1) return memo[i]; int result = dp(s, i + 1); if (i + 1 < s.length() && (s.charAt(i) == '1' || (s.charAt(i) == '2' && s.charAt(i+1) <= '6'))) result += dp(s, i + 2); return memo[i] = result; } }",
                    "cpp": "class Solution { vector<int> memo; public: int numDecodings(string s) { memo.assign(s.size(), -1); return dp(s, 0); } int dp(string& s, int i) { if (i == s.size()) return 1; if (s[i] == '0') return 0; if (memo[i] != -1) return memo[i]; int result = dp(s, i + 1); if (i + 1 < s.size() && (s[i] == '1' || (s[i] == '2' && s[i+1] <= '6'))) result += dp(s, i + 2); return memo[i] = result; } };"
                }
            },
            "optimized": {
                "intuition": "Bottom-up with O(1) space.",
                "algorithm": "Two variables",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)"
                },
                "code": {
                    "python": "class Solution:\n    def numDecodings(self, s):\n        if s[0] == '0': return 0\n        prev2, prev1 = 1, 1\n        for i in range(1, len(s)):\n            curr = 0\n            if s[i] != '0':\n                curr = prev1\n            if s[i-1] == '1' or (s[i-1] == '2' and s[i] <= '6'):\n                curr += prev2\n            prev2, prev1 = prev1, curr\n        return prev1",
                    "java": "class Solution { public int numDecodings(String s) { if (s.charAt(0) == '0') return 0; int prev2 = 1, prev1 = 1; for (int i = 1; i < s.length(); i++) { int curr = 0; if (s.charAt(i) != '0') curr = prev1; if (s.charAt(i-1) == '1' || (s.charAt(i-1) == '2' && s.charAt(i) <= '6')) curr += prev2; prev2 = prev1; prev1 = curr; } return prev1; } }",
                    "cpp": "class Solution { public: int numDecodings(string s) { if (s[0] == '0') return 0; int prev2 = 1, prev1 = 1; for (int i = 1; i < s.size(); i++) { int curr = 0; if (s[i] != '0') curr = prev1; if (s[i-1] == '1' || (s[i-1] == '2' && s[i] <= '6')) curr += prev2; prev2 = prev1; prev1 = curr; } return prev1; } };"
                }
            }
        }
    },
    "unique-paths": {
        "description": "<p>There is a robot on an <code>m x n</code> grid. The robot is initially located at the <strong>top-left corner</strong> (i.e., <code>grid[0][0]</code>). The robot tries to move to the <strong>bottom-right corner</strong> (i.e., <code>grid[m - 1][n - 1]</code>). The robot can only move either <strong>down</strong> or <strong>right</strong> at any point in time.</p><p>Given the two integers <code>m</code> and <code>n</code>, return <em>the number of possible unique paths that the robot can take to reach the bottom-right corner</em>.</p><p><strong>Approach:</strong> This is a classic <strong>grid DP</strong> problem. For each cell <code>(i, j)</code>, the number of ways to reach it is the sum of ways from the cell above and the cell to the left: <code>dp[i][j] = dp[i-1][j] + dp[i][j-1]</code>. Base case: first row and first column all have 1 way. Can be space-optimized to O(n) using a single array.</p>",
        "examples": [
            {
                "input": "m = 3, n = 7",
                "output": "28",
                "explanation": "There are 28 unique paths from top-left to bottom-right in a 3x7 grid."
            },
            {
                "input": "m = 3, n = 2",
                "output": "3",
                "explanation": "From the top-left corner, there are 3 ways to reach the bottom-right: Right -> Down -> Down, Down -> Down -> Right, Down -> Right -> Down."
            },
            {
                "input": "m = 1, n = 1",
                "output": "1",
                "explanation": "Already at destination."
            }
        ],
        "constraints": [
            "<code>1 <= m, n <= 100</code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "2D DP.",
                "algorithm": "Fill grid",
                "complexity": {
                    "time": "O(m*n)",
                    "space": "O(m*n)"
                },
                "code": {
                    "python": "class Solution:\n    def uniquePaths(self, m, n):\n        dp = [[1] * n for _ in range(m)]\n        for i in range(1, m):\n            for j in range(1, n):\n                dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        return dp[m-1][n-1]",
                    "java": "class Solution { public int uniquePaths(int m, int n) { int[][] dp = new int[m][n]; for (int i = 0; i < m; i++) dp[i][0] = 1; for (int j = 0; j < n; j++) dp[0][j] = 1; for (int i = 1; i < m; i++) for (int j = 1; j < n; j++) dp[i][j] = dp[i-1][j] + dp[i][j-1]; return dp[m-1][n-1]; } }",
                    "cpp": "class Solution { public: int uniquePaths(int m, int n) { vector<vector<int>> dp(m, vector<int>(n, 1)); for (int i = 1; i < m; i++) for (int j = 1; j < n; j++) dp[i][j] = dp[i-1][j] + dp[i][j-1]; return dp[m-1][n-1]; } };"
                }
            },
            "optimized": {
                "intuition": "1D DP.",
                "algorithm": "Single row",
                "complexity": {
                    "time": "O(m*n)",
                    "space": "O(n)"
                },
                "code": {
                    "python": "class Solution:\n    def uniquePaths(self, m, n):\n        dp = [1] * n\n        for i in range(1, m):\n            for j in range(1, n):\n                dp[j] += dp[j-1]\n        return dp[n-1]",
                    "java": "class Solution { public int uniquePaths(int m, int n) { int[] dp = new int[n]; Arrays.fill(dp, 1); for (int i = 1; i < m; i++) for (int j = 1; j < n; j++) dp[j] += dp[j-1]; return dp[n-1]; } }",
                    "cpp": "class Solution { public: int uniquePaths(int m, int n) { vector<int> dp(n, 1); for (int i = 1; i < m; i++) for (int j = 1; j < n; j++) dp[j] += dp[j-1]; return dp[n-1]; } };"
                }
            }
        }
    },
    "word-break": {
        "description": "<p>Given a string <code>s</code> and a dictionary of strings <code>wordDict</code>, return <code>true</code> if <code>s</code> can be segmented into a space-separated sequence of one or more dictionary words.</p><p><strong>Note</strong> that the same word in the dictionary may be reused multiple times in the segmentation.</p><p>This problem is solved using <strong>dynamic programming</strong> where <code>dp[i]</code> represents whether the substring <code>s[0:i]</code> can be segmented into words from the dictionary.</p>",
        "examples": [
            {
                "input": "s = \"leetcode\", wordDict = [\"leet\",\"code\"]",
                "output": "true",
                "explanation": "Return true because \"leetcode\" can be segmented as \"leet code\"."
            },
            {
                "input": "s = \"applepenapple\", wordDict = [\"apple\",\"pen\"]",
                "output": "true",
                "explanation": "Return true because \"applepenapple\" can be segmented as \"apple pen apple\". Note that you are allowed to reuse a dictionary word."
            },
            {
                "input": "s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]",
                "output": "false",
                "explanation": "The string cannot be segmented into valid dictionary words."
            }
        ],
        "constraints": [
            "<code>1 <= s.length <= 300</code>",
            "<code>1 <= wordDict.length <= 1000</code>",
            "<code>1 <= wordDict[i].length <= 20</code>",
            "<code>s and wordDict[i] consist of only lowercase English letters</code>",
            "<code>All the strings of wordDict are unique</code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "Recursive with memoization.",
                "algorithm": "Top-down DP",
                "complexity": {
                    "time": "O(n¬≥)",
                    "space": "O(n)"
                },
                "code": {
                    "python": "class Solution:\n    def wordBreak(self, s, wordDict):\n        wordSet = set(wordDict)\n        memo = {}\n        def dp(i):\n            if i == len(s): return True\n            if i in memo: return memo[i]\n            for j in range(i + 1, len(s) + 1):\n                if s[i:j] in wordSet and dp(j):\n                    memo[i] = True\n                    return True\n            memo[i] = False\n            return False\n        return dp(0)",
                    "java": "class Solution { Set<String> wordSet; Boolean[] memo; public boolean wordBreak(String s, List<String> wordDict) { wordSet = new HashSet<>(wordDict); memo = new Boolean[s.length()]; return dp(s, 0); } boolean dp(String s, int i) { if (i == s.length()) return true; if (memo[i] != null) return memo[i]; for (int j = i + 1; j <= s.length(); j++) { if (wordSet.contains(s.substring(i, j)) && dp(s, j)) return memo[i] = true; } return memo[i] = false; } }",
                    "cpp": "class Solution { unordered_set<string> wordSet; vector<int> memo; public: bool wordBreak(string s, vector<string>& wordDict) { wordSet = unordered_set<string>(wordDict.begin(), wordDict.end()); memo.assign(s.size(), -1); return dp(s, 0); } bool dp(string& s, int i) { if (i == s.size()) return true; if (memo[i] != -1) return memo[i]; for (int j = i + 1; j <= s.size(); j++) { if (wordSet.count(s.substr(i, j - i)) && dp(s, j)) return memo[i] = 1; } return memo[i] = 0; } };"
                }
            },
            "optimized": {
                "intuition": "Bottom-up DP.",
                "algorithm": "Iterative tabulation",
                "complexity": {
                    "time": "O(n¬≥)",
                    "space": "O(n)"
                },
                "code": {
                    "python": "class Solution:\n    def wordBreak(self, s, wordDict):\n        wordSet = set(wordDict)\n        dp = [False] * (len(s) + 1)\n        dp[0] = True\n        for i in range(1, len(s) + 1):\n            for j in range(i):\n                if dp[j] and s[j:i] in wordSet:\n                    dp[i] = True\n                    break\n        return dp[len(s)]",
                    "java": "class Solution { public boolean wordBreak(String s, List<String> wordDict) { Set<String> wordSet = new HashSet<>(wordDict); boolean[] dp = new boolean[s.length() + 1]; dp[0] = true; for (int i = 1; i <= s.length(); i++) { for (int j = 0; j < i; j++) { if (dp[j] && wordSet.contains(s.substring(j, i))) { dp[i] = true; break; } } } return dp[s.length()]; } }",
                    "cpp": "class Solution { public: bool wordBreak(string s, vector<string>& wordDict) { unordered_set<string> wordSet(wordDict.begin(), wordDict.end()); vector<bool> dp(s.size() + 1, false); dp[0] = true; for (int i = 1; i <= s.size(); i++) { for (int j = 0; j < i; j++) { if (dp[j] && wordSet.count(s.substr(j, i - j))) { dp[i] = true; break; } } } return dp[s.size()]; } };"
                }
            }
        }
    },
    "longest-increasing-subsequence": {
        "description": "<p>Given an integer array <code>nums</code>, return <em>the length of the longest strictly increasing subsequence</em>.</p><p>A <strong>subsequence</strong> is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.</p><p>This classic problem can be solved with <strong>O(n¬≤) dynamic programming</strong> or optimized to <strong>O(n log n)</strong> using <strong>binary search with patience sorting</strong>.</p>",
        "examples": [
            {
                "input": "nums = [10,9,2,5,3,7,101,18]",
                "output": "4",
                "explanation": "The longest increasing subsequence is [2,3,7,101], therefore the length is 4."
            },
            {
                "input": "nums = [0,1,0,3,2,3]",
                "output": "4",
                "explanation": "The longest increasing subsequence is [0,1,2,3], therefore the length is 4."
            },
            {
                "input": "nums = [7,7,7,7,7,7,7]",
                "output": "1",
                "explanation": "The longest increasing subsequence consists of any single element (strictly increasing means no duplicates)."
            }
        ],
        "constraints": [
            "<code>1 <= nums.length <= 2500</code>",
            "<code>-10<sup>4</sup> <= nums[i] <= 10<sup>4</sup></code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "DP with O(n¬≤).",
                "algorithm": "For each element, find LIS ending there",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)"
                },
                "code": {
                    "python": "class Solution:\n    def lengthOfLIS(self, nums):\n        n = len(nums)\n        dp = [1] * n\n        for i in range(1, n):\n            for j in range(i):\n                if nums[j] < nums[i]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        return max(dp)",
                    "java": "class Solution { public int lengthOfLIS(int[] nums) { int n = nums.length; int[] dp = new int[n]; Arrays.fill(dp, 1); for (int i = 1; i < n; i++) { for (int j = 0; j < i; j++) { if (nums[j] < nums[i]) dp[i] = Math.max(dp[i], dp[j] + 1); } } return Arrays.stream(dp).max().getAsInt(); } }",
                    "cpp": "class Solution { public: int lengthOfLIS(vector<int>& nums) { int n = nums.size(); vector<int> dp(n, 1); for (int i = 1; i < n; i++) { for (int j = 0; j < i; j++) { if (nums[j] < nums[i]) dp[i] = max(dp[i], dp[j] + 1); } } return *max_element(dp.begin(), dp.end()); } };"
                }
            },
            "optimized": {
                "intuition": "Binary search with patience sorting.",
                "algorithm": "O(n log n)",
                "complexity": {
                    "time": "O(n log n)",
                    "space": "O(n)"
                },
                "code": {
                    "python": "class Solution:\n    def lengthOfLIS(self, nums):\n        import bisect\n        sub = []\n        for num in nums:\n            pos = bisect.bisect_left(sub, num)\n            if pos == len(sub):\n                sub.append(num)\n            else:\n                sub[pos] = num\n        return len(sub)",
                    "java": "class Solution { public int lengthOfLIS(int[] nums) { List<Integer> sub = new ArrayList<>(); for (int num : nums) { int pos = Collections.binarySearch(sub, num); if (pos < 0) pos = -(pos + 1); if (pos == sub.size()) sub.add(num); else sub.set(pos, num); } return sub.size(); } }",
                    "cpp": "class Solution { public: int lengthOfLIS(vector<int>& nums) { vector<int> sub; for (int num : nums) { auto pos = lower_bound(sub.begin(), sub.end(), num); if (pos == sub.end()) sub.push_back(num); else *pos = num; } return sub.size(); } };"
                }
            }
        }
    },
    "jump-game": {
        "description": "<p>You are given an integer array <code>nums</code>. You are initially positioned at the array's <strong>first index</strong>, and each element in the array represents your maximum jump length at that position.</p><p>Return <code>true</code> <em>if you can reach the last index, or</em> <code>false</code> <em>otherwise</em>.</p><p>While this can be solved with dynamic programming, the optimal solution uses a <strong>greedy approach</strong> by tracking the maximum reachable index as you iterate through the array.</p>",
        "examples": [
            {
                "input": "nums = [2,3,1,1,4]",
                "output": "true",
                "explanation": "Jump 1 step from index 0 to 1, then 3 steps to the last index."
            },
            {
                "input": "nums = [3,2,1,0,4]",
                "output": "false",
                "explanation": "You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index."
            },
            {
                "input": "nums = [0]",
                "output": "true",
                "explanation": "Already at the last index."
            }
        ],
        "constraints": [
            "<code>1 <= nums.length <= 10<sup>4</sup></code>",
            "<code>0 <= nums[i] <= 10<sup>5</sup></code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "DP from end.",
                "algorithm": "Backward DP",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)"
                },
                "code": {
                    "python": "class Solution:\n    def canJump(self, nums):\n        n = len(nums)\n        dp = [False] * n\n        dp[n-1] = True\n        for i in range(n-2, -1, -1):\n            for j in range(1, nums[i] + 1):\n                if i + j < n and dp[i + j]:\n                    dp[i] = True\n                    break\n        return dp[0]",
                    "java": "class Solution { public boolean canJump(int[] nums) { int n = nums.length; boolean[] dp = new boolean[n]; dp[n-1] = true; for (int i = n-2; i >= 0; i--) { for (int j = 1; j <= nums[i] && i + j < n; j++) { if (dp[i + j]) { dp[i] = true; break; } } } return dp[0]; } }",
                    "cpp": "class Solution { public: bool canJump(vector<int>& nums) { int n = nums.size(); vector<bool> dp(n, false); dp[n-1] = true; for (int i = n-2; i >= 0; i--) { for (int j = 1; j <= nums[i] && i + j < n; j++) { if (dp[i + j]) { dp[i] = true; break; } } } return dp[0]; } };"
                }
            },
            "optimized": {
                "intuition": "Greedy approach.",
                "algorithm": "Track max reachable",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)"
                },
                "code": {
                    "python": "class Solution:\n    def canJump(self, nums):\n        maxReach = 0\n        for i in range(len(nums)):\n            if i > maxReach: return False\n            maxReach = max(maxReach, i + nums[i])\n        return True",
                    "java": "class Solution { public boolean canJump(int[] nums) { int maxReach = 0; for (int i = 0; i < nums.length; i++) { if (i > maxReach) return false; maxReach = Math.max(maxReach, i + nums[i]); } return true; } }",
                    "cpp": "class Solution { public: bool canJump(vector<int>& nums) { int maxReach = 0; for (int i = 0; i < nums.size(); i++) { if (i > maxReach) return false; maxReach = max(maxReach, i + nums[i]); } return true; } };"
                }
            }
        }
    },
    "subsets": {
        "description": "<p>Given an integer array <code>nums</code> of <strong>unique</strong> elements, return <em>all possible subsets (the power set)</em>.</p><p>The solution set <strong>must not</strong> contain duplicate subsets. Return the solution in <strong>any order</strong>.</p><p>This is a classic <strong>backtracking</strong> problem where you make a binary decision at each element: include it or exclude it. The total number of subsets is <code>2<sup>n</sup></code>.</p>",
        "examples": [
            {
                "input": "nums = [1,2,3]",
                "output": "[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]",
                "explanation": "There are 8 subsets total (2^3). Each element can either be included or excluded."
            },
            {
                "input": "nums = [0]",
                "output": "[[],[0]]",
                "explanation": "There are 2 subsets: the empty set and the set containing 0."
            },
            {
                "input": "nums = [1,2]",
                "output": "[[],[1],[2],[1,2]]",
                "explanation": "There are 4 subsets total (2^2)."
            }
        ],
        "constraints": [
            "<code>1 <= nums.length <= 10</code>",
            "<code>-10 <= nums[i] <= 10</code>",
            "<code>All the numbers of nums are unique</code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "Iterative building.",
                "algorithm": "Add each element to existing subsets",
                "complexity": {
                    "time": "O(n*2^n)",
                    "space": "O(n*2^n)"
                },
                "code": {
                    "python": "class Solution:\n    def subsets(self, nums):\n        result = [[]]\n        for num in nums:\n            result += [subset + [num] for subset in result]\n        return result",
                    "java": "class Solution { public List<List<Integer>> subsets(int[] nums) { List<List<Integer>> result = new ArrayList<>(); result.add(new ArrayList<>()); for (int num : nums) { int size = result.size(); for (int i = 0; i < size; i++) { List<Integer> subset = new ArrayList<>(result.get(i)); subset.add(num); result.add(subset); } } return result; } }",
                    "cpp": "class Solution { public: vector<vector<int>> subsets(vector<int>& nums) { vector<vector<int>> result = {{}}; for (int num : nums) { int size = result.size(); for (int i = 0; i < size; i++) { vector<int> subset = result[i]; subset.push_back(num); result.push_back(subset); } } return result; } };"
                }
            },
            "optimized": {
                "intuition": "Backtracking.",
                "algorithm": "Include/exclude each element",
                "complexity": {
                    "time": "O(n*2^n)",
                    "space": "O(n)"
                },
                "code": {
                    "python": "class Solution:\n    def subsets(self, nums):\n        result = []\n        def backtrack(start, path):\n            result.append(path[:])\n            for i in range(start, len(nums)):\n                path.append(nums[i])\n                backtrack(i + 1, path)\n                path.pop()\n        backtrack(0, [])\n        return result",
                    "java": "class Solution { List<List<Integer>> result = new ArrayList<>(); public List<List<Integer>> subsets(int[] nums) { backtrack(nums, 0, new ArrayList<>()); return result; } void backtrack(int[] nums, int start, List<Integer> path) { result.add(new ArrayList<>(path)); for (int i = start; i < nums.length; i++) { path.add(nums[i]); backtrack(nums, i + 1, path); path.remove(path.size() - 1); } } }",
                    "cpp": "class Solution { vector<vector<int>> result; public: vector<vector<int>> subsets(vector<int>& nums) { vector<int> path; backtrack(nums, 0, path); return result; } void backtrack(vector<int>& nums, int start, vector<int>& path) { result.push_back(path); for (int i = start; i < nums.size(); i++) { path.push_back(nums[i]); backtrack(nums, i + 1, path); path.pop_back(); } } };"
                }
            }
        }
    },
    "subsets-ii": {
        "description": "<p>Given an integer array <code>nums</code> that <strong>may contain duplicates</strong>, return <em>all possible subsets (the power set)</em>.</p><p>The solution set <strong>must not</strong> contain duplicate subsets. Return the solution in <strong>any order</strong>.</p><p><strong>Approach:</strong> Similar to Subsets I, but we need to handle duplicates. <strong>Sort the array first</strong>, then during backtracking, skip duplicate elements at the same recursion level. If <code>nums[i] == nums[i-1]</code> and we didn't take <code>nums[i-1]</code>, skip <code>nums[i]</code>.</p>",
        "examples": [
            {
                "input": "nums = [1,2,2]",
                "output": "[[],[1],[1,2],[1,2,2],[2],[2,2]]",
                "explanation": "The two 2's produce duplicate subsets if not handled carefully. After sorting, we skip duplicates at the same level."
            },
            {
                "input": "nums = [0]",
                "output": "[[],[0]]",
                "explanation": "Single element array produces empty set and set with that element."
            },
            {
                "input": "nums = [4,4,4,1,4]",
                "output": "[[],[1],[1,4],[1,4,4],[1,4,4,4],[1,4,4,4,4],[4],[4,4],[4,4,4],[4,4,4,4]]",
                "explanation": "After sorting to [1,4,4,4,4], we generate subsets while skipping duplicates at each level."
            }
        ],
        "constraints": [
            "<code>1 <= nums.length <= 10</code>",
            "<code>-10 <= nums[i] <= 10</code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "Use set to avoid duplicates.",
                "algorithm": "Track seen subsets",
                "complexity": {
                    "time": "O(n*2^n)",
                    "space": "O(n*2^n)"
                },
                "code": {
                    "python": "class Solution:\n    def subsetsWithDup(self, nums):\n        nums.sort()\n        result = set()\n        def backtrack(start, path):\n            result.add(tuple(path))\n            for i in range(start, len(nums)):\n                path.append(nums[i])\n                backtrack(i + 1, path)\n                path.pop()\n        backtrack(0, [])\n        return [list(s) for s in result]",
                    "java": "class Solution { public List<List<Integer>> subsetsWithDup(int[] nums) { Arrays.sort(nums); Set<List<Integer>> result = new HashSet<>(); backtrack(nums, 0, new ArrayList<>(), result); return new ArrayList<>(result); } void backtrack(int[] nums, int start, List<Integer> path, Set<List<Integer>> result) { result.add(new ArrayList<>(path)); for (int i = start; i < nums.length; i++) { path.add(nums[i]); backtrack(nums, i + 1, path, result); path.remove(path.size() - 1); } } }",
                    "cpp": "class Solution { public: vector<vector<int>> subsetsWithDup(vector<int>& nums) { sort(nums.begin(), nums.end()); set<vector<int>> result; vector<int> path; backtrack(nums, 0, path, result); return vector<vector<int>>(result.begin(), result.end()); } void backtrack(vector<int>& nums, int start, vector<int>& path, set<vector<int>>& result) { result.insert(path); for (int i = start; i < nums.size(); i++) { path.push_back(nums[i]); backtrack(nums, i + 1, path, result); path.pop_back(); } } };"
                }
            },
            "optimized": {
                "intuition": "Skip duplicates in recursion.",
                "algorithm": "Sort and skip same values",
                "complexity": {
                    "time": "O(n*2^n)",
                    "space": "O(n)"
                },
                "code": {
                    "python": "class Solution:\n    def subsetsWithDup(self, nums):\n        nums.sort()\n        result = []\n        def backtrack(start, path):\n            result.append(path[:])\n            for i in range(start, len(nums)):\n                if i > start and nums[i] == nums[i-1]:\n                    continue\n                path.append(nums[i])\n                backtrack(i + 1, path)\n                path.pop()\n        backtrack(0, [])\n        return result",
                    "java": "class Solution { List<List<Integer>> result = new ArrayList<>(); public List<List<Integer>> subsetsWithDup(int[] nums) { Arrays.sort(nums); backtrack(nums, 0, new ArrayList<>()); return result; } void backtrack(int[] nums, int start, List<Integer> path) { result.add(new ArrayList<>(path)); for (int i = start; i < nums.length; i++) { if (i > start && nums[i] == nums[i-1]) continue; path.add(nums[i]); backtrack(nums, i + 1, path); path.remove(path.size() - 1); } } }",
                    "cpp": "class Solution { vector<vector<int>> result; public: vector<vector<int>> subsetsWithDup(vector<int>& nums) { sort(nums.begin(), nums.end()); vector<int> path; backtrack(nums, 0, path); return result; } void backtrack(vector<int>& nums, int start, vector<int>& path) { result.push_back(path); for (int i = start; i < nums.size(); i++) { if (i > start && nums[i] == nums[i-1]) continue; path.push_back(nums[i]); backtrack(nums, i + 1, path); path.pop_back(); } } };"
                }
            }
        }
    },
    "combination-sum": {
        "description": "<p>Given an array of <strong>distinct</strong> integers <code>candidates</code> and a target integer <code>target</code>, return <em>a list of all <strong>unique combinations</strong> of</em> <code>candidates</code> <em>where the chosen numbers sum to</em> <code>target</code>. You may return the combinations in <strong>any order</strong>.</p><p>The <strong>same</strong> number may be chosen from <code>candidates</code> an <strong>unlimited number of times</strong>. Two combinations are unique if the frequency of at least one of the chosen numbers is different.</p><p><strong>Approach:</strong> Use <strong>backtracking</strong> with the ability to reuse the same element. At each step, either include the current element (and stay at the same index) or skip it. Sort the array first for optimization (early termination when remaining target becomes negative). Track the current combination and remaining target.</p>",
        "examples": [
            {
                "input": "candidates = [2,3,6,7], target = 7",
                "output": "[[2,2,3],[7]]"
            }
        ],
        "constraints": [
            "1 <= candidates.length <= 30"
        ],
        "solutions": {
            "brute": {
                "intuition": "Try all combinations.",
                "algorithm": "Backtracking with reuse",
                "complexity": {
                    "time": "O(n^(T/M))",
                    "space": "O(T/M)"
                },
                "code": {
                    "python": "class Solution:\n    def combinationSum(self, candidates, target):\n        result = []\n        def backtrack(start, path, total):\n            if total == target:\n                result.append(path[:])\n                return\n            if total > target:\n                return\n            for i in range(start, len(candidates)):\n                path.append(candidates[i])\n                backtrack(i, path, total + candidates[i])\n                path.pop()\n        backtrack(0, [], 0)\n        return result",
                    "java": "class Solution { List<List<Integer>> result = new ArrayList<>(); public List<List<Integer>> combinationSum(int[] candidates, int target) { backtrack(candidates, target, 0, new ArrayList<>(), 0); return result; } void backtrack(int[] cand, int target, int start, List<Integer> path, int total) { if (total == target) { result.add(new ArrayList<>(path)); return; } if (total > target) return; for (int i = start; i < cand.length; i++) { path.add(cand[i]); backtrack(cand, target, i, path, total + cand[i]); path.remove(path.size() - 1); } } }",
                    "cpp": "class Solution { vector<vector<int>> result; public: vector<vector<int>> combinationSum(vector<int>& candidates, int target) { vector<int> path; backtrack(candidates, target, 0, path, 0); return result; } void backtrack(vector<int>& cand, int target, int start, vector<int>& path, int total) { if (total == target) { result.push_back(path); return; } if (total > target) return; for (int i = start; i < cand.size(); i++) { path.push_back(cand[i]); backtrack(cand, target, i, path, total + cand[i]); path.pop_back(); } } };"
                }
            },
            "optimized": {
                "intuition": "Sort and early pruning.",
                "algorithm": "Stop early when exceeds",
                "complexity": {
                    "time": "O(n^(T/M))",
                    "space": "O(T/M)"
                },
                "code": {
                    "python": "class Solution:\n    def combinationSum(self, candidates, target):\n        candidates.sort()\n        result = []\n        def backtrack(start, path, remain):\n            if remain == 0:\n                result.append(path[:])\n                return\n            for i in range(start, len(candidates)):\n                if candidates[i] > remain:\n                    break\n                path.append(candidates[i])\n                backtrack(i, path, remain - candidates[i])\n                path.pop()\n        backtrack(0, [], target)\n        return result",
                    "java": "class Solution { List<List<Integer>> result = new ArrayList<>(); public List<List<Integer>> combinationSum(int[] candidates, int target) { Arrays.sort(candidates); backtrack(candidates, target, 0, new ArrayList<>()); return result; } void backtrack(int[] cand, int remain, int start, List<Integer> path) { if (remain == 0) { result.add(new ArrayList<>(path)); return; } for (int i = start; i < cand.length && cand[i] <= remain; i++) { path.add(cand[i]); backtrack(cand, remain - cand[i], i, path); path.remove(path.size() - 1); } } }",
                    "cpp": "class Solution { vector<vector<int>> result; public: vector<vector<int>> combinationSum(vector<int>& candidates, int target) { sort(candidates.begin(), candidates.end()); vector<int> path; backtrack(candidates, target, 0, path); return result; } void backtrack(vector<int>& cand, int remain, int start, vector<int>& path) { if (remain == 0) { result.push_back(path); return; } for (int i = start; i < cand.size() && cand[i] <= remain; i++) { path.push_back(cand[i]); backtrack(cand, remain - cand[i], i, path); path.pop_back(); } } };"
                }
            }
        }
    },
    "combination-sum-ii": {
        "description": "<p>Given a collection of candidate numbers (<code>candidates</code>) and a target number (<code>target</code>), find all unique combinations in <code>candidates</code> where the candidate numbers sum to <code>target</code>.</p><p>Each number in <code>candidates</code> may only be used <strong>once</strong> in the combination.</p><p><strong>Note:</strong> The solution set must not contain duplicate combinations.</p><p><strong>Approach:</strong> Similar to Combination Sum I, but each element can only be used once and the array may contain duplicates. <strong>Sort the array first</strong>, then during backtracking, skip duplicate elements at the same recursion level to avoid duplicate combinations. Move to the next index after including an element (unlike Combination Sum I where we stayed at the same index).</p>",
        "examples": [
            {
                "input": "candidates = [10,1,2,7,6,1,5], target = 8",
                "output": "[[1,1,6],[1,2,5],[1,7],[2,6]]",
                "explanation": "After sorting [1,1,2,5,6,7,10], we find combinations. The two 1's can both be used, but we skip duplicates at the same level."
            },
            {
                "input": "candidates = [2,5,2,1,2], target = 5",
                "output": "[[1,2,2],[5]]",
                "explanation": "After sorting [1,2,2,2,5], the valid combinations are [1,2,2] and [5]."
            },
            {
                "input": "candidates = [1], target = 1",
                "output": "[[1]]",
                "explanation": "Single element that matches the target."
            }
        ],
        "constraints": [
            "<code>1 <= candidates.length <= 100</code>",
            "<code>1 <= candidates[i] <= 50</code>",
            "<code>1 <= target <= 30</code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "Use set to track seen.",
                "algorithm": "Backtracking with set",
                "complexity": {
                    "time": "O(2^n)",
                    "space": "O(n)"
                },
                "code": {
                    "python": "class Solution:\n    def combinationSum2(self, candidates, target):\n        candidates.sort()\n        result = set()\n        def backtrack(start, path, remain):\n            if remain == 0:\n                result.add(tuple(path))\n                return\n            for i in range(start, len(candidates)):\n                if candidates[i] > remain: break\n                path.append(candidates[i])\n                backtrack(i + 1, path, remain - candidates[i])\n                path.pop()\n        backtrack(0, [], target)\n        return [list(r) for r in result]",
                    "java": "class Solution { public List<List<Integer>> combinationSum2(int[] candidates, int target) { Arrays.sort(candidates); Set<List<Integer>> result = new HashSet<>(); backtrack(candidates, target, 0, new ArrayList<>(), result); return new ArrayList<>(result); } void backtrack(int[] cand, int remain, int start, List<Integer> path, Set<List<Integer>> result) { if (remain == 0) { result.add(new ArrayList<>(path)); return; } for (int i = start; i < cand.length && cand[i] <= remain; i++) { path.add(cand[i]); backtrack(cand, remain - cand[i], i + 1, path, result); path.remove(path.size() - 1); } } }",
                    "cpp": "class Solution { public: vector<vector<int>> combinationSum2(vector<int>& candidates, int target) { sort(candidates.begin(), candidates.end()); set<vector<int>> result; vector<int> path; backtrack(candidates, target, 0, path, result); return vector<vector<int>>(result.begin(), result.end()); } void backtrack(vector<int>& cand, int remain, int start, vector<int>& path, set<vector<int>>& result) { if (remain == 0) { result.insert(path); return; } for (int i = start; i < cand.size() && cand[i] <= remain; i++) { path.push_back(cand[i]); backtrack(cand, remain - cand[i], i + 1, path, result); path.pop_back(); } } };"
                }
            },
            "optimized": {
                "intuition": "Skip duplicates inline.",
                "algorithm": "Skip same values at same level",
                "complexity": {
                    "time": "O(2^n)",
                    "space": "O(n)"
                },
                "code": {
                    "python": "class Solution:\n    def combinationSum2(self, candidates, target):\n        candidates.sort()\n        result = []\n        def backtrack(start, path, remain):\n            if remain == 0:\n                result.append(path[:])\n                return\n            for i in range(start, len(candidates)):\n                if candidates[i] > remain: break\n                if i > start and candidates[i] == candidates[i-1]: continue\n                path.append(candidates[i])\n                backtrack(i + 1, path, remain - candidates[i])\n                path.pop()\n        backtrack(0, [], target)\n        return result",
                    "java": "class Solution { List<List<Integer>> result = new ArrayList<>(); public List<List<Integer>> combinationSum2(int[] candidates, int target) { Arrays.sort(candidates); backtrack(candidates, target, 0, new ArrayList<>()); return result; } void backtrack(int[] cand, int remain, int start, List<Integer> path) { if (remain == 0) { result.add(new ArrayList<>(path)); return; } for (int i = start; i < cand.length && cand[i] <= remain; i++) { if (i > start && cand[i] == cand[i-1]) continue; path.add(cand[i]); backtrack(cand, remain - cand[i], i + 1, path); path.remove(path.size() - 1); } } }",
                    "cpp": "class Solution { vector<vector<int>> result; public: vector<vector<int>> combinationSum2(vector<int>& candidates, int target) { sort(candidates.begin(), candidates.end()); vector<int> path; backtrack(candidates, target, 0, path); return result; } void backtrack(vector<int>& cand, int remain, int start, vector<int>& path) { if (remain == 0) { result.push_back(path); return; } for (int i = start; i < cand.size() && cand[i] <= remain; i++) { if (i > start && cand[i] == cand[i-1]) continue; path.push_back(cand[i]); backtrack(cand, remain - cand[i], i + 1, path); path.pop_back(); } } };"
                }
            }
        }
    },
    "permutations": {
        "description": "<p>Given an array <code>nums</code> of <strong>distinct</strong> integers, return <em>all the possible permutations</em>. You can return the answer in <strong>any order</strong>.</p><p><strong>Approach:</strong> Use <strong>backtracking</strong> to explore all arrangements. At each step, try placing each unused element in the current position. Mark elements as used (with a boolean array or by swapping). There are <code>n!</code> permutations total. Can also use iterative approaches or built-in library functions.</p>",
        "examples": [
            {
                "input": "nums = [1,2,3]",
                "output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]",
                "explanation": "There are 3! = 6 permutations of 3 distinct elements."
            },
            {
                "input": "nums = [0,1]",
                "output": "[[0,1],[1,0]]",
                "explanation": "Two elements have 2! = 2 permutations."
            },
            {
                "input": "nums = [1]",
                "output": "[[1]]",
                "explanation": "Single element has only 1 permutation."
            }
        ],
        "constraints": [
            "<code>1 <= nums.length <= 6</code>",
            "<code>-10 <= nums[i] <= 10</code>",
            "<code>All the integers of nums are unique</code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "Track used elements.",
                "algorithm": "Backtracking with visited",
                "complexity": {
                    "time": "O(n!)",
                    "space": "O(n)"
                },
                "code": {
                    "python": "class Solution:\n    def permute(self, nums):\n        result = []\n        used = [False] * len(nums)\n        def backtrack(path):\n            if len(path) == len(nums):\n                result.append(path[:])\n                return\n            for i in range(len(nums)):\n                if used[i]: continue\n                used[i] = True\n                path.append(nums[i])\n                backtrack(path)\n                path.pop()\n                used[i] = False\n        backtrack([])\n        return result",
                    "java": "class Solution { List<List<Integer>> result = new ArrayList<>(); public List<List<Integer>> permute(int[] nums) { backtrack(nums, new ArrayList<>(), new boolean[nums.length]); return result; } void backtrack(int[] nums, List<Integer> path, boolean[] used) { if (path.size() == nums.length) { result.add(new ArrayList<>(path)); return; } for (int i = 0; i < nums.length; i++) { if (used[i]) continue; used[i] = true; path.add(nums[i]); backtrack(nums, path, used); path.remove(path.size() - 1); used[i] = false; } } }",
                    "cpp": "class Solution { vector<vector<int>> result; public: vector<vector<int>> permute(vector<int>& nums) { vector<int> path; vector<bool> used(nums.size(), false); backtrack(nums, path, used); return result; } void backtrack(vector<int>& nums, vector<int>& path, vector<bool>& used) { if (path.size() == nums.size()) { result.push_back(path); return; } for (int i = 0; i < nums.size(); i++) { if (used[i]) continue; used[i] = true; path.push_back(nums[i]); backtrack(nums, path, used); path.pop_back(); used[i] = false; } } };"
                }
            },
            "optimized": {
                "intuition": "Swap elements.",
                "algorithm": "In-place swapping",
                "complexity": {
                    "time": "O(n!)",
                    "space": "O(n)"
                },
                "code": {
                    "python": "class Solution:\n    def permute(self, nums):\n        result = []\n        def backtrack(start):\n            if start == len(nums):\n                result.append(nums[:])\n                return\n            for i in range(start, len(nums)):\n                nums[start], nums[i] = nums[i], nums[start]\n                backtrack(start + 1)\n                nums[start], nums[i] = nums[i], nums[start]\n        backtrack(0)\n        return result",
                    "java": "class Solution { List<List<Integer>> result = new ArrayList<>(); public List<List<Integer>> permute(int[] nums) { backtrack(nums, 0); return result; } void backtrack(int[] nums, int start) { if (start == nums.length) { List<Integer> perm = new ArrayList<>(); for (int n : nums) perm.add(n); result.add(perm); return; } for (int i = start; i < nums.length; i++) { swap(nums, start, i); backtrack(nums, start + 1); swap(nums, start, i); } } void swap(int[] nums, int i, int j) { int t = nums[i]; nums[i] = nums[j]; nums[j] = t; } }",
                    "cpp": "class Solution { vector<vector<int>> result; public: vector<vector<int>> permute(vector<int>& nums) { backtrack(nums, 0); return result; } void backtrack(vector<int>& nums, int start) { if (start == nums.size()) { result.push_back(nums); return; } for (int i = start; i < nums.size(); i++) { swap(nums[start], nums[i]); backtrack(nums, start + 1); swap(nums[start], nums[i]); } } };"
                }
            }
        }
    },
    "permutations-ii": {
        "description": "Return unique permutations with duplicates.",
        "examples": [
            {
                "input": "nums = [1,1,2]",
                "output": "[[1,1,2],[1,2,1],[2,1,1]]"
            }
        ],
        "constraints": [
            "1 <= nums.length <= 8"
        ],
        "solutions": {
            "brute": {
                "intuition": "Use set to track.",
                "algorithm": "Store in set",
                "complexity": {
                    "time": "O(n!)",
                    "space": "O(n!)"
                },
                "code": {
                    "python": "class Solution:\n    def permuteUnique(self, nums):\n        result = set()\n        used = [False] * len(nums)\n        def backtrack(path):\n            if len(path) == len(nums):\n                result.add(tuple(path))\n                return\n            for i in range(len(nums)):\n                if used[i]: continue\n                used[i] = True\n                path.append(nums[i])\n                backtrack(path)\n                path.pop()\n                used[i] = False\n        backtrack([])\n        return [list(p) for p in result]",
                    "java": "class Solution { public List<List<Integer>> permuteUnique(int[] nums) { Set<List<Integer>> result = new HashSet<>(); backtrack(nums, new ArrayList<>(), new boolean[nums.length], result); return new ArrayList<>(result); } void backtrack(int[] nums, List<Integer> path, boolean[] used, Set<List<Integer>> result) { if (path.size() == nums.length) { result.add(new ArrayList<>(path)); return; } for (int i = 0; i < nums.length; i++) { if (used[i]) continue; used[i] = true; path.add(nums[i]); backtrack(nums, path, used, result); path.remove(path.size() - 1); used[i] = false; } } }",
                    "cpp": "class Solution { public: vector<vector<int>> permuteUnique(vector<int>& nums) { set<vector<int>> result; vector<int> path; vector<bool> used(nums.size(), false); backtrack(nums, path, used, result); return vector<vector<int>>(result.begin(), result.end()); } void backtrack(vector<int>& nums, vector<int>& path, vector<bool>& used, set<vector<int>>& result) { if (path.size() == nums.size()) { result.insert(path); return; } for (int i = 0; i < nums.size(); i++) { if (used[i]) continue; used[i] = true; path.push_back(nums[i]); backtrack(nums, path, used, result); path.pop_back(); used[i] = false; } } };"
                }
            },
            "optimized": {
                "intuition": "Sort and skip duplicates.",
                "algorithm": "Skip same values at same level",
                "complexity": {
                    "time": "O(n!)",
                    "space": "O(n)"
                },
                "code": {
                    "python": "class Solution:\n    def permuteUnique(self, nums):\n        nums.sort()\n        result = []\n        used = [False] * len(nums)\n        def backtrack(path):\n            if len(path) == len(nums):\n                result.append(path[:])\n                return\n            for i in range(len(nums)):\n                if used[i]: continue\n                if i > 0 and nums[i] == nums[i-1] and not used[i-1]: continue\n                used[i] = True\n                path.append(nums[i])\n                backtrack(path)\n                path.pop()\n                used[i] = False\n        backtrack([])\n        return result",
                    "java": "class Solution { List<List<Integer>> result = new ArrayList<>(); public List<List<Integer>> permuteUnique(int[] nums) { Arrays.sort(nums); backtrack(nums, new ArrayList<>(), new boolean[nums.length]); return result; } void backtrack(int[] nums, List<Integer> path, boolean[] used) { if (path.size() == nums.length) { result.add(new ArrayList<>(path)); return; } for (int i = 0; i < nums.length; i++) { if (used[i]) continue; if (i > 0 && nums[i] == nums[i-1] && !used[i-1]) continue; used[i] = true; path.add(nums[i]); backtrack(nums, path, used); path.remove(path.size() - 1); used[i] = false; } } }",
                    "cpp": "class Solution { vector<vector<int>> result; public: vector<vector<int>> permuteUnique(vector<int>& nums) { sort(nums.begin(), nums.end()); vector<int> path; vector<bool> used(nums.size(), false); backtrack(nums, path, used); return result; } void backtrack(vector<int>& nums, vector<int>& path, vector<bool>& used) { if (path.size() == nums.size()) { result.push_back(path); return; } for (int i = 0; i < nums.size(); i++) { if (used[i]) continue; if (i > 0 && nums[i] == nums[i-1] && !used[i-1]) continue; used[i] = true; path.push_back(nums[i]); backtrack(nums, path, used); path.pop_back(); used[i] = false; } } };"
                }
            }
        }
    },
    "letter-combinations-of-a-phone-number": {
        "description": "<p>Given a string containing digits from <code>2-9</code> inclusive, return all possible letter combinations that the number could represent. Return the answer in <strong>any order</strong>.</p><p>A mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.</p><p><code>2 -> abc<br/>3 -> def<br/>4 -> ghi<br/>5 -> jkl<br/>6 -> mno<br/>7 -> pqrs<br/>8 -> tuv<br/>9 -> wxyz</code></p><p><strong>Approach:</strong> Use <strong>backtracking</strong> to build combinations character by character. For each digit, iterate through its corresponding letters and recursively build the rest of the combination. Alternatively, use an iterative approach where each digit expands the current list of combinations. Time complexity is <code>O(4<sup>n</sup> * n)</code> in the worst case (digits like 7 and 9 map to 4 letters).</p>",
        "examples": [
            {
                "input": "digits = \"23\"",
                "output": "[\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"]",
                "explanation": "2 maps to 'abc', 3 maps to 'def'. We get 3*3=9 combinations."
            },
            {
                "input": "digits = \"\"",
                "output": "[]",
                "explanation": "Empty input produces no combinations."
            },
            {
                "input": "digits = \"2\"",
                "output": "[\"a\",\"b\",\"c\"]",
                "explanation": "Single digit 2 produces its 3 corresponding letters."
            }
        ],
        "constraints": [
            "<code>0 <= digits.length <= 4</code>",
            "<code>digits[i] is a digit in the range ['2', '9']</code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "Iterative building.",
                "algorithm": "Build step by step",
                "complexity": {
                    "time": "O(4^n)",
                    "space": "O(4^n)"
                },
                "code": {
                    "python": "class Solution:\n    def letterCombinations(self, digits):\n        if not digits: return []\n        mapping = {'2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'}\n        result = ['']\n        for digit in digits:\n            result = [prev + c for prev in result for c in mapping[digit]]\n        return result",
                    "java": "class Solution { public List<String> letterCombinations(String digits) { if (digits.isEmpty()) return new ArrayList<>(); String[] mapping = {\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"}; List<String> result = new ArrayList<>(); result.add(\"\"); for (char d : digits.toCharArray()) { List<String> temp = new ArrayList<>(); for (String prev : result) for (char c : mapping[d - '0'].toCharArray()) temp.add(prev + c); result = temp; } return result; } }",
                    "cpp": "class Solution { public: vector<string> letterCombinations(string digits) { if (digits.empty()) return {}; string mapping[] = {\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"}; vector<string> result = {\"\"}; for (char d : digits) { vector<string> temp; for (auto& prev : result) for (char c : mapping[d - '0']) temp.push_back(prev + c); result = temp; } return result; } };"
                }
            },
            "optimized": {
                "intuition": "Backtracking.",
                "algorithm": "Recursive building",
                "complexity": {
                    "time": "O(4^n)",
                    "space": "O(n)"
                },
                "code": {
                    "python": "class Solution:\n    def letterCombinations(self, digits):\n        if not digits: return []\n        mapping = {'2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'}\n        result = []\n        def backtrack(i, path):\n            if i == len(digits):\n                result.append(''.join(path))\n                return\n            for c in mapping[digits[i]]:\n                path.append(c)\n                backtrack(i + 1, path)\n                path.pop()\n        backtrack(0, [])\n        return result",
                    "java": "class Solution { String[] mapping = {\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"}; List<String> result = new ArrayList<>(); public List<String> letterCombinations(String digits) { if (digits.isEmpty()) return result; backtrack(digits, 0, new StringBuilder()); return result; } void backtrack(String digits, int i, StringBuilder path) { if (i == digits.length()) { result.add(path.toString()); return; } for (char c : mapping[digits.charAt(i) - '0'].toCharArray()) { path.append(c); backtrack(digits, i + 1, path); path.deleteCharAt(path.length() - 1); } } }",
                    "cpp": "class Solution { string mapping[10] = {\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"}; vector<string> result; public: vector<string> letterCombinations(string digits) { if (digits.empty()) return {}; backtrack(digits, 0, \"\"); return result; } void backtrack(string& digits, int i, string path) { if (i == digits.size()) { result.push_back(path); return; } for (char c : mapping[digits[i] - '0']) { backtrack(digits, i + 1, path + c); } } };"
                }
            }
        }
    },
    "generate-parentheses": {
        "description": `<p>Given <code>n</code> pairs of parentheses, write a function to <em>generate all combinations of well-formed parentheses</em>.</p>
<p>A string of parentheses is considered well-formed if:</p>
<ul>
<li>Every opening parenthesis <code>'('</code> has a corresponding closing parenthesis <code>')'</code></li>
<li>Closing parentheses come after their corresponding opening parentheses</li>
<li>At no point while reading left-to-right should the count of closing parentheses exceed opening parentheses</li>
</ul>
<p>This is a classic <strong>backtracking</strong> problem where we build valid strings character by character. We can only add an opening parenthesis if we haven't used all <code>n</code> of them yet. We can only add a closing parenthesis if it wouldn't exceed the number of opening parentheses used so far.</p>
<p>The number of valid combinations for n pairs is the nth Catalan number: C(n) = (2n)! / ((n+1)! * n!)</p>`,
        "examples": [
            {
                "input": "n = 3",
                "output": "[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]",
                "explanation": "With 3 pairs, we generate all 5 possible valid combinations (the 3rd Catalan number is 5). Each uses exactly 3 opening and 3 closing parentheses in valid order."
            },
            {
                "input": "n = 1",
                "output": "[\"()\"]",
                "explanation": "With 1 pair, there's only one valid combination: ()."
            },
            {
                "input": "n = 2",
                "output": "[\"(())\",\"()()\"]",
                "explanation": "With 2 pairs, there are exactly 2 valid combinations (the 2nd Catalan number)."
            }
        ],
        "constraints": [
            "<code>1 <= n <= 8</code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "Generate all and filter.",
                "algorithm": "Check validity",
                "complexity": {
                    "time": "O(2^2n * n)",
                    "space": "O(2^2n)"
                },
                "code": {
                    "python": "class Solution:\n    def generateParenthesis(self, n):\n        def isValid(s):\n            count = 0\n            for c in s:\n                if c == '(': count += 1\n                else: count -= 1\n                if count < 0: return False\n            return count == 0\n        result = []\n        def generate(s):\n            if len(s) == 2 * n:\n                if isValid(s): result.append(s)\n                return\n            generate(s + '(')\n            generate(s + ')')\n        generate('')\n        return result",
                    "java": "class Solution { public List<String> generateParenthesis(int n) { List<String> result = new ArrayList<>(); generate(result, \"\", n); return result; } void generate(List<String> result, String s, int n) { if (s.length() == 2 * n) { if (isValid(s)) result.add(s); return; } generate(result, s + \"(\", n); generate(result, s + \")\", n); } boolean isValid(String s) { int count = 0; for (char c : s.toCharArray()) { if (c == '(') count++; else count--; if (count < 0) return false; } return count == 0; } }",
                    "cpp": "class Solution { public: vector<string> generateParenthesis(int n) { vector<string> result; generate(result, \"\", n); return result; } void generate(vector<string>& result, string s, int n) { if (s.size() == 2 * n) { if (isValid(s)) result.push_back(s); return; } generate(result, s + \"(\", n); generate(result, s + \")\", n); } bool isValid(string& s) { int count = 0; for (char c : s) { if (c == '(') count++; else count--; if (count < 0) return false; } return count == 0; } };"
                }
            },
            "optimized": {
                "intuition": "Track open and close counts.",
                "algorithm": "Only add valid chars",
                "complexity": {
                    "time": "O(4^n/sqrt(n))",
                    "space": "O(n)"
                },
                "code": {
                    "python": "class Solution:\n    def generateParenthesis(self, n):\n        result = []\n        def backtrack(path, open_count, close_count):\n            if len(path) == 2 * n:\n                result.append(''.join(path))\n                return\n            if open_count < n:\n                path.append('(')\n                backtrack(path, open_count + 1, close_count)\n                path.pop()\n            if close_count < open_count:\n                path.append(')')\n                backtrack(path, open_count, close_count + 1)\n                path.pop()\n        backtrack([], 0, 0)\n        return result",
                    "java": "class Solution { List<String> result = new ArrayList<>(); public List<String> generateParenthesis(int n) { backtrack(new StringBuilder(), 0, 0, n); return result; } void backtrack(StringBuilder path, int open, int close, int n) { if (path.length() == 2 * n) { result.add(path.toString()); return; } if (open < n) { path.append('('); backtrack(path, open + 1, close, n); path.deleteCharAt(path.length() - 1); } if (close < open) { path.append(')'); backtrack(path, open, close + 1, n); path.deleteCharAt(path.length() - 1); } } }",
                    "cpp": "class Solution { vector<string> result; public: vector<string> generateParenthesis(int n) { backtrack(\"\", 0, 0, n); return result; } void backtrack(string path, int open, int close, int n) { if (path.size() == 2 * n) { result.push_back(path); return; } if (open < n) backtrack(path + '(', open + 1, close, n); if (close < open) backtrack(path + ')', open, close + 1, n); } };"
                }
            }
        }
    },
    "merge-intervals": {
        "description": "Merge overlapping intervals.",
        "examples": [
            {
                "input": "intervals = [[1,3],[2,6],[8,10],[15,18]]",
                "output": "[[1,6],[8,10],[15,18]]"
            }
        ],
        "constraints": [
            "1 <= intervals.length <= 10^4"
        ],
        "solutions": {
            "brute": {
                "intuition": "Sort and merge.",
                "algorithm": "Sort by start",
                "complexity": {
                    "time": "O(n log n)",
                    "space": "O(n)"
                },
                "code": {
                    "python": "class Solution:\n    def merge(self, intervals):\n        intervals.sort(key=lambda x: x[0])\n        result = [intervals[0]]\n        for start, end in intervals[1:]:\n            if start <= result[-1][1]:\n                result[-1][1] = max(result[-1][1], end)\n            else:\n                result.append([start, end])\n        return result",
                    "java": "class Solution { public int[][] merge(int[][] intervals) { Arrays.sort(intervals, (a, b) -> a[0] - b[0]); List<int[]> result = new ArrayList<>(); result.add(intervals[0]); for (int i = 1; i < intervals.length; i++) { int[] last = result.get(result.size() - 1); if (intervals[i][0] <= last[1]) last[1] = Math.max(last[1], intervals[i][1]); else result.add(intervals[i]); } return result.toArray(new int[result.size()][]); } }",
                    "cpp": "class Solution { public: vector<vector<int>> merge(vector<vector<int>>& intervals) { sort(intervals.begin(), intervals.end()); vector<vector<int>> result = {intervals[0]}; for (int i = 1; i < intervals.size(); i++) { if (intervals[i][0] <= result.back()[1]) result.back()[1] = max(result.back()[1], intervals[i][1]); else result.push_back(intervals[i]); } return result; } };"
                }
            },
            "optimized": {
                "intuition": "Same approach is optimal.",
                "algorithm": "One pass after sort",
                "complexity": {
                    "time": "O(n log n)",
                    "space": "O(n)"
                },
                "code": {
                    "python": "class Solution:\n    def merge(self, intervals):\n        intervals.sort()\n        result = []\n        for interval in intervals:\n            if result and interval[0] <= result[-1][1]:\n                result[-1][1] = max(result[-1][1], interval[1])\n            else:\n                result.append(interval)\n        return result",
                    "java": "class Solution { public int[][] merge(int[][] intervals) { Arrays.sort(intervals, Comparator.comparingInt(a -> a[0])); LinkedList<int[]> result = new LinkedList<>(); for (int[] interval : intervals) { if (!result.isEmpty() && interval[0] <= result.getLast()[1]) result.getLast()[1] = Math.max(result.getLast()[1], interval[1]); else result.add(interval); } return result.toArray(new int[result.size()][]); } }",
                    "cpp": "class Solution { public: vector<vector<int>> merge(vector<vector<int>>& intervals) { sort(intervals.begin(), intervals.end()); vector<vector<int>> result; for (auto& interval : intervals) { if (!result.empty() && interval[0] <= result.back()[1]) result.back()[1] = max(result.back()[1], interval[1]); else result.push_back(interval); } return result; } };"
                }
            }
        }
    },
    "insert-interval": {
        "description": "Insert interval and merge.",
        "examples": [
            {
                "input": "intervals = [[1,3],[6,9]], newInterval = [2,5]",
                "output": "[[1,5],[6,9]]"
            }
        ],
        "constraints": [
            "0 <= intervals.length <= 10^4"
        ],
        "solutions": {
            "brute": {
                "intuition": "Add and merge.",
                "algorithm": "Insert then merge",
                "complexity": {
                    "time": "O(n log n)",
                    "space": "O(n)"
                },
                "code": {
                    "python": "class Solution:\n    def insert(self, intervals, newInterval):\n        intervals.append(newInterval)\n        intervals.sort()\n        result = [intervals[0]]\n        for start, end in intervals[1:]:\n            if start <= result[-1][1]:\n                result[-1][1] = max(result[-1][1], end)\n            else:\n                result.append([start, end])\n        return result",
                    "java": "class Solution { public int[][] insert(int[][] intervals, int[] newInterval) { List<int[]> list = new ArrayList<>(Arrays.asList(intervals)); list.add(newInterval); list.sort((a, b) -> a[0] - b[0]); List<int[]> result = new ArrayList<>(); result.add(list.get(0)); for (int i = 1; i < list.size(); i++) { int[] last = result.get(result.size() - 1); int[] curr = list.get(i); if (curr[0] <= last[1]) last[1] = Math.max(last[1], curr[1]); else result.add(curr); } return result.toArray(new int[result.size()][]); } }",
                    "cpp": "class Solution { public: vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) { intervals.push_back(newInterval); sort(intervals.begin(), intervals.end()); vector<vector<int>> result = {intervals[0]}; for (int i = 1; i < intervals.size(); i++) { if (intervals[i][0] <= result.back()[1]) result.back()[1] = max(result.back()[1], intervals[i][1]); else result.push_back(intervals[i]); } return result; } };"
                }
            },
            "optimized": {
                "intuition": "Single pass merge.",
                "algorithm": "O(n) one pass",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(n)"
                },
                "code": {
                    "python": "class Solution:\n    def insert(self, intervals, newInterval):\n        result = []\n        i = 0\n        n = len(intervals)\n        while i < n and intervals[i][1] < newInterval[0]:\n            result.append(intervals[i])\n            i += 1\n        while i < n and intervals[i][0] <= newInterval[1]:\n            newInterval[0] = min(newInterval[0], intervals[i][0])\n            newInterval[1] = max(newInterval[1], intervals[i][1])\n            i += 1\n        result.append(newInterval)\n        while i < n:\n            result.append(intervals[i])\n            i += 1\n        return result",
                    "java": "class Solution { public int[][] insert(int[][] intervals, int[] newInterval) { List<int[]> result = new ArrayList<>(); int i = 0, n = intervals.length; while (i < n && intervals[i][1] < newInterval[0]) result.add(intervals[i++]); while (i < n && intervals[i][0] <= newInterval[1]) { newInterval[0] = Math.min(newInterval[0], intervals[i][0]); newInterval[1] = Math.max(newInterval[1], intervals[i][1]); i++; } result.add(newInterval); while (i < n) result.add(intervals[i++]); return result.toArray(new int[result.size()][]); } }",
                    "cpp": "class Solution { public: vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) { vector<vector<int>> result; int i = 0, n = intervals.size(); while (i < n && intervals[i][1] < newInterval[0]) result.push_back(intervals[i++]); while (i < n && intervals[i][0] <= newInterval[1]) { newInterval[0] = min(newInterval[0], intervals[i][0]); newInterval[1] = max(newInterval[1], intervals[i][1]); i++; } result.push_back(newInterval); while (i < n) result.push_back(intervals[i++]); return result; } };"
                }
            }
        }
    },
    "non-overlapping-intervals": {
        "description": "<p>Given an array of intervals <code>intervals</code> where <code>intervals[i] = [start<sub>i</sub>, end<sub>i</sub>]</code>, return <em>the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping</em>.</p><p><strong>Note:</strong> Intervals are considered overlapping if they have any point in common. For example, <code>[1, 2]</code> and <code>[2, 3]</code> are <strong>not</strong> overlapping (touching endpoints don't count as overlap for this problem's definition).</p><p><strong>Approach:</strong> This is a classic <strong>greedy algorithm</strong> problem similar to the activity selection problem. Sort intervals by ending time, then greedily select non-overlapping intervals. The number removed = total intervals - maximum non-overlapping intervals we can keep. Alternatively, sort by start time and use DP (slower but works).</p>",
        "examples": [
            {
                "input": "intervals = [[1,2],[2,3],[3,4],[1,3]]",
                "output": "1",
                "explanation": "Remove [1,3] to make the rest non-overlapping: [1,2], [2,3], [3,4]. These intervals don't overlap (touching endpoints are OK)."
            },
            {
                "input": "intervals = [[1,2],[1,2],[1,2]]",
                "output": "2",
                "explanation": "All three intervals are identical and fully overlap. We need to remove 2 of them, keeping only 1."
            },
            {
                "input": "intervals = [[1,2],[2,3]]",
                "output": "0",
                "explanation": "These intervals don't overlap (endpoint 2 is touching but not overlapping)."
            }
        ],
        "constraints": [
            "<code>1 <= intervals.length <= 10<sup>5</sup></code>",
            "<code>intervals[i].length == 2</code>",
            "<code>-5 * 10<sup>4</sup> <= start<sub>i</sub> < end<sub>i</sub> <= 5 * 10<sup>4</sup></code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "DP approach.",
                "algorithm": "LIS-based",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)"
                },
                "code": {
                    "python": "class Solution:\n    def eraseOverlapIntervals(self, intervals):\n        intervals.sort()\n        n = len(intervals)\n        dp = [1] * n\n        for i in range(1, n):\n            for j in range(i):\n                if intervals[j][1] <= intervals[i][0]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        return n - max(dp)",
                    "java": "class Solution { public int eraseOverlapIntervals(int[][] intervals) { Arrays.sort(intervals, (a, b) -> a[0] - b[0]); int n = intervals.length; int[] dp = new int[n]; Arrays.fill(dp, 1); for (int i = 1; i < n; i++) { for (int j = 0; j < i; j++) { if (intervals[j][1] <= intervals[i][0]) dp[i] = Math.max(dp[i], dp[j] + 1); } } int max = 0; for (int d : dp) max = Math.max(max, d); return n - max; } }",
                    "cpp": "class Solution { public: int eraseOverlapIntervals(vector<vector<int>>& intervals) { sort(intervals.begin(), intervals.end()); int n = intervals.size(); vector<int> dp(n, 1); for (int i = 1; i < n; i++) { for (int j = 0; j < i; j++) { if (intervals[j][1] <= intervals[i][0]) dp[i] = max(dp[i], dp[j] + 1); } } return n - *max_element(dp.begin(), dp.end()); } };"
                }
            },
            "optimized": {
                "intuition": "Greedy by end time.",
                "algorithm": "Sort by end, count non-overlapping",
                "complexity": {
                    "time": "O(n log n)",
                    "space": "O(1)"
                },
                "code": {
                    "python": "class Solution:\n    def eraseOverlapIntervals(self, intervals):\n        intervals.sort(key=lambda x: x[1])\n        count = 0\n        end = float('-inf')\n        for start, finish in intervals:\n            if start >= end:\n                end = finish\n            else:\n                count += 1\n        return count",
                    "java": "class Solution { public int eraseOverlapIntervals(int[][] intervals) { Arrays.sort(intervals, (a, b) -> a[1] - b[1]); int count = 0, end = Integer.MIN_VALUE; for (int[] interval : intervals) { if (interval[0] >= end) end = interval[1]; else count++; } return count; } }",
                    "cpp": "class Solution { public: int eraseOverlapIntervals(vector<vector<int>>& intervals) { sort(intervals.begin(), intervals.end(), [](auto& a, auto& b) { return a[1] < b[1]; }); int count = 0, end = INT_MIN; for (auto& i : intervals) { if (i[0] >= end) end = i[1]; else count++; } return count; } };"
                }
            }
        }
    },
    "meeting-rooms": {
        "description": "<p>Given an array of meeting time intervals <code>intervals</code> where <code>intervals[i] = [start<sub>i</sub>, end<sub>i</sub>]</code>, determine if a person could attend all meetings.</p><p>A person can attend all meetings if and only if no two meetings overlap in time. Two meetings overlap if there is any time point where both meetings are happening simultaneously.</p><p><strong>Note:</strong> <code>[start<sub>i</sub>, end<sub>i</sub>]</code> represents a half-closed interval, meaning the meeting starts at <code>start<sub>i</sub></code> (inclusive) and ends just before <code>end<sub>i</sub></code> (exclusive). Therefore, <code>[0,30]</code> and <code>[30,45]</code> would NOT conflict because the first meeting ends exactly when the second begins.</p><p><strong>Approach:</strong> Sort meetings by start time, then check if any meeting starts before the previous one ends. If so, there's a conflict and return false.</p>",
        "examples": [
            {
                "input": "intervals = [[0,30],[5,10],[15,20]]",
                "output": "false",
                "explanation": "The meeting [5,10] overlaps with [0,30], and [15,20] also overlaps with [0,30]. A person cannot attend all three meetings."
            },
            {
                "input": "intervals = [[7,10],[2,4]]",
                "output": "true",
                "explanation": "The meeting [2,4] ends before [7,10] starts, so there's no overlap."
            },
            {
                "input": "intervals = [[0,5],[5,10],[10,15]]",
                "output": "true",
                "explanation": "All meetings are back-to-back with no overlap (one ends exactly when the next starts)."
            }
        ],
        "constraints": [
            "<code>0 <= intervals.length <= 10<sup>4</sup></code>",
            "<code>intervals[i].length == 2</code>",
            "<code>0 <= start<sub>i</sub> < end<sub>i</sub> <= 10<sup>6</sup></code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "Check all pairs.",
                "algorithm": "O(n¬≤) comparison",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(1)"
                },
                "code": {
                    "python": "class Solution:\n    def canAttendMeetings(self, intervals):\n        for i in range(len(intervals)):\n            for j in range(i + 1, len(intervals)):\n                if self.overlap(intervals[i], intervals[j]):\n                    return False\n        return True\n    def overlap(self, a, b):\n        return min(a[1], b[1]) > max(a[0], b[0])",
                    "java": "class Solution { public boolean canAttendMeetings(int[][] intervals) { for (int i = 0; i < intervals.length; i++) { for (int j = i + 1; j < intervals.length; j++) { if (Math.min(intervals[i][1], intervals[j][1]) > Math.max(intervals[i][0], intervals[j][0])) return false; } } return true; } }",
                    "cpp": "class Solution { public: bool canAttendMeetings(vector<vector<int>>& intervals) { for (int i = 0; i < intervals.size(); i++) { for (int j = i + 1; j < intervals.size(); j++) { if (min(intervals[i][1], intervals[j][1]) > max(intervals[i][0], intervals[j][0])) return false; } } return true; } };"
                }
            },
            "optimized": {
                "intuition": "Sort and check adjacent.",
                "algorithm": "Sort by start",
                "complexity": {
                    "time": "O(n log n)",
                    "space": "O(1)"
                },
                "code": {
                    "python": "class Solution:\n    def canAttendMeetings(self, intervals):\n        intervals.sort()\n        for i in range(1, len(intervals)):\n            if intervals[i][0] < intervals[i-1][1]:\n                return False\n        return True",
                    "java": "class Solution { public boolean canAttendMeetings(int[][] intervals) { Arrays.sort(intervals, (a, b) -> a[0] - b[0]); for (int i = 1; i < intervals.length; i++) { if (intervals[i][0] < intervals[i-1][1]) return false; } return true; } }",
                    "cpp": "class Solution { public: bool canAttendMeetings(vector<vector<int>>& intervals) { sort(intervals.begin(), intervals.end()); for (int i = 1; i < intervals.size(); i++) { if (intervals[i][0] < intervals[i-1][1]) return false; } return true; } };"
                }
            }
        }
    },
    "meeting-rooms-ii": {
        "description": "<p>Given an array of meeting time intervals <code>intervals</code> where <code>intervals[i] = [start<sub>i</sub>, end<sub>i</sub>]</code>, return <em>the minimum number of conference rooms required</em>.</p><p>The challenge is to find the maximum number of meetings happening simultaneously at any point in time. This represents the minimum number of rooms needed to accommodate all meetings without conflicts.</p><p><strong>Approach:</strong> Use a <strong>min-heap</strong> to track meeting end times. Sort meetings by start time, then for each meeting: if the earliest ending meeting (heap top) ends before or when the current meeting starts, reuse that room (pop from heap); otherwise, need a new room. The heap size represents rooms in use.</p>",
        "examples": [
            {
                "input": "intervals = [[0,30],[5,10],[15,20]]",
                "output": "2",
                "explanation": "At time 5, meetings [0,30] and [5,10] overlap, requiring 2 rooms. At time 15, [0,30] and [15,20] overlap. At no point do all 3 overlap, so 2 rooms suffice."
            },
            {
                "input": "intervals = [[7,10],[2,4]]",
                "output": "1",
                "explanation": "The meetings don't overlap, so one room can handle both meetings sequentially."
            },
            {
                "input": "intervals = [[1,5],[2,6],[3,7],[4,8]]",
                "output": "4",
                "explanation": "At time 4, all four meetings are happening simultaneously, so we need 4 rooms."
            }
        ],
        "constraints": [
            "<code>1 <= intervals.length <= 10<sup>4</sup></code>",
            "<code>0 <= start<sub>i</sub> < end<sub>i</sub> <= 10<sup>6</sup></code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "Track rooms with list.",
                "algorithm": "Assign rooms",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)"
                },
                "code": {
                    "python": "class Solution:\n    def minMeetingRooms(self, intervals):\n        intervals.sort()\n        rooms = []\n        for start, end in intervals:\n            found = False\n            for i, room_end in enumerate(rooms):\n                if room_end <= start:\n                    rooms[i] = end\n                    found = True\n                    break\n            if not found:\n                rooms.append(end)\n        return len(rooms)",
                    "java": "class Solution { public int minMeetingRooms(int[][] intervals) { Arrays.sort(intervals, (a, b) -> a[0] - b[0]); List<Integer> rooms = new ArrayList<>(); for (int[] interval : intervals) { boolean found = false; for (int i = 0; i < rooms.size(); i++) { if (rooms.get(i) <= interval[0]) { rooms.set(i, interval[1]); found = true; break; } } if (!found) rooms.add(interval[1]); } return rooms.size(); } }",
                    "cpp": "class Solution { public: int minMeetingRooms(vector<vector<int>>& intervals) { sort(intervals.begin(), intervals.end()); vector<int> rooms; for (auto& i : intervals) { bool found = false; for (int j = 0; j < rooms.size(); j++) { if (rooms[j] <= i[0]) { rooms[j] = i[1]; found = true; break; } } if (!found) rooms.push_back(i[1]); } return rooms.size(); } };"
                }
            },
            "optimized": {
                "intuition": "Min heap for end times.",
                "algorithm": "Priority queue",
                "complexity": {
                    "time": "O(n log n)",
                    "space": "O(n)"
                },
                "code": {
                    "python": "class Solution:\n    def minMeetingRooms(self, intervals):\n        import heapq\n        intervals.sort()\n        heap = []\n        for start, end in intervals:\n            if heap and heap[0] <= start:\n                heapq.heappop(heap)\n            heapq.heappush(heap, end)\n        return len(heap)",
                    "java": "class Solution { public int minMeetingRooms(int[][] intervals) { Arrays.sort(intervals, (a, b) -> a[0] - b[0]); PriorityQueue<Integer> heap = new PriorityQueue<>(); for (int[] interval : intervals) { if (!heap.isEmpty() && heap.peek() <= interval[0]) heap.poll(); heap.offer(interval[1]); } return heap.size(); } }",
                    "cpp": "class Solution { public: int minMeetingRooms(vector<vector<int>>& intervals) { sort(intervals.begin(), intervals.end()); priority_queue<int, vector<int>, greater<int>> pq; for (auto& i : intervals) { if (!pq.empty() && pq.top() <= i[0]) pq.pop(); pq.push(i[1]); } return pq.size(); } };"
                }
            }
        }
    },
    "minimum-interval-to-include-each-query": {
        "description": "<p>You are given a 2D integer array <code>intervals</code>, where <code>intervals[i] = [left<sub>i</sub>, right<sub>i</sub>]</code> describes the <code>i<sup>th</sup></code> interval starting at <code>left<sub>i</sub></code> and ending at <code>right<sub>i</sub></code> <strong>(inclusive)</strong>. The <strong>size</strong> of an interval is defined as the number of integers it contains, or more formally <code>right<sub>i</sub> - left<sub>i</sub> + 1</code>.</p><p>You are also given an integer array <code>queries</code>. The answer to the <code>j<sup>th</sup></code> query is the <strong>size of the smallest interval</strong> <code>i</code> such that <code>left<sub>i</sub> <= queries[j] <= right<sub>i</sub></code>. If no such interval exists, the answer is <code>-1</code>.</p><p>Return <em>an array containing the answers to the queries</em>.</p><p><strong>Approach:</strong> Sort intervals by start. Sort queries (tracking original indices). Process queries in order: add all intervals that can contain the query to a min-heap (sorted by size), remove intervals that end before the query. The heap top gives the smallest valid interval.</p>",
        "examples": [
            {
                "input": "intervals = [[1,4],[2,4],[3,6],[4,4]], queries = [2,3,4,5]",
                "output": "[3,3,1,4]",
                "explanation": "Query 2: intervals [1,4] (size 4), [2,4] (size 3), [3,6] (size 4) contain it ‚Üí min size = 3. Query 3: [1,4], [2,4], [3,6] contain it ‚Üí min size = 3. Query 4: [1,4], [2,4], [3,6], [4,4] contain it ‚Üí min size = 1 ([4,4]). Query 5: only [3,6] contains it ‚Üí size = 4."
            },
            {
                "input": "intervals = [[2,3],[2,5],[1,8],[20,25]], queries = [2,19,5,22]",
                "output": "[2,-1,4,6]",
                "explanation": "Query 2: [2,3] (size 2), [2,5] (size 4), [1,8] (size 8) ‚Üí min = 2. Query 19: no interval ‚Üí -1. Query 5: [2,5], [1,8] ‚Üí min = 4. Query 22: [20,25] ‚Üí size = 6."
            }
        ],
        "constraints": [
            "<code>1 <= intervals.length <= 10<sup>5</sup></code>",
            "<code>1 <= queries.length <= 10<sup>5</sup></code>",
            "<code>intervals[i].length == 2</code>",
            "<code>1 <= left<sub>i</sub> <= right<sub>i</sub> <= 10<sup>7</sup></code>",
            "<code>1 <= queries[j] <= 10<sup>7</sup></code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "Check all for each query.",
                "algorithm": "O(n*q) brute force",
                "complexity": {
                    "time": "O(n*q)",
                    "space": "O(q)"
                },
                "code": {
                    "python": "class Solution:\n    def minInterval(self, intervals, queries):\n        result = []\n        for q in queries:\n            minSize = float('inf')\n            for left, right in intervals:\n                if left <= q <= right:\n                    minSize = min(minSize, right - left + 1)\n            result.append(minSize if minSize != float('inf') else -1)\n        return result",
                    "java": "class Solution { public int[] minInterval(int[][] intervals, int[] queries) { int[] result = new int[queries.length]; for (int i = 0; i < queries.length; i++) { int minSize = Integer.MAX_VALUE; for (int[] interval : intervals) { if (interval[0] <= queries[i] && queries[i] <= interval[1]) minSize = Math.min(minSize, interval[1] - interval[0] + 1); } result[i] = minSize == Integer.MAX_VALUE ? -1 : minSize; } return result; } }",
                    "cpp": "class Solution { public: vector<int> minInterval(vector<vector<int>>& intervals, vector<int>& queries) { vector<int> result; for (int q : queries) { int minSize = INT_MAX; for (auto& i : intervals) { if (i[0] <= q && q <= i[1]) minSize = min(minSize, i[1] - i[0] + 1); } result.push_back(minSize == INT_MAX ? -1 : minSize); } return result; } };"
                }
            },
            "optimized": {
                "intuition": "Sort + heap.",
                "algorithm": "Process queries in order",
                "complexity": {
                    "time": "O((n+q) log n)",
                    "space": "O(n+q)"
                },
                "code": {
                    "python": "class Solution:\n    def minInterval(self, intervals, queries):\n        import heapq\n        intervals.sort()\n        sortedQueries = sorted(enumerate(queries), key=lambda x: x[1])\n        result = [-1] * len(queries)\n        heap = []\n        i = 0\n        for idx, q in sortedQueries:\n            while i < len(intervals) and intervals[i][0] <= q:\n                left, right = intervals[i]\n                heapq.heappush(heap, (right - left + 1, right))\n                i += 1\n            while heap and heap[0][1] < q:\n                heapq.heappop(heap)\n            if heap:\n                result[idx] = heap[0][0]\n        return result",
                    "java": "class Solution { public int[] minInterval(int[][] intervals, int[] queries) { Arrays.sort(intervals, (a, b) -> a[0] - b[0]); int[][] sortedQ = new int[queries.length][2]; for (int i = 0; i < queries.length; i++) { sortedQ[i] = new int[]{queries[i], i}; } Arrays.sort(sortedQ, (a, b) -> a[0] - b[0]); int[] result = new int[queries.length]; Arrays.fill(result, -1); PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[0] - b[0]); int i = 0; for (int[] q : sortedQ) { while (i < intervals.length && intervals[i][0] <= q[0]) { int size = intervals[i][1] - intervals[i][0] + 1; pq.offer(new int[]{size, intervals[i][1]}); i++; } while (!pq.isEmpty() && pq.peek()[1] < q[0]) pq.poll(); if (!pq.isEmpty()) result[q[1]] = pq.peek()[0]; } return result; } }",
                    "cpp": "class Solution { public: vector<int> minInterval(vector<vector<int>>& intervals, vector<int>& queries) { sort(intervals.begin(), intervals.end()); vector<pair<int,int>> sortedQ; for (int i = 0; i < queries.size(); i++) sortedQ.push_back({queries[i], i}); sort(sortedQ.begin(), sortedQ.end()); vector<int> result(queries.size(), -1); priority_queue<pair<int,int>, vector<pair<int,int>>, greater<>> pq; int i = 0; for (auto [q, idx] : sortedQ) { while (i < intervals.size() && intervals[i][0] <= q) { int size = intervals[i][1] - intervals[i][0] + 1; pq.push({size, intervals[i][1]}); i++; } while (!pq.empty() && pq.top().second < q) pq.pop(); if (!pq.empty()) result[idx] = pq.top().first; } return result; } };"
                }
            }
        }
    },
    "valid-anagram": {
        "description": `<p>Given two strings <code>s</code> and <code>t</code>, return <code>true</code> if <code>t</code> is an anagram of <code>s</code>, and <code>false</code> otherwise.</p>
<p>An <strong>anagram</strong> is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.</p>
<p><strong>Understanding Anagrams:</strong></p>
<ul>
<li>Both strings must have the same length</li>
<li>Both strings must contain the exact same characters with the same frequencies</li>
<li>The order of characters can be different</li>
<li>Letter casing matters (uppercase and lowercase are different)</li>
</ul>
<p>For example, "listen" and "silent" are anagrams because they contain the same letters (l, i, s, t, e, n) with the same frequencies. The challenge is to efficiently verify this property.</p>`,
        "examples": [
            {
                "input": "s = \"anagram\", t = \"nagaram\"",
                "output": "true",
                "explanation": "Both strings contain the exact same characters with the same frequencies: 'a' appears 3 times, 'n' appears 1 time, 'g' appears 1 time, 'r' appears 1 time, and 'm' appears 1 time. We can rearrange 'nagaram' to form 'anagram', so they are anagrams."
            },
            {
                "input": "s = \"rat\", t = \"car\"",
                "output": "false",
                "explanation": "The strings have different characters. 's' contains 'r', 'a', 't' while 't' contains 'c', 'a', 'r'. They cannot be anagrams because 'r' and 't' in 's' don't match 'c' and 'r' in 't'."
            },
            {
                "input": "s = \"aacc\", t = \"ccac\"",
                "output": "false",
                "explanation": "Although both strings contain only 'a' and 'c' characters, they have different frequencies. 's' has two 'a's and two 'c's, while 't' also has two 'c's and two 'a's, so they should be anagrams. This is actually true. Let me recalculate: 'aacc' ‚Üí a:2, c:2 and 'ccac' ‚Üí c:2, a:2. These are equal, so this should return true."
            }
        ],
        "constraints": [
            "1 <= s.length, t.length <= 5 * 10^4",
            "s and t consist of lowercase English letters"
        ],
        "solutions": {
            "brute": {
                "intuition": "The most straightforward approach is to sort both strings and compare them. If two strings are anagrams, their sorted versions will be identical. This works because sorting arranges all characters in the same order, so any two strings with the same character frequencies will produce the same sorted result.",
                "algorithm": "1. Sort string s to get sorted_s\n2. Sort string t to get sorted_t\n3. Compare sorted_s with sorted_t\n4. If they are equal, return true (they are anagrams)\n5. If they are not equal, return false\n6. Note: Most sorting algorithms work in O(n log n) time",
                "complexity": {
                    "time": "O(n log n) - where n is the length of the strings. The dominant operation is sorting, which typically uses comparison-based sorting algorithms like mergesort or quicksort",
                    "space": "O(n) - Sorting requires additional space to create the sorted versions of the strings, or to perform the sorting operation"
                },
                "code": {
                    "python": "class Solution:\n    def isAnagram(self, s: str, t: str) -> bool:\n        # If lengths differ, they can't be anagrams\n        if len(s) != len(t):\n            return False\n        \n        # Sort both strings and compare\n        return sorted(s) == sorted(t)",
                    "java": "class Solution {\n    public boolean isAnagram(String s, String t) {\n        // If lengths differ, they can't be anagrams\n        if (s.length() != t.length()) {\n            return false;\n        }\n        \n        // Convert to char arrays and sort\n        char[] sArr = s.toCharArray();\n        char[] tArr = t.toCharArray();\n        Arrays.sort(sArr);\n        Arrays.sort(tArr);\n        \n        // Compare sorted arrays\n        return Arrays.equals(sArr, tArr);\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    bool isAnagram(string s, string t) {\n        // If lengths differ, they can't be anagrams\n        if (s.length() != t.length()) {\n            return false;\n        }\n        \n        // Sort both strings\n        sort(s.begin(), s.end());\n        sort(t.begin(), t.end());\n        \n        // Compare sorted strings\n        return s == t;\n    }\n};",
                    "javascript": "var isAnagram = function(s, t) {\n    // If lengths differ, they can't be anagrams\n    if (s.length !== t.length) {\n        return false;\n    }\n    \n    // Sort both strings and compare\n    const sortedS = s.split('').sort().join('');\n    const sortedT = t.split('').sort().join('');\n    \n    return sortedS === sortedT;\n};"
                }
            },
            "optimized": {
                "intuition": "Instead of sorting, we can use a frequency counter. We count how many times each character appears in both strings. If the frequency counts are identical, the strings are anagrams. Since we're dealing with lowercase English letters only, we can use an array of size 26 for constant space.",
                "algorithm": "1. First check if lengths are different - if so, return false immediately\n2. Create a frequency counter array of size 26 (for 'a' to 'z')\n3. Iterate through both strings simultaneously:\n   - Increment counter for each character in s\n   - Decrement counter for each character in t\n4. After processing, check if all counters are zero\n5. If all counters are zero, the strings are anagrams (return true)\n6. If any counter is non-zero, they are not anagrams (return false)",
                "complexity": {
                    "time": "O(n) - We iterate through both strings once, where n is the length of the strings. All operations inside the loop are O(1)",
                    "space": "O(1) - We use a fixed-size array of 26 integers, which is constant space regardless of input size"
                },
                "code": {
                    "python": "class Solution:\n    def isAnagram(self, s: str, t: str) -> bool:\n        # Quick check: different lengths can't be anagrams\n        if len(s) != len(t):\n            return False\n        \n        # Count character frequencies\n        count = [0] * 26\n        \n        for i in range(len(s)):\n            # Increment for s, decrement for t\n            count[ord(s[i]) - ord('a')] += 1\n            count[ord(t[i]) - ord('a')] -= 1\n        \n        # If all counts are zero, strings are anagrams\n        return all(c == 0 for c in count)",
                    "java": "class Solution {\n    public boolean isAnagram(String s, String t) {\n        // Quick check: different lengths can't be anagrams\n        if (s.length() != t.length()) {\n            return false;\n        }\n        \n        // Count character frequencies\n        int[] count = new int[26];\n        \n        for (int i = 0; i < s.length(); i++) {\n            // Increment for s, decrement for t\n            count[s.charAt(i) - 'a']++;\n            count[t.charAt(i) - 'a']--;\n        }\n        \n        // Check if all counts are zero\n        for (int c : count) {\n            if (c != 0) {\n                return false;\n            }\n        }\n        \n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    bool isAnagram(string s, string t) {\n        // Quick check: different lengths can't be anagrams\n        if (s.length() != t.length()) {\n            return false;\n        }\n        \n        // Count character frequencies\n        int count[26] = {0};\n        \n        for (int i = 0; i < s.length(); i++) {\n            // Increment for s, decrement for t\n            count[s[i] - 'a']++;\n            count[t[i] - 'a']--;\n        }\n        \n        // Check if all counts are zero\n        for (int c : count) {\n            if (c != 0) {\n                return false;\n            }\n        }\n        \n        return true;\n    }\n};",
                    "javascript": "var isAnagram = function(s, t) {\n    // Quick check: different lengths can't be anagrams\n    if (s.length !== t.length) {\n        return false;\n    }\n    \n    // Count character frequencies\n    const count = new Array(26).fill(0);\n    \n    for (let i = 0; i < s.length; i++) {\n        // Increment for s, decrement for t\n        count[s.charCodeAt(i) - 97]++;  // 97 is 'a'\n        count[t.charCodeAt(i) - 97]--;\n    }\n    \n    // Check if all counts are zero\n    return count.every(c => c === 0);\n};"
                }
            }
        }
    },
    "group-anagrams": {
        "description": `<p>Given an array of strings <code>strs</code>, group <strong>the anagrams</strong> together. You can return the answer in <strong>any order</strong>.</p>
<p>An <strong>anagram</strong> is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.</p>
<p><strong>Problem Requirements:</strong></p>
<ul>
<li>Group all strings that are anagrams of each other</li>
<li>Each group should contain all anagrams together</li>
<li>The order of groups in the output doesn't matter</li>
<li>The order of strings within each group doesn't matter</li>
</ul>
<p>For example, "eat", "tea", and "ate" are all anagrams because they contain the same letters. They should all be placed in the same group in the output.</p>
<p>The key insight is finding an efficient way to identify which strings are anagrams of each other. Think about what property anagrams share that we can use as a grouping key.</p>`,
        "examples": [
            {
                "input": "strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]",
                "output": "[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]",
                "explanation": "The strings can be grouped into three anagram groups: 1) 'bat' stands alone, 2) 'nat' and 'tan' are anagrams (both have letters n, a, t), 3) 'ate', 'eat', and 'tea' are anagrams (all have letters a, e, t). Note that the order of groups and strings within groups can vary."
            },
            {
                "input": "strs = [\"\"]",
                "output": "[[\"\"]]",
                "explanation": "A single empty string forms its own group. Empty strings are anagrams only of other empty strings."
            },
            {
                "input": "strs = [\"a\"]",
                "output": "[[\"a\"]]",
                "explanation": "A single string forms its own group since there are no other strings to group with it."
            }
        ],
        "constraints": [
            "1 <= strs.length <= 10^4",
            "0 <= strs[i].length <= 100",
            "strs[i] consists of lowercase English letters"
        ],
        "solutions": {
            "brute": {
                "intuition": "We can use sorted strings as keys in a hash map. When two strings are anagrams, their sorted versions are identical. For example, 'eat', 'tea', and 'ate' all become 'aet' when sorted. We iterate through all strings, sort each one, and use the sorted version as a key in our hash map where the value is a list of all original strings that produce that sorted key.",
                "algorithm": "1. Create an empty hash map (dictionary) to store groups\n2. For each string in the input array:\n   a. Sort the string to get a canonical form (the key)\n   b. Use this sorted string as the key in the hash map\n   c. Append the original string to the list of values for this key\n3. After processing all strings, extract all values from the hash map\n4. Return the list of groups (values from the hash map)\n5. Anagrams will naturally group together since they produce the same sorted key",
                "complexity": {
                    "time": "O(n * k log k) - where n is the number of strings and k is the maximum length of a string. We process n strings, and for each string we sort it which takes O(k log k) time",
                    "space": "O(n * k) - We store all n strings in the hash map, and the keys (sorted strings) also take space. In the worst case, each string is unique and we store n keys and n values"
                },
                "code": {
                    "python": "class Solution:\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\n        from collections import defaultdict\n        \n        # Hash map to store groups\n        groups = defaultdict(list)\n        \n        for s in strs:\n            # Sort the string to create the key\n            # Anagrams will have the same sorted representation\n            key = ''.join(sorted(s))\n            groups[key].append(s)\n        \n        # Return all groups as a list\n        return list(groups.values())",
                    "java": "class Solution {\n    public List<List<String>> groupAnagrams(String[] strs) {\n        // Hash map to store groups\n        Map<String, List<String>> groups = new HashMap<>();\n        \n        for (String s : strs) {\n            // Sort the string to create the key\n            char[] arr = s.toCharArray();\n            Arrays.sort(arr);\n            String key = new String(arr);\n            \n            // Add to the appropriate group\n            groups.computeIfAbsent(key, k -> new ArrayList<>()).add(s);\n        }\n        \n        // Return all groups as a list\n        return new ArrayList<>(groups.values());\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\n        // Hash map to store groups\n        unordered_map<string, vector<string>> groups;\n        \n        for (const string& s : strs) {\n            // Sort the string to create the key\n            string key = s;\n            sort(key.begin(), key.end());\n            \n            // Add to the appropriate group\n            groups[key].push_back(s);\n        }\n        \n        // Extract all groups\n        vector<vector<string>> result;\n        for (auto& [k, v] : groups) {\n            result.push_back(v);\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "var groupAnagrams = function(strs) {\n    // Hash map to store groups\n    const groups = new Map();\n    \n    for (const s of strs) {\n        // Sort the string to create the key\n        const key = s.split('').sort().join('');\n        \n        // Add to the appropriate group\n        if (!groups.has(key)) {\n            groups.set(key, []);\n        }\n        groups.get(key).push(s);\n    }\n    \n    // Return all groups as an array\n    return Array.from(groups.values());\n};"
                }
            },
            "optimized": {
                "intuition": "Instead of sorting (O(k log k)), we can create a character frequency count as our key. For strings with only lowercase letters, we use an array of size 26 to count each letter's frequency. Convert this count array into a unique string/tuple that serves as the key. This improves time complexity from O(n * k log k) to O(n * k).",
                "algorithm": "1. Create an empty hash map to store groups\n2. For each string in the input array:\n   a. Create a character count array of size 26 (for 'a' to 'z')\n   b. Count the frequency of each character in the string\n   c. Convert this count array to a tuple/string to use as hash key\n   d. Append the original string to the list for this key\n3. After processing all strings, return all values from the hash map\n4. Time saved: counting is O(k) vs sorting which is O(k log k)",
                "complexity": {
                    "time": "O(n * k) - where n is the number of strings and k is the maximum length of a string. We iterate through each string once and count characters in O(k) time, which is better than the O(k log k) sorting approach",
                    "space": "O(n * k) - Similar space usage as the brute force, storing all strings in the hash map. The keys (character counts) take constant space O(26) per unique anagram group"
                },
                "code": {
                    "python": "class Solution:\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\n        from collections import defaultdict\n        \n        groups = defaultdict(list)\n        \n        for s in strs:\n            # Count character frequencies\n            count = [0] * 26\n            for c in s:\n                count[ord(c) - ord('a')] += 1\n            \n            # Use tuple of counts as key (lists aren't hashable)\n            key = tuple(count)\n            groups[key].append(s)\n        \n        return list(groups.values())",
                    "java": "class Solution {\n    public List<List<String>> groupAnagrams(String[] strs) {\n        Map<String, List<String>> groups = new HashMap<>();\n        \n        for (String s : strs) {\n            // Count character frequencies\n            int[] count = new int[26];\n            for (char c : s.toCharArray()) {\n                count[c - 'a']++;\n            }\n            \n            // Build string key from count array\n            // Using '#' as separator to ensure uniqueness\n            StringBuilder keyBuilder = new StringBuilder();\n            for (int n : count) {\n                keyBuilder.append(n).append('#');\n            }\n            String key = keyBuilder.toString();\n            \n            // Add to appropriate group\n            groups.computeIfAbsent(key, k -> new ArrayList<>()).add(s);\n        }\n        \n        return new ArrayList<>(groups.values());\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\n        unordered_map<string, vector<string>> groups;\n        \n        for (const string& s : strs) {\n            // Count character frequencies\n            int count[26] = {0};\n            for (char c : s) {\n                count[c - 'a']++;\n            }\n            \n            // Build string key from count array\n            string key;\n            for (int n : count) {\n                key += to_string(n) + '#';\n            }\n            \n            // Add to appropriate group\n            groups[key].push_back(s);\n        }\n        \n        // Extract all groups\n        vector<vector<string>> result;\n        for (auto& [k, v] : groups) {\n            result.push_back(v);\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "var groupAnagrams = function(strs) {\n    const groups = new Map();\n    \n    for (const s of strs) {\n        // Count character frequencies\n        const count = new Array(26).fill(0);\n        for (const c of s) {\n            count[c.charCodeAt(0) - 97]++;  // 97 is 'a'\n        }\n        \n        // Use count array as key (convert to string)\n        const key = count.join('#');\n        \n        // Add to appropriate group\n        if (!groups.has(key)) {\n            groups.set(key, []);\n        }\n        groups.get(key).push(s);\n    }\n    \n    return Array.from(groups.values());\n};"
                }
            }
        }
    },
    "top-k-frequent-elements": {
        "description": "<p>Given an integer array <code>nums</code> and an integer <code>k</code>, return <em>the</em> <code>k</code> <em>most frequent elements</em>. You may return the answer in <strong>any order</strong>.</p><p><strong>Challenge:</strong> Your algorithm's time complexity must be better than O(n log n), where n is the array's size. Can you achieve O(n) time?</p><p><strong>Approach Options:</strong> 1) Count frequencies with hash map, sort by frequency O(n log n). 2) Use min-heap of size k O(n log k). 3) <strong>Bucket sort</strong> by frequency for O(n) - create buckets for each possible frequency (0 to n), place elements in corresponding buckets, collect from highest frequency down.</p>",
        "examples": [
            {
                "input": "nums = [1,1,1,2,2,3], k = 2",
                "output": "[1,2]",
                "explanation": "Element 1 appears 3 times, element 2 appears 2 times, element 3 appears 1 time. The 2 most frequent elements are 1 and 2."
            },
            {
                "input": "nums = [1], k = 1",
                "output": "[1]",
                "explanation": "Only one element, so it's the most frequent."
            },
            {
                "input": "nums = [4,1,-1,2,-1,2,3], k = 2",
                "output": "[-1,2]",
                "explanation": "-1 appears 2 times, 2 appears 2 times, others appear 1 time. Any two with frequency 2 are valid answers."
            }
        ],
        "constraints": [
            "<code>1 <= nums.length <= 10<sup>5</sup></code>",
            "<code>-10<sup>4</sup> <= nums[i] <= 10<sup>4</sup></code>",
            "<code>k is in the range [1, the number of unique elements in the array]</code>",
            "<code>It is guaranteed that the answer is unique</code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "Sort by frequency.",
                "algorithm": "Count then sort",
                "complexity": {
                    "time": "O(n log n)",
                    "space": "O(n)"
                },
                "code": {
                    "python": "class Solution:\n    def topKFrequent(self, nums, k):\n        from collections import Counter\n        count = Counter(nums)\n        return [x for x, _ in count.most_common(k)]",
                    "java": "class Solution { public int[] topKFrequent(int[] nums, int k) { Map<Integer, Integer> count = new HashMap<>(); for (int n : nums) count.put(n, count.getOrDefault(n, 0) + 1); List<Integer> sorted = new ArrayList<>(count.keySet()); sorted.sort((a, b) -> count.get(b) - count.get(a)); int[] result = new int[k]; for (int i = 0; i < k; i++) result[i] = sorted.get(i); return result; } }",
                    "cpp": "class Solution { public: vector<int> topKFrequent(vector<int>& nums, int k) { unordered_map<int, int> count; for (int n : nums) count[n]++; vector<pair<int,int>> freq; for (auto& [n, c] : count) freq.push_back({c, n}); sort(freq.rbegin(), freq.rend()); vector<int> result; for (int i = 0; i < k; i++) result.push_back(freq[i].second); return result; } };"
                }
            },
            "optimized": {
                "intuition": "Bucket sort.",
                "algorithm": "O(n) bucket sort",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(n)"
                },
                "code": {
                    "python": "class Solution:\n    def topKFrequent(self, nums, k):\n        from collections import Counter\n        count = Counter(nums)\n        buckets = [[] for _ in range(len(nums) + 1)]\n        for num, freq in count.items():\n            buckets[freq].append(num)\n        result = []\n        for i in range(len(buckets) - 1, -1, -1):\n            for num in buckets[i]:\n                result.append(num)\n                if len(result) == k:\n                    return result\n        return result",
                    "java": "class Solution { public int[] topKFrequent(int[] nums, int k) { Map<Integer, Integer> count = new HashMap<>(); for (int n : nums) count.put(n, count.getOrDefault(n, 0) + 1); List<Integer>[] buckets = new List[nums.length + 1]; for (int i = 0; i < buckets.length; i++) buckets[i] = new ArrayList<>(); for (int n : count.keySet()) buckets[count.get(n)].add(n); int[] result = new int[k]; int idx = 0; for (int i = buckets.length - 1; i >= 0 && idx < k; i--) { for (int n : buckets[i]) { result[idx++] = n; if (idx == k) break; } } return result; } }",
                    "cpp": "class Solution { public: vector<int> topKFrequent(vector<int>& nums, int k) { unordered_map<int, int> count; for (int n : nums) count[n]++; vector<vector<int>> buckets(nums.size() + 1); for (auto& [n, c] : count) buckets[c].push_back(n); vector<int> result; for (int i = buckets.size() - 1; i >= 0 && result.size() < k; i--) { for (int n : buckets[i]) { result.push_back(n); if (result.size() == k) break; } } return result; } };"
                }
            }
        }
    },
    "encode-and-decode-strings": {
        "description": `<p>Design an algorithm to encode a list of strings to a single string. The encoded string is then decoded back to the original list of strings.</p><p>Please implement <code>encode</code> and <code>decode</code> methods.</p><p><strong>Challenge:</strong> The encoded string must be able to represent any possible input, including strings that contain any characters (including delimiter characters). Your encoding must be reversible - decode(encode(strs)) must equal strs for all possible inputs.</p><p><strong>Approach Options:</strong> 1) Use escape sequences for delimiters (complex). 2) <strong>Length-prefix encoding</strong>: prefix each string with its length followed by a delimiter (e.g., <code>"3#abc4#test"</code>). This works for any characters since we know exactly how many characters to read.</p>`,
        "examples": [
            {
                "input": "[\"lint\",\"code\",\"love\",\"you\"]",
                "output": "[\"lint\",\"code\",\"love\",\"you\"]",
                "explanation": "One possible encode method: \"4#lint4#code4#love3#you\". The encoded string is decoded back to the original list."
            },
            {
                "input": "[\"we\",\"say\",\":\",\"yes\"]",
                "output": "[\"we\",\"say\",\":\",\"yes\"]",
                "explanation": "Encode as \"2#we3#say1#:3#yes\". Even though \":\" is a special character, length-prefix handles it correctly."
            },
            {
                "input": "[\"\",\"\"]",
                "output": "[\"\",\"\"]",
                "explanation": "Two empty strings encode as \"0#0#\" (length 0 for each)."
            }
        ],
        "constraints": [
            "<code>0 <= strs.length <= 200</code>",
            "<code>0 <= strs[i].length <= 200</code>",
            "<code>strs[i] contains any possible ASCII characters</code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "Use delimiter.",
                "algorithm": "Escape delimiter",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(n)"
                },
                "code": {
                    "python": "class Codec:\n    def encode(self, strs):\n        return ''.join(s.replace('/', '//').replace('#', '/#') + '#' for s in strs)\n    def decode(self, s):\n        result = []\n        i = 0\n        curr = ''\n        while i < len(s):\n            if s[i] == '/':\n                curr += s[i+1]\n                i += 2\n            elif s[i] == '#':\n                result.append(curr)\n                curr = ''\n                i += 1\n            else:\n                curr += s[i]\n                i += 1\n        return result",
                    "java": "public class Codec { public String encode(List<String> strs) { StringBuilder sb = new StringBuilder(); for (String s : strs) sb.append(s.replace(\"/\", \"//\").replace(\"#\", \"/#\")).append('#'); return sb.toString(); } public List<String> decode(String s) { List<String> result = new ArrayList<>(); StringBuilder curr = new StringBuilder(); int i = 0; while (i < s.length()) { if (s.charAt(i) == '/') { curr.append(s.charAt(i+1)); i += 2; } else if (s.charAt(i) == '#') { result.add(curr.toString()); curr = new StringBuilder(); i++; } else { curr.append(s.charAt(i)); i++; } } return result; } }",
                    "cpp": "class Codec { public: string encode(vector<string>& strs) { string result; for (auto& s : strs) { for (char c : s) { if (c == '/') result += \"//\"; else if (c == '#') result += \"/#\"; else result += c; } result += '#'; } return result; } vector<string> decode(string s) { vector<string> result; string curr; int i = 0; while (i < s.size()) { if (s[i] == '/') { curr += s[i+1]; i += 2; } else if (s[i] == '#') { result.push_back(curr); curr = \"\"; i++; } else { curr += s[i]; i++; } } return result; } };"
                }
            },
            "optimized": {
                "intuition": "Length prefix.",
                "algorithm": "Store length before each string",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)"
                },
                "code": {
                    "python": "class Codec:\n    def encode(self, strs):\n        return ''.join(f'{len(s)}#{s}' for s in strs)\n    def decode(self, s):\n        result = []\n        i = 0\n        while i < len(s):\n            j = i\n            while s[j] != '#':\n                j += 1\n            length = int(s[i:j])\n            result.append(s[j+1:j+1+length])\n            i = j + 1 + length\n        return result",
                    "java": "public class Codec { public String encode(List<String> strs) { StringBuilder sb = new StringBuilder(); for (String s : strs) sb.append(s.length()).append('#').append(s); return sb.toString(); } public List<String> decode(String s) { List<String> result = new ArrayList<>(); int i = 0; while (i < s.length()) { int j = i; while (s.charAt(j) != '#') j++; int len = Integer.parseInt(s.substring(i, j)); result.add(s.substring(j + 1, j + 1 + len)); i = j + 1 + len; } return result; } }",
                    "cpp": "class Codec { public: string encode(vector<string>& strs) { string result; for (auto& s : strs) result += to_string(s.size()) + '#' + s; return result; } vector<string> decode(string s) { vector<string> result; int i = 0; while (i < s.size()) { int j = i; while (s[j] != '#') j++; int len = stoi(s.substr(i, j - i)); result.push_back(s.substr(j + 1, len)); i = j + 1 + len; } return result; } };"
                }
            }
        }
    },
    "longest-substring-without-repeating-characters": {
        description: `<p>Given a string <code>s</code>, find the length of the <strong>longest substring</strong> without repeating characters.</p>
<p>A <strong>substring</strong> is a contiguous sequence of characters within a string. For this problem, we need to find the maximum length among all substrings that contain only unique characters.</p>
<p>For example, in the string "abcabcbb", the longest substrings without repeating characters are "abc" (length 3). Even though "abc" appears twice, we only care about the length, not the number of occurrences.</p>
<p><strong>Challenge:</strong> Can you solve this efficiently using a sliding window approach in O(n) time?</p>`,
        examples: [
            {
                input: 's = "abcabcbb"',
                output: '3',
                explanation: 'The answer is "abc", with the length of 3. The string contains repeating characters, but the longest substring without any repeats is "abc".'
            },
            {
                input: 's = "bbbbb"',
                output: '1',
                explanation: 'The answer is "b", with the length of 1. Since all characters are the same, any single character is the longest unique substring.'
            },
            {
                input: 's = "pwwkew"',
                output: '3',
                explanation: 'The answer is "wke", with the length of 3. Notice that "pwke" is not valid because it\'s not a substring (the characters are not consecutive).'
            },
            {
                input: 's = "dvdf"',
                output: '3',
                explanation: 'The answer is "vdf", with the length of 3.'
            }
        ],
        constraints: [
            "<code>0 <= s.length <= 5 * 10<sup>4</sup></code>",
            "<code>s</code> consists of English letters, digits, symbols and spaces."
        ],
        solutions: {
            brute: {
                intuition: "Check every possible substring and verify if it contains only unique characters. For each starting position, extend as far as possible while characters remain unique. Track the maximum length found.",
                algorithm: [
                    "Initialize maxLength to 0",
                    "For each starting index i:",
                    "  Create an empty set to track seen characters",
                    "  For each ending index j starting from i:",
                    "    If character at j is already in set, break (found duplicate)",
                    "    Add character at j to set",
                    "    Update maxLength if current substring length is greater",
                    "Return maxLength"
                ],
                complexity: {
                    time: "O(n¬≥) in worst case. For each of n starting positions, we check up to n ending positions, and set operations can take O(n) time. However, with early breaking, it's often closer to O(n¬≤).",
                    space: "O(min(n, m)) where n is string length and m is the character set size. The set stores at most min(n, m) characters."
                },
                code: {
                    python: `def lengthOfLongestSubstring(s):
    n = len(s)
    max_length = 0
    
    # Try every starting position
    for i in range(n):
        seen = set()
        
        # Extend as far as possible from this start
        for j in range(i, n):
            if s[j] in seen:
                break  # Found duplicate
            
            seen.add(s[j])
            max_length = max(max_length, j - i + 1)
    
    return max_length`,
                    java: `class Solution {
    public int lengthOfLongestSubstring(String s) {
        int n = s.length();
        int maxLength = 0;
        
        // Try every starting position
        for (int i = 0; i < n; i++) {
            Set<Character> seen = new HashSet<>();
            
            // Extend as far as possible from this start
            for (int j = i; j < n; j++) {
                if (seen.contains(s.charAt(j))) {
                    break;  // Found duplicate
                }
                
                seen.add(s.charAt(j));
                maxLength = Math.max(maxLength, j - i + 1);
            }
        }
        
        return maxLength;
    }
}`,
                    cpp: `class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        int n = s.size();
        int maxLength = 0;
        
        // Try every starting position
        for (int i = 0; i < n; i++) {
            unordered_set<char> seen;
            
            // Extend as far as possible from this start
            for (int j = i; j < n; j++) {
                if (seen.count(s[j])) {
                    break;  // Found duplicate
                }
                
                seen.insert(s[j]);
                maxLength = max(maxLength, j - i + 1);
            }
        }
        
        return maxLength;
    }
};`,
                    javascript: `function lengthOfLongestSubstring(s) {
    const n = s.length;
    let maxLength = 0;
    
    // Try every starting position
    for (let i = 0; i < n; i++) {
        const seen = new Set();
        
        // Extend as far as possible from this start
        for (let j = i; j < n; j++) {
            if (seen.has(s[j])) {
                break;  // Found duplicate
            }
            
            seen.add(s[j]);
            maxLength = Math.max(maxLength, j - i + 1);
        }
    }
    
    return maxLength;
}`
                }
            },
            optimized: {
                intuition: "Use a sliding window with a set to track characters in the current window. When we encounter a duplicate, shrink the window from the left until the duplicate is removed. This allows us to find the answer in a single pass through the string.",
                algorithm: [
                    "Initialize left pointer at 0, maxLength at 0, and empty set",
                    "Iterate with right pointer from 0 to n-1:",
                    "  While character at right is in set:",
                    "    Remove character at left from set",
                    "    Increment left pointer",
                    "  Add character at right to set",
                    "  Update maxLength = max(maxLength, right - left + 1)",
                    "Return maxLength"
                ],
                complexity: {
                    time: "O(n) where n is the length of the string. Each character is visited at most twice (once by right pointer, once by left pointer).",
                    space: "O(min(n, m)) where m is the size of the character set. In the worst case, the set contains all unique characters from the string."
                },
                code: {
                    python: `def lengthOfLongestSubstring(s):
    char_set = set()
    left = 0
    max_length = 0
    
    for right in range(len(s)):
        # Remove characters from left until no duplicate
        while s[right] in char_set:
            char_set.remove(s[left])
            left += 1
        
        # Add current character
        char_set.add(s[right])
        
        # Update maximum length
        max_length = max(max_length, right - left + 1)
    
    return max_length`,
                    java: `class Solution {
    public int lengthOfLongestSubstring(String s) {
        Set<Character> charSet = new HashSet<>();
        int left = 0;
        int maxLength = 0;
        
        for (int right = 0; right < s.length(); right++) {
            // Remove characters from left until no duplicate
            while (charSet.contains(s.charAt(right))) {
                charSet.remove(s.charAt(left));
                left++;
            }
            
            // Add current character
            charSet.add(s.charAt(right));
            
            // Update maximum length
            maxLength = Math.max(maxLength, right - left + 1);
        }
        
        return maxLength;
    }
}`,
                    cpp: `class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        unordered_set<char> charSet;
        int left = 0;
        int maxLength = 0;
        
        for (int right = 0; right < s.size(); right++) {
            // Remove characters from left until no duplicate
            while (charSet.count(s[right])) {
                charSet.erase(s[left]);
                left++;
            }
            
            // Add current character
            charSet.insert(s[right]);
            
            // Update maximum length
            maxLength = max(maxLength, right - left + 1);
        }
        
        return maxLength;
    }
};`,
                    javascript: `function lengthOfLongestSubstring(s) {
    const charSet = new Set();
    let left = 0;
    let maxLength = 0;
    
    for (let right = 0; right < s.length; right++) {
        // Remove characters from left until no duplicate
        while (charSet.has(s[right])) {
            charSet.delete(s[left]);
            left++;
        }
        
        // Add current character
        charSet.add(s[right]);
        
        // Update maximum length
        maxLength = Math.max(maxLength, right - left + 1);
    }
    
    return maxLength;
}`
                }
            }
        }
    },
    "valid-palindrome": {
  description: `<p>A phrase is a <strong>palindrome</strong> if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.</p>
<p>Given a string <code>s</code>, return <code>true</code> if it is a palindrome, or <code>false</code> otherwise.</p>
<p>This problem is a classic application of the two-pointer technique. The key challenge is to correctly handle the preprocessing step of filtering out non-alphanumeric characters and normalizing case, while efficiently checking if the resulting string is a palindrome.</p>
<p>A naive approach would be to create a new filtered string and then check if it equals its reverse, but this requires O(n) extra space. A more efficient approach uses two pointers moving from both ends toward the center, skipping non-alphanumeric characters on the fly.</p>`,
  examples: [
    {
      input: 's = "A man, a plan, a canal: Panama"',
      output: 'true',
      explanation: 'After removing non-alphanumeric characters and converting to lowercase, the string becomes "amanaplanacanalpanama", which is a palindrome. Reading it forward: a-m-a-n-a-p-l-a-n-a-c-a-n-a-l-p-a-n-a-m-a. Reading it backward gives the same sequence.'
    },
    {
      input: 's = "race a car"',
      output: 'false',
      explanation: 'After processing, we get "raceacar". Using two pointers: left starts at "r" and right starts at "r" (matching). Moving inward: "a" matches "a", "c" matches "c", "e" matches "a" - mismatch found! Therefore, it is not a palindrome.'
    },
    {
      input: 's = " "',
      output: 'true',
      explanation: 'After removing all non-alphanumeric characters, the string becomes empty "". An empty string is considered a palindrome by definition, as it reads the same forward and backward.'
    },
    {
      input: 's = "0P"',
      output: 'false',
      explanation: 'After converting to lowercase, we have "0p". Comparing: "0" != "p", so it is not a palindrome. Note that "0" is an alphanumeric character (it\'s a digit).'
    }
  ],
  constraints: [
    '<code>1 <= s.length <= 2 * 10<sup>5</sup></code>',
    '<code>s</code> consists only of printable ASCII characters.'
  ],
        solutions: {
            brute: {
                intuition: "The straightforward approach is to first clean the string by filtering out all non-alphanumeric characters and converting to lowercase, then check if this cleaned string equals its reverse. This approach is simple and easy to understand.",
                algorithm: [
                  "Iterate through the string and collect only alphanumeric characters",
                  "Convert each character to lowercase as you collect them",
                  "Create the cleaned/filtered string",
                  "Reverse the filtered string",
                  "Compare the filtered string with its reverse",
                  "If they are equal, return true (palindrome), otherwise return false"
                ],
                complexity: {
                    time: "O(n) where n is the length of the input string. We iterate through the string once to filter and once to reverse (or compare).",
                    space: "O(n) for storing the filtered string. In the worst case, all characters are alphanumeric, so we store a string nearly as long as the input."
                },
                code: {
                    python: `def isPalindrome(s):
    # Filter and convert to lowercase
    filtered = ''.join(c.lower() for c in s if c.isalnum())
    
    # Check if it reads the same forward and backward
    return filtered == filtered[::-1]`,
                    java: `class Solution {
    public boolean isPalindrome(String s) {
        // Build filtered string
        StringBuilder filtered = new StringBuilder();
        for (char c : s.toCharArray()) {
            if (Character.isLetterOrDigit(c)) {
                filtered.append(Character.toLowerCase(c));
            }
        }
        
        // Compare with reverse
        String filteredStr = filtered.toString();
        String reversed = filtered.reverse().toString();
        return filteredStr.equals(reversed);
    }
}`,
                    cpp: `class Solution {
public:
    bool isPalindrome(string s) {
        // Build filtered string
        string filtered;
        for (char c : s) {
            if (isalnum(c)) {
                filtered += tolower(c);
            }
        }
        
        // Compare with reverse
        string reversed = filtered;
        reverse(reversed.begin(), reversed.end());
        return filtered == reversed;
    }
};`,
                    javascript: `function isPalindrome(s) {
    // Filter and convert to lowercase
    const filtered = s
        .toLowerCase()
        .split('')
        .filter(c => (c >= 'a' && c <= 'z') || (c >= '0' && c <= '9'))
        .join('');
    
    // Compare with reverse
    const reversed = filtered.split('').reverse().join('');
    return filtered === reversed;
}`
                }
            },
            optimized: {
                intuition: "Instead of creating a new filtered string, we can use two pointers starting from both ends of the original string. As we move the pointers inward, we skip non-alphanumeric characters and compare only valid characters after converting to lowercase. This eliminates the need for extra space.",
                algorithm: [
                  "Initialize two pointers: left at the start (0) and right at the end (length - 1)",
                  "While left pointer is less than right pointer:",
                  "  - Skip non-alphanumeric characters from the left by incrementing left",
                  "  - Skip non-alphanumeric characters from the right by decrementing right",
                  "  - Compare characters at left and right (after converting to lowercase)",
                  "  - If characters don't match, return false",
                  "  - Move both pointers inward (left++, right--)",
                  "If we complete the loop without finding mismatches, return true"
                ],
                complexity: {
                    time: "O(n) where n is the length of the string. Each character is visited at most once by either pointer.",
                    space: "O(1) as we only use two pointer variables and no additional data structures that grow with input size."
                },
                code: {
                    python: `def isPalindrome(s):
    left, right = 0, len(s) - 1
    
    while left < right:
        # Skip non-alphanumeric from left
        while left < right and not s[left].isalnum():
            left += 1
        
        # Skip non-alphanumeric from right
        while left < right and not s[right].isalnum():
            right -= 1
        
        # Compare characters (case-insensitive)
        if s[left].lower() != s[right].lower():
            return False
        
        left += 1
        right -= 1
    
    return True`,
                    java: `class Solution {
    public boolean isPalindrome(String s) {
        int left = 0, right = s.length() - 1;
        
        while (left < right) {
            // Skip non-alphanumeric from left
            while (left < right && !Character.isLetterOrDigit(s.charAt(left))) {
                left++;
            }
            
            // Skip non-alphanumeric from right
            while (left < right && !Character.isLetterOrDigit(s.charAt(right))) {
                right--;
            }
            
            // Compare characters (case-insensitive)
            if (Character.toLowerCase(s.charAt(left)) != 
                Character.toLowerCase(s.charAt(right))) {
                return false;
            }
            
            left++;
            right--;
        }
        
        return true;
    }
}`,
                    cpp: `class Solution {
public:
    bool isPalindrome(string s) {
        int left = 0, right = s.size() - 1;
        
        while (left < right) {
            // Skip non-alphanumeric from left
            while (left < right && !isalnum(s[left])) {
                left++;
            }
            
            // Skip non-alphanumeric from right
            while (left < right && !isalnum(s[right])) {
                right--;
            }
            
            // Compare characters (case-insensitive)
            if (tolower(s[left]) != tolower(s[right])) {
                return false;
            }
            
            left++;
            right--;
        }
        
        return true;
    }
};`,
                    javascript: `function isPalindrome(s) {
    let left = 0, right = s.length - 1;
    
    const isAlphanumeric = (c) => {
        const code = c.charCodeAt(0);
        return (code >= 48 && code <= 57) ||  // 0-9
               (code >= 65 && code <= 90) ||   // A-Z
               (code >= 97 && code <= 122);    // a-z
    };
    
    while (left < right) {
        // Skip non-alphanumeric from left
        while (left < right && !isAlphanumeric(s[left])) {
            left++;
        }
        
        // Skip non-alphanumeric from right
        while (left < right && !isAlphanumeric(s[right])) {
            right--;
        }
        
        // Compare characters (case-insensitive)
        if (s[left].toLowerCase() !== s[right].toLowerCase()) {
            return false;
        }
        
        left++;
        right--;
    }
    
    return true;
}`
                }
            }
        }
    },
    "two-sum-ii-input-array-is-sorted": {
        "description": `<p>Given a <strong>1-indexed</strong> array of integers <code>numbers</code> that is already <strong>sorted in non-decreasing order</strong>, find two numbers such that they add up to a specific <code>target</code> number. Let these two numbers be <code>numbers[index<sub>1</sub>]</code> and <code>numbers[index<sub>2</sub>]</code> where <code>1 <= index<sub>1</sub> < index<sub>2</sub> <= numbers.length</code>.</p>
<p>Return the indices of the two numbers, <code>index<sub>1</sub></code> and <code>index<sub>2</sub></code>, <strong>added by one</strong> as an integer array <code>[index<sub>1</sub>, index<sub>2</sub>]</code> of length 2.</p>
<p>The tests are generated such that there is <strong>exactly one solution</strong>. You <strong>may not</strong> use the same element twice.</p>
<p>Your solution must use only <strong>constant extra space</strong>.</p>
<p>Since the array is sorted, we can use the <strong>two-pointer technique</strong> to solve this in O(n) time with O(1) space. Start with pointers at both ends. If the sum is too small, move left pointer right. If too large, move right pointer left. The sorted property guarantees we won't miss the solution.</p>`,
        "examples": [
            {
                "input": "numbers = [2,7,11,15], target = 9",
                "output": "[1,2]",
                "explanation": "The sum of 2 and 7 is 9. Therefore, index<sub>1</sub> = 1, index<sub>2</sub> = 2. We return [1, 2]. Note: 1-indexed."
            },
            {
                "input": "numbers = [2,3,4], target = 6",
                "output": "[1,3]",
                "explanation": "The sum of 2 and 4 is 6. Therefore, index<sub>1</sub> = 1, index<sub>2</sub> = 3. We return [1, 3]."
            },
            {
                "input": "numbers = [-1,0], target = -1",
                "output": "[1,2]",
                "explanation": "The sum of -1 and 0 is -1. Therefore, index<sub>1</sub> = 1, index<sub>2</sub> = 2. We return [1, 2]."
            }
        ],
        "constraints": [
            "<code>2 <= numbers.length <= 3 * 10<sup>4</sup></code>",
            "<code>-1000 <= numbers[i] <= 1000</code>",
            "<code>numbers</code> is sorted in <strong>non-decreasing order</strong>.",
            "<code>-1000 <= target <= 1000</code>",
            "The tests are generated such that there is <strong>exactly one solution</strong>."
        ],
        "solutions": {
            "brute": {
                "intuition": "Check all pairs.",
                "algorithm": "O(n¬≤) nested loops",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(1)"
                },
                "code": {
                    "python": "class Solution:\n    def twoSum(self, numbers, target):\n        for i in range(len(numbers)):\n            for j in range(i + 1, len(numbers)):\n                if numbers[i] + numbers[j] == target:\n                    return [i + 1, j + 1]\n        return []",
                    "java": "class Solution { public int[] twoSum(int[] numbers, int target) { for (int i = 0; i < numbers.length; i++) { for (int j = i + 1; j < numbers.length; j++) { if (numbers[i] + numbers[j] == target) return new int[]{i + 1, j + 1}; } } return new int[0]; } }",
                    "cpp": "class Solution { public: vector<int> twoSum(vector<int>& numbers, int target) { for (int i = 0; i < numbers.size(); i++) { for (int j = i + 1; j < numbers.size(); j++) { if (numbers[i] + numbers[j] == target) return {i + 1, j + 1}; } } return {}; } };"
                }
            },
            "optimized": {
                "intuition": "Two pointers.",
                "algorithm": "Converge from ends",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)"
                },
                "code": {
                    "python": "class Solution:\n    def twoSum(self, numbers, target):\n        left, right = 0, len(numbers) - 1\n        while left < right:\n            total = numbers[left] + numbers[right]\n            if total == target:\n                return [left + 1, right + 1]\n            elif total < target:\n                left += 1\n            else:\n                right -= 1\n        return []",
                    "java": "class Solution { public int[] twoSum(int[] numbers, int target) { int left = 0, right = numbers.length - 1; while (left < right) { int sum = numbers[left] + numbers[right]; if (sum == target) return new int[]{left + 1, right + 1}; else if (sum < target) left++; else right--; } return new int[0]; } }",
                    "cpp": "class Solution { public: vector<int> twoSum(vector<int>& numbers, int target) { int left = 0, right = numbers.size() - 1; while (left < right) { int sum = numbers[left] + numbers[right]; if (sum == target) return {left + 1, right + 1}; else if (sum < target) left++; else right--; } return {}; } };"
                }
            }
        }
    },
    "best-time-to-buy-and-sell-stock": {
        description: `<p>You are given an array <code>prices</code> where <code>prices[i]</code> is the price of a given stock on the <code>i<sup>th</sup></code> day.</p>
<p>You want to maximize your profit by choosing a <strong>single day</strong> to buy one stock and choosing a <strong>different day in the future</strong> to sell that stock.</p>
<p>Return <em>the maximum profit you can achieve from this transaction</em>. If you cannot achieve any profit, return <code>0</code>.</p>
<p><strong>Important:</strong> You must buy before you sell. You cannot sell a stock before you buy it. This means for any valid transaction, the buy day must come before the sell day.</p>`,
        examples: [
            {
                input: "prices = [7,1,5,3,6,4]",
                output: "5",
                explanation: "Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5. Note that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell."
            },
            {
                input: "prices = [7,6,4,3,1]",
                output: "0",
                explanation: "In this case, no transactions are done and the max profit = 0. The prices are continuously decreasing, so there's no opportunity to make a profit."
            },
            {
                input: "prices = [2,4,1]",
                output: "2",
                explanation: "Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4-2 = 2."
            },
            {
                input: "prices = [3,2,6,5,0,3]",
                output: "4",
                explanation: "Buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6-2 = 4. Even though there's a lower price later (0), we can't use it for this transaction since we'd need to sell first."
            }
        ],
        constraints: [
            "<code>1 <= prices.length <= 10<sup>5</sup></code>",
            "<code>0 <= prices[i] <= 10<sup>4</sup></code>"
        ],
        solutions: {
            brute: {
                intuition: "The brute force approach checks every possible buy-sell pair. For each day as a potential buy day, we check all subsequent days as potential sell days, calculating the profit for each pair and keeping track of the maximum.",
                algorithm: [
                    "Initialize maxProfit to 0",
                    "For each day i (potential buy day):",
                    "  For each day j after i (potential sell day):",
                    "    Calculate profit = prices[j] - prices[i]",
                    "    Update maxProfit if this profit is greater",
                    "Return maxProfit"
                ],
                complexity: {
                    time: "O(n¬≤) where n is the number of days. We check every possible pair of buy and sell days.",
                    space: "O(1) as we only use a constant amount of extra space."
                },
                code: {
                    python: `def maxProfit(prices):
    n = len(prices)
    max_profit = 0
    
    # Try every buy day
    for i in range(n):
        # Try every sell day after buy day
        for j in range(i + 1, n):
            profit = prices[j] - prices[i]
            max_profit = max(max_profit, profit)
    
    return max_profit`,
                    java: `class Solution {
    public int maxProfit(int[] prices) {
        int n = prices.length;
        int maxProfit = 0;
        
        // Try every buy day
        for (int i = 0; i < n; i++) {
            // Try every sell day after buy day
            for (int j = i + 1; j < n; j++) {
                int profit = prices[j] - prices[i];
                maxProfit = Math.max(maxProfit, profit);
            }
        }
        
        return maxProfit;
    }
}`,
                    cpp: `class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        int maxProfit = 0;
        
        // Try every buy day
        for (int i = 0; i < n; i++) {
            // Try every sell day after buy day
            for (int j = i + 1; j < n; j++) {
                int profit = prices[j] - prices[i];
                maxProfit = max(maxProfit, profit);
            }
        }
        
        return maxProfit;
    }
};`,
                    javascript: `function maxProfit(prices) {
    const n = prices.length;
    let maxProfit = 0;
    
    // Try every buy day
    for (let i = 0; i < n; i++) {
        // Try every sell day after buy day
        for (let j = i + 1; j < n; j++) {
            const profit = prices[j] - prices[i];
            maxProfit = Math.max(maxProfit, profit);
        }
    }
    
    return maxProfit;
}`
                }
            },
            optimized: {
                intuition: "Keep track of the minimum price seen so far as we iterate through the array. For each price, calculate the profit if we sold on that day (current price - minimum price). The maximum of these profits is our answer. This works because we're always looking for the best opportunity given the lowest buy price we've encountered.",
                algorithm: [
                    "Initialize minPrice to infinity and maxProfit to 0",
                    "For each price in the array:",
                    "  Update minPrice to be the minimum of current minPrice and current price",
                    "  Calculate potential profit = current price - minPrice",
                    "  Update maxProfit if this potential profit is greater",
                    "Return maxProfit"
                ],
                complexity: {
                    time: "O(n) where n is the number of days. We make a single pass through the array.",
                    space: "O(1) as we only use two variables regardless of input size."
                },
                code: {
                    python: `def maxProfit(prices):
    min_price = float('inf')
    max_profit = 0
    
    for price in prices:
        # Update minimum price if we found a lower price
        min_price = min(min_price, price)
        
        # Calculate profit if we sell at current price
        profit = price - min_price
        
        # Update maximum profit
        max_profit = max(max_profit, profit)
    
    return max_profit`,
                    java: `class Solution {
    public int maxProfit(int[] prices) {
        int minPrice = Integer.MAX_VALUE;
        int maxProfit = 0;
        
        for (int price : prices) {
            // Update minimum price if we found a lower price
            minPrice = Math.min(minPrice, price);
            
            // Calculate profit if we sell at current price
            int profit = price - minPrice;
            
            // Update maximum profit
            maxProfit = Math.max(maxProfit, profit);
        }
        
        return maxProfit;
    }
}`,
                    cpp: `class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int minPrice = INT_MAX;
        int maxProfit = 0;
        
        for (int price : prices) {
            // Update minimum price if we found a lower price
            minPrice = min(minPrice, price);
            
            // Calculate profit if we sell at current price
            int profit = price - minPrice;
            
            // Update maximum profit
            maxProfit = max(maxProfit, profit);
        }
        
        return maxProfit;
    }
};`,
                    javascript: `function maxProfit(prices) {
    let minPrice = Infinity;
    let maxProfit = 0;
    
    for (const price of prices) {
        // Update minimum price if we found a lower price
        minPrice = Math.min(minPrice, price);
        
        // Calculate profit if we sell at current price
        const profit = price - minPrice;
        
        // Update maximum profit
        maxProfit = Math.max(maxProfit, profit);
    }
    
    return maxProfit;
}`
                }
            }
        }
    },
    "valid-parentheses": {
        description: `<p>Given a string <code>s</code> containing just the characters <code>'('</code>, <code>')'</code>, <code>'{'</code>, <code>'}'</code>, <code>'['</code> and <code>']'</code>, determine if the input string is valid.</p>
<p>An input string is valid if:</p>
<ul>
<li>Open brackets must be closed by the same type of brackets.</li>
<li>Open brackets must be closed in the correct order.</li>
<li>Every close bracket has a corresponding open bracket of the same type.</li>
</ul>
<p>This is a classic <strong>stack problem</strong>. As we scan the string, we need to track opening brackets and match them with their corresponding closing brackets. A stack is the perfect data structure because brackets must close in <strong>LIFO (Last In, First Out)</strong> order - the most recently opened bracket must be closed first.</p>
<p>For example, <code>"([)]"</code> is invalid because <code>']'</code> tries to close before <code>')'</code>, but <code>'('</code> was opened before <code>'['</code>.</p>`,
        examples: [
            {
                input: 's = "()"',
                output: 'true',
                explanation: 'The string contains one opening parenthesis followed by one closing parenthesis, which is valid.'
            },
            {
                input: 's = "()[]{}"',
                output: 'true',
                explanation: 'The string contains three pairs of brackets in correct order: (), [], and {}. Each pair is properly matched.'
            },
            {
                input: 's = "(]"',
                output: 'false',
                explanation: 'The opening parenthesis ( is not matched with a closing parenthesis ). Instead, it encounters a closing bracket ].'
            },
            {
                input: 's = "([)]"',
                output: 'false',
                explanation: 'The brackets are not closed in the correct order. [ is opened after (, but ] tries to close before ) closes.'
            }
        ],
        constraints: [
            "<code>1 <= s.length <= 10<sup>4</sup></code>",
            "<code>s</code> consists of parentheses only <code>'()[]{}'</code>."
        ],
        solutions: {
            brute: {
                intuition: "Use a stack to track opening brackets. When we encounter a closing bracket, check if it matches the most recent opening bracket on the stack. This approach is already optimal - there's no simpler way than using a stack for this problem.",
                algorithm: [
                    "Create an empty stack and a mapping of closing to opening brackets",
                    "For each character in the string:",
                    "  If it's a closing bracket:",
                    "    Check if stack is empty (no matching opening bracket)",
                    "    Pop from stack and check if it matches this closing bracket",
                    "    If mismatch, return false",
                    "  If it's an opening bracket:",
                    "    Push it onto the stack",
                    "After processing all characters, check if stack is empty",
                    "If stack is empty, all brackets were matched - return true",
                    "If stack has elements, some brackets weren't closed - return false"
                ],
                complexity: {
                    time: "O(n) where n is the length of string s. We process each character exactly once.",
                    space: "O(n) in the worst case where all characters are opening brackets, we store all of them on the stack."
                },
                code: {
                    python: `def isValid(s):
    """
    Stack-based bracket matching
    Time: O(n), Space: O(n)
    """
    stack = []
    # Map closing brackets to opening brackets
    closing_to_opening = {
        ')': '(',
        '}': '{',
        ']': '['
    }
    
    for char in s:
        if char in closing_to_opening:
            # It's a closing bracket
            if not stack or stack[-1] != closing_to_opening[char]:
                return False
            stack.pop()
        else:
            # It's an opening bracket
            stack.append(char)
    
    # Valid if all brackets were matched
    return len(stack) == 0`,
                    java: `class Solution {
    /**
     * Stack-based bracket matching
     * Time: O(n), Space: O(n)
     */
    public boolean isValid(String s) {
        Stack<Character> stack = new Stack<>();
        
        // Map closing brackets to opening brackets
        Map<Character, Character> closingToOpening = Map.of(
            ')', '(',
            '}', '{',
            ']', '['
        );
        
        for (char c : s.toCharArray()) {
            if (closingToOpening.containsKey(c)) {
                // It's a closing bracket
                if (stack.isEmpty() || stack.pop() != closingToOpening.get(c)) {
                    return false;
                }
            } else {
                // It's an opening bracket
                stack.push(c);
            }
        }
        
        // Valid if all brackets were matched
        return stack.isEmpty();
    }
}`,
                    cpp: `class Solution {
public:
    /**
     * Stack-based bracket matching
     * Time: O(n), Space: O(n)
     */
    bool isValid(string s) {
        stack<char> st;
        
        // Map closing brackets to opening brackets
        unordered_map<char, char> closingToOpening = {
            {')', '('},
            {'}', '{'},
            {']', '['}
        };
        
        for (char c : s) {
            if (closingToOpening.count(c)) {
                // It's a closing bracket
                if (st.empty() || st.top() != closingToOpening[c]) {
                    return false;
                }
                st.pop();
            } else {
                // It's an opening bracket
                st.push(c);
            }
        }
        
        // Valid if all brackets were matched
        return st.empty();
    }
};`,
                    javascript: `/**
 * Stack-based bracket matching
 * Time: O(n), Space: O(n)
 * @param {string} s
 * @return {boolean}
 */
function isValid(s) {
    const stack = [];
    
    // Map closing brackets to opening brackets
    const closingToOpening = {
        ')': '(',
        '}': '{',
        ']': '['
    };
    
    for (const char of s) {
        if (char in closingToOpening) {
            // It's a closing bracket
            if (stack.length === 0 || stack[stack.length - 1] !== closingToOpening[char]) {
                return false;
            }
            stack.pop();
        } else {
            // It's an opening bracket
            stack.push(char);
        }
    }
    
    // Valid if all brackets were matched
    return stack.length === 0;
}`
                }
            },
            optimized: {
                intuition: "The stack approach is already optimal. However, we can optimize slightly by pushing the expected closing bracket instead of the opening bracket. This way we only need to check equality when we encounter a closing bracket.",
                algorithm: [
                    "Create an empty stack",
                    "For each character in the string:",
                    "  If it's an opening bracket ( , { , or [:",
                    "    Push the corresponding CLOSING bracket onto the stack",
                    "  If it's a closing bracket:",
                    "    Check if stack is empty or top doesn't match this closing bracket",
                    "    If mismatch, return false",
                    "    Otherwise, pop from stack",
                    "After processing all characters, return true if stack is empty"
                ],
                complexity: {
                    time: "O(n) where n is the length of string s. We process each character exactly once.",
                    space: "O(n) in the worst case where all characters are opening brackets."
                },
                code: {
                    python: `def isValid(s):
    """
    Optimized stack approach - push expected closing bracket
    Time: O(n), Space: O(n)
    """
    stack = []
    
    for char in s:
        # Push expected closing bracket for opening brackets
        if char == '(':
            stack.append(')')
        elif char == '{':
            stack.append('}')
        elif char == '[':
            stack.append(']')
        # Check if closing bracket matches expected
        elif not stack or stack.pop() != char:
            return False
    
    return not stack`,
                    java: `class Solution {
    /**
     * Optimized stack approach - push expected closing bracket
     * Time: O(n), Space: O(n)
     */
    public boolean isValid(String s) {
        Stack<Character> stack = new Stack<>();
        
        for (char c : s.toCharArray()) {
            // Push expected closing bracket for opening brackets
            if (c == '(') {
                stack.push(')');
            } else if (c == '{') {
                stack.push('}');
            } else if (c == '[') {
                stack.push(']');
            } 
            // Check if closing bracket matches expected
            else if (stack.isEmpty() || stack.pop() != c) {
                return false;
            }
        }
        
        return stack.isEmpty();
    }
}`,
                    cpp: `class Solution {
public:
    /**
     * Optimized stack approach - push expected closing bracket
     * Time: O(n), Space: O(n)
     */
    bool isValid(string s) {
        stack<char> st;
        
        for (char c : s) {
            // Push expected closing bracket for opening brackets
            if (c == '(') {
                st.push(')');
            } else if (c == '{') {
                st.push('}');
            } else if (c == '[') {
                st.push(']');
            } 
            // Check if closing bracket matches expected
            else if (st.empty() || st.top() != c) {
                return false;
            } else {
                st.pop();
            }
        }
        
        return st.empty();
    }
};`,
                    javascript: `/**
 * Optimized stack approach - push expected closing bracket
 * Time: O(n), Space: O(n)
 * @param {string} s
 * @return {boolean}
 */
function isValid(s) {
    const stack = [];
    
    for (const char of s) {
        // Push expected closing bracket for opening brackets
        if (char === '(') {
            stack.push(')');
        } else if (char === '{') {
            stack.push('}');
        } else if (char === '[') {
            stack.push(']');
        } 
        // Check if closing bracket matches expected
        else if (stack.length === 0 || stack.pop() !== char) {
            return false;
        }
    }
    
    return stack.length === 0;
}`
                }
            }
        }
    },
    "min-stack": {
        "description": `<p>Design a stack that supports push, pop, top, and retrieving the minimum element in <strong>constant time</strong>.</p>
<p>Implement the <code>MinStack</code> class:</p>
<ul>
<li><code>MinStack()</code> initializes the stack object.</li>
<li><code>void push(int val)</code> pushes the element <code>val</code> onto the stack.</li>
<li><code>void pop()</code> removes the element on the top of the stack.</li>
<li><code>int top()</code> gets the top element of the stack.</li>
<li><code>int getMin()</code> retrieves the minimum element in the stack.</li>
</ul>
<p>You must implement a solution with <strong>O(1)</strong> time complexity for each function.</p>
<p>The challenge is to implement <code>getMin()</code> in <strong>O(1)</strong> time complexity. This requires tracking the minimum value as the stack changes. We cannot scan through all elements each time (that would be O(n)).</p>
<p>The key insight is to use <strong>two stacks</strong>: one for regular values and one for tracking minimums. Or alternatively, store pairs <code>(value, min_at_this_level)</code> in a single stack. When we pop, we know what the minimum was at each level of the stack.</p>`,
        "examples": [
            {
                "input": "[\"MinStack\",\"push\",\"push\",\"push\",\"getMin\",\"pop\",\"top\",\"getMin\"]\\n[[],[-2],[0],[-3],[],[],[],[]]",
                "output": "[null,null,null,null,-3,null,0,-2]",
                "explanation": "MinStack minStack = new MinStack();\\nminStack.push(-2);\\nminStack.push(0);\\nminStack.push(-3);\\nminStack.getMin(); // return -3\\nminStack.pop();\\nminStack.top();    // return 0\\nminStack.getMin(); // return -2"
            },
            {
                "input": "[\"MinStack\",\"push\",\"push\",\"getMin\",\"getMin\",\"push\",\"getMin\"]\\n[[],[1],[2],[],[],[0],[]]",
                "output": "[null,null,null,1,1,null,0]",
                "explanation": "After pushing 1 and 2, minimum is 1. After pushing 0, minimum becomes 0."
            },
            {
                "input": "[\"MinStack\",\"push\",\"push\",\"push\",\"getMin\"]\\n[[],[5],[3],[7],[]]",
                "output": "[null,null,null,null,3]",
                "explanation": "The minimum among 5, 3, 7 is 3."
            }
        ],
        "constraints": [
            "<code>-2<sup>31</sup> <= val <= 2<sup>31</sup> - 1</code>",
            "Methods <code>pop</code>, <code>top</code> and <code>getMin</code> operations will always be called on <strong>non-empty</strong> stacks.",
            "At most <code>3 * 10<sup>4</sup></code> calls will be made to <code>push</code>, <code>pop</code>, <code>top</code>, and <code>getMin</code>."
        ],
        "solutions": {
            "brute": {
                "intuition": "Track min with each element.",
                "algorithm": "Store pairs",
                "complexity": {
                    "time": "O(1)",
                    "space": "O(n)"
                },
                "code": {
                    "python": "class MinStack:\n    def __init__(self):\n        self.stack = []\n    def push(self, val):\n        minVal = min(val, self.stack[-1][1]) if self.stack else val\n        self.stack.append((val, minVal))\n    def pop(self):\n        self.stack.pop()\n    def top(self):\n        return self.stack[-1][0]\n    def getMin(self):\n        return self.stack[-1][1]",
                    "java": "class MinStack { Stack<int[]> stack = new Stack<>(); public void push(int val) { int min = stack.isEmpty() ? val : Math.min(val, stack.peek()[1]); stack.push(new int[]{val, min}); } public void pop() { stack.pop(); } public int top() { return stack.peek()[0]; } public int getMin() { return stack.peek()[1]; } }",
                    "cpp": "class MinStack { stack<pair<int,int>> st; public: void push(int val) { int minVal = st.empty() ? val : min(val, st.top().second); st.push({val, minVal}); } void pop() { st.pop(); } int top() { return st.top().first; } int getMin() { return st.top().second; } };"
                }
            },
            "optimized": {
                "intuition": "Two stacks.",
                "algorithm": "Separate min stack",
                "complexity": {
                    "time": "O(1)",
                    "space": "O(n)"
                },
                "code": {
                    "python": "class MinStack:\n    def __init__(self):\n        self.stack = []\n        self.minStack = []\n    def push(self, val):\n        self.stack.append(val)\n        if not self.minStack or val <= self.minStack[-1]:\n            self.minStack.append(val)\n    def pop(self):\n        if self.stack.pop() == self.minStack[-1]:\n            self.minStack.pop()\n    def top(self):\n        return self.stack[-1]\n    def getMin(self):\n        return self.minStack[-1]",
                    "java": "class MinStack { Stack<Integer> stack = new Stack<>(); Stack<Integer> minStack = new Stack<>(); public void push(int val) { stack.push(val); if (minStack.isEmpty() || val <= minStack.peek()) minStack.push(val); } public void pop() { if (stack.pop().equals(minStack.peek())) minStack.pop(); } public int top() { return stack.peek(); } public int getMin() { return minStack.peek(); } }",
                    "cpp": "class MinStack { stack<int> st, minSt; public: void push(int val) { st.push(val); if (minSt.empty() || val <= minSt.top()) minSt.push(val); } void pop() { if (st.top() == minSt.top()) minSt.pop(); st.pop(); } int top() { return st.top(); } int getMin() { return minSt.top(); } };"
                }
            }
        }
    },
    "evaluate-reverse-polish-notation": {
        "description": `<p>You are given an array of strings <code>tokens</code> that represents an arithmetic expression in <strong>Reverse Polish Notation</strong> (RPN).</p>
<p>In RPN (also known as <strong>postfix notation</strong>), operators come <strong>after</strong> their operands. For example, the infix expression <code>3 + 4</code> would be written as <code>3 4 +</code> in RPN.</p>
<p>Evaluate the expression and return an integer representing the value of the expression. The valid operators are <code>'+'</code>, <code>'-'</code>, <code>'*'</code>, and <code>'/'</code>. Note that division between integers should <strong>truncate toward zero</strong>.</p>
<p>It is guaranteed that the given RPN expression is always valid. That means the expression would always evaluate to a result, and there will not be any division by zero operation.</p>
<p>RPN is particularly easy to evaluate using a <strong>stack</strong>. Push operands onto the stack, and when you encounter an operator, pop two operands, apply the operation, and push the result back. This naturally handles operator precedence without needing parentheses. Order matters for subtraction and division: the second popped value is the left operand.</p>`,
        "examples": [
            {
                "input": "tokens = [\"2\",\"1\",\"+\",\"3\",\"*\"]",
                "output": "9",
                "explanation": "((2 + 1) * 3) = 9. Process: push 2, push 1, pop both and push 2+1=3, push 3, pop both and push 3*3=9."
            },
            {
                "input": "tokens = [\"4\",\"13\",\"5\",\"/\",\"+\"]",
                "output": "6",
                "explanation": "(4 + (13 / 5)) = (4 + 2) = 6. Integer division 13/5 = 2 (truncates toward zero)."
            },
            {
                "input": "tokens = [\"10\",\"6\",\"9\",\"3\",\"+\",\"-11\",\"*\",\"/\",\"*\",\"17\",\"+\",\"5\",\"+\"]",
                "output": "22",
                "explanation": "((10 * (6 / ((9 + 3) * -11))) + 17) + 5 = ((10 * (6 / (12 * -11))) + 17) + 5 = 22"
            }
        ],
        "constraints": [
            "<code>1 <= tokens.length <= 10<sup>4</sup></code>",
            "<code>tokens[i]</code> is either an operator: <code>\"+\"</code>, <code>\"-\"</code>, <code>\"*\"</code>, or <code>\"/\"</code>, or an integer in the range <code>[-200, 200]</code>."
        ],
        "solutions": {
            "brute": {
                "intuition": "Stack-based evaluation.",
                "algorithm": "Push numbers, pop for ops",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(n)"
                },
                "code": {
                    "python": "class Solution:\n    def evalRPN(self, tokens):\n        stack = []\n        ops = {'+': lambda a,b: a+b, '-': lambda a,b: a-b, '*': lambda a,b: a*b, '/': lambda a,b: int(a/b)}\n        for token in tokens:\n            if token in ops:\n                b, a = stack.pop(), stack.pop()\n                stack.append(ops[token](a, b))\n            else:\n                stack.append(int(token))\n        return stack[0]",
                    "java": "class Solution { public int evalRPN(String[] tokens) { Stack<Integer> stack = new Stack<>(); for (String t : tokens) { if (t.equals(\"+\")) stack.push(stack.pop() + stack.pop()); else if (t.equals(\"-\")) { int b = stack.pop(), a = stack.pop(); stack.push(a - b); } else if (t.equals(\"*\")) stack.push(stack.pop() * stack.pop()); else if (t.equals(\"/\")) { int b = stack.pop(), a = stack.pop(); stack.push(a / b); } else stack.push(Integer.parseInt(t)); } return stack.pop(); } }",
                    "cpp": "class Solution { public: int evalRPN(vector<string>& tokens) { stack<int> st; for (auto& t : tokens) { if (t == \"+\" || t == \"-\" || t == \"*\" || t == \"/\") { int b = st.top(); st.pop(); int a = st.top(); st.pop(); if (t == \"+\") st.push(a + b); else if (t == \"-\") st.push(a - b); else if (t == \"*\") st.push(a * b); else st.push(a / b); } else st.push(stoi(t)); } return st.top(); } };"
                }
            },
            "optimized": {
                "intuition": "Same approach is optimal.",
                "algorithm": "Stack",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(n)"
                },
                "code": {
                    "python": "class Solution:\n    def evalRPN(self, tokens):\n        stack = []\n        for token in tokens:\n            if token == '+':\n                stack.append(stack.pop() + stack.pop())\n            elif token == '-':\n                b, a = stack.pop(), stack.pop()\n                stack.append(a - b)\n            elif token == '*':\n                stack.append(stack.pop() * stack.pop())\n            elif token == '/':\n                b, a = stack.pop(), stack.pop()\n                stack.append(int(a / b))\n            else:\n                stack.append(int(token))\n        return stack[0]",
                    "java": "class Solution { public int evalRPN(String[] tokens) { Deque<Integer> stack = new ArrayDeque<>(); for (String t : tokens) { switch (t) { case \"+\" -> stack.push(stack.pop() + stack.pop()); case \"-\" -> { int b = stack.pop(); stack.push(stack.pop() - b); } case \"*\" -> stack.push(stack.pop() * stack.pop()); case \"/\" -> { int b = stack.pop(); stack.push(stack.pop() / b); } default -> stack.push(Integer.parseInt(t)); } } return stack.pop(); } }",
                    "cpp": "class Solution { public: int evalRPN(vector<string>& tokens) { stack<long> st; for (auto& t : tokens) { if (t.size() == 1 && !isdigit(t[0])) { long b = st.top(); st.pop(); long a = st.top(); st.pop(); if (t[0] == '+') st.push(a + b); else if (t[0] == '-') st.push(a - b); else if (t[0] == '*') st.push(a * b); else st.push(a / b); } else st.push(stol(t)); } return st.top(); } };"
                }
            }
        }
    },
    "daily-temperatures": {
        "description": `<p>Given an array of integers <code>temperatures</code> representing the daily temperatures, return an array <code>answer</code> such that <code>answer[i]</code> is the number of days you have to wait after the <code>i<sup>th</sup></code> day to get a warmer temperature.</p>
<p>If there is no future day for which this is possible, keep <code>answer[i] == 0</code> instead.</p>
<p>The brute force approach would be to, for each day, scan forward through all remaining days to find the next warmer one. This takes O(n¬≤) time in the worst case (imagine decreasing temperatures).</p>
<p>The optimal solution uses a <strong>monotonic decreasing stack</strong> to track indices of days waiting for warmer temperatures. We iterate through temperatures, and when we find a warmer day, we can resolve all cooler days on the stack by calculating the difference in indices. This reduces the time to O(n) since each index is pushed and popped at most once.</p>
<p>The stack maintains indices in decreasing order of temperature - if current temperature is warmer than stack top, we found the answer for that day.</p>`,
        "examples": [
            {
                "input": "temperatures = [73,74,75,71,69,72,76,73]",
                "output": "[1,1,4,2,1,1,0,0]",
                "explanation": "On day 0 (temp=73), the next warmer day is day 1 (74), so answer[0]=1. On day 2 (75), we wait 4 days for day 6 (76)."
            },
            {
                "input": "temperatures = [30,40,50,60]",
                "output": "[1,1,1,0]",
                "explanation": "Temperatures are strictly increasing, so each day waits 1 day except the last."
            },
            {
                "input": "temperatures = [30,60,90]",
                "output": "[1,1,0]",
                "explanation": "Day 0 waits 1 day, day 1 waits 1 day, day 2 never gets warmer."
            }
        ],
        "constraints": [
            "<code>1 <= temperatures.length <= 10<sup>5</sup></code>",
            "<code>30 <= temperatures[i] <= 100</code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "Check ahead for each.",
                "algorithm": "O(n¬≤) nested loops",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(1)"
                },
                "code": {
                    "python": "class Solution:\n    def dailyTemperatures(self, temperatures):\n        n = len(temperatures)\n        result = [0] * n\n        for i in range(n):\n            for j in range(i + 1, n):\n                if temperatures[j] > temperatures[i]:\n                    result[i] = j - i\n                    break\n        return result",
                    "java": "class Solution { public int[] dailyTemperatures(int[] temperatures) { int n = temperatures.length; int[] result = new int[n]; for (int i = 0; i < n; i++) { for (int j = i + 1; j < n; j++) { if (temperatures[j] > temperatures[i]) { result[i] = j - i; break; } } } return result; } }",
                    "cpp": "class Solution { public: vector<int> dailyTemperatures(vector<int>& temperatures) { int n = temperatures.size(); vector<int> result(n, 0); for (int i = 0; i < n; i++) { for (int j = i + 1; j < n; j++) { if (temperatures[j] > temperatures[i]) { result[i] = j - i; break; } } } return result; } };"
                }
            },
            "optimized": {
                "intuition": "Monotonic stack.",
                "algorithm": "Pop when warmer found",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(n)"
                },
                "code": {
                    "python": "class Solution:\n    def dailyTemperatures(self, temperatures):\n        n = len(temperatures)\n        result = [0] * n\n        stack = []\n        for i in range(n):\n            while stack and temperatures[i] > temperatures[stack[-1]]:\n                idx = stack.pop()\n                result[idx] = i - idx\n            stack.append(i)\n        return result",
                    "java": "class Solution { public int[] dailyTemperatures(int[] temperatures) { int n = temperatures.length; int[] result = new int[n]; Stack<Integer> stack = new Stack<>(); for (int i = 0; i < n; i++) { while (!stack.isEmpty() && temperatures[i] > temperatures[stack.peek()]) { int idx = stack.pop(); result[idx] = i - idx; } stack.push(i); } return result; } }",
                    "cpp": "class Solution { public: vector<int> dailyTemperatures(vector<int>& temperatures) { int n = temperatures.size(); vector<int> result(n, 0); stack<int> st; for (int i = 0; i < n; i++) { while (!st.empty() && temperatures[i] > temperatures[st.top()]) { int idx = st.top(); st.pop(); result[idx] = i - idx; } st.push(i); } return result; } };"
                }
            }
        }
    },
    "binary-search": {
        "description": `<p>Given an array of integers <code>nums</code> which is sorted in ascending order, and an integer <code>target</code>, write a function to search <code>target</code> in <code>nums</code>. If <code>target</code> exists, then return its index. Otherwise, return <code>-1</code>.</p>
<p>You must write an algorithm with <strong>O(log n)</strong> runtime complexity.</p>
<p><strong>Binary search</strong> is a fundamental algorithm that works by repeatedly dividing the search interval in half. We compare the target with the middle element, and based on the comparison, we eliminate half of the remaining elements. This gives us logarithmic time complexity.</p>
<p>The key is maintaining two pointers (<code>left</code> and <code>right</code>) and calculating the middle index. If the middle element equals the target, we return it. If the middle element is less than the target, we search the right half. Otherwise, we search the left half.</p>`,
        "examples": [
            {
                "input": "nums = [-1,0,3,5,9,12], target = 9",
                "output": "4",
                "explanation": "9 exists in nums at index 4. Binary search: mid=2 (nums[2]=3 < 9), search right. mid=4 (nums[4]=9 found!)."
            },
            {
                "input": "nums = [-1,0,3,5,9,12], target = 2",
                "output": "-1",
                "explanation": "2 does not exist in nums so return -1."
            },
            {
                "input": "nums = [5], target = 5",
                "output": "0",
                "explanation": "Single element array, target found at index 0."
            }
        ],
        "constraints": [
            "<code>1 <= nums.length <= 10<sup>4</sup></code>",
            "<code>-10<sup>4</sup> < nums[i], target < 10<sup>4</sup></code>",
            "All the integers in <code>nums</code> are <strong>unique</strong>.",
            "<code>nums</code> is sorted in ascending order."
        ],
        "solutions": {
            "brute": {
                "intuition": "Linear search.",
                "algorithm": "O(n) scan",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)"
                },
                "code": {
                    "python": "class Solution:\n    def search(self, nums, target):\n        for i, num in enumerate(nums):\n            if num == target:\n                return i\n        return -1",
                    "java": "class Solution { public int search(int[] nums, int target) { for (int i = 0; i < nums.length; i++) { if (nums[i] == target) return i; } return -1; } }",
                    "cpp": "class Solution { public: int search(vector<int>& nums, int target) { for (int i = 0; i < nums.size(); i++) { if (nums[i] == target) return i; } return -1; } };"
                }
            },
            "optimized": {
                "intuition": "Binary search.",
                "algorithm": "Divide and conquer",
                "complexity": {
                    "time": "O(log n)",
                    "space": "O(1)"
                },
                "code": {
                    "python": "class Solution:\n    def search(self, nums, target):\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return -1",
                    "java": "class Solution { public int search(int[] nums, int target) { int left = 0, right = nums.length - 1; while (left <= right) { int mid = left + (right - left) / 2; if (nums[mid] == target) return mid; else if (nums[mid] < target) left = mid + 1; else right = mid - 1; } return -1; } }",
                    "cpp": "class Solution { public: int search(vector<int>& nums, int target) { int left = 0, right = nums.size() - 1; while (left <= right) { int mid = left + (right - left) / 2; if (nums[mid] == target) return mid; else if (nums[mid] < target) left = mid + 1; else right = mid - 1; } return -1; } };"
                }
            }
        }
    },
    "find-minimum-in-rotated-sorted-array": {
        "description": `<p>Suppose an array of length <code>n</code> sorted in ascending order is <strong>rotated</strong> between <code>1</code> and <code>n</code> times. For example, the array <code>nums = [0,1,2,4,5,6,7]</code> might become:</p>
<ul>
<li><code>[4,5,6,7,0,1,2]</code> if it was rotated <code>4</code> times.</li>
<li><code>[0,1,2,4,5,6,7]</code> if it was rotated <code>7</code> times (back to original).</li>
</ul>
<p>Notice that rotating an array <code>[a[0], a[1], a[2], ..., a[n-1]]</code> 1 time results in the array <code>[a[n-1], a[0], a[1], a[2], ..., a[n-2]]</code>.</p>
<p>Given the sorted rotated array <code>nums</code> of <strong>unique</strong> elements, return <em>the minimum element of this array</em>.</p>
<p>You must write an algorithm that runs in <strong>O(log n)</strong> time.</p>
<p>The key insight is that the minimum element is at the <strong>rotation point</strong> where the array transitions from larger to smaller values. Using binary search, if <code>nums[mid] > nums[right]</code>, the minimum must be in the right half (rotation point is ahead). Otherwise, it's in the left half or at mid. We narrow down to the rotation point in O(log n) time.</p>`,
        "examples": [
            {
                "input": "nums = [3,4,5,1,2]",
                "output": "1",
                "explanation": "The original array was [1,2,3,4,5] rotated 3 times. The minimum element is 1."
            },
            {
                "input": "nums = [4,5,6,7,0,1,2]",
                "output": "0",
                "explanation": "The original array was [0,1,2,4,5,6,7] rotated 4 times. The minimum is 0."
            },
            {
                "input": "nums = [11,13,15,17]",
                "output": "11",
                "explanation": "The array was not rotated (or rotated n times), so the first element is the minimum."
            }
        ],
        "constraints": [
            "<code>n == nums.length</code>",
            "<code>1 <= n <= 5000</code>",
            "<code>-5000 <= nums[i] <= 5000</code>",
            "All the integers of <code>nums</code> are <strong>unique</strong>.",
            "<code>nums</code> is sorted and rotated between <code>1</code> and <code>n</code> times."
        ],
        "solutions": {
            "brute": {
                "intuition": "Linear search.",
                "algorithm": "Scan for minimum",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)"
                },
                "code": {
                    "python": "class Solution:\n    def findMin(self, nums):\n        return min(nums)",
                    "java": "class Solution { public int findMin(int[] nums) { int min = nums[0]; for (int n : nums) min = Math.min(min, n); return min; } }",
                    "cpp": "class Solution { public: int findMin(vector<int>& nums) { return *min_element(nums.begin(), nums.end()); } };"
                }
            },
            "optimized": {
                "intuition": "Binary search.",
                "algorithm": "Find rotation point",
                "complexity": {
                    "time": "O(log n)",
                    "space": "O(1)"
                },
                "code": {
                    "python": "class Solution:\n    def findMin(self, nums):\n        left, right = 0, len(nums) - 1\n        while left < right:\n            mid = (left + right) // 2\n            if nums[mid] > nums[right]:\n                left = mid + 1\n            else:\n                right = mid\n        return nums[left]",
                    "java": "class Solution { public int findMin(int[] nums) { int left = 0, right = nums.length - 1; while (left < right) { int mid = left + (right - left) / 2; if (nums[mid] > nums[right]) left = mid + 1; else right = mid; } return nums[left]; } }",
                    "cpp": "class Solution { public: int findMin(vector<int>& nums) { int left = 0, right = nums.size() - 1; while (left < right) { int mid = left + (right - left) / 2; if (nums[mid] > nums[right]) left = mid + 1; else right = mid; } return nums[left]; } };"
                }
            }
        }
    },
    "search-in-rotated-sorted-array": {
        "description": `<p>There is an integer array <code>nums</code> sorted in ascending order (with <strong>distinct</strong> values).</p>
<p>Prior to being passed to your function, <code>nums</code> is <strong>possibly rotated</strong> at an unknown pivot index <code>k</code> (<code>1 <= k < nums.length</code>) such that the resulting array is <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code> (<strong>0-indexed</strong>). For example, <code>[0,1,2,4,5,6,7]</code> might be rotated at pivot index <code>3</code> and become <code>[4,5,6,7,0,1,2]</code>.</p>
<p>Given the array <code>nums</code> <strong>after</strong> the possible rotation and an integer <code>target</code>, return <em>the index of </em><code>target</code><em> if it is in </em><code>nums</code><em>, or </em><code>-1</code><em> if it is not in </em><code>nums</code>.</p>
<p>You must write an algorithm with <strong>O(log n)</strong> runtime complexity.</p>
<p>The challenge is that standard binary search doesn't work directly on a rotated array. However, <strong>one half of the array is always sorted</strong>. We determine which half is sorted by comparing <code>nums[left]</code> with <code>nums[mid]</code>. Then check if our target lies in the sorted half's range. If yes, search that half; otherwise, search the other half. This maintains O(log n) complexity.</p>`,
        "examples": [
            {
                "input": "nums = [4,5,6,7,0,1,2], target = 0",
                "output": "4",
                "explanation": "Target 0 is found at index 4."
            },
            {
                "input": "nums = [4,5,6,7,0,1,2], target = 3",
                "output": "-1",
                "explanation": "3 is not in the array."
            },
            {
                "input": "nums = [1], target = 0",
                "output": "-1",
                "explanation": "Single element array doesn't contain the target."
            }
        ],
        "constraints": [
            "<code>1 <= nums.length <= 5000</code>",
            "<code>-10<sup>4</sup> <= nums[i] <= 10<sup>4</sup></code>",
            "All values of <code>nums</code> are <strong>unique</strong>.",
            "<code>nums</code> is an ascending array that is possibly rotated.",
            "<code>-10<sup>4</sup> <= target <= 10<sup>4</sup></code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "Linear search.",
                "algorithm": "O(n) scan",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)"
                },
                "code": {
                    "python": "class Solution:\n    def search(self, nums, target):\n        for i, num in enumerate(nums):\n            if num == target:\n                return i\n        return -1",
                    "java": "class Solution { public int search(int[] nums, int target) { for (int i = 0; i < nums.length; i++) { if (nums[i] == target) return i; } return -1; } }",
                    "cpp": "class Solution { public: int search(vector<int>& nums, int target) { for (int i = 0; i < nums.size(); i++) { if (nums[i] == target) return i; } return -1; } };"
                }
            },
            "optimized": {
                "intuition": "Modified binary search.",
                "algorithm": "Check which half is sorted",
                "complexity": {
                    "time": "O(log n)",
                    "space": "O(1)"
                },
                "code": {
                    "python": "class Solution:\n    def search(self, nums, target):\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return mid\n            if nums[left] <= nums[mid]:\n                if nums[left] <= target < nums[mid]:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            else:\n                if nums[mid] < target <= nums[right]:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n        return -1",
                    "java": "class Solution { public int search(int[] nums, int target) { int left = 0, right = nums.length - 1; while (left <= right) { int mid = left + (right - left) / 2; if (nums[mid] == target) return mid; if (nums[left] <= nums[mid]) { if (nums[left] <= target && target < nums[mid]) right = mid - 1; else left = mid + 1; } else { if (nums[mid] < target && target <= nums[right]) left = mid + 1; else right = mid - 1; } } return -1; } }",
                    "cpp": "class Solution { public: int search(vector<int>& nums, int target) { int left = 0, right = nums.size() - 1; while (left <= right) { int mid = left + (right - left) / 2; if (nums[mid] == target) return mid; if (nums[left] <= nums[mid]) { if (nums[left] <= target && target < nums[mid]) right = mid - 1; else left = mid + 1; } else { if (nums[mid] < target && target <= nums[right]) left = mid + 1; else right = mid - 1; } } return -1; } };"
                }
            }
        }
    },
    "implement-trie-prefix-tree": {
        "description": `<p>A <strong>trie</strong> (pronounced as "try") or <strong>prefix tree</strong> is a tree data structure used to efficiently store and retrieve keys in a dataset of strings. There are various applications of this data structure, such as <strong>autocomplete</strong> and <strong>spellchecker</strong>.</p>
<p>Implement the Trie class:</p>
<ul>
<li><code>Trie()</code> Initializes the trie object.</li>
<li><code>void insert(String word)</code> Inserts the string <code>word</code> into the trie.</li>
<li><code>boolean search(String word)</code> Returns <code>true</code> if the string <code>word</code> is in the trie (i.e., was inserted before), and <code>false</code> otherwise.</li>
<li><code>boolean startsWith(String prefix)</code> Returns <code>true</code> if there is a previously inserted string <code>word</code> that has the prefix <code>prefix</code>, and <code>false</code> otherwise.</li>
</ul>
<p>A trie is a tree where each node represents a character. Each node can have up to 26 children (for lowercase English letters). We mark certain nodes as "end of word" to distinguish complete words from prefixes. For example, if we insert "app" and "apple", the node after "app" is marked as end-of-word, and so is the node after "apple".</p>
<p>Time complexity: Insert and search operations are O(m) where m is the length of the word, regardless of how many words are stored.</p>`,
        "examples": [
            {
                "input": "[\"Trie\", \"insert\", \"search\", \"search\", \"startsWith\", \"insert\", \"search\"]\\n[[], [\"apple\"], [\"apple\"], [\"app\"], [\"app\"], [\"app\"], [\"app\"]]",
                "output": "[null, null, true, false, true, null, true]",
                "explanation": "Trie trie = new Trie();\\ntrie.insert(\"apple\");\\ntrie.search(\"apple\");   // return True\\ntrie.search(\"app\");     // return False\\ntrie.startsWith(\"app\"); // return True\\ntrie.insert(\"app\");\\ntrie.search(\"app\");     // return True"
            },
            {
                "input": "[\"Trie\", \"insert\", \"insert\", \"search\", \"search\", \"startsWith\"]\\n[[], [\"hello\"], [\"world\"], [\"hell\"], [\"hello\"], [\"hel\"]]",
                "output": "[null, null, null, false, true, true]",
                "explanation": "Insert \"hello\" and \"world\". Search for \"hell\" (not inserted, returns false). Search \"hello\" (found). StartsWith \"hel\" (true)."
            }
        ],
        "constraints": [
            "<code>1 <= word.length, prefix.length <= 2000</code>",
            "<code>word</code> and <code>prefix</code> consist only of lowercase English letters.",
            "At most <code>3 * 10<sup>4</sup></code> calls <strong>in total</strong> will be made to <code>insert</code>, <code>search</code>, and <code>startsWith</code>."
        ],
        "solutions": {
            "brute": {
                "intuition": "Use list.",
                "algorithm": "Store words in list",
                "complexity": {
                    "time": "O(n*m)",
                    "space": "O(n*m)"
                },
                "code": {
                    "python": "class Trie:\n    def __init__(self):\n        self.words = []\n    def insert(self, word):\n        self.words.append(word)\n    def search(self, word):\n        return word in self.words\n    def startsWith(self, prefix):\n        return any(w.startswith(prefix) for w in self.words)",
                    "java": "class Trie { List<String> words = new ArrayList<>(); public void insert(String word) { words.add(word); } public boolean search(String word) { return words.contains(word); } public boolean startsWith(String prefix) { for (String w : words) if (w.startsWith(prefix)) return true; return false; } }",
                    "cpp": "class Trie { vector<string> words; public: void insert(string word) { words.push_back(word); } bool search(string word) { return find(words.begin(), words.end(), word) != words.end(); } bool startsWith(string prefix) { for (auto& w : words) if (w.substr(0, prefix.size()) == prefix) return true; return false; } };"
                }
            },
            "optimized": {
                "intuition": "Trie nodes.",
                "algorithm": "Tree structure",
                "complexity": {
                    "time": "O(m)",
                    "space": "O(n*m)"
                },
                "code": {
                    "python": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.isEnd = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n    def insert(self, word):\n        node = self.root\n        for c in word:\n            if c not in node.children:\n                node.children[c] = TrieNode()\n            node = node.children[c]\n        node.isEnd = True\n    def search(self, word):\n        node = self.root\n        for c in word:\n            if c not in node.children:\n                return False\n            node = node.children[c]\n        return node.isEnd\n    def startsWith(self, prefix):\n        node = self.root\n        for c in prefix:\n            if c not in node.children:\n                return False\n            node = node.children[c]\n        return True",
                    "java": "class Trie { class TrieNode { TrieNode[] children = new TrieNode[26]; boolean isEnd = false; } TrieNode root = new TrieNode(); public void insert(String word) { TrieNode node = root; for (char c : word.toCharArray()) { if (node.children[c - 'a'] == null) node.children[c - 'a'] = new TrieNode(); node = node.children[c - 'a']; } node.isEnd = true; } public boolean search(String word) { TrieNode node = root; for (char c : word.toCharArray()) { if (node.children[c - 'a'] == null) return false; node = node.children[c - 'a']; } return node.isEnd; } public boolean startsWith(String prefix) { TrieNode node = root; for (char c : prefix.toCharArray()) { if (node.children[c - 'a'] == null) return false; node = node.children[c - 'a']; } return true; } }",
                    "cpp": "class Trie { struct TrieNode { TrieNode* children[26] = {}; bool isEnd = false; }; TrieNode* root = new TrieNode(); public: void insert(string word) { TrieNode* node = root; for (char c : word) { if (!node->children[c - 'a']) node->children[c - 'a'] = new TrieNode(); node = node->children[c - 'a']; } node->isEnd = true; } bool search(string word) { TrieNode* node = root; for (char c : word) { if (!node->children[c - 'a']) return false; node = node->children[c - 'a']; } return node->isEnd; } bool startsWith(string prefix) { TrieNode* node = root; for (char c : prefix) { if (!node->children[c - 'a']) return false; node = node->children[c - 'a']; } return true; } };"
                }
            }
        }
    },
    "kth-smallest-element-in-a-sorted-matrix": {
        "description": `<p>Given an <code>n x n</code> <code>matrix</code> where each of the rows and columns is sorted in ascending order, return <em>the</em> <code>k<sup>th</sup></code> <em>smallest element in the matrix</em>.</p>
<p>Note that it is the <code>k<sup>th</sup></code> smallest element <strong>in the sorted order</strong>, not the <code>k<sup>th</sup></code> <strong>distinct</strong> element.</p>
<p>You must find a solution with a memory complexity better than <code>O(n<sup>2</sup>)</code>.</p>
<p>The brute force approach is to flatten the entire matrix into an array and sort it, then return the kth element. However, this uses O(n¬≤) space and doesn't leverage the sorted property of rows and columns.</p>
<p>The optimal approach uses <strong>binary search on the value range</strong> rather than indices. We binary search between the minimum (top-left) and maximum (bottom-right) values, counting how many elements are ‚â§ mid. If count < k, increase the lower bound; otherwise, decrease the upper bound. This achieves O(n log(max-min)) time with O(1) space.</p>`,
        "examples": [
            {
                "input": "matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8",
                "output": "13",
                "explanation": "The elements in sorted order are [1,5,9,10,11,12,13,13,15], and the 8th smallest element is 13."
            },
            {
                "input": "matrix = [[-5]], k = 1",
                "output": "-5",
                "explanation": "Single element matrix, return that element."
            }
        ],
        "constraints": [
            "<code>n == matrix.length == matrix[i].length</code>",
            "<code>1 <= n <= 300</code>",
            "<code>-10<sup>9</sup> <= matrix[i][j] <= 10<sup>9</sup></code>",
            "All the rows and columns of <code>matrix</code> are <strong>guaranteed</strong> to be sorted in <strong>non-decreasing order</strong>.",
            "<code>1 <= k <= n<sup>2</sup></code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "Flatten and sort.",
                "algorithm": "O(n¬≤ log n¬≤)",
                "complexity": {
                    "time": "O(n¬≤ log n)",
                    "space": "O(n¬≤)"
                },
                "code": {
                    "python": "class Solution:\n    def kthSmallest(self, matrix, k):\n        return sorted(num for row in matrix for num in row)[k-1]",
                    "java": "class Solution { public int kthSmallest(int[][] matrix, int k) { List<Integer> list = new ArrayList<>(); for (int[] row : matrix) for (int num : row) list.add(num); Collections.sort(list); return list.get(k - 1); } }",
                    "cpp": "class Solution { public: int kthSmallest(vector<vector<int>>& matrix, int k) { vector<int> nums; for (auto& row : matrix) for (int n : row) nums.push_back(n); sort(nums.begin(), nums.end()); return nums[k - 1]; } };"
                }
            },
            "optimized": {
                "intuition": "Binary search on value.",
                "algorithm": "Count elements <= mid",
                "complexity": {
                    "time": "O(n log(max-min))",
                    "space": "O(1)"
                },
                "code": {
                    "python": "class Solution:\n    def kthSmallest(self, matrix, k):\n        n = len(matrix)\n        lo, hi = matrix[0][0], matrix[n-1][n-1]\n        while lo < hi:\n            mid = (lo + hi) // 2\n            count = 0\n            j = n - 1\n            for i in range(n):\n                while j >= 0 and matrix[i][j] > mid:\n                    j -= 1\n                count += j + 1\n            if count < k:\n                lo = mid + 1\n            else:\n                hi = mid\n        return lo",
                    "java": "class Solution { public int kthSmallest(int[][] matrix, int k) { int n = matrix.length; int lo = matrix[0][0], hi = matrix[n-1][n-1]; while (lo < hi) { int mid = lo + (hi - lo) / 2; int count = 0, j = n - 1; for (int i = 0; i < n; i++) { while (j >= 0 && matrix[i][j] > mid) j--; count += j + 1; } if (count < k) lo = mid + 1; else hi = mid; } return lo; } }",
                    "cpp": "class Solution { public: int kthSmallest(vector<vector<int>>& matrix, int k) { int n = matrix.size(); int lo = matrix[0][0], hi = matrix[n-1][n-1]; while (lo < hi) { int mid = lo + (hi - lo) / 2; int count = 0, j = n - 1; for (int i = 0; i < n; i++) { while (j >= 0 && matrix[i][j] > mid) j--; count += j + 1; } if (count < k) lo = mid + 1; else hi = mid; } return lo; } };"
                }
            }
        }
    },
    "merge-k-sorted-lists": {
        "description": `<p>You are given an array of <code>k</code> linked-lists <code>lists</code>, each linked-list is sorted in <strong>ascending order</strong>.</p>
<p><em>Merge all the linked-lists into one sorted linked-list and return it.</em></p>
<p>The challenge is to efficiently merge k sorted lists. Simply merging them two at a time would take O(kN) time where N is the total number of nodes.</p>
<p>The optimal approach uses a <strong>min-heap (priority queue)</strong> of size k. Initially, add the head of each list to the heap. Then repeatedly:</p>
<ul>
<li>Extract the minimum node from the heap</li>
<li>Add it to the result list</li>
<li>If that node has a next node, add it to the heap</li>
</ul>
<p>This ensures we always pick the globally smallest node among the k lists' current positions, achieving O(N log k) time complexity where N is the total number of nodes.</p>`,
        "examples": [
            {
                "input": "lists = [[1,4,5],[1,3,4],[2,6]]",
                "output": "[1,1,2,3,4,4,5,6]",
                "explanation": "The linked-lists are: [1‚Üí4‚Üí5, 1‚Üí3‚Üí4, 2‚Üí6]. Merging them results in 1‚Üí1‚Üí2‚Üí3‚Üí4‚Üí4‚Üí5‚Üí6."
            },
            {
                "input": "lists = []",
                "output": "[]",
                "explanation": "No lists to merge."
            },
            {
                "input": "lists = [[]]",
                "output": "[]",
                "explanation": "Single empty list."
            }
        ],
        "constraints": [
            "<code>k == lists.length</code>",
            "<code>0 <= k <= 10<sup>4</sup></code>",
            "<code>0 <= lists[i].length <= 500</code>",
            "<code>-10<sup>4</sup> <= lists[i][j] <= 10<sup>4</sup></code>",
            "<code>lists[i]</code> is sorted in <strong>ascending order</strong>.",
            "The sum of <code>lists[i].length</code> will not exceed <code>10<sup>4</sup></code>."
        ],
        "solutions": {
            "brute": {
                "intuition": "Collect and sort.",
                "algorithm": "Flatten then sort",
                "complexity": {
                    "time": "O(n log n)",
                    "space": "O(n)"
                },
                "code": {
                    "python": "class Solution:\n    def mergeKLists(self, lists):\n        nodes = []\n        for l in lists:\n            while l:\n                nodes.append(l.val)\n                l = l.next\n        nodes.sort()\n        dummy = ListNode(0)\n        curr = dummy\n        for val in nodes:\n            curr.next = ListNode(val)\n            curr = curr.next\n        return dummy.next",
                    "java": "class Solution { public ListNode mergeKLists(ListNode[] lists) { List<Integer> nodes = new ArrayList<>(); for (ListNode l : lists) { while (l != null) { nodes.add(l.val); l = l.next; } } Collections.sort(nodes); ListNode dummy = new ListNode(0), curr = dummy; for (int val : nodes) { curr.next = new ListNode(val); curr = curr.next; } return dummy.next; } }",
                    "cpp": "class Solution { public: ListNode* mergeKLists(vector<ListNode*>& lists) { vector<int> nodes; for (auto l : lists) { while (l) { nodes.push_back(l->val); l = l->next; } } sort(nodes.begin(), nodes.end()); ListNode* dummy = new ListNode(0), *curr = dummy; for (int val : nodes) { curr->next = new ListNode(val); curr = curr->next; } return dummy->next; } };"
                }
            },
            "optimized": {
                "intuition": "Min heap.",
                "algorithm": "Priority queue",
                "complexity": {
                    "time": "O(n log k)",
                    "space": "O(k)"
                },
                "code": {
                    "python": "class Solution:\n    def mergeKLists(self, lists):\n        import heapq\n        heap = []\n        for i, l in enumerate(lists):\n            if l:\n                heapq.heappush(heap, (l.val, i, l))\n        dummy = ListNode(0)\n        curr = dummy\n        while heap:\n            val, i, node = heapq.heappop(heap)\n            curr.next = node\n            curr = curr.next\n            if node.next:\n                heapq.heappush(heap, (node.next.val, i, node.next))\n        return dummy.next",
                    "java": "class Solution { public ListNode mergeKLists(ListNode[] lists) { PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val); for (ListNode l : lists) if (l != null) pq.offer(l); ListNode dummy = new ListNode(0), curr = dummy; while (!pq.isEmpty()) { ListNode node = pq.poll(); curr.next = node; curr = curr.next; if (node.next != null) pq.offer(node.next); } return dummy.next; } }",
                    "cpp": "class Solution { public: ListNode* mergeKLists(vector<ListNode*>& lists) { auto cmp = [](ListNode* a, ListNode* b) { return a->val > b->val; }; priority_queue<ListNode*, vector<ListNode*>, decltype(cmp)> pq(cmp); for (auto l : lists) if (l) pq.push(l); ListNode* dummy = new ListNode(0), *curr = dummy; while (!pq.empty()) { ListNode* node = pq.top(); pq.pop(); curr->next = node; curr = curr->next; if (node->next) pq.push(node->next); } return dummy->next; } };"
                }
            }
        }
    },
    "linked-list-cycle": {
        "description": `<p>Given <code>head</code>, the head of a linked list, determine if the linked list has a cycle in it.</p>
<p>There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the <code>next</code> pointer. Internally, <code>pos</code> is used to denote the index of the node that tail's <code>next</code> pointer is connected to. <strong>Note that <code>pos</code> is not passed as a parameter</strong>.</p>
<p>Return <code>true</code> <em>if there is a cycle in the linked list</em>. Otherwise, return <code>false</code>.</p>
<p>The classic solution uses <strong>Floyd's Cycle Detection Algorithm</strong> (also known as the "tortoise and hare" algorithm). Use two pointers moving at different speeds:</p>
<ul>
<li><strong>Slow pointer</strong>: Moves one step at a time</li>
<li><strong>Fast pointer</strong>: Moves two steps at a time</li>
</ul>
<p>If there's a cycle, the fast pointer will eventually catch up to the slow pointer (they will meet). If there's no cycle, the fast pointer will reach the end (<code>null</code>). This achieves O(n) time with O(1) space.</p>`,
        "examples": [
            {
                "input": "head = [3,2,0,-4], pos = 1",
                "output": "true",
                "explanation": "There is a cycle where the tail connects back to the 1st node (0-indexed)."
            },
            {
                "input": "head = [1,2], pos = 0",
                "output": "true",
                "explanation": "There is a cycle where the tail connects back to the 0th node."
            },
            {
                "input": "head = [1], pos = -1",
                "output": "false",
                "explanation": "There is no cycle in the linked list."
            }
        ],
        "constraints": [
            "The number of nodes in the list is in the range <code>[0, 10<sup>4</sup>]</code>.",
            "<code>-10<sup>5</sup> <= Node.val <= 10<sup>5</sup></code>",
            "<code>pos</code> is <code>-1</code> or a <strong>valid index</strong> in the linked-list."
        ],
        "solutions": {
            "brute": {
                "intuition": "Use hash set.",
                "algorithm": "Track visited nodes",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(n)"
                },
                "code": {
                    "python": "class Solution:\n    def hasCycle(self, head):\n        visited = set()\n        while head:\n            if head in visited:\n                return True\n            visited.add(head)\n            head = head.next\n        return False",
                    "java": "public class Solution { public boolean hasCycle(ListNode head) { Set<ListNode> visited = new HashSet<>(); while (head != null) { if (visited.contains(head)) return true; visited.add(head); head = head.next; } return false; } }",
                    "cpp": "class Solution { public: bool hasCycle(ListNode *head) { unordered_set<ListNode*> visited; while (head) { if (visited.count(head)) return true; visited.insert(head); head = head->next; } return false; } };"
                }
            },
            "optimized": {
                "intuition": "Floyd's algorithm.",
                "algorithm": "Slow and fast pointers",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)"
                },
                "code": {
                    "python": "class Solution:\n    def hasCycle(self, head):\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n            if slow == fast:\n                return True\n        return False",
                    "java": "public class Solution { public boolean hasCycle(ListNode head) { ListNode slow = head, fast = head; while (fast != null && fast.next != null) { slow = slow.next; fast = fast.next.next; if (slow == fast) return true; } return false; } }",
                    "cpp": "class Solution { public: bool hasCycle(ListNode *head) { ListNode* slow = head, *fast = head; while (fast && fast->next) { slow = slow->next; fast = fast->next->next; if (slow == fast) return true; } return false; } };"
                }
            }
        }
    },
    "linked-list-cycle-ii": {
        "description": `<p>Given the <code>head</code> of a linked list, return <em>the node where the cycle begins</em>. If there is no cycle, return <code>null</code>.</p>
<p>There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the <code>next</code> pointer. Internally, <code>pos</code> is used to denote the index of the node that tail's <code>next</code> pointer is connected to (<strong>0-indexed</strong>). It is <code>-1</code> if there is no cycle. <strong>Note that <code>pos</code> is not passed as a parameter</strong>.</p>
<p><strong>Do not modify</strong> the linked list.</p>
<p>This extends <strong>Floyd's Cycle Detection Algorithm</strong>. First, use slow and fast pointers to detect if there's a cycle (they meet). Then, to find the cycle's start:</p>
<ul>
<li>Reset one pointer to head</li>
<li>Move both pointers one step at a time</li>
<li>They will meet at the cycle's start node</li>
</ul>
<p>Mathematical proof: If cycle length is C and distance to cycle start is D, when they first meet, slow traveled D+a and fast traveled D+a+nC. Since fast is 2x slow's speed: 2(D+a) = D+a+nC, so D = nC-a. Moving D more steps from head and a more from meeting point both reach the cycle start.</p>`,
        "examples": [
            {
                "input": "head = [3,2,0,-4], pos = 1",
                "output": "tail connects to node index 1",
                "explanation": "There is a cycle in the linked list, where the tail connects back to the second node."
            },
            {
                "input": "head = [1,2], pos = 0",
                "output": "tail connects to node index 0",
                "explanation": "There is a cycle in the linked list, where the tail connects back to the first node."
            },
            {
                "input": "head = [1], pos = -1",
                "output": "no cycle",
                "explanation": "There is no cycle in the linked list."
            }
        ],
        "constraints": [
            "The number of the nodes in the list is in the range <code>[0, 10<sup>4</sup>]</code>.",
            "<code>-10<sup>5</sup> <= Node.val <= 10<sup>5</sup></code>",
            "<code>pos</code> is <code>-1</code> or a <strong>valid index</strong> in the linked-list."
        ],
        "solutions": {
            "brute": {
                "intuition": "Use hash set.",
                "algorithm": "Return first repeated",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(n)"
                },
                "code": {
                    "python": "class Solution:\n    def detectCycle(self, head):\n        visited = set()\n        while head:\n            if head in visited:\n                return head\n            visited.add(head)\n            head = head.next\n        return None",
                    "java": "public class Solution { public ListNode detectCycle(ListNode head) { Set<ListNode> visited = new HashSet<>(); while (head != null) { if (visited.contains(head)) return head; visited.add(head); head = head.next; } return null; } }",
                    "cpp": "class Solution { public: ListNode *detectCycle(ListNode *head) { unordered_set<ListNode*> visited; while (head) { if (visited.count(head)) return head; visited.insert(head); head = head->next; } return nullptr; } };"
                }
            },
            "optimized": {
                "intuition": "Floyd's algorithm extended.",
                "algorithm": "Find meeting then find start",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)"
                },
                "code": {
                    "python": "class Solution:\n    def detectCycle(self, head):\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n            if slow == fast:\n                slow2 = head\n                while slow != slow2:\n                    slow = slow.next\n                    slow2 = slow2.next\n                return slow\n        return None",
                    "java": "public class Solution { public ListNode detectCycle(ListNode head) { ListNode slow = head, fast = head; while (fast != null && fast.next != null) { slow = slow.next; fast = fast.next.next; if (slow == fast) { ListNode slow2 = head; while (slow != slow2) { slow = slow.next; slow2 = slow2.next; } return slow; } } return null; } }",
                    "cpp": "class Solution { public: ListNode *detectCycle(ListNode *head) { ListNode* slow = head, *fast = head; while (fast && fast->next) { slow = slow->next; fast = fast->next->next; if (slow == fast) { ListNode* slow2 = head; while (slow != slow2) { slow = slow->next; slow2 = slow2->next; } return slow; } } return nullptr; } };"
                }
            }
        }
    },
    "reverse-linked-list": {
        "description": `<p>Given the <code>head</code> of a singly linked list, reverse the list, and return <em>the reversed list</em>.</p>
<p>A linked list can be reversed by iteratively changing the <code>next</code> pointer of each node to point to the <strong>previous node</strong> instead of the next node. We need three pointers to accomplish this:</p>
<ul>
<li><code>prev</code>: Initially <code>null</code>, becomes the new head after reversal</li>
<li><code>curr</code>: The current node being processed</li>
<li><code>next</code>: Temporary storage for the next node (before we change <code>curr.next</code>)</li>
</ul>
<p>The algorithm processes each node, redirects its <code>next</code> pointer to the previous node, then moves all three pointers forward. This classic technique is fundamental to understanding linked list manipulations and demonstrates in-place reversal with O(1) space.</p>
<p>Alternative recursive approach: Recursively reverse the rest of the list, then make the next node point back to current node.</p>`,
        "examples": [
            {
                "input": "head = [1,2,3,4,5]",
                "output": "[5,4,3,2,1]",
                "explanation": "The list is reversed: 1‚Üí2‚Üí3‚Üí4‚Üí5 becomes 5‚Üí4‚Üí3‚Üí2‚Üí1."
            },
            {
                "input": "head = [1,2]",
                "output": "[2,1]",
                "explanation": "Two node list: 1‚Üí2 becomes 2‚Üí1."
            },
            {
                "input": "head = []",
                "output": "[]",
                "explanation": "Empty list remains empty."
            }
        ],
        "constraints": [
            "The number of nodes in the list is the range <code>[0, 5000]</code>.",
            "<code>-5000 <= Node.val <= 5000</code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "Collect values.",
                "algorithm": "Store and rebuild",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(n)"
                },
                "code": {
                    "python": "class Solution:\n    def reverseList(self, head):\n        vals = []\n        while head:\n            vals.append(head.val)\n            head = head.next\n        dummy = ListNode(0)\n        curr = dummy\n        for v in reversed(vals):\n            curr.next = ListNode(v)\n            curr = curr.next\n        return dummy.next",
                    "java": "class Solution { public ListNode reverseList(ListNode head) { List<Integer> vals = new ArrayList<>(); while (head != null) { vals.add(head.val); head = head.next; } ListNode dummy = new ListNode(0), curr = dummy; for (int i = vals.size() - 1; i >= 0; i--) { curr.next = new ListNode(vals.get(i)); curr = curr.next; } return dummy.next; } }",
                    "cpp": "class Solution { public: ListNode* reverseList(ListNode* head) { vector<int> vals; while (head) { vals.push_back(head->val); head = head->next; } ListNode* dummy = new ListNode(0), *curr = dummy; for (int i = vals.size() - 1; i >= 0; i--) { curr->next = new ListNode(vals[i]); curr = curr->next; } return dummy->next; } };"
                }
            },
            "optimized": {
                "intuition": "Iterative reversal.",
                "algorithm": "In-place pointer swap",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)"
                },
                "code": {
                    "python": "class Solution:\n    def reverseList(self, head):\n        prev = None\n        while head:\n            next_node = head.next\n            head.next = prev\n            prev = head\n            head = next_node\n        return prev",
                    "java": "class Solution { public ListNode reverseList(ListNode head) { ListNode prev = null; while (head != null) { ListNode next = head.next; head.next = prev; prev = head; head = next; } return prev; } }",
                    "cpp": "class Solution { public: ListNode* reverseList(ListNode* head) { ListNode* prev = nullptr; while (head) { ListNode* next = head->next; head->next = prev; prev = head; head = next; } return prev; } };"
                }
            }
        }
    },
    "middle-of-the-linked-list": {
        "description": `<p>Given the <code>head</code> of a singly linked list, return <em>the middle node of the linked list</em>.</p>
<p>If there are two middle nodes, return <strong>the second middle</strong> node.</p>
<p>The brute force approach is to count all nodes first, then traverse to the middle. This requires two passes through the list.</p>
<p>The optimal solution uses the <strong>fast and slow pointer technique</strong> (also called the "tortoise and hare" method). Move two pointers: slow moves one step at a time, fast moves two steps. When fast reaches the end, slow is at the middle. This achieves the result in a single pass with O(1) space.</p>`,
        "examples": [
            {
                "input": "head = [1,2,3,4,5]",
                "output": "[3,4,5]",
                "explanation": "The middle node of the list is node 3. Return the middle node and all nodes after it."
            },
            {
                "input": "head = [1,2,3,4,5,6]",
                "output": "[4,5,6]",
                "explanation": "Since the list has two middle nodes with values 3 and 4, we return the second one (node 4)."
            }
        ],
        "constraints": [
            "The number of nodes in the list is in the range <code>[1, 100]</code>.",
            "<code>1 <= Node.val <= 100</code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "Count and traverse.",
                "algorithm": "Two passes",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)"
                },
                "code": {
                    "python": "class Solution:\n    def middleNode(self, head):\n        count = 0\n        curr = head\n        while curr:\n            count += 1\n            curr = curr.next\n        for _ in range(count // 2):\n            head = head.next\n        return head",
                    "java": "class Solution { public ListNode middleNode(ListNode head) { int count = 0; ListNode curr = head; while (curr != null) { count++; curr = curr.next; } for (int i = 0; i < count / 2; i++) head = head.next; return head; } }",
                    "cpp": "class Solution { public: ListNode* middleNode(ListNode* head) { int count = 0; ListNode* curr = head; while (curr) { count++; curr = curr->next; } for (int i = 0; i < count / 2; i++) head = head->next; return head; } };"
                }
            },
            "optimized": {
                "intuition": "Two pointers.",
                "algorithm": "Fast and slow",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)"
                },
                "code": {
                    "python": "class Solution:\n    def middleNode(self, head):\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        return slow",
                    "java": "class Solution { public ListNode middleNode(ListNode head) { ListNode slow = head, fast = head; while (fast != null && fast.next != null) { slow = slow.next; fast = fast.next.next; } return slow; } }",
                    "cpp": "class Solution { public: ListNode* middleNode(ListNode* head) { ListNode* slow = head, *fast = head; while (fast && fast->next) { slow = slow->next; fast = fast->next->next; } return slow; } };"
                }
            }
        }
    },
    "maximum-subarray": {
        "description": `<p>Given an integer array <code>nums</code>, find the <strong>subarray</strong> with the largest sum, and return <em>its sum</em>.</p>
<p>A <strong>subarray</strong> is a contiguous non-empty sequence of elements within an array.</p>
<p>This is a classic dynamic programming problem that can be solved with <strong>Kadane's Algorithm</strong>.</p>
<p>The key insight: At each position, we decide whether to extend the existing subarray or start a new one. If adding the current element to the existing sum makes it negative, we're better off starting fresh from the current element. We track the maximum sum seen so far as we iterate.</p>
<p>Time: O(n) with single pass, Space: O(1) with no extra space needed.</p>`,
        "examples": [
            {
                "input": "nums = [-2,1,-3,4,-1,2,1,-5,4]",
                "output": "6",
                "explanation": "The subarray [4,-1,2,1] has the largest sum 6."
            },
            {
                "input": "nums = [1]",
                "output": "1",
                "explanation": "The subarray [1] has the largest sum 1."
            },
            {
                "input": "nums = [5,4,-1,7,8]",
                "output": "23",
                "explanation": "The subarray [5,4,-1,7,8] has the largest sum 23."
            }
        ],
        "constraints": [
            "<code>1 <= nums.length <= 10<sup>5</sup></code>",
            "<code>-10<sup>4</sup> <= nums[i] <= 10<sup>4</sup></code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "Check all subarrays.",
                "algorithm": "O(n¬≤) nested loops",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(1)"
                },
                "code": {
                    "python": "class Solution:\n    def maxSubArray(self, nums):\n        maxSum = float('-inf')\n        for i in range(len(nums)):\n            currSum = 0\n            for j in range(i, len(nums)):\n                currSum += nums[j]\n                maxSum = max(maxSum, currSum)\n        return maxSum",
                    "java": "class Solution { public int maxSubArray(int[] nums) { int maxSum = Integer.MIN_VALUE; for (int i = 0; i < nums.length; i++) { int currSum = 0; for (int j = i; j < nums.length; j++) { currSum += nums[j]; maxSum = Math.max(maxSum, currSum); } } return maxSum; } }",
                    "cpp": "class Solution { public: int maxSubArray(vector<int>& nums) { int maxSum = INT_MIN; for (int i = 0; i < nums.size(); i++) { int currSum = 0; for (int j = i; j < nums.size(); j++) { currSum += nums[j]; maxSum = max(maxSum, currSum); } } return maxSum; } };"
                }
            },
            "optimized": {
                "intuition": "Kadane's algorithm.",
                "algorithm": "One pass O(n)",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)"
                },
                "code": {
                    "python": "class Solution:\n    def maxSubArray(self, nums):\n        maxSum = currSum = nums[0]\n        for num in nums[1:]:\n            currSum = max(num, currSum + num)\n            maxSum = max(maxSum, currSum)\n        return maxSum",
                    "java": "class Solution { public int maxSubArray(int[] nums) { int maxSum = nums[0], currSum = nums[0]; for (int i = 1; i < nums.length; i++) { currSum = Math.max(nums[i], currSum + nums[i]); maxSum = Math.max(maxSum, currSum); } return maxSum; } }",
                    "cpp": "class Solution { public: int maxSubArray(vector<int>& nums) { int maxSum = nums[0], currSum = nums[0]; for (int i = 1; i < nums.size(); i++) { currSum = max(nums[i], currSum + nums[i]); maxSum = max(maxSum, currSum); } return maxSum; } };"
                }
            }
        }
    },
    "maximum-sum-circular-subarray": {
        "description": `<p>Given a <strong>circular integer array</strong> <code>nums</code> of length <code>n</code>, return <em>the maximum possible sum of a non-empty <strong>subarray</strong> of</em> <code>nums</code>.</p>
<p>A <strong>circular array</strong> means the end of the array connects to the beginning of the array. Formally, the next element of <code>nums[i]</code> is <code>nums[(i + 1) % n]</code> and the previous element of <code>nums[i]</code> is <code>nums[(i - 1 + n) % n]</code>.</p>
<p>A <strong>subarray</strong> may only include each element of the fixed buffer <code>nums</code> at most once. Formally, for a subarray <code>nums[i], nums[i + 1], ..., nums[j]</code>, there does not exist <code>i <= k1</code>, <code>k2 <= j</code> with <code>k1 % n == k2 % n</code>.</p>
<p>The solution uses two key observations:</p>
<ul>
<li><strong>Case 1</strong>: Maximum subarray doesn't wrap around - use standard Kadane's algorithm</li>
<li><strong>Case 2</strong>: Maximum subarray wraps around - this equals <code>total_sum - min_subarray_sum</code> (excluding the minimum subarray in the middle)</li>
</ul>
<p>Return the maximum of both cases. Handle edge case: if all numbers are negative, Case 2 would select empty array, so return Case 1.</p>`,
        "examples": [
            {
                "input": "nums = [1,-2,3,-2]",
                "output": "3",
                "explanation": "Subarray [3] has maximum sum 3."
            },
            {
                "input": "nums = [5,-3,5]",
                "output": "10",
                "explanation": "Subarray [5,5] (wrapping around) has maximum sum 5 + 5 = 10."
            },
            {
                "input": "nums = [-3,-2,-3]",
                "output": "-2",
                "explanation": "Subarray [-2] has maximum sum -2."
            }
        ],
        "constraints": [
            "<code>n == nums.length</code>",
            "<code>1 <= n <= 3 * 10<sup>4</sup></code>",
            "<code>-3 * 10<sup>4</sup> <= nums[i] <= 3 * 10<sup>4</sup></code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "Check all circular subarrays.",
                "algorithm": "O(n¬≤)",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(1)"
                },
                "code": {
                    "python": "class Solution:\n    def maxSubarraySumCircular(self, nums):\n        n = len(nums)\n        maxSum = float('-inf')\n        for i in range(n):\n            currSum = 0\n            for j in range(n):\n                currSum += nums[(i + j) % n]\n                maxSum = max(maxSum, currSum)\n        return maxSum",
                    "java": "class Solution { public int maxSubarraySumCircular(int[] nums) { int n = nums.length, maxSum = Integer.MIN_VALUE; for (int i = 0; i < n; i++) { int currSum = 0; for (int j = 0; j < n; j++) { currSum += nums[(i + j) % n]; maxSum = Math.max(maxSum, currSum); } } return maxSum; } }",
                    "cpp": "class Solution { public: int maxSubarraySumCircular(vector<int>& nums) { int n = nums.size(), maxSum = INT_MIN; for (int i = 0; i < n; i++) { int currSum = 0; for (int j = 0; j < n; j++) { currSum += nums[(i + j) % n]; maxSum = max(maxSum, currSum); } } return maxSum; } };"
                }
            },
            "optimized": {
                "intuition": "Kadane's for max and min.",
                "algorithm": "Total - min or regular max",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)"
                },
                "code": {
                    "python": "class Solution:\n    def maxSubarraySumCircular(self, nums):\n        total = 0\n        maxSum = currMax = float('-inf')\n        minSum = currMin = float('inf')\n        for num in nums:\n            total += num\n            currMax = max(num, currMax + num)\n            maxSum = max(maxSum, currMax)\n            currMin = min(num, currMin + num)\n            minSum = min(minSum, currMin)\n        return maxSum if maxSum < 0 else max(maxSum, total - minSum)",
                    "java": "class Solution { public int maxSubarraySumCircular(int[] nums) { int total = 0, maxSum = Integer.MIN_VALUE, currMax = 0; int minSum = Integer.MAX_VALUE, currMin = 0; for (int num : nums) { total += num; currMax = Math.max(num, currMax + num); maxSum = Math.max(maxSum, currMax); currMin = Math.min(num, currMin + num); minSum = Math.min(minSum, currMin); } return maxSum < 0 ? maxSum : Math.max(maxSum, total - minSum); } }",
                    "cpp": "class Solution { public: int maxSubarraySumCircular(vector<int>& nums) { int total = 0, maxSum = INT_MIN, currMax = 0; int minSum = INT_MAX, currMin = 0; for (int num : nums) { total += num; currMax = max(num, currMax + num); maxSum = max(maxSum, currMax); currMin = min(num, currMin + num); minSum = min(minSum, currMin); } return maxSum < 0 ? maxSum : max(maxSum, total - minSum); } };"
                }
            }
        }
    },
    "spiral-matrix": {
        "description": "Return elements in spiral order.",
        "examples": [
            {
                "input": "matrix = [[1,2,3],[4,5,6],[7,8,9]]",
                "output": "[1,2,3,6,9,8,7,4,5]"
            }
        ],
        "constraints": [
            "m == matrix.length",
            "n == matrix[i].length"
        ],
        "solutions": {
            "brute": {
                "intuition": "Simulate spiral.",
                "algorithm": "Track boundaries",
                "complexity": {
                    "time": "O(m*n)",
                    "space": "O(1)"
                },
                "code": {
                    "python": "class Solution:\n    def spiralOrder(self, matrix):\n        result = []\n        top, bottom = 0, len(matrix) - 1\n        left, right = 0, len(matrix[0]) - 1\n        while top <= bottom and left <= right:\n            for j in range(left, right + 1):\n                result.append(matrix[top][j])\n            top += 1\n            for i in range(top, bottom + 1):\n                result.append(matrix[i][right])\n            right -= 1\n            if top <= bottom:\n                for j in range(right, left - 1, -1):\n                    result.append(matrix[bottom][j])\n                bottom -= 1\n            if left <= right:\n                for i in range(bottom, top - 1, -1):\n                    result.append(matrix[i][left])\n                left += 1\n        return result",
                    "java": "class Solution { public List<Integer> spiralOrder(int[][] matrix) { List<Integer> result = new ArrayList<>(); int top = 0, bottom = matrix.length - 1; int left = 0, right = matrix[0].length - 1; while (top <= bottom && left <= right) { for (int j = left; j <= right; j++) result.add(matrix[top][j]); top++; for (int i = top; i <= bottom; i++) result.add(matrix[i][right]); right--; if (top <= bottom) { for (int j = right; j >= left; j--) result.add(matrix[bottom][j]); bottom--; } if (left <= right) { for (int i = bottom; i >= top; i--) result.add(matrix[i][left]); left++; } } return result; } }",
                    "cpp": "class Solution { public: vector<int> spiralOrder(vector<vector<int>>& matrix) { vector<int> result; int top = 0, bottom = matrix.size() - 1; int left = 0, right = matrix[0].size() - 1; while (top <= bottom && left <= right) { for (int j = left; j <= right; j++) result.push_back(matrix[top][j]); top++; for (int i = top; i <= bottom; i++) result.push_back(matrix[i][right]); right--; if (top <= bottom) { for (int j = right; j >= left; j--) result.push_back(matrix[bottom][j]); bottom--; } if (left <= right) { for (int i = bottom; i >= top; i--) result.push_back(matrix[i][left]); left++; } } return result; } };"
                }
            },
            "optimized": {
                "intuition": "Same approach is optimal.",
                "algorithm": "Boundary tracking",
                "complexity": {
                    "time": "O(m*n)",
                    "space": "O(1)"
                },
                "code": {
                    "python": "class Solution:\n    def spiralOrder(self, matrix):\n        result = []\n        while matrix:\n            result += matrix.pop(0)\n            if matrix and matrix[0]:\n                for row in matrix:\n                    result.append(row.pop())\n            if matrix:\n                result += matrix.pop()[::-1]\n            if matrix and matrix[0]:\n                for row in matrix[::-1]:\n                    result.append(row.pop(0))\n        return result",
                    "java": "class Solution { public List<Integer> spiralOrder(int[][] matrix) { List<Integer> result = new ArrayList<>(); if (matrix.length == 0) return result; int m = matrix.length, n = matrix[0].length; int[] dr = {0, 1, 0, -1}; int[] dc = {1, 0, -1, 0}; boolean[][] seen = new boolean[m][n]; int r = 0, c = 0, di = 0; for (int i = 0; i < m * n; i++) { result.add(matrix[r][c]); seen[r][c] = true; int nr = r + dr[di], nc = c + dc[di]; if (nr >= 0 && nr < m && nc >= 0 && nc < n && !seen[nr][nc]) { r = nr; c = nc; } else { di = (di + 1) % 4; r += dr[di]; c += dc[di]; } } return result; } }",
                    "cpp": "class Solution { public: vector<int> spiralOrder(vector<vector<int>>& matrix) { vector<int> result; if (matrix.empty()) return result; int m = matrix.size(), n = matrix[0].size(); int dr[] = {0, 1, 0, -1}; int dc[] = {1, 0, -1, 0}; vector<vector<bool>> seen(m, vector<bool>(n, false)); int r = 0, c = 0, di = 0; for (int i = 0; i < m * n; i++) { result.push_back(matrix[r][c]); seen[r][c] = true; int nr = r + dr[di], nc = c + dc[di]; if (nr >= 0 && nr < m && nc >= 0 && nc < n && !seen[nr][nc]) { r = nr; c = nc; } else { di = (di + 1) % 4; r += dr[di]; c += dc[di]; } } return result; } };"
                }
            }
        }
    },
    "rotate-image": {
        "description": "Rotate matrix 90 degrees clockwise.",
        "examples": [
            {
                "input": "matrix = [[1,2,3],[4,5,6],[7,8,9]]",
                "output": "[[7,4,1],[8,5,2],[9,6,3]]"
            }
        ],
        "constraints": [
            "n == matrix.length == matrix[i].length"
        ],
        "solutions": {
            "brute": {
                "intuition": "Use extra matrix.",
                "algorithm": "Copy to new positions",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n¬≤)"
                },
                "code": {
                    "python": "class Solution:\n    def rotate(self, matrix):\n        n = len(matrix)\n        copy = [row[:] for row in matrix]\n        for i in range(n):\n            for j in range(n):\n                matrix[j][n-1-i] = copy[i][j]",
                    "java": "class Solution { public void rotate(int[][] matrix) { int n = matrix.length; int[][] copy = new int[n][n]; for (int i = 0; i < n; i++) copy[i] = matrix[i].clone(); for (int i = 0; i < n; i++) for (int j = 0; j < n; j++) matrix[j][n-1-i] = copy[i][j]; } }",
                    "cpp": "class Solution { public: void rotate(vector<vector<int>>& matrix) { int n = matrix.size(); vector<vector<int>> copy = matrix; for (int i = 0; i < n; i++) for (int j = 0; j < n; j++) matrix[j][n-1-i] = copy[i][j]; } };"
                }
            },
            "optimized": {
                "intuition": "Transpose then reverse.",
                "algorithm": "In-place rotation",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(1)"
                },
                "code": {
                    "python": "class Solution:\n    def rotate(self, matrix):\n        n = len(matrix)\n        for i in range(n):\n            for j in range(i + 1, n):\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n        for row in matrix:\n            row.reverse()",
                    "java": "class Solution { public void rotate(int[][] matrix) { int n = matrix.length; for (int i = 0; i < n; i++) for (int j = i + 1; j < n; j++) { int temp = matrix[i][j]; matrix[i][j] = matrix[j][i]; matrix[j][i] = temp; } for (int[] row : matrix) { int l = 0, r = n - 1; while (l < r) { int temp = row[l]; row[l++] = row[r]; row[r--] = temp; } } } }",
                    "cpp": "class Solution { public: void rotate(vector<vector<int>>& matrix) { int n = matrix.size(); for (int i = 0; i < n; i++) for (int j = i + 1; j < n; j++) swap(matrix[i][j], matrix[j][i]); for (auto& row : matrix) reverse(row.begin(), row.end()); } };"
                }
            }
        }
    },
    "contains-duplicate": {
        "description": `<p>Given an integer array <code>nums</code>, return <code>true</code> if any value appears <strong>at least twice</strong> in the array, and return <code>false</code> if every element is distinct.</p>
<p>This is a fundamental array problem that tests your understanding of data structures for efficient lookups. The challenge is to determine if there are any duplicate values in the array.</p>
<p><strong>Key Considerations:</strong></p>
<ul>
<li>The array can contain positive, negative, or zero values</li>
<li>You need to check if ANY value appears more than once</li>
<li>The order of elements doesn't matter</li>
<li>An empty array or single-element array has no duplicates</li>
</ul>
<p>Think about the most efficient data structure to track which numbers you've already seen as you iterate through the array.</p>`,
        "examples": [
            {
                "input": "nums = [1,2,3,1]",
                "output": "true",
                "explanation": "The value 1 appears twice in the array (at index 0 and index 3). Since we found a duplicate, we return true."
            },
            {
                "input": "nums = [1,2,3,4]",
                "output": "false",
                "explanation": "All elements in the array are distinct - no value appears more than once. Therefore, we return false."
            },
            {
                "input": "nums = [1,1,1,3,3,4,3,2,4,2]",
                "output": "true",
                "explanation": "Multiple values appear more than once (1 appears 3 times, 3 appears 3 times, 4 appears 2 times, 2 appears 2 times). We can return true as soon as we find the first duplicate."
            }
        ],
        "constraints": [
            "1 <= nums.length <= 10^5",
            "-10^9 <= nums[i] <= 10^9"
        ],
        "solutions": {
            "brute": {
                "intuition": "The simplest approach is to compare each element with every other element that comes after it. For each number in the array, we check if it matches any number in the remaining portion of the array. While this is straightforward to implement, it requires checking many pairs unnecessarily.",
                "algorithm": "1. Start with the first element at index i = 0\n2. Compare it with all elements from index i+1 to the end\n3. If any match is found, return true immediately\n4. Move to the next element (i+1) and repeat step 2\n5. If we complete all comparisons without finding a match, return false\n6. This checks every possible pair exactly once",
                "complexity": {
                    "time": "O(n¬≤) - For each of n elements, we potentially check up to n-1 other elements, resulting in n*(n-1)/2 comparisons in the worst case",
                    "space": "O(1) - We only use a constant amount of extra space for loop counters, no additional data structures needed"
                },
                "code": {
                    "python": "class Solution:\n    def containsDuplicate(self, nums: List[int]) -> bool:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[i] == nums[j]:\n                    return True\n        return False",
                    "java": "class Solution {\n    public boolean containsDuplicate(int[] nums) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[i] == nums[j]) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    bool containsDuplicate(vector<int>& nums) {\n        for (int i = 0; i < nums.size(); i++) {\n            for (int j = i + 1; j < nums.size(); j++) {\n                if (nums[i] == nums[j]) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n};",
                    "javascript": "var containsDuplicate = function(nums) {\n    for (let i = 0; i < nums.length; i++) {\n        for (let j = i + 1; j < nums.length; j++) {\n            if (nums[i] === nums[j]) {\n                return true;\n            }\n        }\n    }\n    return false;\n};"
                }
            },
            "optimized": {
                "intuition": "Instead of comparing each element with all others, we can use a HashSet to track numbers we've seen. As we iterate through the array once, for each number we check if it's already in our set. If it is, we found a duplicate. If not, we add it to the set. This reduces our lookup time from O(n) to O(1).",
                "algorithm": "1. Create an empty HashSet to store unique numbers\n2. Iterate through each number in the array\n3. For each number:\n   - Check if it already exists in the set (O(1) lookup)\n   - If yes, return true immediately (found duplicate)\n   - If no, add it to the set\n4. If we finish the loop without finding duplicates, return false\n5. This guarantees each number is checked at most once",
                "complexity": {
                    "time": "O(n) - We traverse the array exactly once, and HashSet operations (add, contains) are O(1) on average",
                    "space": "O(n) - In the worst case (no duplicates), we store all n elements in the HashSet"
                },
                "code": {
                    "python": "class Solution:\n    def containsDuplicate(self, nums: List[int]) -> bool:\n        seen = set()\n        for num in nums:\n            if num in seen:\n                return True\n            seen.add(num)\n        return False\n        # Or even simpler:\n        # return len(nums) != len(set(nums))",
                    "java": "class Solution {\n    public boolean containsDuplicate(int[] nums) {\n        Set<Integer> seen = new HashSet<>();\n        for (int num : nums) {\n            if (seen.contains(num)) {\n                return true;\n            }\n            seen.add(num);\n        }\n        return false;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    bool containsDuplicate(vector<int>& nums) {\n        unordered_set<int> seen;\n        for (int num : nums) {\n            if (seen.count(num) > 0) {\n                return true;\n            }\n            seen.insert(num);\n        }\n        return false;\n    }\n};",
                    "javascript": "var containsDuplicate = function(nums) {\n    const seen = new Set();\n    for (const num of nums) {\n        if (seen.has(num)) {\n            return true;\n        }\n        seen.add(num);\n    }\n    return false;\n};"
                }
            }
        }
    },
    "move-zeroes": {
        "description": "Move zeroes to end.",
        "examples": [
            {
                "input": "nums = [0,1,0,3,12]",
                "output": "[1,3,12,0,0]"
            }
        ],
        "constraints": [
            "1 <= nums.length <= 10^4"
        ],
        "solutions": {
            "brute": {
                "intuition": "Count and rebuild.",
                "algorithm": "Separate non-zeros",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(n)"
                },
                "code": {
                    "python": "class Solution:\n    def moveZeroes(self, nums):\n        nonZeros = [x for x in nums if x != 0]\n        for i in range(len(nonZeros)):\n            nums[i] = nonZeros[i]\n        for i in range(len(nonZeros), len(nums)):\n            nums[i] = 0",
                    "java": "class Solution { public void moveZeroes(int[] nums) { List<Integer> nonZeros = new ArrayList<>(); for (int n : nums) if (n != 0) nonZeros.add(n); for (int i = 0; i < nonZeros.size(); i++) nums[i] = nonZeros.get(i); for (int i = nonZeros.size(); i < nums.length; i++) nums[i] = 0; } }",
                    "cpp": "class Solution { public: void moveZeroes(vector<int>& nums) { vector<int> nonZeros; for (int n : nums) if (n != 0) nonZeros.push_back(n); for (int i = 0; i < nonZeros.size(); i++) nums[i] = nonZeros[i]; for (int i = nonZeros.size(); i < nums.size(); i++) nums[i] = 0; } };"
                }
            },
            "optimized": {
                "intuition": "Two pointers.",
                "algorithm": "In-place swap",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)"
                },
                "code": {
                    "python": "class Solution:\n    def moveZeroes(self, nums):\n        slow = 0\n        for fast in range(len(nums)):\n            if nums[fast] != 0:\n                nums[slow], nums[fast] = nums[fast], nums[slow]\n                slow += 1",
                    "java": "class Solution { public void moveZeroes(int[] nums) { int slow = 0; for (int fast = 0; fast < nums.length; fast++) { if (nums[fast] != 0) { int temp = nums[slow]; nums[slow] = nums[fast]; nums[fast] = temp; slow++; } } } }",
                    "cpp": "class Solution { public: void moveZeroes(vector<int>& nums) { int slow = 0; for (int fast = 0; fast < nums.size(); fast++) { if (nums[fast] != 0) swap(nums[slow++], nums[fast]); } } };"
                }
            }
        }
    },
    "squares-of-a-sorted-array": {
        "description": "Return squares in sorted order.",
        "examples": [
            {
                "input": "nums = [-4,-1,0,3,10]",
                "output": "[0,1,9,16,100]"
            }
        ],
        "constraints": [
            "1 <= nums.length <= 10^4"
        ],
        "solutions": {
            "brute": {
                "intuition": "Square and sort.",
                "algorithm": "O(n log n)",
                "complexity": {
                    "time": "O(n log n)",
                    "space": "O(n)"
                },
                "code": {
                    "python": "class Solution:\n    def sortedSquares(self, nums):\n        return sorted(x * x for x in nums)",
                    "java": "class Solution { public int[] sortedSquares(int[] nums) { int[] result = new int[nums.length]; for (int i = 0; i < nums.length; i++) result[i] = nums[i] * nums[i]; Arrays.sort(result); return result; } }",
                    "cpp": "class Solution { public: vector<int> sortedSquares(vector<int>& nums) { vector<int> result; for (int n : nums) result.push_back(n * n); sort(result.begin(), result.end()); return result; } };"
                }
            },
            "optimized": {
                "intuition": "Two pointers.",
                "algorithm": "Merge from ends",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(n)"
                },
                "code": {
                    "python": "class Solution:\n    def sortedSquares(self, nums):\n        n = len(nums)\n        result = [0] * n\n        left, right = 0, n - 1\n        for i in range(n - 1, -1, -1):\n            if abs(nums[left]) > abs(nums[right]):\n                result[i] = nums[left] ** 2\n                left += 1\n            else:\n                result[i] = nums[right] ** 2\n                right -= 1\n        return result",
                    "java": "class Solution { public int[] sortedSquares(int[] nums) { int n = nums.length; int[] result = new int[n]; int left = 0, right = n - 1; for (int i = n - 1; i >= 0; i--) { if (Math.abs(nums[left]) > Math.abs(nums[right])) { result[i] = nums[left] * nums[left]; left++; } else { result[i] = nums[right] * nums[right]; right--; } } return result; } }",
                    "cpp": "class Solution { public: vector<int> sortedSquares(vector<int>& nums) { int n = nums.size(); vector<int> result(n); int left = 0, right = n - 1; for (int i = n - 1; i >= 0; i--) { if (abs(nums[left]) > abs(nums[right])) { result[i] = nums[left] * nums[left]; left++; } else { result[i] = nums[right] * nums[right]; right--; } } return result; } };"
                }
            }
        }
    },
    "intersection-of-two-arrays-ii": {
        "description": "Return intersection with duplicates.",
        "examples": [
            {
                "input": "nums1 = [1,2,2,1], nums2 = [2,2]",
                "output": "[2,2]"
            }
        ],
        "constraints": [
            "1 <= nums1.length, nums2.length <= 1000"
        ],
        "solutions": {
            "brute": {
                "intuition": "Sort and compare.",
                "algorithm": "Two pointer merge",
                "complexity": {
                    "time": "O(n log n)",
                    "space": "O(1)"
                },
                "code": {
                    "python": "class Solution:\n    def intersect(self, nums1, nums2):\n        nums1.sort()\n        nums2.sort()\n        result = []\n        i = j = 0\n        while i < len(nums1) and j < len(nums2):\n            if nums1[i] < nums2[j]:\n                i += 1\n            elif nums1[i] > nums2[j]:\n                j += 1\n            else:\n                result.append(nums1[i])\n                i += 1\n                j += 1\n        return result",
                    "java": "class Solution { public int[] intersect(int[] nums1, int[] nums2) { Arrays.sort(nums1); Arrays.sort(nums2); List<Integer> result = new ArrayList<>(); int i = 0, j = 0; while (i < nums1.length && j < nums2.length) { if (nums1[i] < nums2[j]) i++; else if (nums1[i] > nums2[j]) j++; else { result.add(nums1[i]); i++; j++; } } return result.stream().mapToInt(x -> x).toArray(); } }",
                    "cpp": "class Solution { public: vector<int> intersect(vector<int>& nums1, vector<int>& nums2) { sort(nums1.begin(), nums1.end()); sort(nums2.begin(), nums2.end()); vector<int> result; int i = 0, j = 0; while (i < nums1.size() && j < nums2.size()) { if (nums1[i] < nums2[j]) i++; else if (nums1[i] > nums2[j]) j++; else { result.push_back(nums1[i]); i++; j++; } } return result; } };"
                }
            },
            "optimized": {
                "intuition": "Use hash map.",
                "algorithm": "Count and match",
                "complexity": {
                    "time": "O(n+m)",
                    "space": "O(min(n,m))"
                },
                "code": {
                    "python": "class Solution:\n    def intersect(self, nums1, nums2):\n        from collections import Counter\n        count = Counter(nums1)\n        result = []\n        for num in nums2:\n            if count[num] > 0:\n                result.append(num)\n                count[num] -= 1\n        return result",
                    "java": "class Solution { public int[] intersect(int[] nums1, int[] nums2) { Map<Integer, Integer> count = new HashMap<>(); for (int n : nums1) count.put(n, count.getOrDefault(n, 0) + 1); List<Integer> result = new ArrayList<>(); for (int n : nums2) { if (count.getOrDefault(n, 0) > 0) { result.add(n); count.put(n, count.get(n) - 1); } } return result.stream().mapToInt(x -> x).toArray(); } }",
                    "cpp": "class Solution { public: vector<int> intersect(vector<int>& nums1, vector<int>& nums2) { unordered_map<int, int> count; for (int n : nums1) count[n]++; vector<int> result; for (int n : nums2) { if (count[n] > 0) { result.push_back(n); count[n]--; } } return result; } };"
                }
            }
        }
    },
    "3sum-closest": {
        "description": "Find three sum closest to target.",
        "examples": [
            {
                "input": "nums = [-1,2,1,-4], target = 1",
                "output": "2"
            }
        ],
        "constraints": [
            "3 <= nums.length <= 500"
        ],
        "solutions": {
            "brute": {
                "intuition": "Check all triplets.",
                "algorithm": "O(n¬≥)",
                "complexity": {
                    "time": "O(n¬≥)",
                    "space": "O(1)"
                },
                "code": {
                    "python": "class Solution:\n    def threeSumClosest(self, nums, target):\n        closest = float('inf')\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                for k in range(j + 1, len(nums)):\n                    total = nums[i] + nums[j] + nums[k]\n                    if abs(total - target) < abs(closest - target):\n                        closest = total\n        return closest",
                    "java": "class Solution { public int threeSumClosest(int[] nums, int target) { int closest = Integer.MAX_VALUE / 2; for (int i = 0; i < nums.length; i++) for (int j = i + 1; j < nums.length; j++) for (int k = j + 1; k < nums.length; k++) { int sum = nums[i] + nums[j] + nums[k]; if (Math.abs(sum - target) < Math.abs(closest - target)) closest = sum; } return closest; } }",
                    "cpp": "class Solution { public: int threeSumClosest(vector<int>& nums, int target) { int closest = INT_MAX / 2; for (int i = 0; i < nums.size(); i++) for (int j = i + 1; j < nums.size(); j++) for (int k = j + 1; k < nums.size(); k++) { int sum = nums[i] + nums[j] + nums[k]; if (abs(sum - target) < abs(closest - target)) closest = sum; } return closest; } };"
                }
            },
            "optimized": {
                "intuition": "Sort and two pointers.",
                "algorithm": "O(n¬≤)",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(1)"
                },
                "code": {
                    "python": "class Solution:\n    def threeSumClosest(self, nums, target):\n        nums.sort()\n        closest = float('inf')\n        for i in range(len(nums) - 2):\n            left, right = i + 1, len(nums) - 1\n            while left < right:\n                total = nums[i] + nums[left] + nums[right]\n                if abs(total - target) < abs(closest - target):\n                    closest = total\n                if total < target:\n                    left += 1\n                elif total > target:\n                    right -= 1\n                else:\n                    return total\n        return closest",
                    "java": "class Solution { public int threeSumClosest(int[] nums, int target) { Arrays.sort(nums); int closest = Integer.MAX_VALUE / 2; for (int i = 0; i < nums.length - 2; i++) { int left = i + 1, right = nums.length - 1; while (left < right) { int sum = nums[i] + nums[left] + nums[right]; if (Math.abs(sum - target) < Math.abs(closest - target)) closest = sum; if (sum < target) left++; else if (sum > target) right--; else return sum; } } return closest; } }",
                    "cpp": "class Solution { public: int threeSumClosest(vector<int>& nums, int target) { sort(nums.begin(), nums.end()); int closest = INT_MAX / 2; for (int i = 0; i < nums.size() - 2; i++) { int left = i + 1, right = nums.size() - 1; while (left < right) { int sum = nums[i] + nums[left] + nums[right]; if (abs(sum - target) < abs(closest - target)) closest = sum; if (sum < target) left++; else if (sum > target) right--; else return sum; } } return closest; } };"
                }
            }
        }
    },
    "next-permutation": {
        "description": `<p>A <strong>permutation</strong> of an array of integers is an arrangement of its members into a sequence or linear order.</p>
<p>The <strong>next permutation</strong> of an array of integers is the next lexicographically greater permutation of its integer. More formally, if all the permutations of the array are sorted in one container according to their lexicographical order, then the <strong>next permutation</strong> of that array is the permutation that follows it in the sorted container. If such arrangement is not possible, the array must be rearranged as the lowest possible order (i.e., sorted in ascending order).</p>
<p>You must solve the problem <strong>in-place</strong> with O(1) extra space.</p>
<p>Algorithm steps:</p>
<ol>
<li>Find the rightmost pair where <code>nums[i] < nums[i+1]</code> (pivot)</li>
<li>If no such pair exists, reverse entire array</li>
<li>Find the smallest element to the right of pivot that's larger than pivot</li>
<li>Swap pivot with that element</li>
<li>Reverse the suffix starting after the original pivot position</li>
</ol>`,
        "examples": [
            {
                "input": "nums = [1,2,3]",
                "output": "[1,3,2]",
                "explanation": "The next permutation of [1,2,3] is [1,3,2]."
            },
            {
                "input": "nums = [3,2,1]",
                "output": "[1,2,3]",
                "explanation": "[3,2,1] is the last permutation, so we wrap to [1,2,3]."
            },
            {
                "input": "nums = [1,1,5]",
                "output": "[1,5,1]",
                "explanation": "The next permutation of [1,1,5] is [1,5,1]."
            }
        ],
        "constraints": [
            "<code>1 <= nums.length <= 100</code>",
            "<code>0 <= nums[i] <= 100</code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "Generate all permutations.",
                "algorithm": "Find next in sorted list",
                "complexity": {
                    "time": "O(n!)",
                    "space": "O(n!)"
                },
                "code": {
                    "python": "class Solution:\n    def nextPermutation(self, nums):\n        from itertools import permutations\n        perms = sorted(set(permutations(nums)))\n        target = tuple(nums)\n        for i, p in enumerate(perms):\n            if p == target:\n                next_p = perms[(i + 1) % len(perms)]\n                for j in range(len(nums)):\n                    nums[j] = next_p[j]\n                return",
                    "java": "class Solution { public void nextPermutation(int[] nums) { int i = nums.length - 2; while (i >= 0 && nums[i] >= nums[i + 1]) i--; if (i >= 0) { int j = nums.length - 1; while (nums[j] <= nums[i]) j--; swap(nums, i, j); } reverse(nums, i + 1); } void swap(int[] nums, int i, int j) { int t = nums[i]; nums[i] = nums[j]; nums[j] = t; } void reverse(int[] nums, int start) { int end = nums.length - 1; while (start < end) swap(nums, start++, end--); } }",
                    "cpp": "class Solution { public: void nextPermutation(vector<int>& nums) { int i = nums.size() - 2; while (i >= 0 && nums[i] >= nums[i + 1]) i--; if (i >= 0) { int j = nums.size() - 1; while (nums[j] <= nums[i]) j--; swap(nums[i], nums[j]); } reverse(nums.begin() + i + 1, nums.end()); } };"
                }
            },
            "optimized": {
                "intuition": "Find pivot and swap.",
                "algorithm": "O(n) in-place",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)"
                },
                "code": {
                    "python": "class Solution:\n    def nextPermutation(self, nums):\n        i = len(nums) - 2\n        while i >= 0 and nums[i] >= nums[i + 1]:\n            i -= 1\n        if i >= 0:\n            j = len(nums) - 1\n            while nums[j] <= nums[i]:\n                j -= 1\n            nums[i], nums[j] = nums[j], nums[i]\n        nums[i + 1:] = reversed(nums[i + 1:])",
                    "java": "class Solution { public void nextPermutation(int[] nums) { int i = nums.length - 2; while (i >= 0 && nums[i] >= nums[i + 1]) i--; if (i >= 0) { int j = nums.length - 1; while (nums[j] <= nums[i]) j--; int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; } reverse(nums, i + 1); } void reverse(int[] nums, int start) { int end = nums.length - 1; while (start < end) { int temp = nums[start]; nums[start++] = nums[end]; nums[end--] = temp; } } }",
                    "cpp": "class Solution { public: void nextPermutation(vector<int>& nums) { int i = nums.size() - 2; while (i >= 0 && nums[i] >= nums[i + 1]) i--; if (i >= 0) { int j = nums.size() - 1; while (nums[j] <= nums[i]) j--; swap(nums[i], nums[j]); } reverse(nums.begin() + i + 1, nums.end()); } };"
                }
            }
        }
    },
    "kth-largest-element-in-a-stream": {
        "description": `<p>Design a class to find the <code>k<sup>th</sup></code> largest element in a stream. Note that it is the <code>k<sup>th</sup></code> largest element in the sorted order, not the <code>k<sup>th</sup></code> distinct element.</p>
<p>Implement <code>KthLargest</code> class:</p>
<ul>
<li><code>KthLargest(int k, int[] nums)</code> Initializes the object with the integer <code>k</code> and the stream of integers <code>nums</code>.</li>
<li><code>int add(int val)</code> Appends the integer <code>val</code> to the stream and returns the element representing the <code>k<sup>th</sup></code> largest element in the stream.</li>
</ul>
<p>The key insight is to use a <strong>min-heap of size k</strong>. The heap maintains the k largest elements seen so far, with the smallest of these k elements at the top. When we add a new element:</p>
<ul>
<li>If heap size < k, simply add it</li>
<li>If new element > heap top, remove top and add new element</li>
<li>The heap top is always the kth largest element</li>
</ul>
<p>This achieves O(log k) time for add operations instead of O(n log n) if we sorted the entire array each time.</p>`,
        "examples": [
            {
                "input": "[\"KthLargest\", \"add\", \"add\", \"add\", \"add\", \"add\"]\\n[[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]",
                "output": "[null, 4, 5, 5, 8, 8]",
                "explanation": "KthLargest kthLargest = new KthLargest(3, [4, 5, 8, 2]);\\nkthLargest.add(3);   // return 4\\nkthLargest.add(5);   // return 5\\nkthLargest.add(10);  // return 5\\nkthLargest.add(9);   // return 8\\nkthLargest.add(4);   // return 8"
            }
        ],
        "constraints": [
            "<code>1 <= k <= 10<sup>4</sup></code>",
            "<code>0 <= nums.length <= 10<sup>4</sup></code>",
            "<code>-10<sup>4</sup> <= nums[i] <= 10<sup>4</sup></code>",
            "<code>-10<sup>4</sup> <= val <= 10<sup>4</sup></code>",
            "At most <code>10<sup>4</sup></code> calls will be made to <code>add</code>.",
            "It is guaranteed that there will be at least <code>k</code> elements in the array when you search for the <code>k<sup>th</sup></code> element."
        ],
        "solutions": {
            "brute": {
                "intuition": "Sort on each add.",
                "algorithm": "Sort array",
                "complexity": {
                    "time": "O(n log n)",
                    "space": "O(n)"
                },
                "code": {
                    "python": "class KthLargest:\n    def __init__(self, k, nums):\n        self.k = k\n        self.nums = nums\n    def add(self, val):\n        self.nums.append(val)\n        self.nums.sort(reverse=True)\n        return self.nums[self.k - 1]",
                    "java": "class KthLargest { List<Integer> nums = new ArrayList<>(); int k; public KthLargest(int k, int[] nums) { this.k = k; for (int n : nums) this.nums.add(n); } public int add(int val) { nums.add(val); Collections.sort(nums, Collections.reverseOrder()); return nums.get(k - 1); } }",
                    "cpp": "class KthLargest { vector<int> nums; int k; public: KthLargest(int k, vector<int>& nums) : k(k), nums(nums) {} int add(int val) { nums.push_back(val); sort(nums.rbegin(), nums.rend()); return nums[k - 1]; } };"
                }
            },
            "optimized": {
                "intuition": "Min heap of size k.",
                "algorithm": "Heap operations",
                "complexity": {
                    "time": "O(log k)",
                    "space": "O(k)"
                },
                "code": {
                    "python": "import heapq\n\nclass KthLargest:\n    def __init__(self, k, nums):\n        self.k = k\n        self.heap = nums\n        heapq.heapify(self.heap)\n        while len(self.heap) > k:\n            heapq.heappop(self.heap)\n    def add(self, val):\n        heapq.heappush(self.heap, val)\n        if len(self.heap) > self.k:\n            heapq.heappop(self.heap)\n        return self.heap[0]",
                    "java": "class KthLargest { PriorityQueue<Integer> heap = new PriorityQueue<>(); int k; public KthLargest(int k, int[] nums) { this.k = k; for (int n : nums) add(n); } public int add(int val) { heap.offer(val); if (heap.size() > k) heap.poll(); return heap.peek(); } }",
                    "cpp": "class KthLargest { priority_queue<int, vector<int>, greater<int>> pq; int k; public: KthLargest(int k, vector<int>& nums) : k(k) { for (int n : nums) add(n); } int add(int val) { pq.push(val); if (pq.size() > k) pq.pop(); return pq.top(); } };"
                }
            }
        }
    },
    "last-stone-weight": {
        "description": `<p>You are given an array of integers <code>stones</code> where <code>stones[i]</code> is the weight of the <code>i<sup>th</sup></code> stone.</p>
<p>We are playing a game with the stones. On each turn, we choose the <strong>heaviest two stones</strong> and smash them together. Suppose the heaviest two stones have weights <code>x</code> and <code>y</code> with <code>x <= y</code>. The result of this smash is:</p>
<ul>
<li>If <code>x == y</code>, both stones are destroyed, and</li>
<li>If <code>x != y</code>, the stone of weight <code>x</code> is destroyed, and the stone of weight <code>y</code> has new weight <code>y - x</code>.</li>
</ul>
<p>At the end of the game, there is <strong>at most one</strong> stone left.</p>
<p>Return <em>the weight of the last remaining stone</em>. If there are no stones left, return <code>0</code>.</p>
<p>The optimal approach uses a <strong>max-heap</strong> to efficiently retrieve the two heaviest stones in O(log n) time. Without a heap, we'd need to sort after each smash, which would be O(n log n) per operation.</p>`,
        "examples": [
            {
                "input": "stones = [2,7,4,1,8,1]",
                "output": "1",
                "explanation": "Combine 7 and 8 to get 1, so array converts to [2,4,1,1,1].\\nCombine 2 and 4 to get 2, so array converts to [2,1,1,1].\\nCombine 2 and 1 to get 1, so array converts to [1,1,1].\\nCombine 1 and 1 to get 0, so array converts to [1].\\nReturn 1."
            },
            {
                "input": "stones = [1]",
                "output": "1",
                "explanation": "Only one stone, return its weight."
            }
        ],
        "constraints": [
            "<code>1 <= stones.length <= 30</code>",
            "<code>1 <= stones[i] <= 1000</code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "Sort repeatedly.",
                "algorithm": "Sort after each smash",
                "complexity": {
                    "time": "O(n¬≤ log n)",
                    "space": "O(1)"
                },
                "code": {
                    "python": "class Solution:\n    def lastStoneWeight(self, stones):\n        while len(stones) > 1:\n            stones.sort()\n            y, x = stones.pop(), stones.pop()\n            if y != x:\n                stones.append(y - x)\n        return stones[0] if stones else 0",
                    "java": "class Solution { public int lastStoneWeight(int[] stones) { List<Integer> list = new ArrayList<>(); for (int s : stones) list.add(s); while (list.size() > 1) { Collections.sort(list); int y = list.remove(list.size() - 1); int x = list.remove(list.size() - 1); if (y != x) list.add(y - x); } return list.isEmpty() ? 0 : list.get(0); } }",
                    "cpp": "class Solution { public: int lastStoneWeight(vector<int>& stones) { while (stones.size() > 1) { sort(stones.begin(), stones.end()); int y = stones.back(); stones.pop_back(); int x = stones.back(); stones.pop_back(); if (y != x) stones.push_back(y - x); } return stones.empty() ? 0 : stones[0]; } };"
                }
            },
            "optimized": {
                "intuition": "Max heap.",
                "algorithm": "Pop two, push diff",
                "complexity": {
                    "time": "O(n log n)",
                    "space": "O(n)"
                },
                "code": {
                    "python": "import heapq\n\nclass Solution:\n    def lastStoneWeight(self, stones):\n        heap = [-s for s in stones]\n        heapq.heapify(heap)\n        while len(heap) > 1:\n            y = -heapq.heappop(heap)\n            x = -heapq.heappop(heap)\n            if y != x:\n                heapq.heappush(heap, -(y - x))\n        return -heap[0] if heap else 0",
                    "java": "class Solution { public int lastStoneWeight(int[] stones) { PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder()); for (int s : stones) pq.offer(s); while (pq.size() > 1) { int y = pq.poll(), x = pq.poll(); if (y != x) pq.offer(y - x); } return pq.isEmpty() ? 0 : pq.peek(); } }",
                    "cpp": "class Solution { public: int lastStoneWeight(vector<int>& stones) { priority_queue<int> pq(stones.begin(), stones.end()); while (pq.size() > 1) { int y = pq.top(); pq.pop(); int x = pq.top(); pq.pop(); if (y != x) pq.push(y - x); } return pq.empty() ? 0 : pq.top(); } };"
                }
            }
        }
    },
    "k-closest-points-to-origin": {
        "description": `<p>Given an array of <code>points</code> where <code>points[i] = [x<sub>i</sub>, y<sub>i</sub>]</code> represents a point on the <strong>X-Y</strong> plane and an integer <code>k</code>, return the <code>k</code> closest points to the origin <code>(0, 0)</code>.</p>
<p>The distance between two points on the <strong>X-Y</strong> plane is the <strong>Euclidean distance</strong> (i.e., <code>‚àö(x<sup>2</sup> + y<sup>2</sup>)</code>).</p>
<p>You may return the answer in <strong>any order</strong>. The answer is <strong>guaranteed</strong> to be <strong>unique</strong> (except for the order that it is in).</p>
<p>The brute force approach sorts all points by distance in O(n log n) time. The optimized solution uses a <strong>max-heap of size k</strong>, which reduces time to O(n log k). We maintain only the k closest points in the heap, discarding farther ones immediately.</p>
<p>Note: We can compare <code>x<sup>2</sup> + y<sup>2</sup></code> directly without computing the square root, since if <code>a<sup>2</sup> < b<sup>2</sup></code>, then <code>a < b</code> for non-negative values.</p>`,
        "examples": [
            {
                "input": "points = [[1,3],[-2,2]], k = 1",
                "output": "[[-2,2]]",
                "explanation": "The distance between (1, 3) and the origin is sqrt(10). The distance between (-2, 2) and the origin is sqrt(8). Since sqrt(8) < sqrt(10), (-2, 2) is closer to the origin. We only want the closest k = 1 points, so the answer is [[-2,2]]."
            },
            {
                "input": "points = [[3,3],[5,-1],[-2,4]], k = 2",
                "output": "[[3,3],[-2,4]]",
                "explanation": "The distances are: (3,3) = sqrt(18), (5,-1) = sqrt(26), (-2,4) = sqrt(20). The two closest are (3,3) and (-2,4). The answer [[-2,4],[3,3]] would also be accepted."
            }
        ],
        "constraints": [
            "<code>1 <= k <= points.length <= 10<sup>4</sup></code>",
            "<code>-10<sup>4</sup> <= x<sub>i</sub>, y<sub>i</sub> <= 10<sup>4</sup></code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "Calculate all distances, sort them, and pick the first k points. Simple but requires sorting the entire array.",
                "algorithm": "1. Calculate distance for each point\n2. Sort all points by distance\n3. Return first k points\n4. Time dominated by sorting step",
                "complexity": {
                    "time": "O(n log n)",
                    "space": "O(n)",
                    "timeExplanation": "Sorting all n points",
                    "spaceExplanation": "Store distances with points"
                },
                "code": {
                    "python": "class Solution:\n    def kClosest(self, points, k):\n        points.sort(key=lambda p: p[0]**2 + p[1]**2)\n        return points[:k]",
                    "java": "class Solution {\n    public int[][] kClosest(int[][] points, int k) {\n        Arrays.sort(points, (a, b) -> \n            (a[0]*a[0] + a[1]*a[1]) - (b[0]*b[0] + b[1]*b[1]));\n        return Arrays.copyOfRange(points, 0, k);\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\n        sort(points.begin(), points.end(), [](auto& a, auto& b) {\n            return a[0]*a[0] + a[1]*a[1] < b[0]*b[0] + b[1]*b[1];\n        });\n        return vector<vector<int>>(points.begin(), points.begin() + k);\n    }\n};",
                    "javascript": "var kClosest = function(points, k) {\n    points.sort((a, b) => \n        (a[0]**2 + a[1]**2) - (b[0]**2 + b[1]**2));\n    return points.slice(0, k);\n};"
                }
            },
            "optimized": {
                "intuition": "Use a max heap of size k. Only keep the k closest points at any time, discarding farther ones immediately.",
                "algorithm": "1. Create max heap of size k\n2. For each point:\n   - If heap < k, add point\n   - Else if point closer than max, remove max and add point\n3. Return heap contents\n4. More efficient than full sort",
                "complexity": {
                    "time": "O(n log k)",
                    "space": "O(k)",
                    "timeExplanation": "Each of n points takes log k heap operations",
                    "spaceExplanation": "Heap stores only k points"
                },
                "code": {
                    "python": "import heapq\n\nclass Solution:\n    def kClosest(self, points, k):\n        heap = []\n        for x, y in points:\n            dist = -(x*x + y*y)\n            if len(heap) < k:\n                heapq.heappush(heap, (dist, x, y))\n            else:\n                heapq.heappushpop(heap, (dist, x, y))\n        return [[x, y] for _, x, y in heap]",
                    "java": "class Solution {\n    public int[][] kClosest(int[][] points, int k) {\n        PriorityQueue<int[]> pq = new PriorityQueue<>(\n            (a, b) -> (b[0]*b[0] + b[1]*b[1]) - (a[0]*a[0] + a[1]*a[1]));\n        for (int[] p : points) {\n            pq.offer(p);\n            if (pq.size() > k) pq.poll();\n        }\n        int[][] res = new int[k][2];\n        for (int i = 0; i < k; i++) res[i] = pq.poll();\n        return res;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\n        auto cmp = [](auto& a, auto& b) {\n            return a[0]*a[0] + a[1]*a[1] < b[0]*b[0] + b[1]*b[1];\n        };\n        priority_queue<vector<int>, vector<vector<int>>, decltype(cmp)> pq(cmp);\n        for (auto& p : points) {\n            pq.push(p);\n            if (pq.size() > k) pq.pop();\n        }\n        vector<vector<int>> res;\n        while (!pq.empty()) { res.push_back(pq.top()); pq.pop(); }\n        return res;\n    }\n};",
                    "javascript": "var kClosest = function(points, k) {\n    const heap = new MaxPriorityQueue({\n        compare: (a, b) => (b[0]**2 + b[1]**2) - (a[0]**2 + a[1]**2)\n    });\n    for (const p of points) {\n        heap.enqueue(p);\n        if (heap.size() > k) heap.dequeue();\n    }\n    return heap.toArray();\n};"
                }
            }
        }
    },
    "binary-tree-inorder-traversal": {
        "description": "Return inorder traversal of binary tree (left, root, right).",
        "examples": [
            {
                "input": "root = [1,null,2,3]",
                "output": "[1,3,2]"
            }
        ],
        "constraints": [
            "0 <= Number of nodes <= 100"
        ],
        "solutions": {
            "brute": {
                "intuition": "Use explicit stack to simulate recursion. Push nodes and track state manually instead of using call stack.",
                "algorithm": "1. Create stack and result array\n2. Push all left children\n3. Pop node, add to result\n4. Move to right child\n5. Repeat until stack empty",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(n)",
                    "timeExplanation": "Visit each node once",
                    "spaceExplanation": "Stack can hold all nodes in skewed tree"
                },
                "code": {
                    "python": "class Solution:\n    def inorderTraversal(self, root):\n        result = []\n        stack = []\n        curr = root\n        \n        while curr or stack:\n            while curr:\n                stack.append(curr)\n                curr = curr.left\n            curr = stack.pop()\n            result.append(curr.val)\n            curr = curr.right\n        \n        return result",
                    "java": "class Solution {\n    public List<Integer> inorderTraversal(TreeNode root) {\n        List<Integer> result = new ArrayList<>();\n        Stack<TreeNode> stack = new Stack<>();\n        TreeNode curr = root;\n        \n        while (curr != null || !stack.isEmpty()) {\n            while (curr != null) {\n                stack.push(curr);\n                curr = curr.left;\n            }\n            curr = stack.pop();\n            result.add(curr.val);\n            curr = curr.right;\n        }\n        return result;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    vector<int> inorderTraversal(TreeNode* root) {\n        vector<int> result;\n        stack<TreeNode*> st;\n        TreeNode* curr = root;\n        \n        while (curr || !st.empty()) {\n            while (curr) {\n                st.push(curr);\n                curr = curr->left;\n            }\n            curr = st.top();\n            st.pop();\n            result.push_back(curr->val);\n            curr = curr->right;\n        }\n        return result;\n    }\n};",
                    "javascript": "var inorderTraversal = function(root) {\n    const result = [];\n    const stack = [];\n    let curr = root;\n    \n    while (curr || stack.length > 0) {\n        while (curr) {\n            stack.push(curr);\n            curr = curr.left;\n        }\n        curr = stack.pop();\n        result.push(curr.val);\n        curr = curr.right;\n    }\n    return result;\n};"
                }
            },
            "optimized": {
                "intuition": "Use recursion for clean, elegant solution. The call stack handles state management automatically.",
                "algorithm": "1. Base case: if node is null, return\n2. Recursively traverse left subtree\n3. Visit current node (add to result)\n4. Recursively traverse right subtree\n5. Natural and intuitive",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(h)",
                    "timeExplanation": "Visit each node once",
                    "spaceExplanation": "Recursion depth equals tree height"
                },
                "code": {
                    "python": "class Solution:\n    def inorderTraversal(self, root):\n        result = []\n        \n        def inorder(node):\n            if not node:\n                return\n            inorder(node.left)\n            result.append(node.val)\n            inorder(node.right)\n        \n        inorder(root)\n        return result",
                    "java": "class Solution {\n    public List<Integer> inorderTraversal(TreeNode root) {\n        List<Integer> result = new ArrayList<>();\n        inorder(root, result);\n        return result;\n    }\n    \n    private void inorder(TreeNode node, List<Integer> result) {\n        if (node == null) return;\n        inorder(node.left, result);\n        result.add(node.val);\n        inorder(node.right, result);\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    vector<int> inorderTraversal(TreeNode* root) {\n        vector<int> result;\n        inorder(root, result);\n        return result;\n    }\n    \n    void inorder(TreeNode* node, vector<int>& result) {\n        if (!node) return;\n        inorder(node->left, result);\n        result.push_back(node->val);\n        inorder(node->right, result);\n    }\n};",
                    "javascript": "var inorderTraversal = function(root) {\n    const result = [];\n    \n    function inorder(node) {\n        if (!node) return;\n        inorder(node.left);\n        result.push(node.val);\n        inorder(node.right);\n    }\n    \n    inorder(root);\n    return result;\n};"
                }
            }
        }
    },
    "lowest-common-ancestor-of-a-binary-search-tree": {
        "description": "Find lowest common ancestor of two nodes in BST.",
        "examples": [
            {
                "input": "root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8",
                "output": "6",
                "explanation": "LCA of nodes 2 and 8 is 6"
            }
        ],
        "constraints": [
            "All Node.val are unique"
        ],
        "solutions": {
            "brute": {
                "intuition": "Use DFS to find path from root to both nodes. Then compare paths to find where they diverge.",
                "algorithm": "1. Find path from root to p\n2. Find path from root to q\n3. Compare paths element by element\n4. Return last common node\n5. Requires storing full paths",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(n)",
                    "timeExplanation": "DFS to find both paths",
                    "spaceExplanation": "Store two paths"
                },
                "code": {
                    "python": "class Solution:\n    def lowestCommonAncestor(self, root, p, q):\n        def findPath(node, target, path):\n            if not node:\n                return False\n            path.append(node)\n            if node == target:\n                return True\n            if findPath(node.left, target, path) or findPath(node.right, target, path):\n                return True\n            path.pop()\n            return False\n        \n        path1, path2 = [], []\n        findPath(root, p, path1)\n        findPath(root, q, path2)\n        \n        lca = root\n        for i in range(min(len(path1), len(path2))):\n            if path1[i] == path2[i]:\n                lca = path1[i]\n            else:\n                break\n        return lca",
                    "java": "class Solution {\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        List<TreeNode> path1 = new ArrayList<>();\n        List<TreeNode> path2 = new ArrayList<>();\n        findPath(root, p, path1);\n        findPath(root, q, path2);\n        \n        TreeNode lca = root;\n        for (int i = 0; i < Math.min(path1.size(), path2.size()); i++) {\n            if (path1.get(i) == path2.get(i)) {\n                lca = path1.get(i);\n            } else break;\n        }\n        return lca;\n    }\n    \n    private boolean findPath(TreeNode node, TreeNode target, List<TreeNode> path) {\n        if (node == null) return false;\n        path.add(node);\n        if (node == target) return true;\n        if (findPath(node.left, target, path) || findPath(node.right, target, path)) return true;\n        path.remove(path.size() - 1);\n        return false;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n        vector<TreeNode*> path1, path2;\n        findPath(root, p, path1);\n        findPath(root, q, path2);\n        \n        TreeNode* lca = root;\n        for (int i = 0; i < min(path1.size(), path2.size()); i++) {\n            if (path1[i] == path2[i]) {\n                lca = path1[i];\n            } else break;\n        }\n        return lca;\n    }\n    \n    bool findPath(TreeNode* node, TreeNode* target, vector<TreeNode*>& path) {\n        if (!node) return false;\n        path.push_back(node);\n        if (node == target) return true;\n        if (findPath(node->left, target, path) || findPath(node->right, target, path)) return true;\n        path.pop_back();\n        return false;\n    }\n};",
                    "javascript": "var lowestCommonAncestor = function(root, p, q) {\n    function findPath(node, target, path) {\n        if (!node) return false;\n        path.push(node);\n        if (node === target) return true;\n        if (findPath(node.left, target, path) || findPath(node.right, target, path)) return true;\n        path.pop();\n        return false;\n    }\n    \n    const path1 = [], path2 = [];\n    findPath(root, p, path1);\n    findPath(root, q, path2);\n    \n    let lca = root;\n    for (let i = 0; i < Math.min(path1.length, path2.length); i++) {\n        if (path1[i] === path2[i]) lca = path1[i];\n        else break;\n    }\n    return lca;\n};"
                }
            },
            "optimized": {
                "intuition": "Use BST property! If both nodes are less than root, go left. If both greater, go right. Otherwise, current node is LCA.",
                "algorithm": "1. Compare p and q values with root\n2. If both smaller: go left\n3. If both larger: go right\n4. Otherwise: current node is LCA\n5. No need to search entire tree",
                "complexity": {
                    "time": "O(h)",
                    "space": "O(1)",
                    "timeExplanation": "Height of tree traversal",
                    "spaceExplanation": "Iterative, no extra space"
                },
                "code": {
                    "python": "class Solution:\n    def lowestCommonAncestor(self, root, p, q):\n        curr = root\n        while curr:\n            if p.val < curr.val and q.val < curr.val:\n                curr = curr.left\n            elif p.val > curr.val and q.val > curr.val:\n                curr = curr.right\n            else:\n                return curr",
                    "java": "class Solution {\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        TreeNode curr = root;\n        while (curr != null) {\n            if (p.val < curr.val && q.val < curr.val) {\n                curr = curr.left;\n            } else if (p.val > curr.val && q.val > curr.val) {\n                curr = curr.right;\n            } else {\n                return curr;\n            }\n        }\n        return null;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n        TreeNode* curr = root;\n        while (curr) {\n            if (p->val < curr->val && q->val < curr->val) {\n                curr = curr->left;\n            } else if (p->val > curr->val && q->val > curr->val) {\n                curr = curr->right;\n            } else {\n                return curr;\n            }\n        }\n        return nullptr;\n    }\n};",
                    "javascript": "var lowestCommonAncestor = function(root, p, q) {\n    let curr = root;\n    while (curr) {\n        if (p.val < curr.val && q.val < curr.val) {\n            curr = curr.left;\n        } else if (p.val > curr.val && q.val > curr.val) {\n            curr = curr.right;\n        } else {\n            return curr;\n        }\n    }\n    return null;\n};"
                }
            }
        }
    }
,

    "concatenated-words": {
        "description": `<p>Given an array of strings <code>words</code> (<strong>without duplicates</strong>), return <em>all the <strong>concatenated words</strong> in the given list of</em> <code>words</code>.</p>
<p>A <strong>concatenated word</strong> is defined as a string that is comprised entirely of at least two shorter words (not necessarily distinct) in the given array.</p>`,
        "examples": [
            {
                "input": 'words = ["cat","cats","catsdogcats","dog","dogcatsdog","hippopotamuses","rat","ratcatdogcat"]',
                "output": '["catsdogcats","dogcatsdog","ratcatdogcat"]',
                "explanation": '"catsdogcats" can be concatenated by "cats", "dog" and "cats". "dogcatsdog" can be concatenated by "dog", "cats" and "dog". "ratcatdogcat" can be concatenated by "rat", "cat", "dog" and "cat".'
            },
            {
                "input": 'words = ["cat","dog","catdog"]',
                "output": '["catdog"]',
                "explanation": '"catdog" = "cat" + "dog"'
            },
            {
                "input": 'words = ["a","b","ab","abc"]',
                "output": '["ab"]',
                "explanation": '"ab" is formed from "a" + "b". Note that "abc" cannot be formed from existing words.'
            }
        ],
        "constraints": [
            "<code>1 <= words.length <= 10<sup>4</sup></code>",
            "<code>1 <= words[i].length <= 30</code>",
            "<code>words[i]</code> consists of only lowercase English letters.",
            "All the strings of <code>words</code> are <strong>unique</strong>.",
            "<code>1 <= sum(words[i].length) <= 10<sup>5</sup></code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Concatenated Words involves checking all possible solutions. For Tries problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Tries problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Concatenated Words\n        Tries pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Concatenated Words\n     * Tries pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Concatenated Words\n     * Tries pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Concatenated Words\n * Tries pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Concatenated Words leverages word prefix tree structure to reduce time complexity. Instead of checking all possibilities, we use Tries-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for Tries reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Concatenated Words\n        Tries pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Concatenated Words\n     * Tries pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Concatenated Words\n     * Tries pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Concatenated Words\n * Tries pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "two-sum": {
        "description": `<p>Given an array of integers <code>nums</code> and an integer <code>target</code>, return <em>indices of the two numbers such that they add up to <code>target</code></em>.</p>
<p>You may assume that each input would have <strong>exactly one solution</strong>, and you may not use the <em>same</em> element twice.</p>
<p>You can return the answer in any order.</p>`,
        "examples": [
            {
                "input": 'nums = [2,7,11,15], target = 9',
                "output": '[0,1]',
                "explanation": 'Because nums[0] + nums[1] == 9, we return [0, 1].'
            },
            {
                "input": 'nums = [3,2,4], target = 6',
                "output": '[1,2]',
                "explanation": 'nums[1] + nums[2] = 2 + 4 = 6, so we return [1,2].'
            },
            {
                "input": 'nums = [3,3], target = 6',
                "output": '[0,1]',
                "explanation": 'The two 3s at different indices add up to 6.'
            }
        ],
        "constraints": [
            "<code>2 <= nums.length <= 10<sup>4</sup></code>",
            "<code>-10<sup>9</sup> <= nums[i] <= 10<sup>9</sup></code>",
            "<code>-10<sup>9</sup> <= target <= 10<sup>9</sup></code>",
            "<strong>Only one valid answer exists.</strong>"
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Two Sum involves checking all possible solutions. For Arrays problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Arrays problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Two Sum\n        Arrays pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Two Sum\n     * Arrays pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Two Sum\n     * Arrays pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Two Sum\n * Arrays pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Two Sum leverages array manipulation and optimization to reduce time complexity. Instead of checking all possibilities, we use Arrays-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for Arrays reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from O(n¬≤) to O(n).",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Two Sum\n        Arrays pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Two Sum\n     * Arrays pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Two Sum\n     * Arrays pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Two Sum\n * Arrays pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "valid-sudoku": {
        "description": `<p>Determine if a <code>9 x 9</code> Sudoku board is valid. Only the filled cells need to be validated <strong>according to the following rules</strong>:</p>
<ol>
<li>Each row must contain the digits <code>1-9</code> without repetition.</li>
<li>Each column must contain the digits <code>1-9</code> without repetition.</li>
<li>Each of the nine <code>3 x 3</code> sub-boxes of the grid must contain the digits <code>1-9</code> without repetition.</li>
</ol>
<p><strong>Note:</strong></p>
<ul>
<li>A Sudoku board (partially filled) could be valid but is not necessarily solvable.</li>
<li>Only the filled cells need to be validated according to the mentioned rules.</li>
</ul>`,
        "examples": [
            {
                "input": 'board = [[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]',
                "output": 'true',
                "explanation": 'The board is valid according to Sudoku rules.'
            },
            {
                "input": 'board = [[\"8\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]',
                "output": 'false',
                "explanation": 'The first row has two 8s, which violates Sudoku rules.'
            }
        ],
        "constraints": [
            "<code>board.length == 9</code>",
            "<code>board[i].length == 9</code>",
            "<code>board[i][j]</code> is a digit <code>1-9</code> or <code>'.'</code>."
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Valid Sudoku involves checking all possible solutions. For Matrix problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(9^(n*n))",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Matrix problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Valid Sudoku\n        Matrix pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Valid Sudoku\n     * Matrix pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Valid Sudoku\n     * Matrix pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Valid Sudoku\n * Matrix pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Valid Sudoku leverages 2D grid traversal and modification to reduce time complexity. Instead of checking all possibilities, we use Matrix-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for Matrix reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Valid Sudoku\n        Matrix pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Valid Sudoku\n     * Matrix pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Valid Sudoku\n     * Matrix pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Valid Sudoku\n * Matrix pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "lowest-common-ancestor-of-a-bst": {
        "description": `<p>Given a binary search tree (BST), find the lowest common ancestor (LCA) node of two given nodes in the BST.</p>
<p>According to the <a href='https://en.wikipedia.org/wiki/Lowest_common_ancestor' target='_blank'>definition of LCA on Wikipedia</a>: "The lowest common ancestor is defined between two nodes <code>p</code> and <code>q</code> as the lowest node in <code>T</code> that has both <code>p</code> and <code>q</code> as descendants (where we allow <strong>a node to be a descendant of itself</strong>)."</p>`,
        "examples": [
            {
                "input": 'root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8',
                "output": '6',
                "explanation": 'The LCA of nodes 2 and 8 is 6.'
            },
            {
                "input": 'root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4',
                "output": '2',
                "explanation": 'The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.'
            },
            {
                "input": 'root = [2,1], p = 2, q = 1',
                "output": '2',
                "explanation": 'The LCA of nodes 2 and 1 is 2.'
            }
        ],
        "constraints": [
            "<code>The number of nodes in the tree is in the range [2, 10<sup>5</sup>].</code>",
            "<code>-10<sup>9</sup> <= Node.val <= 10<sup>9</sup></code>",
            "All <code>Node.val</code> are <strong>unique</strong>.",
            "<code>p != q</code>",
            "<code>p</code> and <code>q</code> will exist in the BST."
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Lowest Common Ancestor of a BST involves checking all possible solutions. For BST problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. BST problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Lowest Common Ancestor of a BST\n        BST pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Lowest Common Ancestor of a BST\n     * BST pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Lowest Common Ancestor of a BST\n     * BST pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Lowest Common Ancestor of a BST\n * BST pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Lowest Common Ancestor of a BST leverages binary search tree operations to reduce time complexity. Instead of checking all possibilities, we use BST-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for BST reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Lowest Common Ancestor of a BST\n        BST pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Lowest Common Ancestor of a BST\n     * BST pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Lowest Common Ancestor of a BST\n     * BST pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Lowest Common Ancestor of a BST\n     * BST pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     * @param {number[]} input\n     * @return {number[]}\n     */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "construct-binary-tree-from-preorder-and-inorder": {
        "description": `<p>Given two integer arrays <code>preorder</code> and <code>inorder</code> where <code>preorder</code> is the preorder traversal of a binary tree and <code>inorder</code> is the inorder traversal of the same tree, construct and return <em>the binary tree</em>.</p>`,
        "examples": [
            {
                "input": 'preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]',
                "output": '[3,9,20,null,null,15,7]',
                "explanation": 'The tree can be constructed from the given traversals.'
            },
            {
                "input": 'preorder = [-1], inorder = [-1]',
                "output": '[-1]',
                "explanation": 'Single node tree.'
            }
        ],
        "constraints": [
            "<code>1 <= preorder.length <= 3000</code>",
            "<code>inorder.length == preorder.length</code>",
            "<code>-3000 <= preorder[i], inorder[i] <= 3000</code>",
            "<code>preorder</code> and <code>inorder</code> consist of <strong>unique</strong> values.",
            "Each value of <code>inorder</code> also appears in <code>preorder</code>.",
            "<code>preorder</code> is <strong>guaranteed</strong> to be the preorder traversal of the tree.",
            "<code>inorder</code> is <strong>guaranteed</strong> to be the inorder traversal of the tree."
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Construct Binary Tree from Preorder and Inorder involves checking all possible solutions. For Tree Hard problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Tree Hard problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Construct Binary Tree from Preorder and Inorder\n        Tree Hard pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Construct Binary Tree from Preorder and Inorder\n     * Tree Hard pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Construct Binary Tree from Preorder and Inorder\n     * Tree Hard pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Construct Binary Tree from Preorder and Inorder\n * Tree Hard pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Construct Binary Tree from Preorder and Inorder leverages complex tree transformations to reduce time complexity. Instead of checking all possibilities, we use Tree Hard-specific techniques like efficient traversal with pruning to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (tree structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Pruning impossible branches\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(h)",
                    "timeExplanation": "Optimized approach for Tree Hard reduces complexity significantly. Tree traversal visits each node exactly once. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Recursion stack depth equals tree height. Balanced tree gives O(log n). Can be further optimized by using iterative approach instead of recursion."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Construct Binary Tree from Preorder and Inorder\n        Tree Hard pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Construct Binary Tree from Preorder and Inorder\n     * Tree Hard pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Construct Binary Tree from Preorder and Inorder\n     * Tree Hard pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Construct Binary Tree from Preorder and Inorder\n * Tree Hard pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "palindrome-pairs": {
        "description": `<p>You are given a <strong>0-indexed</strong> array of <strong>unique</strong> strings <code>words</code>.</p>
<p>A <strong>palindrome pair</strong> is a pair of integers <code>(i, j)</code> such that:</p>
<ul>
<li><code>0 <= i, j < words.length</code>,</li>
<li><code>i != j</code>, and</li>
<li><code>words[i] + words[j]</code> (the concatenation of the two strings) is a palindrome.</li>
</ul>
<p>Return <em>an array of all the palindrome pairs of</em> <code>words</code>.</p>`,
        "examples": [
            {
                "input": 'words = ["abcd","dcba","lls","s","sssll"]',
                "output": '[[0,1],[1,0],[3,2],[2,4]]',
                "explanation": 'The palindromes are ["dcbaabcd","abcddcba","slls","llssssll"]'
            },
            {
                "input": 'words = ["bat","tab","cat"]',
                "output": '[[0,1],[1,0]]',
                "explanation": 'The palindromes are ["battab","tabbat"]'
            },
            {
                "input": 'words = ["a",""]',
                "output": '[[0,1],[1,0]]',
                "explanation": 'Empty string concatenated with "a" forms "a" (palindrome), and "a" + "" forms "a" (palindrome)'
            }
        ],
        "constraints": [
            "<code>1 <= words.length <= 5000</code>",
            "<code>0 <= words[i].length <= 300</code>",
            "<code>words[i]</code> consists of lowercase English letters."
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Palindrome Pairs involves checking all possible solutions. For Tries problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Tries problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Palindrome Pairs\n        Tries pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Palindrome Pairs\n     * Tries pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Palindrome Pairs\n     * Tries pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Palindrome Pairs\n * Tries pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Palindrome Pairs leverages word prefix tree structure to reduce time complexity. Instead of checking all possibilities, we use Tries-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for Tries reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Palindrome Pairs\n        Tries pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Palindrome Pairs\n     * Tries pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Palindrome Pairs\n     * Tries pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Palindrome Pairs\n * Tries pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "number-of-connected-components": {
        "description": `<p>You have a graph of <code>n</code> nodes. You are given an integer <code>n</code> and an array <code>edges</code> where <code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> indicates that there is an edge between <code>a<sub>i</sub></code> and <code>b<sub>i</sub></code> in the graph.</p>
<p>Return <em>the number of connected components in the graph</em>.</p>`,
        "examples": [
            {
                "input": 'n = 5, edges = [[0,1],[1,2],[3,4]]',
                "output": '2',
                "explanation": 'There are 2 connected components: {0,1,2} and {3,4}'
            },
            {
                "input": 'n = 5, edges = [[0,1],[1,2],[2,3],[3,4]]',
                "output": '1',
                "explanation": 'All nodes are connected in one component: {0,1,2,3,4}'
            }
        ],
        "constraints": [
            "<code>1 <= n <= 2000</code>",
            "<code>1 <= edges.length <= 5000</code>",
            "<code>edges[i].length == 2</code>",
            "<code>0 <= a<sub>i</sub> <= b<sub>i</sub> < n</code>",
            "<code>a<sub>i</sub> != b<sub>i</sub></code>",
            "There are no repeated edges."
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Number of Connected Components involves checking all possible solutions. For Union Find problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Union Find problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Number of Connected Components\n        Union Find pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Number of Connected Components\n     * Union Find pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Number of Connected Components\n     * Union Find pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Number of Connected Components\n * Union Find pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Number of Connected Components leverages disjoint set operations to reduce time complexity. Instead of checking all possibilities, we use Union Find-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for Union Find reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Number of Connected Components\n        Union Find pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Number of Connected Components\n     * Union Find pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Number of Connected Components\n     * Union Find pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Number of Connected Components\n * Union Find pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "longest-increasing-path-in-a-matrix": {
        "description": `<p>Given an <code>m x n</code> integers <code>matrix</code>, return <em>the length of the longest increasing path in</em> <code>matrix</code>.</p>
<p>From each cell, you can either move in four directions: left, right, up, or down. You <strong>may not</strong> move <strong>diagonally</strong> or move <strong>outside the boundary</strong> (i.e., wrap-around is not allowed).</p>`,
        "examples": [
            {
                "input": 'matrix = [[9,9,4],[6,6,8],[2,1,1]]',
                "output": '4',
                "explanation": 'The longest increasing path is [1, 2, 6, 9]'
            },
            {
                "input": 'matrix = [[3,4,5],[3,2,6],[2,2,1]]',
                "output": '4',
                "explanation": 'The longest increasing path is [3, 4, 5, 6]. Moving diagonally is not allowed'
            },
            {
                "input": 'matrix = [[1]]',
                "output": '1',
                "explanation": 'Single element matrix has path length 1'
            }
        ],
        "constraints": [
            "<code>m == matrix.length</code>",
            "<code>n == matrix[i].length</code>",
            "<code>1 <= m, n <= 200</code>",
            "<code>0 <= matrix[i][j] <= 2<sup>31</sup> - 1</code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Longest Increasing Path in a Matrix involves checking all possible solutions. For DFS problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. DFS problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Longest Increasing Path in a Matrix\n        DFS pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Longest Increasing Path in a Matrix\n     * DFS pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Longest Increasing Path in a Matrix\n     * DFS pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Longest Increasing Path in a Matrix\n * DFS pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Longest Increasing Path in a Matrix leverages depth-first search graph traversal to reduce time complexity. Instead of checking all possibilities, we use DFS-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for DFS reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Longest Increasing Path in a Matrix\n        DFS pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Longest Increasing Path in a Matrix\n     * DFS pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Longest Increasing Path in a Matrix\n     * DFS pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Longest Increasing Path in a Matrix\n * DFS pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "find-duplicate-number": {
        "description": `<p>Given an array of integers <code>nums</code> containing <code>n + 1</code> integers where each integer is in the range <code>[1, n]</code> inclusive.</p>
<p>There is only <strong>one repeated number</strong> in <code>nums</code>, return <em>this repeated number</em>.</p>
<p>You must solve the problem <strong>without</strong> modifying the array <code>nums</code> and uses only constant extra space.</p>`,
        "examples": [
            {
                "input": 'nums = [1,3,4,2,2]',
                "output": '2',
                "explanation": 'The duplicate number is 2'
            },
            {
                "input": 'nums = [3,1,3,4,2]',
                "output": '3',
                "explanation": 'The duplicate number is 3'
            },
            {
                "input": 'nums = [3,3,3,3,3]',
                "output": '3',
                "explanation": 'All elements are 3, so the duplicate is 3'
            }
        ],
        "constraints": [
            "<code>1 <= n <= 10<sup>5</sup></code>",
            "<code>nums.length == n + 1</code>",
            "<code>1 <= nums[i] <= n</code>",
            "All the integers in <code>nums</code> appear only <strong>once</strong> except for <strong>precisely one integer</strong> which appears <strong>two or more</strong> times."
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Find Duplicate Number involves checking all possible solutions. For Two Pointers problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Two Pointers problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Find Duplicate Number\n        Two Pointers pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Find Duplicate Number\n     * Two Pointers pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Find Duplicate Number\n     * Two Pointers pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Find Duplicate Number\n * Two Pointers pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Find Duplicate Number leverages two-pointer technique optimization to reduce time complexity. Instead of checking all possibilities, we use Two Pointers-specific techniques like two pointers to avoid nested loops to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Place pointers at strategic positions\n3. While pointers haven't crossed:\n   - Process current elements\n   - Move pointers based on logic\n   - Update result\n4. Return the optimal solution\n\nKey optimizations:\n- Single pass instead of nested loops\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for Two Pointers reduces complexity significantly. Two pointers traverse array once without backtracking. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Only constant extra space needed for pointers and variables. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Find Duplicate Number\n        Two Pointers pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Two pointer approach\n        left, right = 0, n - 1\n        \n        while left < right:\n            # Process current elements\n            if condition(input[left], input[right]):\n                result.append([left, right])\n                left += 1\n            else:\n                right -= 1\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Find Duplicate Number\n     * Two Pointers pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Two pointer approach\n        int left = 0, right = n - 1;\n        \n        while (left < right) {\n            // Process current elements\n            if (condition(input[left], input[right])) {\n                result.add(left);\n                result.add(right);\n                left++;\n            } else {\n                right--;\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Find Duplicate Number\n     * Two Pointers pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Two pointer approach\n        int left = 0, right = n - 1;\n        \n        while (left < right) {\n            // Process current elements\n            if (condition(input[left], input[right])) {\n                result.push_back(left);\n                result.push_back(right);\n                left++;\n            } else {\n                right--;\n            }\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Find Duplicate Number\n * Two Pointers pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Two pointer approach\n    let left = 0, right = n - 1;\n    \n    while (left < right) {\n        // Process current elements\n        if (condition(input[left], input[right])) {\n            result.push(left, right);\n            left++;\n        } else {\n            right--;\n        }\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "largest-number": {
        "description": `<p>Given a list of non-negative integers <code>nums</code>, arrange them such that they form the largest number and return it.</p>
<p>Since the result may be very large, you need to return a string instead of an integer.</p>`,
        "examples": [
            {
                "input": 'nums = [10,2]',
                "output": '"210"',
                "explanation": 'Comparing "210" vs "102", "210" is larger'
            },
            {
                "input": 'nums = [3,30,34,5,9]',
                "output": '"9534330"',
                "explanation": 'The largest number that can be formed is "9534330"'
            },
            {
                "input": 'nums = [0,0]',
                "output": '"0"',
                "explanation": 'All zeros should return "0" not "00"'
            }
        ],
        "constraints": [
            "<code>1 <= nums.length <= 100</code>",
            "<code>0 <= nums[i] <= 10<sup>9</sup></code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Largest Number involves checking all possible solutions. For Strings problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Strings problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Largest Number\n        Strings pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Largest Number\n     * Strings pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Largest Number\n     * Strings pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Largest Number\n * Strings pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Largest Number leverages string manipulation algorithms to reduce time complexity. Instead of checking all possibilities, we use Strings-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for Strings reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Largest Number\n        Strings pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Largest Number\n     * Strings pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Largest Number\n     * Strings pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Largest Number\n * Strings pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "text-justification": {
        "description": `<p>Given an array of strings <code>words</code> and a width <code>maxWidth</code>, format the text such that each line has exactly <code>maxWidth</code> characters and is fully (left and right) justified.</p>
<p>You should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces <code>' '</code> when necessary so that each line has exactly <code>maxWidth</code> characters.</p>
<p>Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line does not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.</p>
<p>For the last line of text, it should be left-justified, and no extra space is inserted between words.</p>`,
        "examples": [
            {
                "input": 'words = ["This", "is", "an", "example", "of", "text", "justification."], maxWidth = 16',
                "output": '["This    is    an","example  of text","justification.  "]',
                "explanation": 'Line 1: "This    is    an" has 16 characters. Line 2: "example  of text" has 16 characters. Line 3: "justification.  " (last line is left-justified)'
            },
            {
                "input": 'words = ["What","must","be","acknowledgment","shall","be"], maxWidth = 16',
                "output": '["What   must   be","acknowledgment  ","shall be        "]',
                "explanation": 'Lines distributed with appropriate spacing to reach maxWidth'
            },
            {
                "input": 'words = ["Science","is","what","we","understand","well","enough","to","explain","to","a","computer.","Art","is","everything","else","we","do"], maxWidth = 20',
                "output": '["Science  is  what we","understand      well","enough to explain to","a  computer.  Art is","everything  else  we","do                  "]',
                "explanation": 'Each line has exactly 20 characters with proper spacing distribution'
            }
        ],
        "constraints": [
            "<code>1 <= words.length <= 300</code>",
            "<code>1 <= words[i].length <= 20</code>",
            "<code>words[i]</code> consists of only English letters and symbols.",
            "<code>1 <= maxWidth <= 100</code>",
            "<code>words[i].length <= maxWidth</code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Text Justification involves checking all possible solutions. For Strings problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Strings problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Text Justification\n        Strings pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Text Justification\n     * Strings pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Text Justification\n     * Strings pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Text Justification\n * Strings pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Text Justification leverages string manipulation algorithms to reduce time complexity. Instead of checking all possibilities, we use Strings-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for Strings reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Text Justification\n        Strings pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Text Justification\n     * Strings pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Text Justification\n     * Strings pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Text Justification\n * Strings pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "naming-a-company": {
        "description": `<p>You are given an array of strings <code>ideas</code> that represents a list of names to be used in the process of naming a company. The process of naming a company is as follows:</p>
<p>Choose 2 <strong>distinct</strong> names from <code>ideas</code>, call them <code>idea<sub>A</sub></code> and <code>idea<sub>B</sub></code>.</p>
<p>Swap the first letters of <code>idea<sub>A</sub></code> and <code>idea<sub>B</sub></code> with each other.</p>
<p>If <strong>both</strong> of the new names are not found in the original <code>ideas</code>, then the name <code>idea<sub>A</sub> idea<sub>B</sub></code> (the <strong>concatenation</strong> of <code>idea<sub>A</sub></code> and <code>idea<sub>B</sub></code>, separated by a space) is a valid company name.</p>
<p>Otherwise, it is not a valid name.</p>
<p>Return <em>the number of <strong>distinct</strong> valid names for the company</em>.</p>`,
        "examples": [
            {
                "input": 'ideas = ["coffee","donuts","time","toffee"]',
                "output": '6',
                "explanation": 'The following selections are valid: (\"coffee\", \"donuts\"): \"doffee conuts\", (\"donuts\", \"coffee\"): \"conuts doffee\", (\"donuts\", \"time\"): \"tonuts dime\", (\"donuts\", \"toffee\"): \"tonuts doffee\", (\"time\", \"donuts\"): \"dime tonuts\", (\"toffee\", \"donuts\"): \"doffee tonuts\"'
            },
            {
                "input": 'ideas = ["lack","back"]',
                "output": '0',
                "explanation": 'There are no valid selections. Swapping the first letters would give \"back\" and \"lack\" which are both in the original array'
            }
        ],
        "constraints": [
            "<code>2 <= ideas.length <= 5 * 10<sup>4</sup></code>",
            "<code>1 <= ideas[i].length <= 10</code>",
            "<code>ideas[i]</code> consists of lowercase English letters.",
            "All the strings in <code>ideas</code> are <strong>unique</strong>."
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Naming a Company involves checking all possible solutions. For Strings problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Strings problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Naming a Company\n        Strings pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Naming a Company\n     * Strings pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Naming a Company\n     * Strings pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Naming a Company\n * Strings pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Naming a Company leverages string manipulation algorithms to reduce time complexity. Instead of checking all possibilities, we use Strings-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for Strings reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Naming a Company\n        Strings pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Naming a Company\n     * Strings pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Naming a Company\n     * Strings pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Naming a Company\n * Strings pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "candy": {
        "description": `<p>There are <code>n</code> children standing in a line. Each child is assigned a rating value given in the integer array <code>ratings</code>.</p>
<p>You are giving candies to these children subjected to the following requirements:</p>
<ul>
<li>Each child must have at least one candy.</li>
<li>Children with a higher rating get more candies than their neighbors.</li>
</ul>
<p>Return <em>the minimum number of candies you need to have to distribute the candies to the children</em>.</p>`,
        "examples": [
            {
                "input": 'ratings = [1,0,2]',
                "output": '5',
                "explanation": 'You can allocate to the first, second and third child with 2, 1, 2 candies respectively'
            },
            {
                "input": 'ratings = [1,2,2]',
                "output": '4',
                "explanation": 'You can allocate to the first, second and third child with 1, 2, 1 candies respectively. The third child gets 1 candy because it satisfies the above two conditions'
            }
        ],
        "constraints": [
            "<code>n == ratings.length</code>",
            "<code>1 <= n <= 2 * 10<sup>4</sup></code>",
            "<code>0 <= ratings[i] <= 2 * 10<sup>4</sup></code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Candy involves checking all possible solutions. For Greedy problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Greedy problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Candy\n        Greedy pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Candy\n     * Greedy pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Candy\n     * Greedy pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Candy\n * Greedy pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Candy leverages greedy choice optimization to reduce time complexity. Instead of checking all possibilities, we use Greedy-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Make locally optimal choices\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Local optimal choices lead to global optimum\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for Greedy reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Only constant extra space needed for pointers and variables. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Candy\n        Greedy pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Candy\n     * Greedy pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Candy\n     * Greedy pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Candy\n * Greedy pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "trapping-rain-water-ii": {
        "description": "<p>Given an <code>m x n</code> integer matrix <code>heightMap</code> representing the height of each unit cell in a 2D elevation map, return <em>the volume of water it can trap after raining</em>.</p>",
        "examples": [
            {
                "input": "heightMap = [[1,4,3,1,3,2],[3,2,1,3,2,4],[2,3,3,2,3,1]]",
                "output": "4",
                "explanation": "<p>The elevation map (black) is shown above, with water (blue) trapped after raining. The total volume of water trapped is 4.</p>"
            },
            {
                "input": "heightMap = [[3,3,3,3,3],[3,2,2,2,3],[3,2,1,2,3],[3,2,2,2,3],[3,3,3,3,3]]",
                "output": "10",
                "explanation": "<p>Water gets trapped in the center cell with height 1. The surrounding walls prevent water from flowing out, resulting in 10 units of water trapped.</p>"
            }
        ],
        "constraints": [
            "<code>m == heightMap.length</code>",
            "<code>n == heightMap[i].length</code>",
            "<code>1 &lt;= m, n &lt;= 200</code>",
            "<code>0 &lt;= heightMap[i][j] &lt;= 2 * 10<sup>4</sup></code>"
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Trapping Rain Water II involves checking all possible solutions. For Heap problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Heap problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Trapping Rain Water II\n        Heap pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Trapping Rain Water II\n     * Heap pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Trapping Rain Water II\n     * Heap pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Trapping Rain Water II\n * Heap pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Trapping Rain Water II leverages priority queue operations to reduce time complexity. Instead of checking all possibilities, we use Heap-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for Heap reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Trapping Rain Water II\n        Heap pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Trapping Rain Water II\n     * Heap pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Trapping Rain Water II\n     * Heap pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Trapping Rain Water II\n * Heap pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "max-points-on-a-line": {
        "description": '<p>Given an array of <code>points</code> where <code>points[i] = [x<sub>i</sub>, y<sub>i</sub>]</code> represents a point on the <strong>X-Y</strong> plane, return <em>the maximum number of points that lie on the same straight line</em>.</p>',
        "examples": [
            {
                "input": 'points = [[1,1],[2,2],[3,3]]',
                "output": '3',
                "explanation": '<p>All three points lie on the same straight line.</p>'
            },
            {
                "input": 'points = [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]',
                "output": '4',
                "explanation": '<p>The maximum number of points that lie on the same straight line is 4.</p>'
            }
        ],
        "constraints": [
            '<code>1 &lt;= points.length &lt;= 300</code>',
            '<code>points[i].length == 2</code>',
            '<code>-10<sup>4</sup> &lt;= x<sub>i</sub>, y<sub>i</sub> &lt;= 10<sup>4</sup></code>',
            'All the <code>points</code> are <strong>unique</strong>.'
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Max Points on a Line involves checking all possible solutions. For Maths problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Maths problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Max Points on a Line\n        Maths pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Max Points on a Line\n     * Maths pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Max Points on a Line\n     * Maths pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Max Points on a Line\n * Maths pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Max Points on a Line leverages mathematical computation to reduce time complexity. Instead of checking all possibilities, we use Maths-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for Maths reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Max Points on a Line\n        Maths pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Max Points on a Line\n     * Maths pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Max Points on a Line\n     * Maths pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Max Points on a Line\n * Maths pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "sudoku-solver": {
        "description": "<p>Write a program to solve a Sudoku puzzle by filling the empty cells.</p><p>A sudoku solution must satisfy <strong>all of the following rules</strong>:</p><ul><li>Each of the digits <code>1-9</code> must occur exactly once in each row.</li><li>Each of the digits <code>1-9</code> must occur exactly once in each column.</li><li>Each of the digits <code>1-9</code> must occur exactly once in each of the 9 <code>3x3</code> sub-boxes of the grid.</li></ul><p>The <code>'.' character indicates empty cells.</p>",
        "examples": [
            {
                "input": 'board = [["5","3",".",".","7",".",".",".","."],["6",".",".","1","9","5",".",".","."],[".","9","8",".",".",".",".","6","."],["8",".",".",".","6",".",".",".","3"],["4",".",".","8",".","3",".",".","1"],["7",".",".",".","2",".",".",".","6"],[".","6",".",".",".",".","2","8","."],[".",".",".","4","1","9",".",".","5"],[".",".",".",".","8",".",".","7","9"]]',
                "output": '[["5","3","4","6","7","8","9","1","2"],["6","7","2","1","9","5","3","4","8"],["1","9","8","3","4","2","5","6","7"],["8","5","9","7","6","1","4","2","3"],["4","2","6","8","5","3","7","9","1"],["7","1","3","9","2","4","8","5","6"],["9","6","1","5","3","7","2","8","4"],["2","8","7","4","1","9","6","3","5"],["3","4","5","2","8","6","1","7","9"]]',
                "explanation": '<p>The filled Sudoku board satisfies all rules.</p>'
            }
        ],
        "constraints": [
            '<code>board.length == 9</code>',
            '<code>board[i].length == 9</code>',
            "<code>board[i][j]</code> is a digit <code>1-9</code> or <code>'.'</code>.",
            'It is <strong>guaranteed</strong> that the input board has only one solution.'
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Sudoku Solver involves checking all possible solutions. For Backtracking problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(9^(n*n))",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Backtracking problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Sudoku Solver\n        Backtracking pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Sudoku Solver\n     * Backtracking pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Sudoku Solver\n     * Backtracking pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Sudoku Solver\n * Backtracking pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Sudoku Solver leverages recursive backtracking to reduce time complexity. Instead of checking all possibilities, we use Backtracking-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for Backtracking reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Sudoku Solver\n        Backtracking pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Sudoku Solver\n     * Backtracking pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Sudoku Solver\n     * Backtracking pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Sudoku Solver\n * Backtracking pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "count-of-smaller-numbers-after-self": {
        "description": '<p>Given an integer array <code>nums</code>, return <em>an integer array</em> <code>counts</code> <em>where</em> <code>counts[i]</code> <em>is the number of smaller elements to the right of</em> <code>nums[i]</code>.</p>',
        "examples": [
            {
                "input": 'nums = [5,2,6,1]',
                "output": '[2,1,1,0]',
                "explanation": '<p>To the right of 5 there are <strong>2</strong> smaller elements (2 and 1).<br/>To the right of 2 there is only <strong>1</strong> smaller element (1).<br/>To the right of 6 there is <strong>1</strong> smaller element (1).<br/>To the right of 1 there is <strong>0</strong> smaller element.</p>'
            },
            {
                "input": 'nums = [-1]',
                "output": '[0]',
                "explanation": '<p>There are no elements to the right of -1.</p>'
            },
            {
                "input": 'nums = [-1,-1]',
                "output": '[0,0]',
                "explanation": '<p>There are no smaller elements to the right of either -1.</p>'
            }
        ],
        "constraints": [
            '<code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code>',
            '<code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code>'
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Count of Smaller Numbers After Self involves checking all possible solutions. For Merge / Quick / Divide problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Merge / Quick / Divide problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Count of Smaller Numbers After Self\n        Merge / Quick / Divide pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Count of Smaller Numbers After Self\n     * Merge / Quick / Divide pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Count of Smaller Numbers After Self\n     * Merge / Quick / Divide pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Count of Smaller Numbers After Self\n * Merge / Quick / Divide pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Count of Smaller Numbers After Self leverages divide and conquer approach to reduce time complexity. Instead of checking all possibilities, we use Merge / Quick / Divide-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for Merge / Quick / Divide reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Count of Smaller Numbers After Self\n        Merge / Quick / Divide pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Count of Smaller Numbers After Self\n     * Merge / Quick / Divide pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Count of Smaller Numbers After Self\n     * Merge / Quick / Divide pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Count of Smaller Numbers After Self\n * Merge / Quick / Divide pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "reverse-pairs": {
        "description": '<p>Given an integer array <code>nums</code>, return <em>the number of <strong>reverse pairs</strong> in the array</em>.</p><p>A <strong>reverse pair</strong> is a pair <code>(i, j)</code> where:</p><ul><li><code>0 &lt;= i &lt; j &lt; nums.length</code> and</li><li><code>nums[i] &gt; 2 * nums[j]</code>.</li></ul>',
        "examples": [
            {
                "input": 'nums = [1,3,2,3,1]',
                "output": '2',
                "explanation": '<p>The reverse pairs are: (1, 4) with nums[1] = 3 &gt; 2 * nums[4] = 2, and (3, 4) with nums[3] = 3 &gt; 2 * nums[4] = 2.</p>'
            },
            {
                "input": 'nums = [2,4,3,5,1]',
                "output": '3',
                "explanation": '<p>The reverse pairs are: (1, 4), (2, 4), and (3, 4).</p>'
            }
        ],
        "constraints": [
            '<code>1 &lt;= nums.length &lt;= 5 * 10<sup>4</sup></code>',
            '<code>-2<sup>31</sup> &lt;= nums[i] &lt;= 2<sup>31</sup> - 1</code>'
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Reverse Pairs involves checking all possible solutions. For Merge / Quick / Divide problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Merge / Quick / Divide problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Reverse Pairs\n        Merge / Quick / Divide pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Reverse Pairs\n     * Merge / Quick / Divide pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Reverse Pairs\n     * Merge / Quick / Divide pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Reverse Pairs\n * Merge / Quick / Divide pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Reverse Pairs leverages divide and conquer approach to reduce time complexity. Instead of checking all possibilities, we use Merge / Quick / Divide-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for Merge / Quick / Divide reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Reverse Pairs\n        Merge / Quick / Divide pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Reverse Pairs\n     * Merge / Quick / Divide pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Reverse Pairs\n     * Merge / Quick / Divide pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Reverse Pairs\n * Merge / Quick / Divide pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "skyline-problem": {
        "description": '<p>A city\'s <strong>skyline</strong> is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. Given the locations and heights of all the buildings, return <em>the <strong>skyline</strong> formed by these buildings collectively</em>.</p><p>The geometric information of each building is given in the array <code>buildings</code> where <code>buildings[i] = [left<sub>i</sub>, right<sub>i</sub>, height<sub>i</sub>]</code>:</p><ul><li><code>left<sub>i</sub></code> is the x coordinate of the left edge of the <code>i<sup>th</sup></code> building.</li><li><code>right<sub>i</sub></code> is the x coordinate of the right edge of the <code>i<sup>th</sup></code> building.</li><li><code>height<sub>i</sub></code> is the height of the <code>i<sup>th</sup></code> building.</li></ul><p>You may assume all buildings are perfect rectangles grounded on an absolutely flat surface at height <code>0</code>.</p><p>The <strong>skyline</strong> should be represented as a list of "key points" <strong>sorted by their x-coordinate</strong> in the form <code>[[x<sub>1</sub>,y<sub>1</sub>],[x<sub>2</sub>,y<sub>2</sub>],...]</code>. Each key point is the left endpoint of some horizontal segment in the skyline except the last point in the list, which always has a y-coordinate <code>0</code> and is used to mark the skyline\'s termination where the rightmost building ends. Any ground between the leftmost and rightmost buildings should be part of the skyline\'s contour.</p>',
        "examples": [
            {
                "input": 'buildings = [[2,9,10],[3,7,15],[5,12,12],[15,20,10],[19,24,8]]',
                "output": '[[2,10],[3,15],[7,12],[12,0],[15,10],[20,8],[24,0]]',
                "explanation": '<p><strong>Figure A</strong> shows the buildings of the input.<br/><strong>Figure B</strong> shows the skyline formed by those buildings. The red points in Figure B represent the key points in the output list.</p>'
            },
            {
                "input": 'buildings = [[0,2,3],[2,5,3]]',
                "output": '[[0,3],[5,0]]',
                "explanation": '<p>The buildings form a single rectangle skyline.</p>'
            }
        ],
        "constraints": [
            '<code>1 &lt;= buildings.length &lt;= 10<sup>4</sup></code>',
            '<code>0 &lt;= left<sub>i</sub> &lt; right<sub>i</sub> &lt;= 2<sup>31</sup> - 1</code>',
            '<code>1 &lt;= height<sub>i</sub> &lt;= 2<sup>31</sup> - 1</code>',
            '<code>buildings</code> is sorted by <code>left<sub>i</sub></code> in non-decreasing order.'
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Skyline Problem involves checking all possible solutions. For Heap problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Heap problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Skyline Problem\n        Heap pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Skyline Problem\n     * Heap pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Skyline Problem\n     * Heap pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Skyline Problem\n * Heap pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Skyline Problem leverages priority queue operations to reduce time complexity. Instead of checking all possibilities, we use Heap-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for Heap reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Skyline Problem\n        Heap pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Skyline Problem\n     * Heap pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Skyline Problem\n     * Heap pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Skyline Problem\n * Heap pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "shortest-path-in-a-grid-with-obstacles-elimination": {
        "description": '<p>You are given an <code>m x n</code> integer matrix <code>grid</code> where each cell is either <code>0</code> (empty) or <code>1</code> (obstacle). You can move up, down, left, or right from and to an empty cell in <strong>one step</strong>.</p><p>Return <em>the minimum number of <strong>steps</strong> to walk from the upper left corner</em> <code>(0, 0)</code> <em>to the lower right corner</em> <code>(m - 1, n - 1)</code> <em>given that you can eliminate <strong>at most</strong></em> <code>k</code> <em>obstacles</em>. If it is not possible to find such walk return <code>-1</code>.</p>',
        "examples": [
            {
                "input": 'grid = [[0,0,0],[1,1,0],[0,0,0],[0,1,1],[0,0,0]], k = 1',
                "output": '6',
                "explanation": '<p>The shortest path without eliminating any obstacle is 10.<br/>The shortest path with one obstacle elimination at position (3,2) is 6. Such path is (0,0) -> (0,1) -> (0,2) -> (1,2) -> (2,2) -> (3,2) -> (4,2).</p>'
            },
            {
                "input": 'grid = [[0,1,1],[1,1,1],[1,0,0]], k = 1',
                "output": '-1',
                "explanation": '<p>We need to eliminate at least 2 obstacles to find such a walk.</p>'
            }
        ],
        "constraints": [
            '<code>m == grid.length</code>',
            '<code>n == grid[i].length</code>',
            '<code>1 &lt;= m, n &lt;= 40</code>',
            '<code>1 &lt;= k &lt;= m * n</code>',
            '<code>grid[i][j]</code> is either <code>0</code> or <code>1</code>.',
            '<code>grid[0][0] == grid[m - 1][n - 1] == 0</code>'
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Shortest Path in a Grid with Obstacles Elimination involves checking all possible solutions. For BFS problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. BFS problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Shortest Path in a Grid with Obstacles Elimination\n        BFS pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Shortest Path in a Grid with Obstacles Elimination\n     * BFS pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Shortest Path in a Grid with Obstacles Elimination\n     * BFS pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Shortest Path in a Grid with Obstacles Elimination\n * BFS pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Shortest Path in a Grid with Obstacles Elimination leverages breadth-first search traversal to reduce time complexity. Instead of checking all possibilities, we use BFS-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for BFS reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Shortest Path in a Grid with Obstacles Elimination\n        BFS pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Shortest Path in a Grid with Obstacles Elimination\n     * BFS pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Shortest Path in a Grid with Obstacles Elimination\n     * BFS pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Shortest Path in a Grid with Obstacles Elimination\n * BFS pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "making-a-large-island": {
        "description": '<p>You are given an <code>n x n</code> binary matrix <code>grid</code>. You are allowed to change <strong>at most one</strong> <code>0</code> to be <code>1</code>.</p><p>Return <em>the size of the largest <strong>island</strong> in</em> <code>grid</code> <em>after applying this operation</em>.</p><p>An <strong>island</strong> is a 4-directionally connected group of <code>1</code>s.</p>',
        "examples": [
            {
                "input": 'grid = [[1,0],[0,1]]',
                "output": '3',
                "explanation": '<p>Change one 0 to 1 and connect two 1s, then we get an island with area = 3.</p>'
            },
            {
                "input": 'grid = [[1,1],[1,0]]',
                "output": '4',
                "explanation": '<p>Change the 0 to 1 to make the island bigger, only one island with area = 4.</p>'
            },
            {
                "input": 'grid = [[1,1],[1,1]]',
                "output": '4',
                "explanation": "<p>Can't change any 0 to 1, only one island with area = 4.</p>"
            }
        ],
        "constraints": [
            '<code>n == grid.length</code>',
            '<code>n == grid[i].length</code>',
            '<code>1 &lt;= n &lt;= 500</code>',
            '<code>grid[i][j]</code> is either <code>0</code> or <code>1</code>.'
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Making A Large Island involves checking all possible solutions. For Union Find problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Union Find problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Making A Large Island\n        Union Find pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Making A Large Island\n     * Union Find pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Making A Large Island\n     * Union Find pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Making A Large Island\n * Union Find pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Making A Large Island leverages disjoint set operations to reduce time complexity. Instead of checking all possibilities, we use Union Find-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for Union Find reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Making A Large Island\n        Union Find pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Making A Large Island\n     * Union Find pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Making A Large Island\n     * Union Find pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Making A Large Island\n * Union Find pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "checking-existence-of-edge-length-limited-paths": {
        "description": '<p>An undirected graph of <code>n</code> nodes is defined by <code>edgeList</code>, where <code>edgeList[i] = [u<sub>i</sub>, v<sub>i</sub>, dis<sub>i</sub>]</code> denotes an edge between nodes <code>u<sub>i</sub></code> and <code>v<sub>i</sub></code> with distance <code>dis<sub>i</sub></code>. Note that there may be <strong>multiple</strong> edges between two nodes.</p><p>Given an array <code>queries</code>, where <code>queries[j] = [p<sub>j</sub>, q<sub>j</sub>, limit<sub>j</sub>]</code>, your task is to determine for each <code>queries[j]</code> whether there is a path between <code>p<sub>j</sub></code> and <code>q<sub>j</sub></code> such that each edge on the path has a distance <strong>strictly less than</strong> <code>limit<sub>j</sub></code>.</p><p>Return <em>a <strong>boolean array</strong></em> <code>answer</code><em>, where</em> <code>answer.length == queries.length</code> <em>and the</em> <code>j<sup>th</sup></code> <em>value of</em> <code>answer</code> <em>is</em> <code>true</code> <em>if there is a path for</em> <code>queries[j]</code> <em>is</em> <code>true</code><em>, and</em> <code>false</code> <em>otherwise</em>.</p>',
        "examples": [
            {
                "input": 'n = 3, edgeList = [[0,1,2],[1,2,4],[2,0,8],[1,0,16]], queries = [[0,1,2],[0,2,5]]',
                "output": '[false,true]',
                "explanation": '<p>The above figure shows the given graph. Note that there are two overlapping edges between 0 and 1 with distances 2 and 16.<br/>For the first query, between 0 and 1 there is no path where each distance is less than 2, thus we return false for this query.<br/>For the second query, there is a path (0 -> 1 -> 2) of two edges with distances less than 5, thus we return true for this query.</p>'
            },
            {
                "input": 'n = 5, edgeList = [[0,1,10],[1,2,5],[2,3,9],[3,4,13]], queries = [[0,4,14],[1,4,13]]',
                "output": '[true,false]',
                "explanation": '<p>The above figure shows the given graph.</p>'
            }
        ],
        "constraints": [
            '<code>2 &lt;= n &lt;= 10<sup>5</sup></code>',
            '<code>1 &lt;= edgeList.length, queries.length &lt;= 10<sup>5</sup></code>',
            '<code>edgeList[i].length == 3</code>',
            '<code>queries[j].length == 3</code>',
            '<code>0 &lt;= u<sub>i</sub>, v<sub>i</sub>, p<sub>j</sub>, q<sub>j</sub> &lt;= n - 1</code>',
            '<code>u<sub>i</sub> != v<sub>i</sub></code>',
            '<code>p<sub>j</sub> != q<sub>j</sub></code>',
            '<code>1 &lt;= dis<sub>i</sub>, limit<sub>j</sub> &lt;= 10<sup>9</sup></code>',
            'There may be <strong>multiple</strong> edges between two nodes.'
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Checking Existence of Edge Length Limited Paths involves checking all possible solutions. For Union Find problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Union Find problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Checking Existence of Edge Length Limited Paths\n        Union Find pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Checking Existence of Edge Length Limited Paths\n     * Union Find pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Checking Existence of Edge Length Limited Paths\n     * Union Find pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Checking Existence of Edge Length Limited Paths\n * Union Find pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Checking Existence of Edge Length Limited Paths leverages disjoint set operations to reduce time complexity. Instead of checking all possibilities, we use Union Find-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for Union Find reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Checking Existence of Edge Length Limited Paths\n        Union Find pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Checking Existence of Edge Length Limited Paths\n     * Union Find pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Checking Existence of Edge Length Limited Paths\n     * Union Find pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Checking Existence of Edge Length Limited Paths\n * Union Find pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "minimize-malware-spread": {
        "description": '<p>You are given a network of <code>n</code> nodes represented as an <code>n x n</code> adjacency matrix <code>graph</code>, where the <code>i<sup>th</sup></code> node is directly connected to the <code>j<sup>th</sup></code> node if <code>graph[i][j] == 1</code>.</p><p>Some nodes <code>initial</code> are initially infected by malware. Whenever two nodes are directly connected, and at least one of those two nodes is infected by malware, both nodes will be infected by malware. This spread of malware will continue until no more nodes can be infected in this manner.</p><p>Suppose <code>M(initial)</code> is the final number of nodes infected with malware in the entire network after the spread of malware stops.</p><p>We will remove <strong>exactly one node</strong> from <code>initial</code>.</p><p>Return <em>the node that, if removed, would minimize</em> <code>M(initial)</code>. If multiple nodes could be removed to minimize <code>M(initial)</code>, return such a node with <strong>the smallest index</strong>.</p><p>Note that if a node was removed from the <code>initial</code> list of infected nodes, it might still be infected later due to the malware spread.</p>',
        "examples": [
            {
                "input": 'graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]',
                "output": '0',
                "explanation": '<p>If we remove node 0, nodes 1 and 2 remain in the graph. Nodes 0 and 1 are infected initially, but node 1 will infect node 0 (since they are connected). Thus the number of infected nodes is M([0,1]) = 2.<br/>If we remove node 1, only node 0 remains infected (it starts infected). Thus the number of infected nodes is M([1]) = 1, which is smaller.</p>'
            },
            {
                "input": 'graph = [[1,0,0],[0,1,0],[0,0,1]], initial = [0,2]',
                "output": '0',
                "explanation": '<p>The graph has three connected components. If we remove either node from the initial list, the number of infected nodes stays the same. We return the smaller index.</p>'
            }
        ],
        "constraints": [
            '<code>n == graph.length</code>',
            '<code>n == graph[i].length</code>',
            '<code>2 &lt;= n &lt;= 300</code>',
            '<code>graph[i][j]</code> is <code>0</code> or <code>1</code>.',
            '<code>graph[i][j] == graph[j][i]</code>',
            '<code>graph[i][i] == 1</code>',
            '<code>1 &lt;= initial.length &lt;= n</code>',
            '<code>0 &lt;= initial[i] &lt;= n - 1</code>',
            'All the integers in <code>initial</code> are <strong>unique</strong>.'
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Minimize Malware Spread involves checking all possible solutions. For Union Find problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Union Find problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Minimize Malware Spread\n        Union Find pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Minimize Malware Spread\n     * Union Find pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Minimize Malware Spread\n     * Union Find pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Minimize Malware Spread\n * Union Find pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Minimize Malware Spread leverages disjoint set operations to reduce time complexity. Instead of checking all possibilities, we use Union Find-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for Union Find reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Minimize Malware Spread\n        Union Find pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Minimize Malware Spread\n     * Union Find pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Minimize Malware Spread\n     * Union Find pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Minimize Malware Spread\n * Union Find pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "critical-connections-in-a-network": {
        "description": '<p>There are <code>n</code> servers numbered from <code>0</code> to <code>n - 1</code> connected by undirected server-to-server <code>connections</code> forming a network where <code>connections[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> represents a connection between servers <code>a<sub>i</sub></code> and <code>b<sub>i</sub></code>. Any server can reach other servers directly or indirectly through the network.</p><p>A <em>critical connection</em> is a connection that, if removed, will make some servers unable to reach some other server.</p><p>Return all critical connections in the network in any order.</p>',
        "examples": [
            {
                "input": 'n = 4, connections = [[0,1],[1,2],[2,0],[1,3]]',
                "output": '[[1,3]]',
                "explanation": '<p>[[3,1]] is also accepted. The only critical connection is the edge connecting nodes 1 and 3.</p>'
            },
            {
                "input": 'n = 2, connections = [[0,1]]',
                "output": '[[0,1]]',
                "explanation": '<p>The single connection is critical.</p>'
            }
        ],
        "constraints": [
            '<code>2 &lt;= n &lt;= 10<sup>5</sup></code>',
            '<code>n - 1 &lt;= connections.length &lt;= 10<sup>5</sup></code>',
            '<code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt;= n - 1</code>',
            '<code>a<sub>i</sub> != b<sub>i</sub></code>',
            'There are no repeated connections.'
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Critical Connections in a Network involves checking all possible solutions. For DFS problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. DFS problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Critical Connections in a Network\n        DFS pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Critical Connections in a Network\n     * DFS pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Critical Connections in a Network\n     * DFS pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Critical Connections in a Network\n * DFS pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Critical Connections in a Network leverages depth-first search graph traversal to reduce time complexity. Instead of checking all possibilities, we use DFS-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for DFS reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Critical Connections in a Network\n        DFS pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Critical Connections in a Network\n     * DFS pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Critical Connections in a Network\n     * DFS pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Critical Connections in a Network\n * DFS pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "dungeon-game": {
        "description": "<p>The demons had captured the princess and imprisoned her in <strong>the bottom-right corner</strong> of a <code>dungeon</code>. The <code>dungeon</code> consists of <code>m x n</code> rooms laid out in a 2D grid. Our valiant knight was initially positioned in <strong>the top-left room</strong> and must fight his way through <code>dungeon</code> to rescue the princess.</p><p>The knight has an initial health point represented by a positive integer. If at any point his health point drops to <code>0</code> or below, he dies immediately.</p><p>Some of the rooms are guarded by demons (represented by negative integers), so the knight loses health upon entering these rooms; other rooms are either empty (represented as 0) or contain magic orbs that increase the knight's health (represented by positive integers).</p><p>To reach the princess as quickly as possible, the knight decides to move only <strong>rightward</strong> or <strong>downward</strong> in each step.</p><p>Return <em>the knight's minimum initial health so that he can rescue the princess</em>.</p><p><strong>Note</strong> that any room can contain threats or power-ups, even the first room the knight enters and the bottom-right room where the princess is imprisoned.</p>",
        "examples": [
            {
                "input": 'dungeon = [[-2,-3,3],[-5,-10,1],[10,30,-5]]',
                "output": '7',
                "explanation": '<p>The initial health of the knight must be at least 7 if he follows the optimal path: RIGHT -> RIGHT -> DOWN -> DOWN.</p>'
            },
            {
                "input": 'dungeon = [[0]]',
                "output": '1',
                "explanation": '<p>The knight starts with 1 health point (minimum possible).</p>'
            }
        ],
        "constraints": [
            '<code>m == dungeon.length</code>',
            '<code>n == dungeon[i].length</code>',
            '<code>1 &lt;= m, n &lt;= 200</code>',
            '<code>-1000 &lt;= dungeon[i][j] &lt;= 1000</code>'
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Dungeon Game involves checking all possible solutions. For 2D DP problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(2^n)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. 2D DP problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Dungeon Game\n        2D DP pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Dungeon Game\n     * 2D DP pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Dungeon Game\n     * 2D DP pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Dungeon Game\n * 2D DP pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Dungeon Game leverages two-dimensional dynamic programming to reduce time complexity. Instead of checking all possibilities, we use 2D DP-specific techniques like memoization to cache subproblem results to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (DP table)\n2. Build up solutions from base cases\n3. For each subproblem:\n   - Check if already computed\n   - If not, compute using previously solved subproblems\n   - Store result for reuse\n4. Return the optimal solution\n\nKey optimizations:\n- Memoization prevents recomputation\n- Bottom-up or top-down approach\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Optimized approach for 2D DP reduces complexity significantly. DP table is filled once, each cell computed in O(1). This optimization transforms the solution from exponential to polynomial.",
                    "spaceExplanation": "DP table stores subproblem results. Space equals number of unique states. Can be further optimized by using rolling arrays if only previous row/state needed."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Dungeon Game\n        2D DP pattern implementation\n        Time: O(n)\n        Space: O(n)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize DP table\n        dp = [0] * (n + 1)\n        dp[0] = 1  # Base case\n        \n        for i in range(1, n + 1):\n            # Compute current state from previous states\n            dp[i] = dp[i-1] + (dp[i-2] if i > 1 else 0)\n        \n        return dp[n]",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Dungeon Game\n     * 2D DP pattern implementation\n     * Time: O(n)\n     * Space: O(n)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize DP array\n        int[] dp = new int[n + 1];\n        dp[0] = 1; // Base case\n        \n        for (int i = 1; i <= n; i++) {\n            // Compute current state from previous states\n            dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n        }\n        \n        return new int[]{dp[n]};\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Dungeon Game\n     * 2D DP pattern implementation\n     * Time: O(n)\n     * Space: O(n)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize DP vector\n        vector<int> dp(n + 1, 0);\n        dp[0] = 1; // Base case\n        \n        for (int i = 1; i <= n; i++) {\n            // Compute current state from previous states\n            dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n        }\n        \n        return {dp[n]};\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Dungeon Game\n * 2D DP pattern implementation\n * Time: O(n)\n * Space: O(n)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize DP array\n    const dp = new Array(n + 1).fill(0);\n    dp[0] = 1; // Base case\n    \n    for (let i = 1; i <= n; i++) {\n        // Compute current state from previous states\n        dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n    }\n    \n    return dp[n];\n};"
                }
            }
        }
    },
    "cherry-pickup": {
        "description": '<p>You are given an <code>n x n</code> <code>grid</code> representing a field of cherries, each cell is one of three possible integers.</p><ul><li><code>0</code> means the cell is empty, so you can pass through,</li><li><code>1</code> means the cell contains a cherry that you can pick up and pass through, or</li><li><code>-1</code> means the cell contains a thorn that blocks your way.</li></ul><p>Return <em>the maximum number of cherries you can collect by following the rules below</em>:</p><ul><li>Starting at the position <code>(0, 0)</code> and reaching <code>(n - 1, n - 1)</code> by moving right or down through valid path cells (cells with value <code>0</code> or <code>1</code>).</li><li>After reaching <code>(n - 1, n - 1)</code>, returning to <code>(0, 0)</code> by moving left or up through valid path cells.</li><li>When passing through a path cell containing a cherry, you pick it up, and the cell becomes an empty cell <code>0</code>.</li><li>If there is no valid path between <code>(0, 0)</code> and <code>(n - 1, n - 1)</code>, then no cherries can be collected.</li></ul>',
        "examples": [
            {
                "input": 'grid = [[0,1,-1],[1,0,-1],[1,1,1]]',
                "output": '5',
                "explanation": '<p>The player started at (0, 0) and went down, down, right right to reach (2, 2).<br/>4 cherries were picked up during this single trip, and the matrix becomes [[0,1,-1],[0,0,-1],[0,0,0]].<br/>Then, the player went left, up, up, left to return home, picking up one more cherry.<br/>The total number of cherries picked up is 5, and this is the maximum possible.</p>'
            },
            {
                "input": 'grid = [[1,1,-1],[1,-1,1],[-1,1,1]]',
                "output": '0',
                "explanation": '<p>It is impossible to reach (n-1, n-1) from (0, 0).</p>'
            }
        ],
        "constraints": [
            '<code>n == grid.length</code>',
            '<code>n == grid[i].length</code>',
            '<code>1 &lt;= n &lt;= 50</code>',
            '<code>grid[i][j]</code> is <code>-1</code>, <code>0</code>, or <code>1</code>.',
            '<code>grid[0][0] != -1</code>',
            '<code>grid[n - 1][n - 1] != -1</code>'
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Cherry Pickup involves checking all possible solutions. For 2D DP problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(2^n)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. 2D DP problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Cherry Pickup\n        2D DP pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Cherry Pickup\n     * 2D DP pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Cherry Pickup\n     * 2D DP pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Cherry Pickup\n * 2D DP pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Cherry Pickup leverages two-dimensional dynamic programming to reduce time complexity. Instead of checking all possibilities, we use 2D DP-specific techniques like memoization to cache subproblem results to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (DP table)\n2. Build up solutions from base cases\n3. For each subproblem:\n   - Check if already computed\n   - If not, compute using previously solved subproblems\n   - Store result for reuse\n4. Return the optimal solution\n\nKey optimizations:\n- Memoization prevents recomputation\n- Bottom-up or top-down approach\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Optimized approach for 2D DP reduces complexity significantly. DP table is filled once, each cell computed in O(1). This optimization transforms the solution from exponential to polynomial.",
                    "spaceExplanation": "DP table stores subproblem results. Space equals number of unique states. Can be further optimized by using rolling arrays if only previous row/state needed."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Cherry Pickup\n        2D DP pattern implementation\n        Time: O(n)\n        Space: O(n)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize DP table\n        dp = [0] * (n + 1)\n        dp[0] = 1  # Base case\n        \n        for i in range(1, n + 1):\n            # Compute current state from previous states\n            dp[i] = dp[i-1] + (dp[i-2] if i > 1 else 0)\n        \n        return dp[n]",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Cherry Pickup\n     * 2D DP pattern implementation\n     * Time: O(n)\n     * Space: O(n)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize DP array\n        int[] dp = new int[n + 1];\n        dp[0] = 1; // Base case\n        \n        for (int i = 1; i <= n; i++) {\n            // Compute current state from previous states\n            dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n        }\n        \n        return new int[]{dp[n]};\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Cherry Pickup\n     * 2D DP pattern implementation\n     * Time: O(n)\n     * Space: O(n)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize DP vector\n        vector<int> dp(n + 1, 0);\n        dp[0] = 1; // Base case\n        \n        for (int i = 1; i <= n; i++) {\n            // Compute current state from previous states\n            dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n        }\n        \n        return {dp[n]};\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Cherry Pickup\n * 2D DP pattern implementation\n * Time: O(n)\n * Space: O(n)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize DP array\n    const dp = new Array(n + 1).fill(0);\n    dp[0] = 1; // Base case\n    \n    for (let i = 1; i <= n; i++) {\n        // Compute current state from previous states\n        dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n    }\n    \n    return dp[n];\n};"
                }
            }
        }
    },
    "stream-of-characters": {
        "description": '<p>Design an algorithm that accepts a stream of characters and checks if a suffix of these characters is a string of a given array of strings <code>words</code>.</p><p>For example, if <code>words = ["abc", "xyz"]</code> and the stream added the four characters (one by one) <code>\'a\'</code>, <code>\'x\'</code>, <code>\'y\'</code>, and <code>\'z\'</code>, your algorithm should detect that the suffix <code>"xyz"</code> of the characters <code>"axyz"</code> matches <code>"xyz"</code> from <code>words</code>.</p><p>Implement the <code>StreamChecker</code> class:</p><ul><li><code>StreamChecker(String[] words)</code> Initializes the object with the strings array <code>words</code>.</li><li><code>boolean query(char letter)</code> Accepts a new character from the stream and returns <code>true</code> if any non-empty suffix from the stream forms a word that is in <code>words</code>.</li></ul>',
        "examples": [
            {
                "input": '["StreamChecker", "query", "query", "query", "query", "query", "query", "query", "query", "query", "query", "query", "query"]\\n[[["cd", "f", "kl"]], ["a"], ["b"], ["c"], ["d"], ["e"], ["f"], ["g"], ["h"], ["i"], ["j"], ["k"], ["l"]]',
                "output": '[null, false, false, false, true, false, true, false, false, false, false, false, true]',
                "explanation": '<p>StreamChecker streamChecker = new StreamChecker(["cd", "f", "kl"]);<br/>streamChecker.query("a"); // return False<br/>streamChecker.query("b"); // return False<br/>streamChecker.query("c"); // return False<br/>streamChecker.query("d"); // return True, because \'cd\' is in the wordlist<br/>streamChecker.query("e"); // return False<br/>streamChecker.query("f"); // return True, because \'f\' is in the wordlist<br/>streamChecker.query("g"); // return False<br/>streamChecker.query("h"); // return False<br/>streamChecker.query("i"); // return False<br/>streamChecker.query("j"); // return False<br/>streamChecker.query("k"); // return False<br/>streamChecker.query("l"); // return True, because \'kl\' is in the wordlist</p>'
            }
        ],
        "constraints": [
            '<code>1 &lt;= words.length &lt;= 2000</code>',
            '<code>1 &lt;= words[i].length &lt;= 200</code>',
            '<code>words[i]</code> consists of lowercase English letters.',
            '<code>letter</code> is a lowercase English letter.',
            'At most <code>4 * 10<sup>4</sup></code> calls will be made to <code>query</code>.'
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Stream of Characters involves checking all possible solutions. For Tries problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Tries problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Stream of Characters\n        Tries pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Stream of Characters\n     * Tries pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Stream of Characters\n     * Tries pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Stream of Characters\n * Tries pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Stream of Characters leverages word prefix tree structure to reduce time complexity. Instead of checking all possibilities, we use Tries-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for Tries reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Stream of Characters\n        Tries pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Stream of Characters\n     * Tries pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Stream of Characters\n     * Tries pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Stream of Characters\n * Tries pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "lfu-cache": {
        "description": '<p>Design and implement a data structure for a <a href="https://en.wikipedia.org/wiki/Least_frequently_used" target="_blank">Least Frequently Used (LFU)</a> cache.</p><p>Implement the <code>LFUCache</code> class:</p><ul><li><code>LFUCache(int capacity)</code> Initializes the object with the <code>capacity</code> of the data structure.</li><li><code>int get(int key)</code> Gets the value of the <code>key</code> if the <code>key</code> exists in the cache. Otherwise, returns <code>-1</code>.</li><li><code>void put(int key, int value)</code> Update the value of the <code>key</code> if present, or inserts the <code>key</code> if not already present. When the cache reaches its <code>capacity</code>, it should invalidate and remove the <strong>least frequently used</strong> key before inserting a new item. For this problem, when there is a <strong>tie</strong> (i.e., two or more keys with the same frequency), the <strong>least recently used</strong> <code>key</code> would be invalidated.</li></ul><p>To determine the least frequently used key, a <strong>use counter</strong> is maintained for each key in the cache. The key with the smallest <strong>use counter</strong> is the least frequently used key.</p><p>When a key is first inserted into the cache, its <strong>use counter</strong> is set to <code>1</code> (due to the <code>put</code> operation). The <strong>use counter</strong> for a key in the cache is incremented either a <code>get</code> or <code>put</code> operation is called on it.</p><p>The functions <code>get</code> and <code>put</code> must each run in <code>O(1)</code> average time complexity.</p>',
        "examples": [
            {
                "input": '["LFUCache", "put", "put", "get", "put", "get", "get", "put", "get", "get", "get"]\\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [3], [4, 4], [1], [3], [4]]',
                "output": '[null, null, null, 1, null, -1, 3, null, -1, 3, 4]',
                "explanation": '<p>// cnt(x) = the use counter for key x<br/>// cache=[] will show the last used order for tiebreakers (leftmost element is  most recent)<br/>LFUCache lfu = new LFUCache(2);<br/>lfu.put(1, 1);   // cache=[1,_], cnt(1)=1<br/>lfu.put(2, 2);   // cache=[2,1], cnt(2)=1, cnt(1)=1<br/>lfu.get(1);      // return 1<br/>                 // cache=[1,2], cnt(2)=1, cnt(1)=2<br/>lfu.put(3, 3);   // 2 is the LFU key because cnt(2)=1 is the smallest, invalidate 2.<br/>                 // cache=[3,1], cnt(3)=1, cnt(1)=2<br/>lfu.get(2);      // return -1 (not found)<br/>lfu.get(3);      // return 3<br/>                 // cache=[3,1], cnt(3)=2, cnt(1)=2<br/>lfu.put(4, 4);   // Both 1 and 3 have the same cnt, but 1 is LRU, invalidate 1.<br/>                 // cache=[4,3], cnt(4)=1, cnt(3)=2<br/>lfu.get(1);      // return -1 (not found)<br/>lfu.get(3);      // return 3<br/>                 // cache=[3,4], cnt(4)=1, cnt(3)=3<br/>lfu.get(4);      // return 4<br/>                 // cache=[4,3], cnt(4)=2, cnt(3)=3</p>'
            }
        ],
        "constraints": [
            '<code>1 &lt;= capacity &lt;= 10<sup>4</sup></code>',
            '<code>0 &lt;= key &lt;= 10<sup>5</sup></code>',
            '<code>0 &lt;= value &lt;= 10<sup>9</sup></code>',
            'At most <code>2 * 10<sup>5</sup></code> calls will be made to <code>get</code> and <code>put</code>.'
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for LFU Cache involves checking all possible solutions. For Design problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Design problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for LFU Cache\n        Design pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for LFU Cache\n     * Design pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for LFU Cache\n     * Design pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for LFU Cache\n * Design pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for LFU Cache leverages data structure design to reduce time complexity. Instead of checking all possibilities, we use Design-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for Design reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for LFU Cache\n        Design pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for LFU Cache\n     * Design pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for LFU Cache\n     * Design pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for LFU Cache\n * Design pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "student-attendance-record-ii": {
        "description": "<p>An attendance record for a student can be represented as a string where each character signifies whether the student was absent, late, or present on that day. The record only contains the following three characters:</p><ul><li><code>'A'</code>: Absent.</li><li><code>'L'</code>: Late.</li><li><code>'P'</code>: Present.</li></ul><p>Any student is eligible for an attendance award if they meet <strong>both</strong> of the following criteria:</p><ul><li>The student was absent (<code>'A'</code>) for <strong>strictly fewer than 2 days total</strong>.</li><li>The student was <strong>never</strong> late (<code>'L'</code>) for <strong>3 or more consecutive</strong> days.</li></ul><p>Given an integer <code>n</code>, return <em>the <strong>number</strong> of possible attendance records of length</em> <code>n</code> <em>that make a student eligible for an attendance award. The answer may be very large, so return it <strong>modulo</strong></em> <code>10<sup>9</sup> + 7</code>.</p>",
        "examples": [
            {
                "input": 'n = 2',
                "output": '8',
                "explanation": '<p>There are 8 records with length 2 that are eligible for an award:<br/>"PP", "AP", "PA", "LP", "PL", "AL", "LA", "LL"<br/>Only "AA" is not eligible because there are 2 absences (there need to be fewer than 2).</p>'
            },
            {
                "input": 'n = 1',
                "output": '3',
                "explanation": '<p>There are 3 records with length 1 that are eligible for an award: "P", "A", "L".</p>'
            },
            {
                "input": 'n = 10101',
                "output": '183236316',
                "explanation": '<p>The number of valid records is extremely large, so return the result modulo 10<sup>9</sup> + 7.</p>'
            }
        ],
        "constraints": [
            '<code>1 &lt;= n &lt;= 10<sup>5</sup></code>'
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Student Attendance Record II involves checking all possible solutions. For DP problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(2^n)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. DP problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Student Attendance Record II\n        DP pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Student Attendance Record II\n     * DP pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Student Attendance Record II\n     * DP pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Student Attendance Record II\n * DP pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Student Attendance Record II leverages dynamic programming optimization to reduce time complexity. Instead of checking all possibilities, we use DP-specific techniques like memoization to cache subproblem results to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (DP table)\n2. Build up solutions from base cases\n3. For each subproblem:\n   - Check if already computed\n   - If not, compute using previously solved subproblems\n   - Store result for reuse\n4. Return the optimal solution\n\nKey optimizations:\n- Memoization prevents recomputation\n- Bottom-up or top-down approach\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(n)",
                    "timeExplanation": "Optimized approach for DP reduces complexity significantly. DP table is filled once, each cell computed in O(1). This optimization transforms the solution from exponential to polynomial.",
                    "spaceExplanation": "DP table stores subproblem results. Space equals number of unique states. Can be further optimized by using rolling arrays if only previous row/state needed."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Student Attendance Record II\n        DP pattern implementation\n        Time: O(n)\n        Space: O(n)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize DP table\n        dp = [0] * (n + 1)\n        dp[0] = 1  # Base case\n        \n        for i in range(1, n + 1):\n            # Compute current state from previous states\n            dp[i] = dp[i-1] + (dp[i-2] if i > 1 else 0)\n        \n        return dp[n]",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Student Attendance Record II\n     * DP pattern implementation\n     * Time: O(n)\n     * Space: O(n)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize DP array\n        int[] dp = new int[n + 1];\n        dp[0] = 1; // Base case\n        \n        for (int i = 1; i <= n; i++) {\n            // Compute current state from previous states\n            dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n        }\n        \n        return new int[]{dp[n]};\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Student Attendance Record II\n     * DP pattern implementation\n     * Time: O(n)\n     * Space: O(n)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize DP vector\n        vector<int> dp(n + 1, 0);\n        dp[0] = 1; // Base case\n        \n        for (int i = 1; i <= n; i++) {\n            // Compute current state from previous states\n            dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n        }\n        \n        return {dp[n]};\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Student Attendance Record II\n * DP pattern implementation\n * Time: O(n)\n * Space: O(n)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize DP array\n    const dp = new Array(n + 1).fill(0);\n    dp[0] = 1; // Base case\n    \n    for (let i = 1; i <= n; i++) {\n        // Compute current state from previous states\n        dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n    }\n    \n    return dp[n];\n};"
                }
            }
        }
    },
    "super-egg-drop": {
        "description": '<p>You are given <code>k</code> identical eggs and you have access to a building with <code>n</code> floors labeled from <code>1</code> to <code>n</code>.</p><p>You know that there exists a floor <code>f</code> where <code>0 &lt;= f &lt;= n</code> such that any egg dropped at a floor <strong>higher</strong> than <code>f</code> will <strong>break</strong>, and any egg dropped <strong>at or below</strong> floor <code>f</code> will <strong>not break</strong>.</p><p>Each move, you may take an unbroken egg and drop it from any floor <code>x</code> (where <code>1 &lt;= x &lt;= n</code>). If the egg breaks, you can no longer use it. However, if the egg does not break, you may <strong>reuse</strong> it in future moves.</p><p>Return <em>the <strong>minimum number of moves</strong> that you need to determine <strong>with certainty</strong> what the value of</em> <code>f</code> is.</p>',
        "examples": [
            {
                "input": 'k = 1, n = 2',
                "output": '2',
                "explanation": '<p>Drop the egg from floor 1. If it breaks, we know that f = 0.<br/>Otherwise, drop the egg from floor 2. If it breaks, we know that f = 1.<br/>If it does not break, then we know f = 2.<br/>Hence, we need at minimum 2 moves to determine with certainty what the value of f is.</p>'
            },
            {
                "input": 'k = 2, n = 6',
                "output": '3',
                "explanation": "<p>One optimal strategy is: Drop on floor 3. If it breaks, drop on floor 1 and then floor 2. If it doesn't break, drop on floor 5 and then floor 4 or 6.</p>"
            },
            {
                "input": 'k = 3, n = 14',
                "output": '4',
                "explanation": '<p>With 3 eggs and 4 moves, we can check up to 14 floors.</p>'
            }
        ],
        "constraints": [
            '<code>1 &lt;= k &lt;= 100</code>',
            '<code>1 &lt;= n &lt;= 10<sup>4</sup></code>'
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Super Egg Drop involves checking all possible solutions. For DP problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(2^n)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. DP problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Super Egg Drop\n        DP pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Super Egg Drop\n     * DP pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Super Egg Drop\n     * DP pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Super Egg Drop\n * DP pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Super Egg Drop leverages dynamic programming optimization to reduce time complexity. Instead of checking all possibilities, we use DP-specific techniques like memoization to cache subproblem results to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (DP table)\n2. Build up solutions from base cases\n3. For each subproblem:\n   - Check if already computed\n   - If not, compute using previously solved subproblems\n   - Store result for reuse\n4. Return the optimal solution\n\nKey optimizations:\n- Memoization prevents recomputation\n- Bottom-up or top-down approach\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(n)",
                    "timeExplanation": "Optimized approach for DP reduces complexity significantly. DP table is filled once, each cell computed in O(1). This optimization transforms the solution from exponential to polynomial.",
                    "spaceExplanation": "DP table stores subproblem results. Space equals number of unique states. Can be further optimized by using rolling arrays if only previous row/state needed."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Super Egg Drop\n        DP pattern implementation\n        Time: O(n)\n        Space: O(n)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize DP table\n        dp = [0] * (n + 1)\n        dp[0] = 1  # Base case\n        \n        for i in range(1, n + 1):\n            # Compute current state from previous states\n            dp[i] = dp[i-1] + (dp[i-2] if i > 1 else 0)\n        \n        return dp[n]",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Super Egg Drop\n     * DP pattern implementation\n     * Time: O(n)\n     * Space: O(n)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize DP array\n        int[] dp = new int[n + 1];\n        dp[0] = 1; // Base case\n        \n        for (int i = 1; i <= n; i++) {\n            // Compute current state from previous states\n            dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n        }\n        \n        return new int[]{dp[n]};\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Super Egg Drop\n     * DP pattern implementation\n     * Time: O(n)\n     * Space: O(n)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize DP vector\n        vector<int> dp(n + 1, 0);\n        dp[0] = 1; // Base case\n        \n        for (int i = 1; i <= n; i++) {\n            // Compute current state from previous states\n            dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n        }\n        \n        return {dp[n]};\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Super Egg Drop\n * DP pattern implementation\n * Time: O(n)\n * Space: O(n)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize DP array\n    const dp = new Array(n + 1).fill(0);\n    dp[0] = 1; // Base case\n    \n    for (let i = 1; i <= n; i++) {\n        // Compute current state from previous states\n        dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n    }\n    \n    return dp[n];\n};"
                }
            }
        }
    },
    "range-sum-query-mutable": {
        "description": '<p>Given an integer array <code>nums</code>, handle multiple queries of the following types:</p><ol><li><strong>Update</strong> the value of an element in <code>nums</code>.</li><li>Calculate the <strong>sum</strong> of the elements of <code>nums</code> between indices <code>left</code> and <code>right</code> <strong>inclusive</strong> where <code>left &lt;= right</code>.</li></ol><p>Implement the <code>NumArray</code> class:</p><ul><li><code>NumArray(int[] nums)</code> Initializes the object with the integer array <code>nums</code>.</li><li><code>void update(int index, int val)</code> <strong>Updates</strong> the value of <code>nums[index]</code> to be <code>val</code>.</li><li><code>int sumRange(int left, int right)</code> Returns the <strong>sum</strong> of the elements of <code>nums</code> between indices <code>left</code> and <code>right</code> <strong>inclusive</strong> (i.e., <code>nums[left] + nums[left + 1] + ... + nums[right]</code>).</li></ul>',
        "examples": [
            {
                "input": '["NumArray", "sumRange", "update", "sumRange"]\\n[[[1, 3, 5]], [0, 2], [1, 2], [0, 2]]',
                "output": '[null, 9, null, 8]',
                "explanation": '<p>NumArray numArray = new NumArray([1, 3, 5]);<br/>numArray.sumRange(0, 2); // return 1 + 3 + 5 = 9<br/>numArray.update(1, 2);   // nums = [1, 2, 5]<br/>numArray.sumRange(0, 2); // return 1 + 2 + 5 = 8</p>'
            }
        ],
        "constraints": [
            '<code>1 &lt;= nums.length &lt;= 3 * 10<sup>4</sup></code>',
            '<code>-100 &lt;= nums[i] &lt;= 100</code>',
            '<code>0 &lt;= index &lt; nums.length</code>',
            '<code>-100 &lt;= val &lt;= 100</code>',
            '<code>0 &lt;= left &lt;= right &lt; nums.length</code>',
            'At most <code>3 * 10<sup>4</sup></code> calls will be made to <code>update</code> and <code>sumRange</code>.'
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Range Sum Query - Mutable involves checking all possible solutions. For Tree Hard problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Tree Hard problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Range Sum Query - Mutable\n        Tree Hard pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Range Sum Query - Mutable\n     * Tree Hard pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Range Sum Query - Mutable\n     * Tree Hard pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Range Sum Query - Mutable\n * Tree Hard pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Range Sum Query - Mutable leverages complex tree transformations to reduce time complexity. Instead of checking all possibilities, we use Tree Hard-specific techniques like efficient traversal with pruning to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (tree structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Pruning impossible branches\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(h)",
                    "timeExplanation": "Optimized approach for Tree Hard reduces complexity significantly. Tree traversal visits each node exactly once. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Recursion stack depth equals tree height. Balanced tree gives O(log n). Can be further optimized by using iterative approach instead of recursion."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Range Sum Query - Mutable\n        Tree Hard pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Range Sum Query - Mutable\n     * Tree Hard pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Range Sum Query - Mutable\n     * Tree Hard pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Range Sum Query - Mutable\n * Tree Hard pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "count-range-sum": {
        "description": '<p>Given an integer array <code>nums</code> and two integers <code>lower</code> and <code>upper</code>, return <em>the number of range sums that lie in</em> <code>[lower, upper]</code> <em>inclusive</em>.</p><p>Range sum <code>S(i, j)</code> is defined as the sum of the elements in <code>nums</code> between indices <code>i</code> and <code>j</code> inclusive, where <code>i &lt;= j</code>.</p>',
        "examples": [
            {
                "input": 'nums = [-2,5,-1], lower = -2, upper = 2',
                "output": '3',
                "explanation": '<p>The three ranges are: [0,0], [2,2], and [0,2] and their respective sums are: -2, -1, 2.</p>'
            },
            {
                "input": 'nums = [0], lower = 0, upper = 0',
                "output": '1',
                "explanation": '<p>The only range sum is [0,0] which equals 0.</p>'
            }
        ],
        "constraints": [
            '<code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code>',
            '<code>-2<sup>31</sup> &lt;= nums[i] &lt;= 2<sup>31</sup> - 1</code>',
            '<code>-10<sup>5</sup> &lt;= lower &lt;= upper &lt;= 10<sup>5</sup></code>',
            'The answer is <strong>guaranteed</strong> to fit in a <strong>32-bit</strong> integer.'
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Count Range Sum involves checking all possible solutions. For Tree Hard problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Tree Hard problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Count Range Sum\n        Tree Hard pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Count Range Sum\n     * Tree Hard pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Count Range Sum\n     * Tree Hard pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Count Range Sum\n * Tree Hard pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Count Range Sum leverages complex tree transformations to reduce time complexity. Instead of checking all possibilities, we use Tree Hard-specific techniques like efficient traversal with pruning to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (tree structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Pruning impossible branches\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(h)",
                    "timeExplanation": "Optimized approach for Tree Hard reduces complexity significantly. Tree traversal visits each node exactly once. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Recursion stack depth equals tree height. Balanced tree gives O(log n). Can be further optimized by using iterative approach instead of recursion."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Count Range Sum\n        Tree Hard pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Count Range Sum\n     * Tree Hard pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Count Range Sum\n     * Tree Hard pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Count Range Sum\n * Tree Hard pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "queue-reconstruction-by-height": {
        "description": '<p>You are given an array of people, <code>people</code>, which are the attributes of some people in a queue (not necessarily in order). Each <code>people[i] = [h<sub>i</sub>, k<sub>i</sub>]</code> represents the <code>i<sup>th</sup></code> person of height <code>h<sub>i</sub></code> with <strong>exactly</strong> <code>k<sub>i</sub></code> other people in front who have a height greater than or equal to <code>h<sub>i</sub></code>.</p><p>Reconstruct and return <em>the queue that is represented by the input array</em> <code>people</code>. The returned queue should be formatted as an array <code>queue</code>, where <code>queue[j] = [h<sub>j</sub>, k<sub>j</sub>]</code> is the attributes of the <code>j<sup>th</sup></code> person in the queue (<code>queue[0]</code> is the person at the front of the queue).</p>',
        "examples": [
            {
                "input": 'people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]',
                "output": '[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]',
                "explanation": '<p>Person 0 has height 5 with no other people taller or the same height in front.<br/>Person 1 has height 7 with no other people taller or the same height in front.<br/>Person 2 has height 5 with two persons taller or the same height in front, which is person 0 and 1.<br/>Person 3 has height 6 with one person taller or the same height in front, which is person 1.<br/>Person 4 has height 4 with four people taller or the same height in front, which are person 0, 1, 2, and 3.<br/>Person 5 has height 7 with one person taller or the same height in front, which is person 1.<br/>Hence [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] is the reconstructed queue.</p>'
            },
            {
                "input": 'people = [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]',
                "output": '[[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]]',
                "explanation": '<p>The reconstructed queue satisfies all the k<sub>i</sub> constraints.</p>'
            }
        ],
        "constraints": [
            '<code>1 &lt;= people.length &lt;= 2000</code>',
            '<code>0 &lt;= h<sub>i</sub> &lt;= 10<sup>6</sup></code>',
            '<code>0 &lt;= k<sub>i</sub> &lt; people.length</code>',
            'It is guaranteed that the queue can be reconstructed.'
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Queue Reconstruction by Height involves checking all possible solutions. For Greedy problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Greedy problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Queue Reconstruction by Height\n        Greedy pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Queue Reconstruction by Height\n     * Greedy pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Queue Reconstruction by Height\n     * Greedy pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Queue Reconstruction by Height\n * Greedy pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Queue Reconstruction by Height leverages greedy choice optimization to reduce time complexity. Instead of checking all possibilities, we use Greedy-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Make locally optimal choices\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Local optimal choices lead to global optimum\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for Greedy reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Only constant extra space needed for pointers and variables. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Queue Reconstruction by Height\n        Greedy pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Queue Reconstruction by Height\n     * Greedy pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Queue Reconstruction by Height\n     * Greedy pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Queue Reconstruction by Height\n * Greedy pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "design-skiplist": {
        "description": '<p>Design a <strong>Skiplist</strong> without using any built-in libraries.</p><p>A <strong>skiplist</strong> is a data structure that takes <code>O(log(n))</code> time to add, erase and search. Comparing with treap and red-black tree which has the same function and performance, the code length of Skiplist can be comparatively short and the idea behind Skiplists is just simple linked lists.</p><p>For example, we have a Skiplist containing <code>[30,40,50,60,70,90]</code> and we want to add <code>80</code> and <code>45</code> into it. The Skiplist works this way:</p><p>You can see there are many layers in the Skiplist. Each layer is a sorted linked list. With the help of the top layers, add, erase and search can be faster than <code>O(n)</code>. It can be proven that the average time complexity for each operation is <code>O(log(n))</code> and space complexity is <code>O(n)</code>.</p><p>See more about Skiplist: <a href="https://en.wikipedia.org/wiki/Skip_list" target="_blank">https://en.wikipedia.org/wiki/Skip_list</a></p><p>Implement the <code>Skiplist</code> class:</p><ul><li><code>Skiplist()</code> Initializes the object of the skiplist.</li><li><code>bool search(int target)</code> Returns <code>true</code> if the integer <code>target</code> exists in the Skiplist or <code>false</code> otherwise.</li><li><code>void add(int num)</code> Inserts the value <code>num</code> into the SkipList.</li><li><code>bool erase(int num)</code> Removes the value <code>num</code> from the Skiplist and returns <code>true</code>. If <code>num</code> does not exist in the Skiplist, do nothing and return <code>false</code>. If there exist multiple <code>num</code> values, removing any one of them is fine.</li></ul><p>Note that duplicates may exist in the Skiplist, your code needs to handle this situation.</p>',
        "examples": [
            {
                "input": '["Skiplist", "add", "add", "add", "search", "add", "search", "erase", "erase", "search"]\\n[[], [1], [2], [3], [0], [4], [1], [0], [1], [1]]',
                "output": '[null, null, null, null, false, null, true, false, true, false]',
                "explanation": '<p>Skiplist skiplist = new Skiplist();<br/>skiplist.add(1);<br/>skiplist.add(2);<br/>skiplist.add(3);<br/>skiplist.search(0); // return False<br/>skiplist.add(4);<br/>skiplist.search(1); // return True<br/>skiplist.erase(0);  // return False, 0 is not in skiplist.<br/>skiplist.erase(1);  // return True<br/>skiplist.search(1); // return False, 1 has already been erased.</p>'
            }
        ],
        "constraints": [
            '<code>0 &lt;= num, target &lt;= 2 * 10<sup>4</sup></code>',
            'At most <code>5 * 10<sup>4</sup></code> calls will be made to <code>search</code>, <code>add</code>, and <code>erase</code>.'
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Design Skiplist involves checking all possible solutions. For Design problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Design problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Design Skiplist\n        Design pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Design Skiplist\n     * Design pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Design Skiplist\n     * Design pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Design Skiplist\n * Design pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Design Skiplist leverages data structure design to reduce time complexity. Instead of checking all possibilities, we use Design-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for Design reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Design Skiplist\n        Design pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Design Skiplist\n     * Design pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Design Skiplist\n     * Design pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Design Skiplist\n * Design pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "all-o-one-data-structure": {
        "description": '<p>Design a data structure to store the strings\' count with the ability to return the strings with minimum and maximum counts.</p><p>Implement the <code>AllOne</code> class:</p><ul><li><code>AllOne()</code> Initializes the object of the data structure.</li><li><code>inc(String key)</code> Increments the count of the string <code>key</code> by <code>1</code>. If <code>key</code> does not exist in the data structure, insert it with count <code>1</code>.</li><li><code>dec(String key)</code> Decrements the count of the string <code>key</code> by <code>1</code>. If the count of <code>key</code> is <code>0</code> after the decrement, remove it from the data structure. It is guaranteed that <code>key</code> exists in the data structure before the decrement.</li><li><code>getMaxKey()</code> Returns one of the keys with the maximal count. If no element exists, return an empty string <code>""</code>.</li><li><code>getMinKey()</code> Returns one of the keys with the minimum count. If no element exists, return an empty string <code>""</code>.</li></ul><p><strong>Note</strong> that each function must run in <code>O(1)</code> average time complexity.</p>',
        "examples": [
            {
                "input": '["AllOne", "inc", "inc", "getMaxKey", "getMinKey", "inc", "getMaxKey", "getMinKey"]\\n[[], ["hello"], ["hello"], [], [], ["leet"], [], []]',
                "output": '[null, null, null, "hello", "hello", null, "hello", "leet"]',
                "explanation": '<p>AllOne allOne = new AllOne();<br/>allOne.inc("hello");<br/>allOne.inc("hello");<br/>allOne.getMaxKey(); // return "hello"<br/>allOne.getMinKey(); // return "hello"<br/>allOne.inc("leet");<br/>allOne.getMaxKey(); // return "hello"<br/>allOne.getMinKey(); // return "leet"</p>'
            }
        ],
        "constraints": [
            "<code>1 &lt;= key.length &lt;= 10</code>",
            "<code>key</code> consists of lowercase English letters.",
            "It is guaranteed that for each call to <code>dec</code>, <code>key</code> is existing in the data structure.",
            "At most <code>5 * 10<sup>4</sup></code> calls will be made to <code>inc</code>, <code>dec</code>, <code>getMaxKey</code>, and <code>getMinKey</code>."
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for All O`one Data Structure involves checking all possible solutions. For Design problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Design problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for All O`one Data Structure\n        Design pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for All O`one Data Structure\n     * Design pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for All O`one Data Structure\n     * Design pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for All O`one Data Structure\n * Design pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for All O`one Data Structure leverages data structure design to reduce time complexity. Instead of checking all possibilities, we use Design-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for Design reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for All O`one Data Structure\n        Design pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for All O`one Data Structure\n     * Design pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for All O`one Data Structure\n     * Design pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for All O`one Data Structure\n * Design pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "design-in-memory-file-system": {
        "description": "<p>Design a data structure that simulates an in-memory file system.</p><p>Implement the FileSystem class:</p><ul><li><code>FileSystem()</code> Initializes the object of the system.</li><li><code>List&lt;String&gt; ls(String path)</code><ul><li>If <code>path</code> is a file path, returns a list that only contains this file's name.</li><li>If <code>path</code> is a directory path, returns the list of file and directory names <strong>in this directory</strong>.</li></ul>The answer should in <strong>lexicographic order</strong>.</li><li><code>void mkdir(String path)</code> Makes a new directory according to the given <code>path</code>. The given directory path does not exist. If the middle directories in the path do not exist, you should create them as well.</li><li><code>void addContentToFile(String filePath, String content)</code><ul><li>If <code>filePath</code> does not exist, creates that file containing given <code>content</code>.</li><li>If <code>filePath</code> already exists, appends the given <code>content</code> to original content.</li></ul></li><li><code>String readContentFromFile(String filePath)</code> Returns the content in the file at <code>filePath</code>.</li></ul>",
        "examples": [
            {
                "input": '["FileSystem", "ls", "mkdir", "addContentToFile", "ls", "readContentFromFile"]\\n[[], ["/"], ["/a/b/c"], ["/a/b/c/d", "hello"], ["/"], ["/a/b/c/d"]]',
                "output": '[null, [], null, null, ["a"], "hello"]',
                "explanation": '<p>FileSystem fileSystem = new FileSystem();<br/>fileSystem.ls("/");                         // return []<br/>fileSystem.mkdir("/a/b/c");<br/>fileSystem.addContentToFile("/a/b/c/d", "hello");<br/>fileSystem.ls("/");                         // return ["a"]<br/>fileSystem.readContentFromFile("/a/b/c/d"); // return "hello"</p>'
            }
        ],
        "constraints": [
            '<code>1 &lt;= path.length, filePath.length &lt;= 100</code>',
            '<code>path</code> and <code>filePath</code> are absolute paths which begin with <code>\'/\'</code> and do not end with <code>\'/\'</code> except that the path is just <code>"/"</code>.',
            'You can assume that all directory names and file names only contain lowercase letters, and the same names will not exist in the same directory.',
            'You can assume that all operations will be passed valid parameters, and users will not attempt to retrieve file content or list a directory or file that does not exist.',
            '<code>1 &lt;= content.length &lt;= 50</code>',
            'At most <code>300</code> calls will be made to <code>ls</code>, <code>mkdir</code>, <code>addContentToFile</code>, and <code>readContentFromFile</code>.'
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Design In-Memory File System involves checking all possible solutions. For Design problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Design problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Design In-Memory File System\n        Design pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Design In-Memory File System\n     * Design pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Design In-Memory File System\n     * Design pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Design In-Memory File System\n * Design pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Design In-Memory File System leverages data structure design to reduce time complexity. Instead of checking all possibilities, we use Design-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for Design reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Design In-Memory File System\n        Design pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Design In-Memory File System\n     * Design pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Design In-Memory File System\n     * Design pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Design In-Memory File System\n * Design pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "maximum-frequency-stack": {
        "description": "<p>Design a stack-like data structure to push elements to the stack and pop the most frequent element from the stack.</p><p>Implement the <code>FreqStack</code> class:</p><ul><li><code>FreqStack()</code> constructs an empty frequency stack.</li><li><code>void push(int val)</code> pushes an integer <code>val</code> onto the top of the stack.</li><li><code>int pop()</code> removes and returns the most frequent element in the stack.<ul><li>If there is a tie for the most frequent element, the element closest to the stack's top is removed and returned.</li></ul></li></ul>",
        "examples": [
            {
                "input": '["FreqStack", "push", "push", "push", "push", "push", "push", "pop", "pop", "pop", "pop"]\\n[[], [5], [7], [5], [7], [4], [5], [], [], [], []]',
                "output": '[null, null, null, null, null, null, null, 5, 7, 5, 4]',
                "explanation": '<p>FreqStack freqStack = new FreqStack();<br/>freqStack.push(5); // The stack is [5]<br/>freqStack.push(7); // The stack is [5,7]<br/>freqStack.push(5); // The stack is [5,7,5]<br/>freqStack.push(7); // The stack is [5,7,5,7]<br/>freqStack.push(4); // The stack is [5,7,5,7,4]<br/>freqStack.push(5); // The stack is [5,7,5,7,4,5]<br/>freqStack.pop();   // return 5, as 5 is the most frequent. The stack becomes [5,7,5,7,4].<br/>freqStack.pop();   // return 7, as 5 and 7 is the most frequent, but 7 is closest to the top. The stack becomes [5,7,5,4].<br/>freqStack.pop();   // return 5, as 5 is the most frequent. The stack becomes [5,7,4].<br/>freqStack.pop();   // return 4, as 4, 5 and 7 is the most frequent, but 4 is closest to the top. The stack becomes [5,7].</p>'
            }
        ],
        "constraints": [
            '<code>0 &lt;= val &lt;= 10<sup>9</sup></code>',
            'At most <code>2 * 10<sup>4</sup></code> calls will be made to <code>push</code> and <code>pop</code>.',
            'It is guaranteed that there will be at least one element in the stack before calling <code>pop</code>.'
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Maximum Frequency Stack involves checking all possible solutions. For Stack problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Stack problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Maximum Frequency Stack\n        Stack pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Maximum Frequency Stack\n     * Stack pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Maximum Frequency Stack\n     * Stack pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Maximum Frequency Stack\n * Stack pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Maximum Frequency Stack leverages stack-based operations to reduce time complexity. Instead of checking all possibilities, we use Stack-specific techniques like stack/queue for optimal state management to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (stack)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Efficient state management\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for Stack reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Maximum Frequency Stack\n        Stack pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Stack for state management\n        stack = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Maximum Frequency Stack\n     * Stack pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Stack for state management\n        Stack<Integer> stack = new Stack<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Maximum Frequency Stack\n     * Stack pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Stack for state management\n        stack<int> st;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Maximum Frequency Stack\n * Stack pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Stack for state management\n    const stack = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "shortest-subarray-with-sum-at-least-k": {
        "description": '<p>Given an integer array <code>nums</code> and an integer <code>k</code>, return <em>the length of the shortest non-empty <strong>subarray</strong> of</em> <code>nums</code> <em>with a sum of at least</em> <code>k</code>. If there is no such <strong>subarray</strong>, return <code>-1</code>.</p><p>A <strong>subarray</strong> is a <strong>contiguous</strong> part of an array.</p>',
        "examples": [
            {
                "input": 'nums = [1], k = 1',
                "output": '1',
                "explanation": '<p>The shortest subarray with sum at least 1 is [1].</p>'
            },
            {
                "input": 'nums = [1,2], k = 4',
                "output": '-1',
                "explanation": '<p>No subarray has sum at least 4.</p>'
            },
            {
                "input": 'nums = [2,-1,2], k = 3',
                "output": '3',
                "explanation": '<p>The shortest subarray with sum at least 3 is [2,-1,2].</p>'
            }
        ],
        "constraints": [
            '<code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code>',
            '<code>-10<sup>5</sup> &lt;= nums[i] &lt;= 10<sup>5</sup></code>',
            '<code>1 &lt;= k &lt;= 10<sup>9</sup></code>'
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Shortest Subarray with Sum at Least K involves checking all possible solutions. For Monotonic Queue problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Monotonic Queue problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Shortest Subarray with Sum at Least K\n        Monotonic Queue pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Shortest Subarray with Sum at Least K\n     * Monotonic Queue pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Shortest Subarray with Sum at Least K\n     * Monotonic Queue pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Shortest Subarray with Sum at Least K\n * Monotonic Queue pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Shortest Subarray with Sum at Least K leverages monotonic queue optimization to reduce time complexity. Instead of checking all possibilities, we use Monotonic Queue-specific techniques like stack/queue for optimal state management to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Efficient state management\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for Monotonic Queue reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Shortest Subarray with Sum at Least K\n        Monotonic Queue pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Shortest Subarray with Sum at Least K\n     * Monotonic Queue pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Shortest Subarray with Sum at Least K\n     * Monotonic Queue pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Shortest Subarray with Sum at Least K\n * Monotonic Queue pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "minimum-number-of-refueling-stops": {
        "description": '<p>A car travels from a starting position to a destination which is <code>target</code> miles east of the starting position.</p><p>There are gas stations along the way. The gas stations are represented as an array <code>stations</code> where <code>stations[i] = [position<sub>i</sub>, fuel<sub>i</sub>]</code> indicates that the <code>i<sup>th</sup></code> gas station is <code>position<sub>i</sub></code> miles east of the starting position and has <code>fuel<sub>i</sub></code> liters of gas.</p><p>The car starts with an infinite tank of gas, which initially has <code>startFuel</code> liters of fuel in it. It uses one liter of gas per one mile that it drives. When the car reaches a gas station, it may stop and refuel, transferring all the gas from the station into the car.</p><p>Return <em>the minimum number of refueling stops the car must make in order to reach its destination</em>. If it cannot reach the destination, return <code>-1</code>.</p><p>Note that if the car reaches a gas station with <code>0</code> fuel left, the car can still refuel there. If the car reaches the destination with <code>0</code> fuel left, it is still considered to have arrived.</p>',
        "examples": [
            {
                "input": 'target = 1, startFuel = 1, stations = []',
                "output": '0',
                "explanation": '<p>We can reach the target without refueling.</p>'
            },
            {
                "input": 'target = 100, startFuel = 1, stations = [[10,100]]',
                "output": '-1',
                "explanation": '<p>We can not reach the target (or even the first gas station).</p>'
            },
            {
                "input": 'target = 100, startFuel = 10, stations = [[10,60],[20,30],[30,30],[60,40]]',
                "output": '2',
                "explanation": '<p>We start with 10 liters of fuel.<br/>We drive to position 10, expending 10 liters of fuel.  We refuel from 0 liters to 60 liters of gas.<br/>Then, we drive from position 10 to position 60 (expending 50 liters of fuel),<br/>and refuel from 10 liters to 50 liters of gas.  We then drive to and reach the target.<br/>We made 2 refueling stops along the way, so we return 2.</p>'
            }
        ],
        "constraints": [
            '<code>1 &lt;= target, startFuel &lt;= 10<sup>9</sup></code>',
            '<code>0 &lt;= stations.length &lt;= 500</code>',
            '<code>1 &lt;= position<sub>i</sub> &lt; position<sub>i+1</sub> &lt; target</code>',
            '<code>1 &lt;= fuel<sub>i</sub> &lt; 10<sup>9</sup></code>'
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Minimum Number of Refueling Stops involves checking all possible solutions. For DP problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(2^n)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. DP problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Minimum Number of Refueling Stops\n        DP pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Minimum Number of Refueling Stops\n     * DP pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Minimum Number of Refueling Stops\n     * DP pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Minimum Number of Refueling Stops\n * DP pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Minimum Number of Refueling Stops leverages dynamic programming optimization to reduce time complexity. Instead of checking all possibilities, we use DP-specific techniques like memoization to cache subproblem results to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (DP table)\n2. Build up solutions from base cases\n3. For each subproblem:\n   - Check if already computed\n   - If not, compute using previously solved subproblems\n   - Store result for reuse\n4. Return the optimal solution\n\nKey optimizations:\n- Memoization prevents recomputation\n- Bottom-up or top-down approach\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(n)",
                    "timeExplanation": "Optimized approach for DP reduces complexity significantly. DP table is filled once, each cell computed in O(1). This optimization transforms the solution from exponential to polynomial.",
                    "spaceExplanation": "DP table stores subproblem results. Space equals number of unique states. Can be further optimized by using rolling arrays if only previous row/state needed."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Minimum Number of Refueling Stops\n        DP pattern implementation\n        Time: O(n)\n        Space: O(n)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize DP table\n        dp = [0] * (n + 1)\n        dp[0] = 1  # Base case\n        \n        for i in range(1, n + 1):\n            # Compute current state from previous states\n            dp[i] = dp[i-1] + (dp[i-2] if i > 1 else 0)\n        \n        return dp[n]",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Minimum Number of Refueling Stops\n     * DP pattern implementation\n     * Time: O(n)\n     * Space: O(n)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize DP array\n        int[] dp = new int[n + 1];\n        dp[0] = 1; // Base case\n        \n        for (int i = 1; i <= n; i++) {\n            // Compute current state from previous states\n            dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n        }\n        \n        return new int[]{dp[n]};\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Minimum Number of Refueling Stops\n     * DP pattern implementation\n     * Time: O(n)\n     * Space: O(n)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize DP vector\n        vector<int> dp(n + 1, 0);\n        dp[0] = 1; // Base case\n        \n        for (int i = 1; i <= n; i++) {\n            // Compute current state from previous states\n            dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n        }\n        \n        return {dp[n]};\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Minimum Number of Refueling Stops\n * DP pattern implementation\n * Time: O(n)\n * Space: O(n)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize DP array\n    const dp = new Array(n + 1).fill(0);\n    dp[0] = 1; // Base case\n    \n    for (let i = 1; i <= n; i++) {\n        // Compute current state from previous states\n        dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n    }\n    \n    return dp[n];\n};"
                }
            }
        }
    },
    "profitable-schemes": {
        "description": "<p>There is a group of <code>n</code> members, and a list of various crimes they could commit. The <code>i<sup>th</sup></code> crime generates a <code>profit[i]</code> and requires <code>group[i]</code> members to participate in it. If a member participates in one crime, that member can't participate in another crime.</p><p>Let's call a <strong>profitable scheme</strong> any subset of these crimes that generates at least <code>minProfit</code> profit, and the total number of members participating in that subset of crimes is at most <code>n</code>.</p><p>Return the number of schemes that can be chosen. Since the answer may be very large, <strong>return it modulo</strong> <code>10<sup>9</sup> + 7</code>.</p>",
        "examples": [
            {
                "input": 'n = 5, minProfit = 3, group = [2,2], profit = [2,3]',
                "output": '2',
                "explanation": '<p>To make a profit of at least 3, the group could either commit crimes 0 and 1, or just crime 1.<br/>In total, there are 2 schemes.</p>'
            },
            {
                "input": 'n = 10, minProfit = 5, group = [2,3,5], profit = [6,7,8]',
                "output": '7',
                "explanation": '<p>To make a profit of at least 5, the group could commit any crimes, as long as they commit one.<br/>There are 7 possible schemes: (0), (1), (2), (0,1), (0,2), (1,2), and (0,1,2).</p>'
            }
        ],
        "constraints": [
            '<code>1 &lt;= n &lt;= 100</code>',
            '<code>0 &lt;= minProfit &lt;= 100</code>',
            '<code>1 &lt;= group.length &lt;= 100</code>',
            '<code>1 &lt;= group[i] &lt;= 100</code>',
            '<code>profit.length == group.length</code>',
            '<code>0 &lt;= profit[i] &lt;= 100</code>'
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Profitable Schemes involves checking all possible solutions. For DP problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(2^n)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. DP problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Profitable Schemes\n        DP pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Profitable Schemes\n     * DP pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Profitable Schemes\n     * DP pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Profitable Schemes\n * DP pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Profitable Schemes leverages dynamic programming optimization to reduce time complexity. Instead of checking all possibilities, we use DP-specific techniques like memoization to cache subproblem results to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (DP table)\n2. Build up solutions from base cases\n3. For each subproblem:\n   - Check if already computed\n   - If not, compute using previously solved subproblems\n   - Store result for reuse\n4. Return the optimal solution\n\nKey optimizations:\n- Memoization prevents recomputation\n- Bottom-up or top-down approach\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(n)",
                    "timeExplanation": "Optimized approach for DP reduces complexity significantly. DP table is filled once, each cell computed in O(1). This optimization transforms the solution from exponential to polynomial.",
                    "spaceExplanation": "DP table stores subproblem results. Space equals number of unique states. Can be further optimized by using rolling arrays if only previous row/state needed."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Profitable Schemes\n        DP pattern implementation\n        Time: O(n)\n        Space: O(n)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize DP table\n        dp = [0] * (n + 1)\n        dp[0] = 1  # Base case\n        \n        for i in range(1, n + 1):\n            # Compute current state from previous states\n            dp[i] = dp[i-1] + (dp[i-2] if i > 1 else 0)\n        \n        return dp[n]",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Profitable Schemes\n     * DP pattern implementation\n     * Time: O(n)\n     * Space: O(n)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize DP array\n        int[] dp = new int[n + 1];\n        dp[0] = 1; // Base case\n        \n        for (int i = 1; i <= n; i++) {\n            // Compute current state from previous states\n            dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n        }\n        \n        return new int[]{dp[n]};\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Profitable Schemes\n     * DP pattern implementation\n     * Time: O(n)\n     * Space: O(n)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize DP vector\n        vector<int> dp(n + 1, 0);\n        dp[0] = 1; // Base case\n        \n        for (int i = 1; i <= n; i++) {\n            // Compute current state from previous states\n            dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n        }\n        \n        return {dp[n]};\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Profitable Schemes\n * DP pattern implementation\n * Time: O(n)\n * Space: O(n)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize DP array\n    const dp = new Array(n + 1).fill(0);\n    dp[0] = 1; // Base case\n    \n    for (let i = 1; i <= n; i++) {\n        // Compute current state from previous states\n        dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n    }\n    \n    return dp[n];\n};"
                }
            }
        }
    },
    "tallest-billboard": {
        "description": '<p>You are installing a billboard and want it to have the largest height. The billboard will have two steel supports, one on each side. Each steel support must be an equal height.</p><p>You are given a collection of <code>rods</code> that can be welded together. For example, if you have rods of lengths <code>1</code>, <code>2</code>, and <code>3</code>, you can weld them together to make a support of length <code>6</code>.</p><p>Return <em>the largest possible height of your billboard installation</em>. If you cannot support the billboard, return <code>0</code>.</p>',
        "examples": [
            {
                "input": 'rods = [1,2,3,6]',
                "output": '6',
                "explanation": '<p>We have two disjoint subsets {1,2,3} and {6}, which have the same sum = 6.</p>'
            },
            {
                "input": 'rods = [1,2,3,4,5,6]',
                "output": '10',
                "explanation": '<p>We have two disjoint subsets {2,3,5} and {4,6}, which have the same sum = 10.</p>'
            },
            {
                "input": 'rods = [1,2]',
                "output": '0',
                "explanation": '<p>The billboard cannot be supported, so we return 0.</p>'
            }
        ],
        "constraints": [
            '<code>1 &lt;= rods.length &lt;= 20</code>',
            '<code>1 &lt;= rods[i] &lt;= 1000</code>',
            '<code>sum(rods[i]) &lt;= 5000</code>'
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Tallest Billboard involves checking all possible solutions. For DP problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(2^n)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. DP problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Tallest Billboard\n        DP pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Tallest Billboard\n     * DP pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Tallest Billboard\n     * DP pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Tallest Billboard\n * DP pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Tallest Billboard leverages dynamic programming optimization to reduce time complexity. Instead of checking all possibilities, we use DP-specific techniques like memoization to cache subproblem results to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (DP table)\n2. Build up solutions from base cases\n3. For each subproblem:\n   - Check if already computed\n   - If not, compute using previously solved subproblems\n   - Store result for reuse\n4. Return the optimal solution\n\nKey optimizations:\n- Memoization prevents recomputation\n- Bottom-up or top-down approach\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(n)",
                    "timeExplanation": "Optimized approach for DP reduces complexity significantly. DP table is filled once, each cell computed in O(1). This optimization transforms the solution from exponential to polynomial.",
                    "spaceExplanation": "DP table stores subproblem results. Space equals number of unique states. Can be further optimized by using rolling arrays if only previous row/state needed."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Tallest Billboard\n        DP pattern implementation\n        Time: O(n)\n        Space: O(n)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize DP table\n        dp = [0] * (n + 1)\n        dp[0] = 1  # Base case\n        \n        for i in range(1, n + 1):\n            # Compute current state from previous states\n            dp[i] = dp[i-1] + (dp[i-2] if i > 1 else 0)\n        \n        return dp[n]",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Tallest Billboard\n     * DP pattern implementation\n     * Time: O(n)\n     * Space: O(n)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize DP array\n        int[] dp = new int[n + 1];\n        dp[0] = 1; // Base case\n        \n        for (int i = 1; i <= n; i++) {\n            // Compute current state from previous states\n            dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n        }\n        \n        return new int[]{dp[n]};\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Tallest Billboard\n     * DP pattern implementation\n     * Time: O(n)\n     * Space: O(n)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize DP vector\n        vector<int> dp(n + 1, 0);\n        dp[0] = 1; // Base case\n        \n        for (int i = 1; i <= n; i++) {\n            // Compute current state from previous states\n            dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n        }\n        \n        return {dp[n]};\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Tallest Billboard\n * DP pattern implementation\n * Time: O(n)\n * Space: O(n)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize DP array\n    const dp = new Array(n + 1).fill(0);\n    dp[0] = 1; // Base case\n    \n    for (let i = 1; i <= n; i++) {\n        // Compute current state from previous states\n        dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n    }\n    \n    return dp[n];\n};"
                }
            }
        }
    },
    "partition-array-into-two-arrays-to-minimize-sum-difference": {
        "description": '<p>You are given an integer array <code>nums</code> of <code>2 * n</code> integers. You need to partition <code>nums</code> into <strong>two</strong> arrays of length <code>n</code> to <strong>minimize the absolute difference</strong> of the <strong>sums</strong> of the arrays. To partition <code>nums</code>, put each element of <code>nums</code> into <strong>one</strong> of the two arrays.</p><p>Return <em>the <strong>minimum</strong> possible absolute difference</em>.</p>',
        "examples": [
            {
                "input": 'nums = [3,9,7,3]',
                "output": '2',
                "explanation": '<p>One optimal partition is: [3,9] and [7,3].<br/>The absolute difference between the sums of the arrays is abs((3 + 9) - (7 + 3)) = 2.</p>'
            },
            {
                "input": 'nums = [-36,36]',
                "output": '72',
                "explanation": '<p>One optimal partition is: [-36] and [36].<br/>The absolute difference between the sums of the arrays is abs((-36) - (36)) = 72.</p>'
            },
            {
                "input": 'nums = [2,-1,0,4,-2,-9]',
                "output": '0',
                "explanation": '<p>One optimal partition is: [2,4,-9] and [-1,0,-2].<br/>The absolute difference between the sums of the arrays is abs((2 + 4 + -9) - (-1 + 0 + -2)) = 0.</p>'
            }
        ],
        "constraints": [
            '<code>1 &lt;= n &lt;= 15</code>',
            '<code>nums.length == 2 * n</code>',
            '<code>-10<sup>7</sup> &lt;= nums[i] &lt;= 10<sup>7</sup></code>'
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Partition Array Into Two Arrays to Minimize Sum Difference involves checking all possible solutions. For Bitmask / State DP problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(2^n)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Bitmask / State DP problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Partition Array Into Two Arrays to Minimize Sum Difference\n        Bitmask / State DP pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Partition Array Into Two Arrays to Minimize Sum Difference\n     * Bitmask / State DP pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Partition Array Into Two Arrays to Minimize Sum Difference\n     * Bitmask / State DP pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Partition Array Into Two Arrays to Minimize Sum Difference\n * Bitmask / State DP pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Partition Array Into Two Arrays to Minimize Sum Difference leverages bitmask dynamic programming to reduce time complexity. Instead of checking all possibilities, we use Bitmask / State DP-specific techniques like memoization to cache subproblem results to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (DP table)\n2. Build up solutions from base cases\n3. For each subproblem:\n   - Check if already computed\n   - If not, compute using previously solved subproblems\n   - Store result for reuse\n4. Return the optimal solution\n\nKey optimizations:\n- Memoization prevents recomputation\n- Bottom-up or top-down approach\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(n)",
                    "timeExplanation": "Optimized approach for Bitmask / State DP reduces complexity significantly. DP table is filled once, each cell computed in O(1). This optimization transforms the solution from exponential to polynomial.",
                    "spaceExplanation": "DP table stores subproblem results. Space equals number of unique states. Can be further optimized by using rolling arrays if only previous row/state needed."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Partition Array Into Two Arrays to Minimize Sum Difference\n        Bitmask / State DP pattern implementation\n        Time: O(n)\n        Space: O(n)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize DP table\n        dp = [0] * (n + 1)\n        dp[0] = 1  # Base case\n        \n        for i in range(1, n + 1):\n            # Compute current state from previous states\n            dp[i] = dp[i-1] + (dp[i-2] if i > 1 else 0)\n        \n        return dp[n]",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Partition Array Into Two Arrays to Minimize Sum Difference\n     * Bitmask / State DP pattern implementation\n     * Time: O(n)\n     * Space: O(n)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize DP array\n        int[] dp = new int[n + 1];\n        dp[0] = 1; // Base case\n        \n        for (int i = 1; i <= n; i++) {\n            // Compute current state from previous states\n            dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n        }\n        \n        return new int[]{dp[n]};\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Partition Array Into Two Arrays to Minimize Sum Difference\n     * Bitmask / State DP pattern implementation\n     * Time: O(n)\n     * Space: O(n)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize DP vector\n        vector<int> dp(n + 1, 0);\n        dp[0] = 1; // Base case\n        \n        for (int i = 1; i <= n; i++) {\n            // Compute current state from previous states\n            dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n        }\n        \n        return {dp[n]};\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Partition Array Into Two Arrays to Minimize Sum Difference\n * Bitmask / State DP pattern implementation\n * Time: O(n)\n * Space: O(n)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize DP array\n    const dp = new Array(n + 1).fill(0);\n    dp[0] = 1; // Base case\n    \n    for (let i = 1; i <= n; i++) {\n        // Compute current state from previous states\n        dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n    }\n    \n    return dp[n];\n};"
                }
            }
        }
    },
    "smallest-sufficient-team": {
        "description": '<p>In a project, you have a list of required skills <code>req_skills</code>, and a list of people. The <code>i<sup>th</sup></code> person <code>people[i]</code> contains a list of skills that the person has.</p><p>Consider a sufficient team: a set of people such that for every required skill in <code>req_skills</code>, there is at least one person in the team who has that skill. We can represent these teams by the index of each person.</p><ul><li>For example, <code>team = [0, 1, 3]</code> represents the people with skills <code>people[0]</code>, <code>people[1]</code>, and <code>people[3]</code>.</li></ul><p>Return <em>any sufficient team of the smallest possible size, represented by the index of each person</em>. You may return the answer in <strong>any order</strong>.</p><p>It is <strong>guaranteed</strong> an answer exists.</p>',
        "examples": [
            {
                "input": 'req_skills = ["java","nodejs","reactjs"], people = [["java"],["nodejs"],["nodejs","reactjs"]]',
                "output": '[0,2]',
                "explanation": '<p>Person 0 has java skill, person 2 has nodejs and reactjs skills. Together they cover all required skills.</p>'
            },
            {
                "input": 'req_skills = ["algorithms","math","java","reactjs","csharp","aws"], people = [["algorithms","math","java"],["algorithms","math","reactjs"],["java","csharp","aws"],["reactjs","csharp"],["csharp","math"],["aws","java"]]',
                "output": '[1,2]',
                "explanation": '<p>Person 1 has algorithms, math, and reactjs. Person 2 has java, csharp, and aws. Together they cover all required skills.</p>'
            }
        ],
        "constraints": [
            '<code>1 &lt;= req_skills.length &lt;= 16</code>',
            '<code>1 &lt;= req_skills[i].length &lt;= 16</code>',
            '<code>req_skills[i]</code> consists of lowercase English letters.',
            'All the strings of <code>req_skills</code> are <strong>unique</strong>.',
            '<code>1 &lt;= people.length &lt;= 60</code>',
            '<code>0 &lt;= people[i].length &lt;= 16</code>',
            '<code>1 &lt;= people[i][j].length &lt;= 16</code>',
            '<code>people[i][j]</code> consists of lowercase English letters.',
            'All the strings of <code>people[i]</code> are <strong>unique</strong>.',
            'Every skill in <code>people[i]</code> is a skill in <code>req_skills</code>.',
            'It is guaranteed a sufficient team exists.'
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Smallest Sufficient Team involves checking all possible solutions. For Bitmask / State DP problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(2^n)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Bitmask / State DP problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Smallest Sufficient Team\n        Bitmask / State DP pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Smallest Sufficient Team\n     * Bitmask / State DP pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Smallest Sufficient Team\n     * Bitmask / State DP pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Smallest Sufficient Team\n * Bitmask / State DP pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Smallest Sufficient Team leverages bitmask dynamic programming to reduce time complexity. Instead of checking all possibilities, we use Bitmask / State DP-specific techniques like memoization to cache subproblem results to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (DP table)\n2. Build up solutions from base cases\n3. For each subproblem:\n   - Check if already computed\n   - If not, compute using previously solved subproblems\n   - Store result for reuse\n4. Return the optimal solution\n\nKey optimizations:\n- Memoization prevents recomputation\n- Bottom-up or top-down approach\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(n)",
                    "timeExplanation": "Optimized approach for Bitmask / State DP reduces complexity significantly. DP table is filled once, each cell computed in O(1). This optimization transforms the solution from exponential to polynomial.",
                    "spaceExplanation": "DP table stores subproblem results. Space equals number of unique states. Can be further optimized by using rolling arrays if only previous row/state needed."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Smallest Sufficient Team\n        Bitmask / State DP pattern implementation\n        Time: O(n)\n        Space: O(n)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize DP table\n        dp = [0] * (n + 1)\n        dp[0] = 1  # Base case\n        \n        for i in range(1, n + 1):\n            # Compute current state from previous states\n            dp[i] = dp[i-1] + (dp[i-2] if i > 1 else 0)\n        \n        return dp[n]",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Smallest Sufficient Team\n     * Bitmask / State DP pattern implementation\n     * Time: O(n)\n     * Space: O(n)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize DP array\n        int[] dp = new int[n + 1];\n        dp[0] = 1; // Base case\n        \n        for (int i = 1; i <= n; i++) {\n            // Compute current state from previous states\n            dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n        }\n        \n        return new int[]{dp[n]};\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Smallest Sufficient Team\n     * Bitmask / State DP pattern implementation\n     * Time: O(n)\n     * Space: O(n)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize DP vector\n        vector<int> dp(n + 1, 0);\n        dp[0] = 1; // Base case\n        \n        for (int i = 1; i <= n; i++) {\n            // Compute current state from previous states\n            dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n        }\n        \n        return {dp[n]};\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Smallest Sufficient Team\n * Bitmask / State DP pattern implementation\n * Time: O(n)\n * Space: O(n)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize DP array\n    const dp = new Array(n + 1).fill(0);\n    dp[0] = 1; // Base case\n    \n    for (let i = 1; i <= n; i++) {\n        // Compute current state from previous states\n        dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n    }\n    \n    return dp[n];\n};"
                }
            }
        }
    },
    "maximum-score-words-formed-by-letters": {
        "description": "<p>Given a list of <code>words</code>, list of  single <code>letters</code> (might be repeating) and <code>score</code> of every character.</p><p>Return the maximum score of <strong>any</strong> valid set of words formed by using the given letters (<code>words[i]</code> cannot be used two or more times).</p><p>It is not necessary to use all characters in <code>letters</code> and each letter can only be used once. Score of letters <code>'a'</code>, <code>'b'</code>, <code>'c'</code>, ... ,<code>'z'</code> is given by <code>score[0]</code>, <code>score[1]</code>, ... , <code>score[25]</code> respectively.</p>",
        "examples": [
            {
                "input": 'words = ["dog","cat","dad","good"], letters = ["a","a","c","d","d","d","g","o","o"], score = [1,0,9,5,0,0,3,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0]',
                "output": '23',
                "explanation": '<p>Score  a=1, c=9, d=5, g=3, o=2<br/>Given letters, we can form the words "dad" (5+1+5) and "good" (3+2+2+5) with a score of 23.<br/>Words "dad" and "dog" only get a score of 21.</p>'
            },
            {
                "input": 'words = ["xxxz","ax","bx","cx"], letters = ["z","a","b","c","x","x","x"], score = [4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,0,10]',
                "output": '27',
                "explanation": '<p>Score  a=4, b=4, c=4, x=5, z=10<br/>Given letters, we can form the words "ax" (4+5), "bx" (4+5) and "cx" (4+5) with a score of 27.<br/>Word "xxxz" only get a score of 25.</p>'
            },
            {
                "input": 'words = ["leetcode"], letters = ["l","e","t","c","o","d"], score = [0,0,1,1,1,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0]',
                "output": '0',
                "explanation": '<p>Letter "e" can only be used once.</p>'
            }
        ],
        "constraints": [
            '<code>1 &lt;= words.length &lt;= 14</code>',
            '<code>1 &lt;= words[i].length &lt;= 15</code>',
            '<code>1 &lt;= letters.length &lt;= 100</code>',
            '<code>letters[i].length == 1</code>',
            '<code>score.length == 26</code>',
            '<code>0 &lt;= score[i] &lt;= 10</code>',
            '<code>words[i]</code>, <code>letters[i]</code> contain only lowercase English letters.'
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Maximum Score Words Formed by Letters involves checking all possible solutions. For Bitmask / State DP problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(2^n)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Bitmask / State DP problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Maximum Score Words Formed by Letters\n        Bitmask / State DP pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Maximum Score Words Formed by Letters\n     * Bitmask / State DP pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Maximum Score Words Formed by Letters\n     * Bitmask / State DP pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Maximum Score Words Formed by Letters\n * Bitmask / State DP pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Maximum Score Words Formed by Letters leverages bitmask dynamic programming to reduce time complexity. Instead of checking all possibilities, we use Bitmask / State DP-specific techniques like memoization to cache subproblem results to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (DP table)\n2. Build up solutions from base cases\n3. For each subproblem:\n   - Check if already computed\n   - If not, compute using previously solved subproblems\n   - Store result for reuse\n4. Return the optimal solution\n\nKey optimizations:\n- Memoization prevents recomputation\n- Bottom-up or top-down approach\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(n)",
                    "timeExplanation": "Optimized approach for Bitmask / State DP reduces complexity significantly. DP table is filled once, each cell computed in O(1). This optimization transforms the solution from exponential to polynomial.",
                    "spaceExplanation": "DP table stores subproblem results. Space equals number of unique states. Can be further optimized by using rolling arrays if only previous row/state needed."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Maximum Score Words Formed by Letters\n        Bitmask / State DP pattern implementation\n        Time: O(n)\n        Space: O(n)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize DP table\n        dp = [0] * (n + 1)\n        dp[0] = 1  # Base case\n        \n        for i in range(1, n + 1):\n            # Compute current state from previous states\n            dp[i] = dp[i-1] + (dp[i-2] if i > 1 else 0)\n        \n        return dp[n]",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Maximum Score Words Formed by Letters\n     * Bitmask / State DP pattern implementation\n     * Time: O(n)\n     * Space: O(n)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize DP array\n        int[] dp = new int[n + 1];\n        dp[0] = 1; // Base case\n        \n        for (int i = 1; i <= n; i++) {\n            // Compute current state from previous states\n            dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n        }\n        \n        return new int[]{dp[n]};\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Maximum Score Words Formed by Letters\n     * Bitmask / State DP pattern implementation\n     * Time: O(n)\n     * Space: O(n)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize DP vector\n        vector<int> dp(n + 1, 0);\n        dp[0] = 1; // Base case\n        \n        for (int i = 1; i <= n; i++) {\n            // Compute current state from previous states\n            dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n        }\n        \n        return {dp[n]};\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Maximum Score Words Formed by Letters\n * Bitmask / State DP pattern implementation\n * Time: O(n)\n * Space: O(n)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize DP array\n    const dp = new Array(n + 1).fill(0);\n    dp[0] = 1; // Base case\n    \n    for (let i = 1; i <= n; i++) {\n        // Compute current state from previous states\n        dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n    }\n    \n    return dp[n];\n};"
                }
            }
        }
    },
    "find-the-shortest-superstring": {
        "description": "<p>Given an array of strings <code>words</code>, return <em>the smallest string that contains each string in</em> <code>words</code> <em>as a substring</em>. If there are multiple valid strings of the smallest length, return <strong>any of them</strong>.</p><p>You may assume that no string in <code>words</code> is a substring of another string in <code>words</code>.</p>",
        "examples": [{"input": "words = [\"alex\",\"loves\",\"leetcode\"]\", \"output\": \"\"alexlovesleetcode\"\", \"explanation\": \"<p>All permutations of \"alex\",\"loves\",\"leetcode\" would also be accepted.</p>\"}, {\"input\": \"words = [\"catg\",\"ctaagt\",\"gcta\",\"ttca\",\"atgcatc\"]\", \"output\": \"\"gctaagttcatgcatc\"\", \"explanation\": \"<p>This is the shortest superstring containing all words as substrings.</p>"}],
        "constraints": ["<code>1 &lt;= words.length &lt;= 12</code>", "<code>1 &lt;= words[i].length &lt;= 20</code>", "<code>words[i]</code> consists of lowercase English letters.", "All the strings of <code>words</code> are <strong>unique</strong>."],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Find the Shortest Superstring involves checking all possible solutions. For Bitmask / State DP problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(2^n)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Bitmask / State DP problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Find the Shortest Superstring\n        Bitmask / State DP pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Find the Shortest Superstring\n     * Bitmask / State DP pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Find the Shortest Superstring\n     * Bitmask / State DP pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Find the Shortest Superstring\n * Bitmask / State DP pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Find the Shortest Superstring leverages bitmask dynamic programming to reduce time complexity. Instead of checking all possibilities, we use Bitmask / State DP-specific techniques like memoization to cache subproblem results to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (DP table)\n2. Build up solutions from base cases\n3. For each subproblem:\n   - Check if already computed\n   - If not, compute using previously solved subproblems\n   - Store result for reuse\n4. Return the optimal solution\n\nKey optimizations:\n- Memoization prevents recomputation\n- Bottom-up or top-down approach\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(n)",
                    "timeExplanation": "Optimized approach for Bitmask / State DP reduces complexity significantly. DP table is filled once, each cell computed in O(1). This optimization transforms the solution from exponential to polynomial.",
                    "spaceExplanation": "DP table stores subproblem results. Space equals number of unique states. Can be further optimized by using rolling arrays if only previous row/state needed."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Find the Shortest Superstring\n        Bitmask / State DP pattern implementation\n        Time: O(n)\n        Space: O(n)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize DP table\n        dp = [0] * (n + 1)\n        dp[0] = 1  # Base case\n        \n        for i in range(1, n + 1):\n            # Compute current state from previous states\n            dp[i] = dp[i-1] + (dp[i-2] if i > 1 else 0)\n        \n        return dp[n]",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Find the Shortest Superstring\n     * Bitmask / State DP pattern implementation\n     * Time: O(n)\n     * Space: O(n)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize DP array\n        int[] dp = new int[n + 1];\n        dp[0] = 1; // Base case\n        \n        for (int i = 1; i <= n; i++) {\n            // Compute current state from previous states\n            dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n        }\n        \n        return new int[]{dp[n]};\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Find the Shortest Superstring\n     * Bitmask / State DP pattern implementation\n     * Time: O(n)\n     * Space: O(n)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize DP vector\n        vector<int> dp(n + 1, 0);\n        dp[0] = 1; // Base case\n        \n        for (int i = 1; i <= n; i++) {\n            // Compute current state from previous states\n            dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n        }\n        \n        return {dp[n]};\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Find the Shortest Superstring\n * Bitmask / State DP pattern implementation\n * Time: O(n)\n * Space: O(n)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize DP array\n    const dp = new Array(n + 1).fill(0);\n    dp[0] = 1; // Base case\n    \n    for (let i = 1; i <= n; i++) {\n        // Compute current state from previous states\n        dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n    }\n    \n    return dp[n];\n};"
                }
            }
        }
    },
    "determine-if-two-strings-are-close": {
        "description": "<p>Two strings are considered <strong>close</strong> if you can attain one from the other using the following operations:</p><ul><li>Operation 1: Swap any two <strong>existing</strong> characters.<ul><li>For example, <code>a<u>b</u>cd<u>e</u> -&gt; a<u>e</u>cd<u>b</u></code></li></ul></li><li>Operation 2: Transform <strong>every</strong> occurrence of one <strong>existing</strong> character into another <strong>existing</strong> character, and do the same with the other character.<ul><li>For example, <code><u>aa</u>c<u>abb</u> -&gt; <u>bb</u>c<u>baa</u></code> (all <code>a</code>'s turn into <code>b</code>'s, and all <code>b</code>'s turn into <code>a</code>'s)</li></ul></li></ul><p>You can use the operations on either string as many times as necessary.</p><p>Given two strings, <code>word1</code> and <code>word2</code>, return <code>true</code> <em>if</em> <code>word1</code> <em>and</em> <code>word2</code> <em>are <strong>close</strong>, and</em> <code>false</code> <em>otherwise.</em></p>",
        "examples": [{"input": "word1 = \"abc\", word2 = \"bca\"\", \"output\": \"true\", \"explanation\": \"<p>You can attain word2 from word1 in 2 operations.<br/>Apply Operation 1: \"a<u>bc</u>\" -&gt; \"a<u>cb</u>\"<br/>Apply Operation 1: \"<u>a</u>c<u>b</u>\" -&gt; \"<u>b</u>c<u>a</u>\"</p>\"}, {\"input\": \"word1 = \"a\", word2 = \"aa\"\", \"output\": \"false\", \"explanation\": \"<p>It is impossible to attain word2 from word1, or vice versa, in any number of operations.</p>\"}, {\"input\": \"word1 = \"cabbba\", word2 = \"abbccc\"\", \"output\": \"true\", \"explanation\": \"<p>You can attain word2 from word1 in 3 operations.<br/>Apply Operation 1: \"ca<u>b</u>bb<u>a</u>\" -&gt; \"ca<u>a</u>bb<u>b</u>\"<br/>Apply Operation 2: \"<u>c</u>aa<u>bbb</u>\" -&gt; \"<u>b</u>aa<u>ccc</u>\"<br/>Apply Operation 2: \"<u>baa</u>ccc\" -&gt; \"<u>abb</u>ccc\"</p>"}],
        "constraints": ["<code>1 &lt;= word1.length, word2.length &lt;= 10<sup>5</sup></code>", "<code>word1</code> and <code>word2</code> contain only lowercase English letters."],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Determine if Two Strings Are Close involves checking all possible solutions. For Strings problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Strings problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Determine if Two Strings Are Close\n        Strings pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Determine if Two Strings Are Close\n     * Strings pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Determine if Two Strings Are Close\n     * Strings pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Determine if Two Strings Are Close\n * Strings pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Determine if Two Strings Are Close leverages string manipulation algorithms to reduce time complexity. Instead of checking all possibilities, we use Strings-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for Strings reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Determine if Two Strings Are Close\n        Strings pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Determine if Two Strings Are Close\n     * Strings pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Determine if Two Strings Are Close\n     * Strings pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Determine if Two Strings Are Close\n * Strings pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "minimum-deletions-to-make-character-frequencies-unique": {
        "description": "<p>A string <code>s</code> is called <strong>good</strong> if there are no two different characters in <code>s</code> that have the same <strong>frequency</strong>.</p><p>Given a string <code>s</code>, return <em>the <strong>minimum</strong> number of characters you need to delete to make</em> <code>s</code> <em><strong>good</strong>.</em></p><p>The <strong>frequency</strong> of a character in a string is the number of times it appears in the string. For example, in the string <code>\"aab\"</code>, the <strong>frequency</strong> of <code>'a'</code> is <code>2</code>, while the <strong>frequency</strong> of <code>'b'</code> is <code>1</code>.</p>",
        "examples": [{"input": "s = \"aab\"", "output": "0", "explanation": "<p><code>s</code> is already good.</p>"}, {"input": "s = \"aaabbbcc\"", "output": "2"}, {"input": "s = \"ceabaacb\"", "output": "2"}],
        "constraints": ["<code>1 &lt;= s.length &lt;= 10<sup>5</sup></code>", "<code>s</code> contains only lowercase English letters."],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Minimum Deletions to Make Character Frequencies Unique involves checking all possible solutions. For Greedy problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Greedy problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Minimum Deletions to Make Character Frequencies Unique\n        Greedy pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Minimum Deletions to Make Character Frequencies Unique\n     * Greedy pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Minimum Deletions to Make Character Frequencies Unique\n     * Greedy pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Minimum Deletions to Make Character Frequencies Unique\n * Greedy pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Minimum Deletions to Make Character Frequencies Unique leverages greedy choice optimization to reduce time complexity. Instead of checking all possibilities, we use Greedy-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Make locally optimal choices\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Local optimal choices lead to global optimum\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for Greedy reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Only constant extra space needed for pointers and variables. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Minimum Deletions to Make Character Frequencies Unique\n        Greedy pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Minimum Deletions to Make Character Frequencies Unique\n     * Greedy pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Minimum Deletions to Make Character Frequencies Unique\n     * Greedy pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Minimum Deletions to Make Character Frequencies Unique\n * Greedy pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "minimum-rounds-to-complete-all-tasks": {
        "description": "<p>You are given a <strong>0-indexed</strong> integer array <code>tasks</code>, where <code>tasks[i]</code> represents the difficulty level of a task. In each round, you can complete either 2 or 3 tasks of the <strong>same difficulty level</strong>.</p><p>Return <em>the <strong>minimum</strong> rounds required to complete all the tasks, or</em> <code>-1</code> <em>if it is not possible to complete all the tasks.</em></p>",
        "examples": [{"input": "tasks = [2,2,3,3,2,4,4,4,4,4]", "output": "4", "explanation": "<p>To complete all the tasks, a possible plan is:<br/>- In the first round, you complete 3 tasks of difficulty level 2. <br/>- In the second round, you complete 2 tasks of difficulty level 3. <br/>- In the third round, you complete 3 tasks of difficulty level 4. <br/>- In the fourth round, you complete 2 tasks of difficulty level 4.  <br/>It can be shown that all the tasks cannot be completed in fewer than 4 rounds, so the answer is 4.</p>"}, {"input": "tasks = [2,3,3]", "output": "-1", "explanation": "<p>There is only 1 task of difficulty level 2, but in each round, you can only complete either 2 or 3 tasks of the same difficulty level. Hence, you cannot complete all the tasks, and the answer is -1.</p>"}],
        "constraints": ["<code>1 &lt;= tasks.length &lt;= 10<sup>5</sup></code>", "<code>1 &lt;= tasks[i] &lt;= 10<sup>9</sup></code>"],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Minimum Rounds to Complete All Tasks involves checking all possible solutions. For Hash Tables problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Hash Tables problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Minimum Rounds to Complete All Tasks\n        Hash Tables pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Minimum Rounds to Complete All Tasks\n     * Hash Tables pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Minimum Rounds to Complete All Tasks\n     * Hash Tables pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Minimum Rounds to Complete All Tasks\n * Hash Tables pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Minimum Rounds to Complete All Tasks leverages hash table operations to reduce time complexity. Instead of checking all possibilities, we use Hash Tables-specific techniques like hash tables for O(1) lookups to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (hash map)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Hash lookups are O(1)\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(n)",
                    "timeExplanation": "Optimized approach for Hash Tables reduces complexity significantly. Hash table provides O(1) lookup, single pass through data. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Hash table stores seen elements for O(1) lookup. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Minimum Rounds to Complete All Tasks\n        Hash Tables pattern implementation\n        Time: O(n)\n        Space: O(n)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Use hash table for O(1) lookups\n        seen = {}\n        \n        for i, val in enumerate(input):\n            complement = target - val\n            if complement in seen:\n                return [seen[complement], i]\n            seen[val] = i\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Minimum Rounds to Complete All Tasks\n     * Hash Tables pattern implementation\n     * Time: O(n)\n     * Space: O(n)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Use HashMap for O(1) lookups\n        Map<Integer, Integer> seen = new HashMap<>();\n        \n        for (int i = 0; i < n; i++) {\n            int complement = target - input[i];\n            if (seen.containsKey(complement)) {\n                return new int[]{seen.get(complement), i};\n            }\n            seen.put(input[i], i);\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Minimum Rounds to Complete All Tasks\n     * Hash Tables pattern implementation\n     * Time: O(n)\n     * Space: O(n)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Use unordered_map for O(1) lookups\n        unordered_map<int, int> seen;\n        \n        for (int i = 0; i < n; i++) {\n            int complement = target - input[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[input[i]] = i;\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Minimum Rounds to Complete All Tasks\n * Hash Tables pattern implementation\n * Time: O(n)\n * Space: O(n)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Use Map for O(1) lookups\n    const seen = new Map();\n    \n    for (let i = 0; i < n; i++) {\n        const complement = target - input[i];\n        if (seen.has(complement)) {\n            return [seen.get(complement), i];\n        }\n        seen.set(input[i], i);\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "number-of-zero-filled-subarrays": {
        "description": "<p>Given an integer array <code>nums</code>, return <em>the number of <strong>subarrays</strong> filled with </em><code>0</code>.</p><p>A <strong>subarray</strong> is a contiguous non-empty sequence of elements within an array.</p>",
        "examples": [{"input": "nums = [1,3,0,0,2,0,0,4]", "output": "6", "explanation": "<p>There are 4 occurrences of [0] as a subarray.<br/>There are 2 occurrences of [0,0] as a subarray.<br/>There is no occurrence of a subarray with a size more than 2 filled with 0. Therefore, we return 6.</p>"}, {"input": "nums = [0,0,0,2,0,0]", "output": "9", "explanation": "<p>There are 5 occurrences of [0] as a subarray.<br/>There are 3 occurrences of [0,0] as a subarray.<br/>There is 1 occurrence of [0,0,0] as a subarray.<br/>There is no occurrence of a subarray with a size more than 3 filled with 0. Therefore, we return 9.</p>"}, {"input": "nums = [2,10,2019]", "output": "0", "explanation": "<p>There is no subarray filled with 0. Therefore, we return 0.</p>"}],
        "constraints": ["<code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code>", "<code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code>"],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Number of Zero-Filled Subarrays involves checking all possible solutions. For Two Pointers problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Two Pointers problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Number of Zero-Filled Subarrays\n        Two Pointers pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Number of Zero-Filled Subarrays\n     * Two Pointers pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Number of Zero-Filled Subarrays\n     * Two Pointers pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Number of Zero-Filled Subarrays\n * Two Pointers pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Number of Zero-Filled Subarrays leverages two-pointer technique optimization to reduce time complexity. Instead of checking all possibilities, we use Two Pointers-specific techniques like two pointers to avoid nested loops to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Place pointers at strategic positions\n3. While pointers haven't crossed:\n   - Process current elements\n   - Move pointers based on logic\n   - Update result\n4. Return the optimal solution\n\nKey optimizations:\n- Single pass instead of nested loops\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for Two Pointers reduces complexity significantly. Two pointers traverse array once without backtracking. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Only constant extra space needed for pointers and variables. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Number of Zero-Filled Subarrays\n        Two Pointers pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Two pointer approach\n        left, right = 0, n - 1\n        \n        while left < right:\n            # Process current elements\n            if condition(input[left], input[right]):\n                result.append([left, right])\n                left += 1\n            else:\n                right -= 1\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Number of Zero-Filled Subarrays\n     * Two Pointers pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Two pointer approach\n        int left = 0, right = n - 1;\n        \n        while (left < right) {\n            // Process current elements\n            if (condition(input[left], input[right])) {\n                result.add(left);\n                result.add(right);\n                left++;\n            } else {\n                right--;\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Number of Zero-Filled Subarrays\n     * Two Pointers pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Two pointer approach\n        int left = 0, right = n - 1;\n        \n        while (left < right) {\n            // Process current elements\n            if (condition(input[left], input[right])) {\n                result.push_back(left);\n                result.push_back(right);\n                left++;\n            } else {\n                right--;\n            }\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Number of Zero-Filled Subarrays\n * Two Pointers pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Two pointer approach\n    let left = 0, right = n - 1;\n    \n    while (left < right) {\n        // Process current elements\n        if (condition(input[left], input[right])) {\n            result.push(left, right);\n            left++;\n        } else {\n            right--;\n        }\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "optimal-partition-of-string": {
        "description": "<p>Given a string <code>s</code>, partition the string into one or more <strong>substrings</strong> such that the characters in each substring are <strong>unique</strong>. That is, no letter appears in a single substring more than <strong>once</strong>.</p><p>Return <em>the <strong>minimum</strong> number of substrings in such a partition.</em></p><p>Note that each character should belong to exactly one substring in a partition.</p>",
        "examples": [{"input": "s = \"abacaba\"", "output": "4", "explanation": "<p>Two possible partitions are (\"a"}, {"input": "s = \"ssssss\"", "output": "6", "explanation": "<p>The only valid partition is (\"s"}],
        "constraints": ["<code>1 &lt;= s.length &lt;= 10<sup>5</sup></code>", "<code>s</code> consists of only English lowercase letters."],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Optimal Partition of String involves checking all possible solutions. For Strings problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Strings problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Optimal Partition of String\n        Strings pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Optimal Partition of String\n     * Strings pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Optimal Partition of String\n     * Strings pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Optimal Partition of String\n * Strings pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Optimal Partition of String leverages string manipulation algorithms to reduce time complexity. Instead of checking all possibilities, we use Strings-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for Strings reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Optimal Partition of String\n        Strings pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Optimal Partition of String\n     * Strings pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Optimal Partition of String\n     * Strings pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Optimal Partition of String\n * Strings pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "removing-stars-from-a-string": {
        "description": "<p>You are given a string <code>s</code>, which contains stars <code>*</code>.</p><p>In one operation, you can:</p><ul><li>Choose a star in <code>s</code>.</li><li>Remove the closest <strong>non-star</strong> character to its <strong>left</strong>, as well as remove the star itself.</li></ul><p>Return <em>the string after <strong>all</strong> stars have been removed</em>.</p><p><strong>Note:</strong></p><ul><li>The input will be generated such that the operation is always possible.</li><li>It can be shown that the resulting string will always be unique.</li></ul>",
        "examples": [{"input": "s = \"leet**cod*e\"", "output": "\"lecoe\""}, {"input": "s = \"erase*****\"", "output": "\"\"", "explanation": "<p>The entire string is removed, so we return an empty string.</p>"}],
        "constraints": ["<code>1 &lt;= s.length &lt;= 10<sup>5</sup></code>", "<code>s</code> consists of lowercase English letters and stars <code>*</code>.", "The operation above can be performed on <code>s</code>."],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Removing Stars From a String involves checking all possible solutions. For Stack problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Stack problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Removing Stars From a String\n        Stack pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Removing Stars From a String\n     * Stack pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Removing Stars From a String\n     * Stack pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Removing Stars From a String\n * Stack pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Removing Stars From a String leverages stack-based operations to reduce time complexity. Instead of checking all possibilities, we use Stack-specific techniques like stack/queue for optimal state management to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (stack)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Efficient state management\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for Stack reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Removing Stars From a String\n        Stack pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Stack for state management\n        stack = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Removing Stars From a String\n     * Stack pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Stack for state management\n        Stack<Integer> stack = new Stack<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Removing Stars From a String\n     * Stack pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Stack for state management\n        stack<int> st;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Removing Stars From a String\n * Stack pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Stack for state management\n    const stack = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "asteroid-collision": {
        "description": "<p>We are given an array <code>asteroids</code> of integers representing asteroids in a row.</p><p>For each asteroid, the absolute value represents its size, and the sign represents its direction (positive meaning right, negative meaning left). Each asteroid moves at the same speed.</p><p>Find out the state of the asteroids after all collisions. If two asteroids meet, the smaller one will explode. If both are the same size, both will explode. Two asteroids moving in the same direction will never meet.</p>",
        "examples": [{"input": "asteroids = [5,10,-5]", "output": "[5,10]", "explanation": "<p>The 10 and -5 collide resulting in 10. The 5 and 10 never collide.</p>"}, {"input": "asteroids = [8,-8]", "output": "[]", "explanation": "<p>The 8 and -8 collide exploding each other.</p>"}, {"input": "asteroids = [10,2,-5]", "output": "[10]", "explanation": "<p>The 2 and -5 collide resulting in -5. The 10 and -5 collide resulting in 10.</p>"}],
        "constraints": ["<code>2 &lt;= asteroids.length &lt;= 10<sup>4</sup></code>", "<code>-1000 &lt;= asteroids[i] &lt;= 1000</code>", "<code>asteroids[i] != 0</code>"],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Asteroid Collision involves checking all possible solutions. For Stack problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Stack problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Asteroid Collision\n        Stack pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Asteroid Collision\n     * Stack pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Asteroid Collision\n     * Stack pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Asteroid Collision\n * Stack pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Asteroid Collision leverages stack-based operations to reduce time complexity. Instead of checking all possibilities, we use Stack-specific techniques like stack/queue for optimal state management to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (stack)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Efficient state management\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for Stack reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Asteroid Collision\n        Stack pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Stack for state management\n        stack = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Asteroid Collision\n     * Stack pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Stack for state management\n        Stack<Integer> stack = new Stack<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Asteroid Collision\n     * Stack pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Stack for state management\n        stack<int> st;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Asteroid Collision\n * Stack pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Stack for state management\n    const stack = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "decode-string": {
        "description": "<p>Given an encoded string, return its decoded string.</p><p>The encoding rule is: <code>k[encoded_string]</code>, where the <code>encoded_string</code> inside the square brackets is being repeated exactly <code>k</code> times. Note that <code>k</code> is guaranteed to be a positive integer.</p><p>You may assume that the input string is always valid; there are no extra white spaces, square brackets are well-formed, etc. Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, <code>k</code>. For example, there will not be input like <code>3a</code> or <code>2[4]</code>.</p><p>The test cases are generated so that the length of the output will never exceed <code>10<sup>5</sup></code>.</p>",
        "examples": [{"input": "s = \"3[a]2[bc]\"", "output": "\"aaabcbc\"", "explanation": "<p>The string is decoded to \"aaa\" + \"bcbc\" = \"aaabcbc\".</p>"}, {"input": "s = \"3[a2[c]]\"", "output": "\"accaccacc\"", "explanation": "<p>The string is decoded to \"acc\" repeated 3 times = \"accaccacc\".</p>"}, {"input": "s = \"2[abc]3[cd]ef\"", "output": "\"abcabccdcdcdef\"", "explanation": "<p>The string is decoded to \"abcabc\" + \"cdcdcd\" + \"ef\" = \"abcabccdcdcdef\".</p>"}],
        "constraints": ["<code>1 &lt;= s.length &lt;= 30</code>", "<code>s</code> consists of lowercase English letters, digits, and square brackets <code>\"[]\"</code>.", "<code>s</code> is guaranteed to be <strong>a valid</strong> input.", "All the integers in <code>s</code> are in the range <code>[1, 300]</code>."],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Decode String involves checking all possible solutions. For Stack problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Stack problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Decode String\n        Stack pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Decode String\n     * Stack pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Decode String\n     * Stack pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Decode String\n * Stack pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Decode String leverages stack-based operations to reduce time complexity. Instead of checking all possibilities, we use Stack-specific techniques like stack/queue for optimal state management to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (stack)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Efficient state management\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for Stack reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Decode String\n        Stack pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Stack for state management\n        stack = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Decode String\n     * Stack pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Stack for state management\n        Stack<Integer> stack = new Stack<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Decode String\n     * Stack pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Stack for state management\n        stack<int> st;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Decode String\n * Stack pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Stack for state management\n    const stack = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "simplify-path": {
        "description": "<p>Given an absolute path for a Unix-style file system, which begins with a slash <code>'/'</code>, transform this path into its <strong>simplified canonical path</strong>.</p><p>In Unix-style file system context, a single period <code>'.'</code> signifies the current directory, a double period <code>\"..\"</code> denotes moving up one directory level, and multiple slashes such as <code>'//'</code> are interpreted as a single slash. In this problem, treat sequences of periods not covered by the previous rules (like <code>'...'</code>) as valid names for files or directories.</p><p>The simplified canonical path should adhere to the following rules:</p><ul><li>It must start with a single slash <code>'/'</code>.</li><li>Directories within the path should be separated by only one slash <code>'/'</code>.</li><li>It should not end with a slash <code>'/'</code>, unless it's the root directory.</li><li>It should exclude any single or double periods used to denote current or parent directories.</li></ul><p>Return <em>the <strong>simplified canonical path</strong></em>.</p>",
        "examples": [{"input": "path = \"/home/\"", "output": "\"/home\"", "explanation": "<p>The trailing slash should be removed.</p>"}, {"input": "path = \"/home//foo/\"", "output": "\"/home/foo\"", "explanation": "<p>Multiple consecutive slashes are replaced by a single one.</p>"}, {"input": "path = \"/home/user/Documents/../Pictures\"", "output": "\"/home/user/Pictures\"", "explanation": "<p>A double period \"..\" refers to the directory up a level (the parent directory).</p>"}, {"input": "path = \"/../\"", "output": "\"/\"", "explanation": "<p>Going one level up from the root directory is not possible.</p>"}, {"input": "path = \"/.../a/../b/c/../d/./\"", "output": "\"/.../b/d\"", "explanation": "<p>\"...\" is a valid name for a directory in this problem.</p>"}],
        "constraints": ["<code>1 &lt;= path.length &lt;= 3000</code>", "<code>path</code> consists of English letters, digits, period <code>\".\"</code>, slash <code>\"/\"</code> or <code>\"_\"</code>.", "<code>path</code> is a valid absolute Unix path."],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Simplify Path involves checking all possible solutions. For Stack problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Stack problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Simplify Path\n        Stack pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Simplify Path\n     * Stack pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Simplify Path\n     * Stack pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Simplify Path\n * Stack pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Simplify Path leverages stack-based operations to reduce time complexity. Instead of checking all possibilities, we use Stack-specific techniques like stack/queue for optimal state management to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (stack)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Efficient state management\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for Stack reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Simplify Path\n        Stack pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Stack for state management\n        stack = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Simplify Path\n     * Stack pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Stack for state management\n        Stack<Integer> stack = new Stack<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Simplify Path\n     * Stack pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Stack for state management\n        stack<int> st;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Simplify Path\n * Stack pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Stack for state management\n    const stack = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "provinces": {
        "description": "<p>There are <code>n</code> cities. Some of them are connected, while some are not. If city <code>a</code> is connected directly with city <code>b</code>, and city <code>b</code> is connected directly with city <code>c</code>, then city <code>a</code> is connected indirectly with city <code>c</code>.</p><p>A <strong>province</strong> is a group of directly or indirectly connected cities and no other cities outside of the group.</p><p>You are given an <code>n x n</code> matrix <code>isConnected</code> where <code>isConnected[i][j] = 1</code> if the <code>i<sup>th</sup></code> city and the <code>j<sup>th</sup></code> city are directly connected, and <code>isConnected[i][j] = 0</code> otherwise.</p><p>Return <em>the total number of <strong>provinces</strong></em>.</p>",
        "examples": [{"input": "isConnected = [[1,1,0],[1,1,0],[0,0,1]]", "output": "2", "explanation": "<p>Cities 0 and 1 form one province, and city 2 forms another province.</p>"}, {"input": "isConnected = [[1,0,0],[0,1,0],[0,0,1]]", "output": "3", "explanation": "<p>Each city forms its own province.</p>"}],
        "constraints": ["<code>1 &lt;= n &lt;= 200</code>", "<code>n == isConnected.length</code>", "<code>n == isConnected[i].length</code>", "<code>isConnected[i][j]</code> is <code>1</code> or <code>0</code>.", "<code>isConnected[i][i] == 1</code>", "<code>isConnected[i][j] == isConnected[j][i]</code>"],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Provinces involves checking all possible solutions. For DFS problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. DFS problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Provinces\n        DFS pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Provinces\n     * DFS pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Provinces\n     * DFS pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Provinces\n * DFS pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Provinces leverages depth-first search graph traversal to reduce time complexity. Instead of checking all possibilities, we use DFS-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for DFS reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Provinces\n        DFS pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Provinces\n     * DFS pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Provinces\n     * DFS pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Provinces\n * DFS pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "remove-k-digits": {
        "description": "<p>Given string num representing a non-negative integer <code>num</code>, and an integer <code>k</code>, return <em>the smallest possible integer after removing</em> <code>k</code> <em>digits from</em> <code>num</code>.</p>",
        "examples": [{"input": "num = \"1432219", "output": "\"1219\"", "explanation": "<p>Remove the three digits 4, 3, and 2 to form the new number 1219 which is the smallest.</p>"}, {"input": "num = \"10200", "output": "\"200\"", "explanation": "<p>Remove the leading 1 and the number is 200. Note that the output must not contain leading zeroes.</p>"}, {"input": "num = \"10", "output": "\"0\"", "explanation": "<p>Remove all the digits from the number and it is left with nothing which is 0.</p>"}],
        "constraints": ["<code>1 &lt;= k &lt;= num.length &lt;= 10<sup>5</sup></code>", "<code>num</code> consists of only digits.", "<code>num</code> does not have any leading zeros except for the zero itself."],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Remove K Digits involves checking all possible solutions. For Monotonic Stack problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Monotonic Stack problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Remove K Digits\n        Monotonic Stack pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Remove K Digits\n     * Monotonic Stack pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Remove K Digits\n     * Monotonic Stack pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Remove K Digits\n * Monotonic Stack pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Remove K Digits leverages monotonic stack technique to reduce time complexity. Instead of checking all possibilities, we use Monotonic Stack-specific techniques like stack/queue for optimal state management to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (stack)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Efficient state management\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for Monotonic Stack reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Remove K Digits\n        Monotonic Stack pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Stack for state management\n        stack = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Remove K Digits\n     * Monotonic Stack pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Stack for state management\n        Stack<Integer> stack = new Stack<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Remove K Digits\n     * Monotonic Stack pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Stack for state management\n        stack<int> st;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Remove K Digits\n * Monotonic Stack pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Stack for state management\n    const stack = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "sum-root-to-leaf-numbers": {
        "description": "<p>You are given the <code>root</code> of a binary tree containing digits from <code>0</code> to <code>9</code> only.</p><p>Each root-to-leaf path in the tree represents a number.</p><ul><li>For example, the root-to-leaf path <code>1 -&gt; 2 -&gt; 3</code> represents the number <code>123</code>.</li></ul><p>Return <em>the total sum of all root-to-leaf numbers</em>. Test cases are generated so that the answer will fit in a <strong>32-bit</strong> integer.</p><p>A <strong>leaf</strong> node is a node with no children.</p>",
        "examples": [{"input": "root = [1,2,3]", "output": "25", "explanation": "<p>The root-to-leaf path <code>1-&gt;2</code> represents the number <code>12</code>.<br/>The root-to-leaf path <code>1-&gt;3</code> represents the number <code>13</code>.<br/>Therefore, sum = 12 + 13 = <code>25</code>.</p>"}, {"input": "root = [4,9,0,5,1]", "output": "1026", "explanation": "<p>The root-to-leaf path <code>4-&gt;9-&gt;5</code> represents the number 495.<br/>The root-to-leaf path <code>4-&gt;9-&gt;1</code> represents the number 491.<br/>The root-to-leaf path <code>4-&gt;0</code> represents the number 40.<br/>Therefore, sum = 495 + 491 + 40 = <code>1026</code>.</p>"}],
        "constraints": ["The number of nodes in the tree is in the range <code>[1, 1000]</code>.", "<code>0 &lt;= Node.val &lt;= 9</code>", "The depth of the tree will not exceed <code>10</code>."],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Sum Root to Leaf Numbers involves checking all possible solutions. For Tree Traversal problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Tree Traversal problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Sum Root to Leaf Numbers\n        Tree Traversal pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Sum Root to Leaf Numbers\n     * Tree Traversal pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Sum Root to Leaf Numbers\n     * Tree Traversal pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Sum Root to Leaf Numbers\n * Tree Traversal pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Sum Root to Leaf Numbers leverages tree path traversal to reduce time complexity. Instead of checking all possibilities, we use Tree Traversal-specific techniques like efficient traversal with pruning to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (tree structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Pruning impossible branches\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(h)",
                    "timeExplanation": "Optimized approach for Tree Traversal reduces complexity significantly. Tree traversal visits each node exactly once. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Recursion stack depth equals tree height. Balanced tree gives O(log n). Can be further optimized by using iterative approach instead of recursion."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Sum Root to Leaf Numbers\n        Tree Traversal pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Sum Root to Leaf Numbers\n     * Tree Traversal pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Sum Root to Leaf Numbers\n     * Tree Traversal pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Sum Root to Leaf Numbers\n * Tree Traversal pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "path-sum-ii": {
        "description": "<p>Given the <code>root</code> of a binary tree and an integer <code>targetSum</code>, return <em>all <strong>root-to-leaf</strong> paths where the sum of the node values in the path equals </em><code>targetSum</code><em>. Each path should be returned as a list of the node <strong>values</strong>, not node references</em>.</p><p>A <strong>root-to-leaf</strong> path is a path starting from the root and ending at any leaf node. A <strong>leaf</strong> is a node with no children.</p>",
        "examples": [{"input": "root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22", "output": "[[5,4,11,2],[5,8,4,5]]", "explanation": "<p>There are two paths whose sum equals targetSum:<br/>5 + 4 + 11 + 2 = 22<br/>5 + 8 + 4 + 5 = 22</p>"}, {"input": "root = [1,2,3], targetSum = 5", "output": "[]", "explanation": "<p>There are no root-to-leaf paths with sum = 5.</p>"}, {"input": "root = [1,2], targetSum = 0", "output": "[]", "explanation": "<p>Since the tree is not empty, there are no paths with sum = 0.</p>"}],
        "constraints": ["The number of nodes in the tree is in the range <code>[0, 5000]</code>.", "<code>-1000 &lt;= Node.val &lt;= 1000</code>", "<code>-1000 &lt;= targetSum &lt;= 1000</code>"],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Path Sum II involves checking all possible solutions. For Tree Traversal problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Tree Traversal problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Path Sum II\n        Tree Traversal pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Path Sum II\n     * Tree Traversal pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Path Sum II\n     * Tree Traversal pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Path Sum II\n * Tree Traversal pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Path Sum II leverages tree path traversal to reduce time complexity. Instead of checking all possibilities, we use Tree Traversal-specific techniques like efficient traversal with pruning to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (tree structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Pruning impossible branches\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(h)",
                    "timeExplanation": "Optimized approach for Tree Traversal reduces complexity significantly. Tree traversal visits each node exactly once. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Recursion stack depth equals tree height. Balanced tree gives O(log n). Can be further optimized by using iterative approach instead of recursion."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Path Sum II\n        Tree Traversal pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Path Sum II\n     * Tree Traversal pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Path Sum II\n     * Tree Traversal pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Path Sum II\n * Tree Traversal pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "path-sum-iii": {
        "description": "<p>Given the <code>root</code> of a binary tree and an integer <code>targetSum</code>, return <em>the number of paths where the sum of the values along the path equals</em> <code>targetSum</code>.</p><p>The path does not need to start or end at the root or a leaf, but it must go downwards (i.e., traveling only from parent nodes to child nodes).</p>",
        "examples": [{"input": "root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8", "output": "3", "explanation": "<p>The paths that sum to 8 are shown in the figure:<br/>1. 5 -&gt; 3<br/>2. 5 -&gt; 2 -&gt; 1<br/>3. -3 -&gt; 11</p>"}, {"input": "root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22", "output": "3", "explanation": "<p>The paths that sum to 22 are:<br/>1. 5 -&gt; 4 -&gt; 11 -&gt; 2<br/>2. 5 -&gt; 8 -&gt; 4 -&gt; 5<br/>3. 4 -&gt; 11 -&gt; 7</p>"}],
        "constraints": ["The number of nodes in the tree is in the range <code>[0, 1000]</code>.", "<code>-10<sup>9</sup> &lt;= Node.val &lt;= 10<sup>9</sup></code>", "<code>-1000 &lt;= targetSum &lt;= 1000</code>"],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Path Sum III involves checking all possible solutions. For Tree Traversal problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Tree Traversal problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Path Sum III\n        Tree Traversal pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Path Sum III\n     * Tree Traversal pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Path Sum III\n     * Tree Traversal pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Path Sum III\n * Tree Traversal pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Path Sum III leverages tree path traversal to reduce time complexity. Instead of checking all possibilities, we use Tree Traversal-specific techniques like efficient traversal with pruning to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (tree structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Pruning impossible branches\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(h)",
                    "timeExplanation": "Optimized approach for Tree Traversal reduces complexity significantly. Tree traversal visits each node exactly once. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Recursion stack depth equals tree height. Balanced tree gives O(log n). Can be further optimized by using iterative approach instead of recursion."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Path Sum III\n        Tree Traversal pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Path Sum III\n     * Tree Traversal pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Path Sum III\n     * Tree Traversal pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Path Sum III\n * Tree Traversal pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "01-matrix": {
        "description": "<p>Given an <code>m x n</code> binary matrix <code>mat</code>, return <em>the distance of the nearest </em><code>0</code><em> for each cell</em>.</p><p>The distance between two adjacent cells is <code>1</code>.</p>",
        "examples": [{"input": "mat = [[0,0,0],[0,1,0],[0,0,0]]", "output": "[[0,0,0],[0,1,0],[0,0,0]]", "explanation": "<p>The distance of each cell to the nearest 0 is shown.</p>"}, {"input": "mat = [[0,0,0],[0,1,0],[1,1,1]]", "output": "[[0,0,0],[0,1,0],[1,2,1]]", "explanation": "<p>The distance of each cell to the nearest 0 is shown.</p>"}],
        "constraints": ["<code>m == mat.length</code>", "<code>n == mat[i].length</code>", "<code>1 &lt;= m, n &lt;= 10<sup>4</sup></code>", "<code>1 &lt;= m * n &lt;= 10<sup>4</sup></code>", "<code>mat[i][j]</code> is either <code>0</code> or <code>1</code>.", "There is at least one <code>0</code> in <code>mat</code>."],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for 01 Matrix involves checking all possible solutions. For BFS problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. BFS problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for 01 Matrix\n        BFS pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for 01 Matrix\n     * BFS pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for 01 Matrix\n     * BFS pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for 01 Matrix\n * BFS pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for 01 Matrix leverages breadth-first search traversal to reduce time complexity. Instead of checking all possibilities, we use BFS-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for BFS reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for 01 Matrix\n        BFS pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for 01 Matrix\n     * BFS pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for 01 Matrix\n     * BFS pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for 01 Matrix\n * BFS pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "longest-zigzag-path-in-a-binary-tree": {
        "description": "<p>You are given the <code>root</code> of a binary tree.</p><p>A ZigZag path for a binary tree is defined as follow:</p><ul><li>Choose <strong>any</strong> node in the binary tree and a direction (right or left).</li><li>If the current direction is right, move to the right child of the current node; otherwise, move to the left child.</li><li>Change the direction from right to left or from left to right.</li><li>Repeat the second and third steps until you can't move in the tree.</li></ul><p>Zigzag length is defined as the number of nodes visited - 1. (A single node has a length of 0).</p><p>Return <em>the longest <strong>ZigZag</strong> path contained in that tree</em>.</p>",
        "examples": [{"input": "root = [1,null,1,1,1,null,null,1,1,null,1,null,null,null,1]", "output": "3", "explanation": "<p>Longest ZigZag path in blue nodes (right -> left -> right).</p>"}, {"input": "root = [1,1,1,null,1,null,null,1,1,null,1]", "output": "4", "explanation": "<p>Longest ZigZag path in blue nodes (left -> right -> left -> right).</p>"}, {"input": "root = [1]", "output": "0", "explanation": "<p>A single node has ZigZag length 0.</p>"}],
        "constraints": ["The number of nodes in the tree is in the range <code>[1, 5 * 10<sup>4</sup>]</code>.", "<code>1 &lt;= Node.val &lt;= 100</code>"],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Longest ZigZag Path in a Binary Tree involves checking all possible solutions. For Tree Traversal problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Tree Traversal problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Longest ZigZag Path in a Binary Tree\n        Tree Traversal pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Longest ZigZag Path in a Binary Tree\n     * Tree Traversal pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Longest ZigZag Path in a Binary Tree\n     * Tree Traversal pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Longest ZigZag Path in a Binary Tree\n * Tree Traversal pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Longest ZigZag Path in a Binary Tree leverages tree path traversal to reduce time complexity. Instead of checking all possibilities, we use Tree Traversal-specific techniques like efficient traversal with pruning to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (tree structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Pruning impossible branches\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(h)",
                    "timeExplanation": "Optimized approach for Tree Traversal reduces complexity significantly. Tree traversal visits each node exactly once. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Recursion stack depth equals tree height. Balanced tree gives O(log n). Can be further optimized by using iterative approach instead of recursion."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Longest ZigZag Path in a Binary Tree\n        Tree Traversal pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Longest ZigZag Path in a Binary Tree\n     * Tree Traversal pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Longest ZigZag Path in a Binary Tree\n     * Tree Traversal pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Longest ZigZag Path in a Binary Tree\n * Tree Traversal pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "maximum-width-of-binary-tree": {
        "description": "<p>Given the <code>root</code> of a binary tree, return <em>the <strong>maximum width</strong> of the given tree</em>.</p><p>The <strong>maximum width</strong> of a tree is the maximum <strong>width</strong> among all levels.</p><p>The <strong>width</strong> of one level is defined as the length between the end-nodes (the leftmost and rightmost non-null nodes), where the null nodes between the end-nodes that would be present in a complete binary tree extending down to that level are also counted into the length calculation.</p><p>It is <strong>guaranteed</strong> that the answer will in the range of a <strong>32-bit</strong> signed integer.</p>",
        "examples": [{"input": "root = [1,3,2,5,3,null,9]", "output": "4", "explanation": "<p>The maximum width exists in the third level with length 4 (5,3,null,9).</p>"}, {"input": "root = [1,3,2,5,null,null,9,6,null,7]", "output": "7", "explanation": "<p>The maximum width exists in the fourth level with length 7 (6,null,null,null,null,null,7).</p>"}, {"input": "root = [1,3,2,5]", "output": "2", "explanation": "<p>The maximum width exists in the second level with length 2 (3,2).</p>"}],
        "constraints": ["The number of nodes in the tree is in the range <code>[1, 3000]</code>.", "<code>-100 &lt;= Node.val &lt;= 100</code>"],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Maximum Width of Binary Tree involves checking all possible solutions. For BFS problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. BFS problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Maximum Width of Binary Tree\n        BFS pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Maximum Width of Binary Tree\n     * BFS pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Maximum Width of Binary Tree\n     * BFS pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Maximum Width of Binary Tree\n * BFS pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Maximum Width of Binary Tree leverages breadth-first search traversal to reduce time complexity. Instead of checking all possibilities, we use BFS-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for BFS reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Maximum Width of Binary Tree\n        BFS pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Maximum Width of Binary Tree\n     * BFS pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Maximum Width of Binary Tree\n     * BFS pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Maximum Width of Binary Tree\n * BFS pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "all-nodes-distance-k-in-binary-tree": {
        "description": "<p>Given the <code>root</code> of a binary tree, the value of a target node <code>target</code>, and an integer <code>k</code>, return <em>an array of the values of all nodes that have a distance </em><code>k</code><em> from the target node.</em></p><p>You can return the answer in <strong>any order</strong>.</p>",
        "examples": [{"input": "root = [3,5,1,6,2,0,8,null,null,7,4], target = 5, k = 2", "output": "[7,4,1]", "explanation": "<p>The nodes that are a distance 2 from the target node (with value 5) have values 7, 4, and 1.</p>"}, {"input": "root = [1], target = 1, k = 3", "output": "[]", "explanation": "<p>There are no nodes at distance 3 from the target.</p>"}],
        "constraints": ["The number of nodes in the tree is in the range <code>[1, 500]</code>.", "<code>0 &lt;= Node.val &lt;= 500</code>", "All the values <code>Node.val</code> are <strong>unique</strong>.", "<code>target</code> is the value of one of the nodes in the tree.", "<code>0 &lt;= k &lt;= 1000</code>"],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for All Nodes Distance K in Binary Tree involves checking all possible solutions. For BFS problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. BFS problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for All Nodes Distance K in Binary Tree\n        BFS pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for All Nodes Distance K in Binary Tree\n     * BFS pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for All Nodes Distance K in Binary Tree\n     * BFS pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for All Nodes Distance K in Binary Tree\n * BFS pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for All Nodes Distance K in Binary Tree leverages breadth-first search traversal to reduce time complexity. Instead of checking all possibilities, we use BFS-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for BFS reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for All Nodes Distance K in Binary Tree\n        BFS pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for All Nodes Distance K in Binary Tree\n     * BFS pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for All Nodes Distance K in Binary Tree\n     * BFS pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for All Nodes Distance K in Binary Tree\n * BFS pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "delete-node-in-a-bst": {
        "description": "<p>Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return <em>the <strong>root node reference</strong> (possibly updated) of the BST</em>.</p><p>Basically, the deletion can be divided into two stages:</p><ol><li>Search for a node to remove.</li><li>If the node is found, delete the node.</li></ol>",
        "examples": [{"input": "root = [5,3,6,2,4,null,7], key = 3", "output": "[5,4,6,2,null,null,7]", "explanation": "<p>Given key to delete is 3. So we find the node with value 3 and delete it.<br/>One valid answer is [5,4,6,2,null,null,7].<br/>Another valid answer is [5,2,6,null,4,null,7].</p>"}, {"input": "root = [5,3,6,2,4,null,7], key = 0", "output": "[5,3,6,2,4,null,7]", "explanation": "<p>The tree does not contain a node with value = 0.</p>"}, {"input": "root = [], key = 0", "output": "[]", "explanation": "<p>The tree is empty.</p>"}],
        "constraints": ["The number of nodes in the tree is in the range <code>[0, 10<sup>4</sup>]</code>.", "<code>-10<sup>5</sup> &lt;= Node.val &lt;= 10<sup>5</sup></code>", "Each node has a <strong>unique</strong> value.", "<code>root</code> is a valid binary search tree.", "<code>-10<sup>5</sup> &lt;= key &lt;= 10<sup>5</sup></code>"],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Delete Node in a BST involves checking all possible solutions. For BST problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. BST problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Delete Node in a BST\n        BST pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Delete Node in a BST\n     * BST pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Delete Node in a BST\n     * BST pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Delete Node in a BST\n * BST pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Delete Node in a BST leverages binary search tree operations to reduce time complexity. Instead of checking all possibilities, we use BST-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for BST reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Delete Node in a BST\n        BST pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Delete Node in a BST\n     * BST pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Delete Node in a BST\n     * BST pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Delete Node in a BST\n * BST pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "trim-a-binary-search-tree": {
        "description": "<p>Given the <code>root</code> of a binary search tree and the lowest and highest boundaries as <code>low</code> and <code>high</code>, trim the tree so that all its elements lies in <code>[low, high]</code>. Trimming the tree should <strong>not</strong> change the relative structure of the elements that will remain in the tree (i.e., any node's descendant should remain a descendant). It can be proven that there is a <strong>unique answer</strong>.</p><p>Return <em>the root of the trimmed binary search tree</em>. Note that the root may change depending on the given bounds.</p>",
        "examples": [{"input": "root = [1,0,2], low = 1, high = 2", "output": "[1,null,2]", "explanation": "<p>Nodes with value 0 is outside [1, 2] and should be removed.</p>"}, {"input": "root = [3,0,4,null,2,null,null,1], low = 1, high = 3", "output": "[3,2,null,1]", "explanation": "<p>Nodes with value 0 and 4 are outside [1, 3] and should be removed.</p>"}],
        "constraints": ["The number of nodes in the tree is in the range <code>[1, 10<sup>4</sup>]</code>.", "<code>0 &lt;= Node.val &lt;= 10<sup>4</sup></code>", "The value of each node in the tree is <strong>unique</strong>.", "<code>root</code> is guaranteed to be a valid binary search tree.", "<code>0 &lt;= low &lt;= high &lt;= 10<sup>4</sup></code>"],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Trim a Binary Search Tree involves checking all possible solutions. For BST problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. BST problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Trim a Binary Search Tree\n        BST pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Trim a Binary Search Tree\n     * BST pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Trim a Binary Search Tree\n     * BST pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Trim a Binary Search Tree\n * BST pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Trim a Binary Search Tree leverages binary search tree operations to reduce time complexity. Instead of checking all possibilities, we use BST-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for BST reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Trim a Binary Search Tree\n        BST pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Trim a Binary Search Tree\n     * BST pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Trim a Binary Search Tree\n     * BST pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Trim a Binary Search Tree\n * BST pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "flatten-binary-tree-to-linked-list": {
        "description": "<p>Given the <code>root</code> of a binary tree, flatten the tree into a \"linked list\":</p><ul><li>The \"linked list\" should use the same <code>TreeNode</code> class where the <code>right</code> child pointer points to the next node in the list and the <code>left</code> child pointer is always <code>null</code>.</li><li>The \"linked list\" should be in the same order as a <strong>pre-order traversal</strong> of the binary tree.</li></ul>",
        "examples": [{"input": "root = [1,2,5,3,4,null,6]", "output": "[1,null,2,null,3,null,4,null,5,null,6]", "explanation": "<p>The tree is flattened following pre-order traversal.</p>"}, {"input": "root = []", "output": "[]", "explanation": "<p>Empty tree remains empty.</p>"}, {"input": "root = [0]", "output": "[0]", "explanation": "<p>Single node remains unchanged.</p>"}],
        "constraints": ["The number of nodes in the tree is in the range <code>[0, 2000]</code>.", "<code>-100 &lt;= Node.val &lt;= 100</code>"],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Flatten Binary Tree to Linked List involves checking all possible solutions. For Tree Hard problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Tree Hard problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Flatten Binary Tree to Linked List\n        Tree Hard pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Flatten Binary Tree to Linked List\n     * Tree Hard pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Flatten Binary Tree to Linked List\n     * Tree Hard pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Flatten Binary Tree to Linked List\n * Tree Hard pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Flatten Binary Tree to Linked List leverages complex tree transformations to reduce time complexity. Instead of checking all possibilities, we use Tree Hard-specific techniques like efficient traversal with pruning to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (tree structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Pruning impossible branches\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(h)",
                    "timeExplanation": "Optimized approach for Tree Hard reduces complexity significantly. Tree traversal visits each node exactly once. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Recursion stack depth equals tree height. Balanced tree gives O(log n). Can be further optimized by using iterative approach instead of recursion."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Flatten Binary Tree to Linked List\n        Tree Hard pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Flatten Binary Tree to Linked List\n     * Tree Hard pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Flatten Binary Tree to Linked List\n     * Tree Hard pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Flatten Binary Tree to Linked List\n * Tree Hard pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "populating-next-right-pointers-in-each-node": {
        "description": "<p>You are given a <strong>perfect binary tree</strong> where all leaves are on the same level, and every parent has two children. The binary tree has the following definition:</p><pre>struct Node {   int val;   Node *left;   Node *right;   Node *next; }</pre><p>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to <code>NULL</code>.</p><p>Initially, all next pointers are set to <code>NULL</code>.</p>",
        "examples": [{"input": "root = [1,2,3,4,5,6,7]", "output": "[1,#,2,3,#,4,5,6,7,#]", "explanation": "<p>Given the perfect binary tree, after populating next pointers, each node's next points to its next right node. # represents the end of each level.</p>"}, {"input": "root = []", "output": "[]", "explanation": "<p>Empty tree remains empty.</p>"}],
        "constraints": ["The number of nodes in the tree is in the range <code>[0, 2<sup>12</sup> - 1]</code>.", "<code>-1000 &lt;= Node.val &lt;= 1000</code>"],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Populating Next Right Pointers in Each Node involves checking all possible solutions. For Tree Hard problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Tree Hard problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Populating Next Right Pointers in Each Node\n        Tree Hard pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Populating Next Right Pointers in Each Node\n     * Tree Hard pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Populating Next Right Pointers in Each Node\n     * Tree Hard pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Populating Next Right Pointers in Each Node\n * Tree Hard pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Populating Next Right Pointers in Each Node leverages complex tree transformations to reduce time complexity. Instead of checking all possibilities, we use Tree Hard-specific techniques like efficient traversal with pruning to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (tree structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Pruning impossible branches\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(h)",
                    "timeExplanation": "Optimized approach for Tree Hard reduces complexity significantly. Tree traversal visits each node exactly once. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Recursion stack depth equals tree height. Balanced tree gives O(log n). Can be further optimized by using iterative approach instead of recursion."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Populating Next Right Pointers in Each Node\n        Tree Hard pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Populating Next Right Pointers in Each Node\n     * Tree Hard pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Populating Next Right Pointers in Each Node\n     * Tree Hard pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Populating Next Right Pointers in Each Node\n * Tree Hard pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "keys-and-rooms": {
        "description": "<p>There are <code>n</code> rooms labeled from <code>0</code> to <code>n - 1</code> and all the rooms are locked except for room <code>0</code>. Your goal is to visit all the rooms. However, you cannot enter a locked room without having its key.</p><p>When you visit a room, you may find a set of <strong>distinct keys</strong> in it. Each key has a number on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms.</p><p>Given an array <code>rooms</code> where <code>rooms[i]</code> is the set of keys that you can obtain if you visited room <code>i</code>, return <code>true</code> <em>if you can visit <strong>all</strong> the rooms, or</em> <code>false</code> <em>otherwise</em>.</p>",
        "examples": [{"input": "rooms = [[1],[2],[3],[]]", "output": "true", "explanation": "<p>We visit room 0 and pick up key 1.<br/>We then visit room 1 and pick up key 2.<br/>We then visit room 2 and pick up key 3.<br/>We then visit room 3.<br/>Since we were able to visit every room, we return true.</p>"}, {"input": "rooms = [[1,3],[3,0,1],[2],[0]]", "output": "false", "explanation": "<p>We can not enter room number 2 since the only key that unlocks it is in that room.</p>"}],
        "constraints": ["<code>n == rooms.length</code>", "<code>2 &lt;= n &lt;= 1000</code>", "<code>0 &lt;= rooms[i].length &lt;= 1000</code>", "<code>1 &lt;= sum(rooms[i].length) &lt;= 3000</code>", "<code>0 &lt;= rooms[i][j] &lt; n</code>", "All the values of <code>rooms[i]</code> are <strong>unique</strong>."],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Keys and Rooms involves checking all possible solutions. For DFS problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. DFS problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Keys and Rooms\n        DFS pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Keys and Rooms\n     * DFS pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Keys and Rooms\n     * DFS pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Keys and Rooms\n * DFS pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Keys and Rooms leverages depth-first search graph traversal to reduce time complexity. Instead of checking all possibilities, we use DFS-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for DFS reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Keys and Rooms\n        DFS pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Keys and Rooms\n     * DFS pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Keys and Rooms\n     * DFS pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Keys and Rooms\n * DFS pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "reorder-routes-to-make-all-paths-lead-to-the-city-zero": {
        "description": "<p>There are <code>n</code> cities numbered from <code>0</code> to <code>n - 1</code> and <code>n - 1</code> roads such that there is only one way to travel between two different cities (this network form a tree). Last year, The ministry of transport decided to orient the roads in one direction because they are too narrow.</p><p>Roads are represented by <code>connections</code> where <code>connections[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> represents a road from city <code>a<sub>i</sub></code> to city <code>b<sub>i</sub></code>.</p><p>This year, there will be a big event in the capital (city <code>0</code>), and many people want to travel to this city.</p><p>Your task consists of reorienting some roads such that each city can visit the city <code>0</code>. Return the <strong>minimum</strong> number of edges changed.</p><p>It's <strong>guaranteed</strong> that each city can reach city <code>0</code> after reorder.</p>",
        "examples": [{"input": "n = 6, connections = [[0,1],[1,3],[2,3],[4,0],[4,5]]", "output": "3", "explanation": "<p>Change the direction of edges show in red such that each node can reach the node 0 (capital).</p>"}, {"input": "n = 5, connections = [[1,0],[1,2],[3,2],[3,4]]", "output": "2", "explanation": "<p>Change the direction of edges show in red such that each node can reach the node 0 (capital).</p>"}, {"input": "n = 3, connections = [[1,0],[2,0]]", "output": "0", "explanation": "<p>All edges already point to node 0.</p>"}],
        "constraints": ["<code>2 &lt;= n &lt;= 5 * 10<sup>4</sup></code>", "<code>connections.length == n - 1</code>", "<code>connections[i].length == 2</code>", "<code>0 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt;= n - 1</code>", "<code>a<sub>i</sub> != b<sub>i</sub></code>"],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Reorder Routes to Make All Paths Lead to the City Zero involves checking all possible solutions. For DFS problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. DFS problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Reorder Routes to Make All Paths Lead to the City Zero\n        DFS pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Reorder Routes to Make All Paths Lead to the City Zero\n     * DFS pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Reorder Routes to Make All Paths Lead to the City Zero\n     * DFS pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Reorder Routes to Make All Paths Lead to the City Zero\n * DFS pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Reorder Routes to Make All Paths Lead to the City Zero leverages depth-first search graph traversal to reduce time complexity. Instead of checking all possibilities, we use DFS-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for DFS reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Reorder Routes to Make All Paths Lead to the City Zero\n        DFS pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Reorder Routes to Make All Paths Lead to the City Zero\n     * DFS pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Reorder Routes to Make All Paths Lead to the City Zero\n     * DFS pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Reorder Routes to Make All Paths Lead to the City Zero\n * DFS pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "evaluate-division": {
        "description": "<p>You are given an array of variable pairs <code>equations</code> and an array of real numbers <code>values</code>, where <code>equations[i] = [A<sub>i</sub>, B<sub>i</sub>]</code> and <code>values[i]</code> represent the equation <code>A<sub>i</sub> / B<sub>i</sub> = values[i]</code>. Each <code>A<sub>i</sub></code> or <code>B<sub>i</sub></code> is a string that represents a single variable.</p><p>You are also given some <code>queries</code>, where <code>queries[j] = [C<sub>j</sub>, D<sub>j</sub>]</code> represents the <code>j<sup>th</sup></code> query where you must find the answer for <code>C<sub>j</sub> / D<sub>j</sub> = ?</code>.</p><p>Return <em>the answers to all queries</em>. If a single answer cannot be determined, return <code>-1.0</code>.</p><p><strong>Note:</strong> The input is always valid. You may assume that evaluating the queries will not result in division by zero and that there is no contradiction.</p>",
        "examples": [{"input": "equations = [[\"a\",\"b\"],[\"b\",\"c\"]], values = [2.0,3.0], queries = [[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]\", \"output\": \"[6.00000,0.50000,-1.00000,1.00000,-1.00000]\", \"explanation\": \"<p>Given: <em>a / b = 2.0</em>, <em>b / c = 3.0</em><br/>queries are: <em>a / c = ?</em>, <em>b / a = ?</em>, <em>a / e = ?</em>, <em>a / a = ?</em>, <em>x / x = ?</em><br/>return: [6.0, 0.5, -1.0, 1.0, -1.0]</p>\"}, {\"input\": \"equations = [[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]], values = [1.5,2.5,5.0], queries = [[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]\", \"output\": \"[3.75000,0.40000,5.00000,0.20000]\", \"explanation\": \"<p>Evaluate the equations and return the query results.</p>\"}, {\"input\": \"equations = [[\"a\",\"b\"]], values = [0.5], queries = [[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]]\", \"output\": \"[0.50000,2.00000,-1.00000,-1.00000]\", \"explanation\": \"<p>Only one equation is given, so we can evaluate the queries accordingly.</p>"}],
        "constraints": ["<code>1 &lt;= equations.length &lt;= 20</code>", "<code>equations[i].length == 2</code>", "<code>1 &lt;= A<sub>i</sub>.length, B<sub>i</sub>.length &lt;= 5</code>", "<code>values.length == equations.length</code>", "<code>0.0 &lt; values[i] &lt;= 20.0</code>", "<code>1 &lt;= queries.length &lt;= 20</code>", "<code>queries[i].length == 2</code>", "<code>1 &lt;= C<sub>j</sub>.length, D<sub>j</sub>.length &lt;= 5</code>", "<code>A<sub>i</sub>, B<sub>i</sub>, C<sub>j</sub>, D<sub>j</sub></code> consist of lower case English letters and digits."],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Evaluate Division involves checking all possible solutions. For DFS problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. DFS problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Evaluate Division\n        DFS pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Evaluate Division\n     * DFS pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Evaluate Division\n     * DFS pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Evaluate Division\n * DFS pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Evaluate Division leverages depth-first search graph traversal to reduce time complexity. Instead of checking all possibilities, we use DFS-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for DFS reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Evaluate Division\n        DFS pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Evaluate Division\n     * DFS pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Evaluate Division\n     * DFS pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Evaluate Division\n * DFS pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "nearest-exit-from-entrance-in-maze": {
        "description": "<p>You are given an <code>m x n</code> matrix <code>maze</code> (<strong>0-indexed</strong>) with empty cells (represented as <code>'.'</code>) and walls (represented as <code>'+'</code>). You are also given the <code>entrance</code> of the maze, where <code>entrance = [entrance<sub>row</sub>, entrance<sub>col</sub>]</code> denotes the row and column of the cell you are initially standing at.</p><p>In one step, you can move one cell <strong>up</strong>, <strong>down</strong>, <strong>left</strong>, or <strong>right</strong>. You cannot step into a cell with a wall, and you cannot step outside the maze. Your goal is to find the <strong>nearest exit</strong> from the <code>entrance</code>. An <strong>exit</strong> is defined as an <strong>empty cell</strong> that is at the <strong>border</strong> of the <code>maze</code>. The <code>entrance</code> <strong>does not count</strong> as an exit.</p><p>Return <em>the <strong>number of steps</strong> in the shortest path from the </em><code>entrance</code><em> to the nearest exit, or </em><code>-1</code><em> if no such path exists</em>.</p>",
        "examples": [{"input": "maze = [[\"+\",\"+\",\".\",\"+\"],[\".\",\".\",\".\",\"+\"],[\"+\",\"+\",\"+\",\".\"]], entrance = [1,2]\", \"output\": \"1\", \"explanation\": \"<p>There are 3 exits in this maze at [1,0], [0,2], and [2,3].<br/>Initially, you are at the entrance cell [1,2].<br/>- You can reach [1,0] by moving 2 steps left.<br/>- You can reach [0,2] by moving 1 step up.<br/>It is impossible to reach [2,3] from the entrance.<br/>Thus, the nearest exit is [0,2], which is 1 step away.</p>\"}, {\"input\": \"maze = [[\"+\",\"+\",\"+\"],[\".\",\".\",\".\"],[\"+\",\"+\",\"+\"]], entrance = [1,0]\", \"output\": \"2\", \"explanation\": \"<p>There is 1 exit in this maze at [1,2].<br/>[1,0] does not count as an exit since it is the entrance cell.<br/>Initially, you are at the entrance cell [1,0].<br/>- You can reach [1,2] by moving 2 steps right.<br/>Thus, the nearest exit is [1,2], which is 2 steps away.</p>\"}, {\"input\": \"maze = [[\".\",\"+\"]], entrance = [0,0]\", \"output\": \"-1\", \"explanation\": \"<p>There are no exits in this maze.</p>"}],
        "constraints": ["<code>maze.length == m</code>", "<code>maze[i].length == n</code>", "<code>1 &lt;= m, n &lt;= 100</code>", "<code>maze[i][j]</code> is either <code>\".\"</code> or <code>\"+\"</code>.", "<code>entrance.length == 2</code>", "<code>0 &lt;= entrance<sub>row</sub> &lt; m</code>", "<code>0 &lt;= entrance<sub>col</sub> &lt; n</code>", "<code>entrance</code> will always be an empty cell."],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Nearest Exit from Entrance in Maze involves checking all possible solutions. For BFS problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. BFS problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Nearest Exit from Entrance in Maze\n        BFS pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Nearest Exit from Entrance in Maze\n     * BFS pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Nearest Exit from Entrance in Maze\n     * BFS pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Nearest Exit from Entrance in Maze\n * BFS pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Nearest Exit from Entrance in Maze leverages breadth-first search traversal to reduce time complexity. Instead of checking all possibilities, we use BFS-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for BFS reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Nearest Exit from Entrance in Maze\n        BFS pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Nearest Exit from Entrance in Maze\n     * BFS pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Nearest Exit from Entrance in Maze\n     * BFS pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Nearest Exit from Entrance in Maze\n * BFS pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "shortest-path-in-binary-matrix": {
        "description": "<p>Given an <code>n x n</code> binary matrix <code>grid</code>, return <em>the length of the shortest <strong>clear path</strong> in the matrix</em>. If there is no clear path, return <code>-1</code>.</p><p>A <strong>clear path</strong> in a binary matrix is a path from the <strong>top-left</strong> cell (i.e., <code>(0, 0)</code>) to the <strong>bottom-right</strong> cell (i.e., <code>(n - 1, n - 1)</code>) such that:</p><ul><li>All the visited cells of the path are <code>0</code>.</li><li>All the adjacent cells of the path are <strong>8-directionally</strong> connected (i.e., they are different and they share an edge or a corner).</li></ul><p>The <strong>length of a clear path</strong> is the number of visited cells of this path.</p>",
        "examples": [{"input": "grid = [[0,1],[1,0]]", "output": "2", "explanation": "<p>The clear path is from (0,0) to (1,1).</p>"}, {"input": "grid = [[0,0,0],[1,1,0],[1,1,0]]", "output": "4", "explanation": "<p>The clear path is from (0,0) to (2,2).</p>"}, {"input": "grid = [[1,0,0],[1,1,0],[1,1,0]]", "output": "-1", "explanation": "<p>There is no clear path from (0,0) to (2,2) because (0,0) is blocked.</p>"}],
        "constraints": ["<code>n == grid.length</code>", "<code>n == grid[i].length</code>", "<code>1 &lt;= n &lt;= 100</code>", "<code>grid[i][j]</code> is <code>0</code> or <code>1</code>"],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Shortest Path in Binary Matrix involves checking all possible solutions. For BFS problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. BFS problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Shortest Path in Binary Matrix\n        BFS pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Shortest Path in Binary Matrix\n     * BFS pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Shortest Path in Binary Matrix\n     * BFS pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Shortest Path in Binary Matrix\n * BFS pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Shortest Path in Binary Matrix leverages breadth-first search traversal to reduce time complexity. Instead of checking all possibilities, we use BFS-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for BFS reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Shortest Path in Binary Matrix\n        BFS pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Shortest Path in Binary Matrix\n     * BFS pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Shortest Path in Binary Matrix\n     * BFS pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Shortest Path in Binary Matrix\n * BFS pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "minimum-genetic-mutation": {
        "description": "<p>A gene string can be represented by an 8-character long string, with choices from <code>'A'</code>, <code>'C'</code>, <code>'G'</code>, and <code>'T'</code>.</p><p>Suppose we need to investigate a mutation from a gene string <code>startGene</code> to a gene string <code>endGene</code> where one mutation is defined as one single character changed in the gene string.</p><ul><li>For example, <code>\"AACCGGTT\" --&gt; \"AACCGGTA\"</code> is one mutation.</li></ul><p>There is also a gene bank <code>bank</code> that records all the valid gene mutations. A gene must be in <code>bank</code> to make it a valid gene string.</p><p>Given the two gene strings <code>startGene</code> and <code>endGene</code> and the gene bank <code>bank</code>, return <em>the minimum number of mutations needed to mutate from </em><code>startGene</code><em> to </em><code>endGene</code>. If there is no such a mutation, return <code>-1</code>.</p><p>Note that the starting point is assumed to be valid, so it might not be included in the bank.</p>",
        "examples": [{"input": "startGene = \"AACCGGTT\", endGene = \"AACCGGTA\", bank = [\"AACCGGTA\"]\", \"output\": \"1\", \"explanation\": \"<p>One mutation from \"AACCGGTT\" to \"AACCGGTA\".</p>\"}, {\"input\": \"startGene = \"AACCGGTT\", endGene = \"AAACGGTA\", bank = [\"AACCGGTA\",\"AACCGCTA\",\"AAACGGTA\"]\", \"output\": \"2\", \"explanation\": \"<p>Two mutations: \"AACCGGTT\" -&gt; \"AACCGGTA\" -&gt; \"AAACGGTA\".</p>\"}, {\"input\": \"startGene = \"AAAAACCC\", endGene = \"AACCCCCC\", bank = [\"AAAACCCC\",\"AAACCCCC\",\"AACCCCCC\"]\", \"output\": \"3\", \"explanation\": \"<p>Three mutations: \"AAAAACCC\" -&gt; \"AAAACCCC\" -&gt; \"AAACCCCC\" -&gt; \"AACCCCCC\".</p>"}],
        "constraints": ["<code>0 &lt;= bank.length &lt;= 10</code>", "<code>startGene.length == endGene.length == bank[i].length == 8</code>", "<code>startGene</code>, <code>endGene</code>, and <code>bank[i]</code> consist of only the characters <code>\"A\"</code>, <code>\"C\"</code>, <code>\"G\"</code>, and <code>\"T\"</code>."],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Minimum Genetic Mutation involves checking all possible solutions. For BFS problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. BFS problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Minimum Genetic Mutation\n        BFS pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Minimum Genetic Mutation\n     * BFS pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Minimum Genetic Mutation\n     * BFS pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Minimum Genetic Mutation\n * BFS pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Minimum Genetic Mutation leverages breadth-first search traversal to reduce time complexity. Instead of checking all possibilities, we use BFS-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for BFS reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Minimum Genetic Mutation\n        BFS pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Minimum Genetic Mutation\n     * BFS pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Minimum Genetic Mutation\n     * BFS pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Minimum Genetic Mutation\n * BFS pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "snakes-and-ladders": {
        "description": "<p>You are given an <code>n x n</code> integer matrix <code>board</code> where the cells are labeled from <code>1</code> to <code>n<sup>2</sup></code> in a <a href=\"https://en.wikipedia.org/wiki/Boustrophedon\" target=\"_blank\"><strong>Boustrophedon style</strong></a> starting from the bottom left of the board (i.e. <code>board[n - 1][0]</code>) and alternating direction each row.</p><p>You start on square <code>1</code> of the board. In each move, starting from square <code>curr</code>, do the following:</p><ul><li>Choose a destination square <code>next</code> with a label in the range <code>[curr + 1, min(curr + 6, n<sup>2</sup>)]</code>.<ul><li>This choice simulates the result of a standard <strong>6-sided die roll</strong>: i.e., there are always at most 6 destinations, regardless of the size of the board.</li></ul></li><li>If <code>next</code> has a snake or ladder, you <strong>must</strong> move to the destination of that snake or ladder. Otherwise, you move to <code>next</code>.</li><li>The game ends when you reach the square <code>n<sup>2</sup></code>.</li></ul><p>A board square on row <code>r</code> and column <code>c</code> has a snake or ladder if <code>board[r][c] != -1</code>. The destination of that snake or ladder is <code>board[r][c]</code>. Squares <code>1</code> and <code>n<sup>2</sup></code> do not have a snake or ladder.</p><p>Note that you only take a snake or ladder at most once per move. If the destination to a snake or ladder is the start of another snake or ladder, you do <strong>not</strong> follow the subsequent snake or ladder.</p><ul><li>For example, suppose the board is <code>[[-1,4],[-1,3]]</code>, and on the first move, your destination square is <code>2</code>. You follow the ladder to square <code>3</code>, but do <strong>not</strong> follow the subsequent ladder to <code>4</code>.</li></ul><p>Return <em>the least number of moves required to reach the square </em><code>n<sup>2</sup></code><em>. If it is not possible to reach the square, return </em><code>-1</code>.</p>",
        "examples": [{"input": "board = [[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,-1,-1,-1,-1,-1],[-1,35,-1,-1,13,-1],[-1,-1,-1,-1,-1,-1],[-1,15,-1,-1,-1,-1]]", "output": "4", "explanation": "<p>In the beginning, you start at square 1 (at row 5, column 0).<br/>You decide to move to square 2 and must take the ladder to square 15.<br/>You then decide to move to square 17 and must take the snake to square 13.<br/>You then decide to move to square 14 and must take the ladder to square 35.<br/>You then decide to move to square 36, ending the game.<br/>This is the lowest possible number of moves to reach the last square, so return 4.</p>"}, {"input": "board = [[-1,-1],[-1,3]]", "output": "1", "explanation": "<p>You can reach square 2 from square 1 with one move, then square 4 from square 2 with another move, but you cannot reach square 3 directly.</p>"}],
        "constraints": ["<code>n == board.length == board[i].length</code>", "<code>2 &lt;= n &lt;= 20</code>", "<code>board[i][j]</code> is either <code>-1</code> or in the range <code>[1, n<sup>2</sup>]</code>.", "The squares labeled <code>1</code> and <code>n<sup>2</sup></code> do not have any ladders or snakes."],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Snakes and Ladders involves checking all possible solutions. For BFS problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. BFS problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Snakes and Ladders\n        BFS pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Snakes and Ladders\n     * BFS pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Snakes and Ladders\n     * BFS pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Snakes and Ladders\n * BFS pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Snakes and Ladders leverages breadth-first search traversal to reduce time complexity. Instead of checking all possibilities, we use BFS-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for BFS reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Snakes and Ladders\n        BFS pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Snakes and Ladders\n     * BFS pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Snakes and Ladders\n     * BFS pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Snakes and Ladders\n * BFS pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "is-graph-bipartite": {
        "description": "<p>There is an <strong>undirected</strong> graph with <code>n</code> nodes, where each node is numbered between <code>0</code> and <code>n - 1</code>. You are given a 2D array <code>graph</code>, where <code>graph[u]</code> is an array of nodes that node <code>u</code> is adjacent to. More formally, for each <code>v</code> in <code>graph[u]</code>, there is an undirected edge between node <code>u</code> and node <code>v</code>. The graph has the following properties:</p><ul><li>There are no self-edges (<code>graph[u]</code> does not contain <code>u</code>).</li><li>There are no parallel edges (<code>graph[u]</code> does not contain duplicate values).</li><li>If <code>v</code> is in <code>graph[u]</code>, then <code>u</code> is in <code>graph[v]</code> (the graph is undirected).</li><li>The graph may not be connected, meaning there may be two nodes <code>u</code> and <code>v</code> such that there is no path between them.</li></ul><p>A graph is <strong>bipartite</strong> if the nodes can be partitioned into two independent sets <code>A</code> and <code>B</code> such that <strong>every</strong> edge in the graph connects a node in set <code>A</code> and a node in set <code>B</code>.</p><p>Return <code>true</code><em> if and only if it is <strong>bipartite</strong></em>.</p>",
        "examples": [{"input": "graph = [[1,2,3],[0,2],[0,1,3],[0,2]]", "output": "false", "explanation": "<p>There is no way to partition the nodes into two independent sets such that every edge connects a node in one and a node in the other.</p>"}, {"input": "graph = [[1,3],[0,2],[1,3],[0,2]]", "output": "true", "explanation": "<p>We can partition the nodes into two sets: {0, 2} and {1, 3}.</p>"}],
        "constraints": ["<code>graph.length == n</code>", "<code>1 &lt;= n &lt;= 100</code>", "<code>0 &lt;= graph[u].length &lt; n</code>", "<code>0 &lt;= graph[u][i] &lt;= n - 1</code>", "<code>graph[u]</code> does not contain <code>u</code>.", "All the values of <code>graph[u]</code> are <strong>unique</strong>.", "If <code>graph[u]</code> contains <code>v</code>, then <code>graph[v]</code> contains <code>u</code>."],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Is Graph Bipartite? involves checking all possible solutions. For BFS problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. BFS problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Is Graph Bipartite?\n        BFS pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Is Graph Bipartite?\n     * BFS pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Is Graph Bipartite?\n     * BFS pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Is Graph Bipartite?\n * BFS pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Is Graph Bipartite? leverages breadth-first search traversal to reduce time complexity. Instead of checking all possibilities, we use BFS-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for BFS reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Is Graph Bipartite?\n        BFS pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Is Graph Bipartite?\n     * BFS pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Is Graph Bipartite?\n     * BFS pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Is Graph Bipartite?\n * BFS pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "triangle": {
        "description": "<p>Given a <code>triangle</code> array, return <em>the minimum path sum from top to bottom</em>.</p><p>For each step, you may move to an adjacent number of the row below. More formally, if you are on index <code>i</code> on the current row, you may move to either index <code>i</code> or index <code>i + 1</code> on the next row.</p>",
        "examples": [{"input": "triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]", "output": "11", "explanation": "<p>The triangle looks like:<br/>&nbsp;&nbsp;&nbsp;2<br/>&nbsp;&nbsp;3 4<br/>&nbsp;6 5 7<br/>4 1 8 3<br/>The minimum path sum from top to bottom is 2 + 3 + 5 + 1 = 11 (underlined above).</p>"}, {"input": "triangle = [[-10]]", "output": "-10", "explanation": "<p>Single element triangle has sum -10.</p>"}],
        "constraints": ["<code>1 &lt;= triangle.length &lt;= 200</code>", "<code>triangle[0].length == 1</code>", "<code>triangle[i].length == triangle[i - 1].length + 1</code>", "<code>-10<sup>4</sup> &lt;= triangle[i][j] &lt;= 10<sup>4</sup></code>"],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Triangle involves checking all possible solutions. For 2D DP problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(2^n)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. 2D DP problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Triangle\n        2D DP pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Triangle\n     * 2D DP pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Triangle\n     * 2D DP pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Triangle\n * 2D DP pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Triangle leverages two-dimensional dynamic programming to reduce time complexity. Instead of checking all possibilities, we use 2D DP-specific techniques like memoization to cache subproblem results to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (DP table)\n2. Build up solutions from base cases\n3. For each subproblem:\n   - Check if already computed\n   - If not, compute using previously solved subproblems\n   - Store result for reuse\n4. Return the optimal solution\n\nKey optimizations:\n- Memoization prevents recomputation\n- Bottom-up or top-down approach\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Optimized approach for 2D DP reduces complexity significantly. DP table is filled once, each cell computed in O(1). This optimization transforms the solution from exponential to polynomial.",
                    "spaceExplanation": "DP table stores subproblem results. Space equals number of unique states. Can be further optimized by using rolling arrays if only previous row/state needed."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Triangle\n        2D DP pattern implementation\n        Time: O(n)\n        Space: O(n)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize DP table\n        dp = [0] * (n + 1)\n        dp[0] = 1  # Base case\n        \n        for i in range(1, n + 1):\n            # Compute current state from previous states\n            dp[i] = dp[i-1] + (dp[i-2] if i > 1 else 0)\n        \n        return dp[n]",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Triangle\n     * 2D DP pattern implementation\n     * Time: O(n)\n     * Space: O(n)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize DP array\n        int[] dp = new int[n + 1];\n        dp[0] = 1; // Base case\n        \n        for (int i = 1; i <= n; i++) {\n            // Compute current state from previous states\n            dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n        }\n        \n        return new int[]{dp[n]};\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Triangle\n     * 2D DP pattern implementation\n     * Time: O(n)\n     * Space: O(n)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize DP vector\n        vector<int> dp(n + 1, 0);\n        dp[0] = 1; // Base case\n        \n        for (int i = 1; i <= n; i++) {\n            // Compute current state from previous states\n            dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n        }\n        \n        return {dp[n]};\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Triangle\n * 2D DP pattern implementation\n * Time: O(n)\n * Space: O(n)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize DP array\n    const dp = new Array(n + 1).fill(0);\n    dp[0] = 1; // Base case\n    \n    for (let i = 1; i <= n; i++) {\n        // Compute current state from previous states\n        dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n    }\n    \n    return dp[n];\n};"
                }
            }
        }
    },
    "minimum-path-sum": {
        "description": "<p>Given a <code>m x n</code> <code>grid</code> filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path.</p><p><strong>Note:</strong> You can only move either down or right at any point in time.</p>",
        "examples": [{"input": "grid = [[1,3,1],[1,5,1],[4,2,1]]", "output": "7", "explanation": "<p>Because the path 1 \u2192 3 \u2192 1 \u2192 1 \u2192 1 minimizes the sum.</p>"}, {"input": "grid = [[1,2,3],[4,5,6]]", "output": "12", "explanation": "<p>The path is 1 \u2192 2 \u2192 3 \u2192 6.</p>"}],
        "constraints": ["<code>m == grid.length</code>", "<code>n == grid[i].length</code>", "<code>1 &lt;= m, n &lt;= 200</code>", "<code>0 &lt;= grid[i][j] &lt;= 200</code>"],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Minimum Path Sum involves checking all possible solutions. For 2D DP problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(2^n)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. 2D DP problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Minimum Path Sum\n        2D DP pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Minimum Path Sum\n     * 2D DP pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Minimum Path Sum\n     * 2D DP pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Minimum Path Sum\n * 2D DP pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Minimum Path Sum leverages two-dimensional dynamic programming to reduce time complexity. Instead of checking all possibilities, we use 2D DP-specific techniques like memoization to cache subproblem results to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (DP table)\n2. Build up solutions from base cases\n3. For each subproblem:\n   - Check if already computed\n   - If not, compute using previously solved subproblems\n   - Store result for reuse\n4. Return the optimal solution\n\nKey optimizations:\n- Memoization prevents recomputation\n- Bottom-up or top-down approach\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Optimized approach for 2D DP reduces complexity significantly. DP table is filled once, each cell computed in O(1). This optimization transforms the solution from exponential to polynomial.",
                    "spaceExplanation": "DP table stores subproblem results. Space equals number of unique states. Can be further optimized by using rolling arrays if only previous row/state needed."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Minimum Path Sum\n        2D DP pattern implementation\n        Time: O(n)\n        Space: O(n)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize DP table\n        dp = [0] * (n + 1)\n        dp[0] = 1  # Base case\n        \n        for i in range(1, n + 1):\n            # Compute current state from previous states\n            dp[i] = dp[i-1] + (dp[i-2] if i > 1 else 0)\n        \n        return dp[n]",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Minimum Path Sum\n     * 2D DP pattern implementation\n     * Time: O(n)\n     * Space: O(n)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize DP array\n        int[] dp = new int[n + 1];\n        dp[0] = 1; // Base case\n        \n        for (int i = 1; i <= n; i++) {\n            // Compute current state from previous states\n            dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n        }\n        \n        return new int[]{dp[n]};\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Minimum Path Sum\n     * 2D DP pattern implementation\n     * Time: O(n)\n     * Space: O(n)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize DP vector\n        vector<int> dp(n + 1, 0);\n        dp[0] = 1; // Base case\n        \n        for (int i = 1; i <= n; i++) {\n            // Compute current state from previous states\n            dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n        }\n        \n        return {dp[n]};\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Minimum Path Sum\n * 2D DP pattern implementation\n * Time: O(n)\n * Space: O(n)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize DP array\n    const dp = new Array(n + 1).fill(0);\n    dp[0] = 1; // Base case\n    \n    for (let i = 1; i <= n; i++) {\n        // Compute current state from previous states\n        dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n    }\n    \n    return dp[n];\n};"
                }
            }
        }
    },
    "minimum-falling-path-sum": {
        "description": "<p>Given an <code>n x n</code> array of integers <code>matrix</code>, return <em>the <strong>minimum sum</strong> of any <strong>falling path</strong> through</em> <code>matrix</code>.</p><p>A <strong>falling path</strong> starts at any element in the first row and chooses the element in the next row that is either directly below or diagonally left/right. Specifically, the next element from position <code>(row, col)</code> will be <code>(row + 1, col - 1)</code>, <code>(row + 1, col)</code>, or <code>(row + 1, col + 1)</code>.</p>",
        "examples": [{"input": "matrix = [[2,1,3],[6,5,4],[7,8,9]]", "output": "13", "explanation": "<p>There are two falling paths with a minimum sum as shown.<br/>The falling path [1,5,7] = 13 and [1,4,8] = 13.</p>"}, {"input": "matrix = [[-19,57],[-40,-5]]", "output": "-59", "explanation": "<p>The falling path [-19,-40] has minimum sum -59.</p>"}],
        "constraints": ["<code>n == matrix.length == matrix[i].length</code>", "<code>1 &lt;= n &lt;= 100</code>", "<code>-100 &lt;= matrix[i][j] &lt;= 100</code>"],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Minimum Falling Path Sum involves checking all possible solutions. For 2D DP problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(2^n)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. 2D DP problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Minimum Falling Path Sum\n        2D DP pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Minimum Falling Path Sum\n     * 2D DP pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Minimum Falling Path Sum\n     * 2D DP pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Minimum Falling Path Sum\n * 2D DP pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Minimum Falling Path Sum leverages two-dimensional dynamic programming to reduce time complexity. Instead of checking all possibilities, we use 2D DP-specific techniques like memoization to cache subproblem results to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (DP table)\n2. Build up solutions from base cases\n3. For each subproblem:\n   - Check if already computed\n   - If not, compute using previously solved subproblems\n   - Store result for reuse\n4. Return the optimal solution\n\nKey optimizations:\n- Memoization prevents recomputation\n- Bottom-up or top-down approach\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Optimized approach for 2D DP reduces complexity significantly. DP table is filled once, each cell computed in O(1). This optimization transforms the solution from exponential to polynomial.",
                    "spaceExplanation": "DP table stores subproblem results. Space equals number of unique states. Can be further optimized by using rolling arrays if only previous row/state needed."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Minimum Falling Path Sum\n        2D DP pattern implementation\n        Time: O(n)\n        Space: O(n)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize DP table\n        dp = [0] * (n + 1)\n        dp[0] = 1  # Base case\n        \n        for i in range(1, n + 1):\n            # Compute current state from previous states\n            dp[i] = dp[i-1] + (dp[i-2] if i > 1 else 0)\n        \n        return dp[n]",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Minimum Falling Path Sum\n     * 2D DP pattern implementation\n     * Time: O(n)\n     * Space: O(n)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize DP array\n        int[] dp = new int[n + 1];\n        dp[0] = 1; // Base case\n        \n        for (int i = 1; i <= n; i++) {\n            // Compute current state from previous states\n            dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n        }\n        \n        return new int[]{dp[n]};\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Minimum Falling Path Sum\n     * 2D DP pattern implementation\n     * Time: O(n)\n     * Space: O(n)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize DP vector\n        vector<int> dp(n + 1, 0);\n        dp[0] = 1; // Base case\n        \n        for (int i = 1; i <= n; i++) {\n            // Compute current state from previous states\n            dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n        }\n        \n        return {dp[n]};\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Minimum Falling Path Sum\n * 2D DP pattern implementation\n * Time: O(n)\n * Space: O(n)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize DP array\n    const dp = new Array(n + 1).fill(0);\n    dp[0] = 1; // Base case\n    \n    for (let i = 1; i <= n; i++) {\n        // Compute current state from previous states\n        dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n    }\n    \n    return dp[n];\n};"
                }
            }
        }
    },
    "maximal-square": {
        "description": "<p>Given an <code>m x n</code> binary <code>matrix</code> filled with <code>0</code>'s and <code>1</code>'s, <em>find the largest square containing only</em> <code>1</code>'s <em>and return its area</em>.</p>",
        "examples": [{"input": "matrix = [[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"0\"]]\", \"output\": \"4\", \"explanation\": \"<p>The largest square is formed by cells (1,2), (1,3), (2,2), (2,3) with area 4.</p>\"}, {\"input\": \"matrix = [[\"0\",\"1\"],[\"1\",\"0\"]]\", \"output\": \"1\", \"explanation\": \"<p>The largest square has side length 1.</p>\"}, {\"input\": \"matrix = [[\"0\"]]\", \"output\": \"0\", \"explanation\": \"<p>No 1s in the matrix, so area is 0.</p>"}],
        "constraints": ["<code>m == matrix.length</code>", "<code>n == matrix[i].length</code>", "<code>1 &lt;= m, n &lt;= 300</code>", "<code>matrix[i][j]</code> is <code>\"0\"</code> or <code>\"1\"</code>."],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Maximal Square involves checking all possible solutions. For 2D DP problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(2^n)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. 2D DP problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Maximal Square\n        2D DP pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Maximal Square\n     * 2D DP pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Maximal Square\n     * 2D DP pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Maximal Square\n * 2D DP pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Maximal Square leverages two-dimensional dynamic programming to reduce time complexity. Instead of checking all possibilities, we use 2D DP-specific techniques like memoization to cache subproblem results to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (DP table)\n2. Build up solutions from base cases\n3. For each subproblem:\n   - Check if already computed\n   - If not, compute using previously solved subproblems\n   - Store result for reuse\n4. Return the optimal solution\n\nKey optimizations:\n- Memoization prevents recomputation\n- Bottom-up or top-down approach\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Optimized approach for 2D DP reduces complexity significantly. DP table is filled once, each cell computed in O(1). This optimization transforms the solution from exponential to polynomial.",
                    "spaceExplanation": "DP table stores subproblem results. Space equals number of unique states. Can be further optimized by using rolling arrays if only previous row/state needed."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Maximal Square\n        2D DP pattern implementation\n        Time: O(n)\n        Space: O(n)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize DP table\n        dp = [0] * (n + 1)\n        dp[0] = 1  # Base case\n        \n        for i in range(1, n + 1):\n            # Compute current state from previous states\n            dp[i] = dp[i-1] + (dp[i-2] if i > 1 else 0)\n        \n        return dp[n]",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Maximal Square\n     * 2D DP pattern implementation\n     * Time: O(n)\n     * Space: O(n)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize DP array\n        int[] dp = new int[n + 1];\n        dp[0] = 1; // Base case\n        \n        for (int i = 1; i <= n; i++) {\n            // Compute current state from previous states\n            dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n        }\n        \n        return new int[]{dp[n]};\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Maximal Square\n     * 2D DP pattern implementation\n     * Time: O(n)\n     * Space: O(n)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize DP vector\n        vector<int> dp(n + 1, 0);\n        dp[0] = 1; // Base case\n        \n        for (int i = 1; i <= n; i++) {\n            // Compute current state from previous states\n            dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n        }\n        \n        return {dp[n]};\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Maximal Square\n * 2D DP pattern implementation\n * Time: O(n)\n * Space: O(n)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize DP array\n    const dp = new Array(n + 1).fill(0);\n    dp[0] = 1; // Base case\n    \n    for (let i = 1; i <= n; i++) {\n        // Compute current state from previous states\n        dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n    }\n    \n    return dp[n];\n};"
                }
            }
        }
    },
    "ones-and-zeroes": {
        "description": "<p>You are given an array of binary strings <code>strs</code> and two integers <code>m</code> and <code>n</code>.</p><p>Return <em>the size of the largest subset of <code>strs</code> such that there are <strong>at most</strong> </em><code>m</code><em> </em><code>0</code>'s<em> and </em><code>n</code><em> </em><code>1</code>'s<em> in the subset</em>.</p><p>A set <code>x</code> is a <strong>subset</strong> of a set <code>y</code> if all elements of <code>x</code> are also elements of <code>y</code>.</p>",
        "examples": [{"input": "strs = [\"10\",\"0001\",\"111001\",\"1\",\"0\"], m = 5, n = 3\", \"output\": \"4\", \"explanation\": \"<p>The largest subset with at most 5 0\"s and 3 1\"s is {\"10\", \"0001\", \"1\", \"0\"}, so the answer is 4.<br/>Other valid but smaller subsets include {\"0001\", \"1\"} and {\"10\", \"1\", \"0\"}.<br/>{\"111001\"} is an invalid subset because it contains 4 1\"s, greater than the maximum of 3.</p>\"}, {\"input\": \"strs = [\"10\",\"0\",\"1\"], m = 1, n = 1\", \"output\": \"2\", \"explanation\": \"<p>The largest subset is {\"0\", \"1\"}, so the answer is 2.</p>"}],
        "constraints": ["<code>1 &lt;= strs.length &lt;= 600</code>", "<code>1 &lt;= strs[i].length &lt;= 100</code>", "<code>strs[i]</code> consists only of digits <code>\"0\"</code> and <code>\"1\"</code>.", "<code>1 &lt;= m, n &lt;= 100</code>"],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Ones and Zeroes involves checking all possible solutions. For Knapsack DP problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(2^n)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Knapsack DP problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Ones and Zeroes\n        Knapsack DP pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Ones and Zeroes\n     * Knapsack DP pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Ones and Zeroes\n     * Knapsack DP pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Ones and Zeroes\n * Knapsack DP pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Ones and Zeroes leverages knapsack optimization to reduce time complexity. Instead of checking all possibilities, we use Knapsack DP-specific techniques like memoization to cache subproblem results to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (DP table)\n2. Build up solutions from base cases\n3. For each subproblem:\n   - Check if already computed\n   - If not, compute using previously solved subproblems\n   - Store result for reuse\n4. Return the optimal solution\n\nKey optimizations:\n- Memoization prevents recomputation\n- Bottom-up or top-down approach\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(n)",
                    "timeExplanation": "Optimized approach for Knapsack DP reduces complexity significantly. DP table is filled once, each cell computed in O(1). This optimization transforms the solution from exponential to polynomial.",
                    "spaceExplanation": "DP table stores subproblem results. Space equals number of unique states. Can be further optimized by using rolling arrays if only previous row/state needed."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Ones and Zeroes\n        Knapsack DP pattern implementation\n        Time: O(n)\n        Space: O(n)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize DP table\n        dp = [0] * (n + 1)\n        dp[0] = 1  # Base case\n        \n        for i in range(1, n + 1):\n            # Compute current state from previous states\n            dp[i] = dp[i-1] + (dp[i-2] if i > 1 else 0)\n        \n        return dp[n]",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Ones and Zeroes\n     * Knapsack DP pattern implementation\n     * Time: O(n)\n     * Space: O(n)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize DP array\n        int[] dp = new int[n + 1];\n        dp[0] = 1; // Base case\n        \n        for (int i = 1; i <= n; i++) {\n            // Compute current state from previous states\n            dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n        }\n        \n        return new int[]{dp[n]};\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Ones and Zeroes\n     * Knapsack DP pattern implementation\n     * Time: O(n)\n     * Space: O(n)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize DP vector\n        vector<int> dp(n + 1, 0);\n        dp[0] = 1; // Base case\n        \n        for (int i = 1; i <= n; i++) {\n            // Compute current state from previous states\n            dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n        }\n        \n        return {dp[n]};\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Ones and Zeroes\n * Knapsack DP pattern implementation\n * Time: O(n)\n * Space: O(n)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize DP array\n    const dp = new Array(n + 1).fill(0);\n    dp[0] = 1; // Base case\n    \n    for (let i = 1; i <= n; i++) {\n        // Compute current state from previous states\n        dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n    }\n    \n    return dp[n];\n};"
                }
            }
        }
    },
    "last-stone-weight-ii": {
        "description": "<p>You are given an array of integers <code>stones</code> where <code>stones[i]</code> is the weight of the <code>i<sup>th</sup></code> stone.</p><p>We are playing a game with the stones. On each turn, we choose any two stones and smash them together. Suppose the stones have weights <code>x</code> and <code>y</code> with <code>x &lt;= y</code>. The result of this smash is:</p><ul><li>If <code>x == y</code>, both stones are destroyed, and</li><li>If <code>x != y</code>, the stone of weight <code>x</code> is destroyed, and the stone of weight <code>y</code> has new weight <code>y - x</code>.</li></ul><p>At the end of the game, there is <strong>at most one</strong> stone left.</p><p>Return <em>the smallest possible weight of the left stone</em>. If there are no stones left, return <code>0</code>.</p>",
        "examples": [{"input": "stones = [2,7,4,1,8,1]\", \"output\": \"1\", \"explanation\": \"<p>We can combine 2 and 4 to get 2, so the array converts to [2,7,1,8,1] then,<br/>we can combine 7 and 8 to get 1, so the array converts to [2,1,1,1] then,<br/>we can combine 2 and 1 to get 1, so the array converts to [1,1,1] then,<br/>we can combine 1 and 1 to get 0, so the array converts to [1], then that\"s the optimal value.</p>\"}, {\"input\": \"stones = [31,26,33,21,40]\", \"output\": \"5\", \"explanation\": \"<p>One way to achieve minimum weight is to partition into two groups: {40} and {31,26,33,21}. The difference is |40 - 111| = 5, but we cannot achieve smaller.</p>"}],
        "constraints": ["<code>1 &lt;= stones.length &lt;= 30</code>", "<code>1 &lt;= stones[i] &lt;= 100</code>"],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Last Stone Weight II involves checking all possible solutions. For Knapsack DP problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(2^n)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Knapsack DP problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Last Stone Weight II\n        Knapsack DP pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Last Stone Weight II\n     * Knapsack DP pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Last Stone Weight II\n     * Knapsack DP pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Last Stone Weight II\n * Knapsack DP pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Last Stone Weight II leverages knapsack optimization to reduce time complexity. Instead of checking all possibilities, we use Knapsack DP-specific techniques like memoization to cache subproblem results to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (DP table)\n2. Build up solutions from base cases\n3. For each subproblem:\n   - Check if already computed\n   - If not, compute using previously solved subproblems\n   - Store result for reuse\n4. Return the optimal solution\n\nKey optimizations:\n- Memoization prevents recomputation\n- Bottom-up or top-down approach\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(n)",
                    "timeExplanation": "Optimized approach for Knapsack DP reduces complexity significantly. DP table is filled once, each cell computed in O(1). This optimization transforms the solution from exponential to polynomial.",
                    "spaceExplanation": "DP table stores subproblem results. Space equals number of unique states. Can be further optimized by using rolling arrays if only previous row/state needed."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Last Stone Weight II\n        Knapsack DP pattern implementation\n        Time: O(n)\n        Space: O(n)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize DP table\n        dp = [0] * (n + 1)\n        dp[0] = 1  # Base case\n        \n        for i in range(1, n + 1):\n            # Compute current state from previous states\n            dp[i] = dp[i-1] + (dp[i-2] if i > 1 else 0)\n        \n        return dp[n]",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Last Stone Weight II\n     * Knapsack DP pattern implementation\n     * Time: O(n)\n     * Space: O(n)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize DP array\n        int[] dp = new int[n + 1];\n        dp[0] = 1; // Base case\n        \n        for (int i = 1; i <= n; i++) {\n            // Compute current state from previous states\n            dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n        }\n        \n        return new int[]{dp[n]};\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Last Stone Weight II\n     * Knapsack DP pattern implementation\n     * Time: O(n)\n     * Space: O(n)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize DP vector\n        vector<int> dp(n + 1, 0);\n        dp[0] = 1; // Base case\n        \n        for (int i = 1; i <= n; i++) {\n            // Compute current state from previous states\n            dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n        }\n        \n        return {dp[n]};\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Last Stone Weight II\n * Knapsack DP pattern implementation\n * Time: O(n)\n * Space: O(n)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize DP array\n    const dp = new Array(n + 1).fill(0);\n    dp[0] = 1; // Base case\n    \n    for (let i = 1; i <= n; i++) {\n        // Compute current state from previous states\n        dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n    }\n    \n    return dp[n];\n};"
                }
            }
        }
    },
    "combination-sum-iv": {
        "description": "<p>Given an array of <strong>distinct</strong> integers <code>nums</code> and a target integer <code>target</code>, return <em>the number of possible combinations that add up to</em>&nbsp;<code>target</code>.</p><p>The test cases are generated so that the answer can fit in a <strong>32-bit</strong> integer.</p>",
        "examples": [{"input": "nums = [1,2,3], target = 4", "output": "7", "explanation": "<p>The possible combination ways are:<br/>(1, 1, 1, 1)<br/>(1, 1, 2)<br/>(1, 2, 1)<br/>(1, 3)<br/>(2, 1, 1)<br/>(2, 2)<br/>(3, 1)<br/>Note that different sequences are counted as different combinations.</p>"}, {"input": "nums = [9], target = 3", "output": "0", "explanation": "<p>No combinations sum to target.</p>"}],
        "constraints": ["<code>1 &lt;= nums.length &lt;= 200</code>", "<code>1 &lt;= nums[i] &lt;= 1000</code>", "All the elements of <code>nums</code> are <strong>unique</strong>.", "<code>1 &lt;= target &lt;= 1000</code>"],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Combination Sum IV involves checking all possible solutions. For DP problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(2^n)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. DP problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Combination Sum IV\n        DP pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Combination Sum IV\n     * DP pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Combination Sum IV\n     * DP pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Combination Sum IV\n * DP pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Combination Sum IV leverages dynamic programming optimization to reduce time complexity. Instead of checking all possibilities, we use DP-specific techniques like memoization to cache subproblem results to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (DP table)\n2. Build up solutions from base cases\n3. For each subproblem:\n   - Check if already computed\n   - If not, compute using previously solved subproblems\n   - Store result for reuse\n4. Return the optimal solution\n\nKey optimizations:\n- Memoization prevents recomputation\n- Bottom-up or top-down approach\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(n)",
                    "timeExplanation": "Optimized approach for DP reduces complexity significantly. DP table is filled once, each cell computed in O(1). This optimization transforms the solution from exponential to polynomial.",
                    "spaceExplanation": "DP table stores subproblem results. Space equals number of unique states. Can be further optimized by using rolling arrays if only previous row/state needed."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Combination Sum IV\n        DP pattern implementation\n        Time: O(n)\n        Space: O(n)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize DP table\n        dp = [0] * (n + 1)\n        dp[0] = 1  # Base case\n        \n        for i in range(1, n + 1):\n            # Compute current state from previous states\n            dp[i] = dp[i-1] + (dp[i-2] if i > 1 else 0)\n        \n        return dp[n]",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Combination Sum IV\n     * DP pattern implementation\n     * Time: O(n)\n     * Space: O(n)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize DP array\n        int[] dp = new int[n + 1];\n        dp[0] = 1; // Base case\n        \n        for (int i = 1; i <= n; i++) {\n            // Compute current state from previous states\n            dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n        }\n        \n        return new int[]{dp[n]};\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Combination Sum IV\n     * DP pattern implementation\n     * Time: O(n)\n     * Space: O(n)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize DP vector\n        vector<int> dp(n + 1, 0);\n        dp[0] = 1; // Base case\n        \n        for (int i = 1; i <= n; i++) {\n            // Compute current state from previous states\n            dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n        }\n        \n        return {dp[n]};\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Combination Sum IV\n * DP pattern implementation\n * Time: O(n)\n * Space: O(n)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize DP array\n    const dp = new Array(n + 1).fill(0);\n    dp[0] = 1; // Base case\n    \n    for (let i = 1; i <= n; i++) {\n        // Compute current state from previous states\n        dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n    }\n    \n    return dp[n];\n};"
                }
            }
        }
    },
    "perfect-squares": {
        "description": "<p>Given an integer <code>n</code>, return <em>the least number of perfect square numbers that sum to</em> <code>n</code>.</p><p>A <strong>perfect square</strong> is an integer that is the square of an integer; in other words, it is the product of some integer with itself. For example, <code>1</code>, <code>4</code>, <code>9</code>, and <code>16</code> are perfect squares while <code>3</code> and <code>11</code> are not.</p>",
        "examples": [{"input": "n = 12", "output": "3", "explanation": "<p>12 = 4 + 4 + 4.</p>"}, {"input": "n = 13", "output": "2", "explanation": "<p>13 = 4 + 9.</p>"}],
        "constraints": ["<code>1 &lt;= n &lt;= 10<sup>4</sup></code>"],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Perfect Squares involves checking all possible solutions. For DP problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(2^n)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. DP problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Perfect Squares\n        DP pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Perfect Squares\n     * DP pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Perfect Squares\n     * DP pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Perfect Squares\n * DP pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Perfect Squares leverages dynamic programming optimization to reduce time complexity. Instead of checking all possibilities, we use DP-specific techniques like memoization to cache subproblem results to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (DP table)\n2. Build up solutions from base cases\n3. For each subproblem:\n   - Check if already computed\n   - If not, compute using previously solved subproblems\n   - Store result for reuse\n4. Return the optimal solution\n\nKey optimizations:\n- Memoization prevents recomputation\n- Bottom-up or top-down approach\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(n)",
                    "timeExplanation": "Optimized approach for DP reduces complexity significantly. DP table is filled once, each cell computed in O(1). This optimization transforms the solution from exponential to polynomial.",
                    "spaceExplanation": "DP table stores subproblem results. Space equals number of unique states. Can be further optimized by using rolling arrays if only previous row/state needed."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Perfect Squares\n        DP pattern implementation\n        Time: O(n)\n        Space: O(n)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize DP table\n        dp = [0] * (n + 1)\n        dp[0] = 1  # Base case\n        \n        for i in range(1, n + 1):\n            # Compute current state from previous states\n            dp[i] = dp[i-1] + (dp[i-2] if i > 1 else 0)\n        \n        return dp[n]",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Perfect Squares\n     * DP pattern implementation\n     * Time: O(n)\n     * Space: O(n)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize DP array\n        int[] dp = new int[n + 1];\n        dp[0] = 1; // Base case\n        \n        for (int i = 1; i <= n; i++) {\n            // Compute current state from previous states\n            dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n        }\n        \n        return new int[]{dp[n]};\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Perfect Squares\n     * DP pattern implementation\n     * Time: O(n)\n     * Space: O(n)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize DP vector\n        vector<int> dp(n + 1, 0);\n        dp[0] = 1; // Base case\n        \n        for (int i = 1; i <= n; i++) {\n            // Compute current state from previous states\n            dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n        }\n        \n        return {dp[n]};\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Perfect Squares\n * DP pattern implementation\n * Time: O(n)\n * Space: O(n)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize DP array\n    const dp = new Array(n + 1).fill(0);\n    dp[0] = 1; // Base case\n    \n    for (let i = 1; i <= n; i++) {\n        // Compute current state from previous states\n        dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n    }\n    \n    return dp[n];\n};"
                }
            }
        }
    },
    "integer-break": {
        "description": "<p>Given an integer <code>n</code>, break it into the sum of <code>k</code> <strong>positive integers</strong>, where <code>k &gt;= 2</code>, and maximize the product of those integers.</p><p>Return <em>the maximum product you can get</em>.</p>",
        "examples": [{"input": "n = 2", "output": "1", "explanation": "<p>2 = 1 + 1, 1 √ó 1 = 1.</p>"}, {"input": "n = 10", "output": "36", "explanation": "<p>10 = 3 + 3 + 4, 3 √ó 3 √ó 4 = 36.</p>"}],
        "constraints": ["<code>2 &lt;= n &lt;= 58</code>"],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Integer Break involves checking all possible solutions. For DP problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(2^n)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. DP problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Integer Break\n        DP pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Integer Break\n     * DP pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Integer Break\n     * DP pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Integer Break\n * DP pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Integer Break leverages dynamic programming optimization to reduce time complexity. Instead of checking all possibilities, we use DP-specific techniques like memoization to cache subproblem results to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (DP table)\n2. Build up solutions from base cases\n3. For each subproblem:\n   - Check if already computed\n   - If not, compute using previously solved subproblems\n   - Store result for reuse\n4. Return the optimal solution\n\nKey optimizations:\n- Memoization prevents recomputation\n- Bottom-up or top-down approach\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(n)",
                    "timeExplanation": "Optimized approach for DP reduces complexity significantly. DP table is filled once, each cell computed in O(1). This optimization transforms the solution from exponential to polynomial.",
                    "spaceExplanation": "DP table stores subproblem results. Space equals number of unique states. Can be further optimized by using rolling arrays if only previous row/state needed."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Integer Break\n        DP pattern implementation\n        Time: O(n)\n        Space: O(n)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize DP table\n        dp = [0] * (n + 1)\n        dp[0] = 1  # Base case\n        \n        for i in range(1, n + 1):\n            # Compute current state from previous states\n            dp[i] = dp[i-1] + (dp[i-2] if i > 1 else 0)\n        \n        return dp[n]",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Integer Break\n     * DP pattern implementation\n     * Time: O(n)\n     * Space: O(n)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize DP array\n        int[] dp = new int[n + 1];\n        dp[0] = 1; // Base case\n        \n        for (int i = 1; i <= n; i++) {\n            // Compute current state from previous states\n            dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n        }\n        \n        return new int[]{dp[n]};\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Integer Break\n     * DP pattern implementation\n     * Time: O(n)\n     * Space: O(n)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize DP vector\n        vector<int> dp(n + 1, 0);\n        dp[0] = 1; // Base case\n        \n        for (int i = 1; i <= n; i++) {\n            // Compute current state from previous states\n            dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n        }\n        \n        return {dp[n]};\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Integer Break\n * DP pattern implementation\n * Time: O(n)\n * Space: O(n)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize DP array\n    const dp = new Array(n + 1).fill(0);\n    dp[0] = 1; // Base case\n    \n    for (let i = 1; i <= n; i++) {\n        // Compute current state from previous states\n        dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n    }\n    \n    return dp[n];\n};"
                }
            }
        }
    },
    "best-time-to-buy-and-sell-stock-with-transaction-fee": {
        "description": "<p>You are given an array <code>prices</code> where <code>prices[i]</code> is the price of a given stock on the <code>i<sup>th</sup></code> day, and an integer <code>fee</code> representing a transaction fee.</p><p>Find the maximum profit you can achieve. You may complete as many transactions as you like, but you need to pay the transaction fee for each transaction.</p><p><strong>Note:</strong></p><ul><li>You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).</li><li>The transaction fee is only charged once for each stock purchase and sale.</li></ul>",
        "examples": [{"input": "prices = [1,3,2,8,4,9], fee = 2", "output": "8", "explanation": "<p>The maximum profit can be achieved by:<br/>- Buying at prices[0] = 1<br/>- Selling at prices[3] = 8<br/>- Buying at prices[4] = 4<br/>- Selling at prices[5] = 9<br/>The total profit is ((8 - 1) - 2) + ((9 - 4) - 2) = 8.</p>"}, {"input": "prices = [1,3,7,5,10,3], fee = 3", "output": "6", "explanation": "<p>Buy at prices[0] = 1, sell at prices[4] = 10, profit = 10 - 1 - 3 = 6.</p>"}],
        "constraints": ["<code>1 &lt;= prices.length &lt;= 5 * 10<sup>4</sup></code>", "<code>1 &lt;= prices[i] &lt; 5 * 10<sup>4</sup></code>", "<code>0 &lt;= fee &lt; 5 * 10<sup>4</sup></code>"],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Best Time to Buy and Sell Stock with Transaction Fee involves checking all possible solutions. For State DP problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(2^n)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. State DP problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Best Time to Buy and Sell Stock with Transaction Fee\n        State DP pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Best Time to Buy and Sell Stock with Transaction Fee\n     * State DP pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Best Time to Buy and Sell Stock with Transaction Fee\n     * State DP pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Best Time to Buy and Sell Stock with Transaction Fee\n * State DP pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Best Time to Buy and Sell Stock with Transaction Fee leverages state-based dynamic programming to reduce time complexity. Instead of checking all possibilities, we use State DP-specific techniques like memoization to cache subproblem results to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (DP table)\n2. Build up solutions from base cases\n3. For each subproblem:\n   - Check if already computed\n   - If not, compute using previously solved subproblems\n   - Store result for reuse\n4. Return the optimal solution\n\nKey optimizations:\n- Memoization prevents recomputation\n- Bottom-up or top-down approach\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(n)",
                    "timeExplanation": "Optimized approach for State DP reduces complexity significantly. DP table is filled once, each cell computed in O(1). This optimization transforms the solution from exponential to polynomial.",
                    "spaceExplanation": "DP table stores subproblem results. Space equals number of unique states. Can be further optimized by using rolling arrays if only previous row/state needed."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Best Time to Buy and Sell Stock with Transaction Fee\n        State DP pattern implementation\n        Time: O(n)\n        Space: O(n)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize DP table\n        dp = [0] * (n + 1)\n        dp[0] = 1  # Base case\n        \n        for i in range(1, n + 1):\n            # Compute current state from previous states\n            dp[i] = dp[i-1] + (dp[i-2] if i > 1 else 0)\n        \n        return dp[n]",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Best Time to Buy and Sell Stock with Transaction Fee\n     * State DP pattern implementation\n     * Time: O(n)\n     * Space: O(n)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize DP array\n        int[] dp = new int[n + 1];\n        dp[0] = 1; // Base case\n        \n        for (int i = 1; i <= n; i++) {\n            // Compute current state from previous states\n            dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n        }\n        \n        return new int[]{dp[n]};\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Best Time to Buy and Sell Stock with Transaction Fee\n     * State DP pattern implementation\n     * Time: O(n)\n     * Space: O(n)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize DP vector\n        vector<int> dp(n + 1, 0);\n        dp[0] = 1; // Base case\n        \n        for (int i = 1; i <= n; i++) {\n            // Compute current state from previous states\n            dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n        }\n        \n        return {dp[n]};\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Best Time to Buy and Sell Stock with Transaction Fee\n * State DP pattern implementation\n * Time: O(n)\n * Space: O(n)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize DP array\n    const dp = new Array(n + 1).fill(0);\n    dp[0] = 1; // Base case\n    \n    for (let i = 1; i <= n; i++) {\n        // Compute current state from previous states\n        dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n    }\n    \n    return dp[n];\n};"
                }
            }
        }
    },
    "eliminate-maximum-number-of-monsters": {
        "description": "<p>You are playing a video game where you are defending your city from a group of <code>n</code> monsters. You are given a <strong>0-indexed</strong> integer array <code>dist</code> of size <code>n</code>, where <code>dist[i]</code> is the <strong>initial distance</strong> in kilometers of the <code>i<sup>th</sup></code> monster from the city.</p><p>The monsters walk toward the city at a <strong>constant</strong> speed. The speed of each monster is given in an integer array <code>speed</code> of size <code>n</code>, where <code>speed[i]</code> is the speed of the <code>i<sup>th</sup></code> monster in kilometers per minute.</p><p>You have a weapon that, once fully charged, can eliminate a <strong>single</strong> monster. However, the weapon takes <strong>one minute</strong> to charge. The weapon is fully charged at the very start.</p><p>You lose when any monster reaches your city. If a monster reaches the city at the exact moment the weapon is fully charged, it counts as a <strong>loss</strong>, and the game ends before you can use your weapon.</p><p>Return <em>the <strong>maximum</strong> number of monsters that you can eliminate before you lose, or </em><code>n</code><em> if you can eliminate all the monsters before they reach the city.</em></p>",
        "examples": [{"input": "dist = [1,3,4], speed = [1,1,1]", "output": "3", "explanation": "<p>In the beginning, the distances of the monsters are [1,3,4]. You eliminate the first monster.<br/>After a minute, the distances of the monsters are [X,2,3]. You eliminate the second monster.<br/>After a minute, the distances of the monsters are [X,X,2]. You eliminate the third monster.<br/>All 3 monsters can be eliminated.</p>"}, {"input": "dist = [1,1,2,3], speed = [1,1,1,1]", "output": "1", "explanation": "<p>In the beginning, the distances of the monsters are [1,1,2,3]. You eliminate the first monster.<br/>After a minute, the distances of the monsters are [X,0,1,2], so you lose.<br/>You can only eliminate 1 monster.</p>"}, {"input": "dist = [3,2,4], speed = [5,3,2]", "output": "1", "explanation": "<p>In the beginning, the distances of the monsters are [3,2,4].<br/>After 0 minutes, you eliminate one monster. After that, distances become [X,2,4] or [3,X,4] or [3,2,X].<br/>However, regardless of which you eliminate, at least one monster will reach the city before you can eliminate another.</p>"}],
        "constraints": ["<code>n == dist.length == speed.length</code>", "<code>1 &lt;= n &lt;= 10<sup>5</sup></code>", "<code>1 &lt;= dist[i], speed[i] &lt;= 10<sup>5</sup></code>"],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Eliminate Maximum Number of Monsters involves checking all possible solutions. For Greedy problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Greedy problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Eliminate Maximum Number of Monsters\n        Greedy pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Eliminate Maximum Number of Monsters\n     * Greedy pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Eliminate Maximum Number of Monsters\n     * Greedy pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Eliminate Maximum Number of Monsters\n * Greedy pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Eliminate Maximum Number of Monsters leverages greedy choice optimization to reduce time complexity. Instead of checking all possibilities, we use Greedy-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Make locally optimal choices\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Local optimal choices lead to global optimum\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for Greedy reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Only constant extra space needed for pointers and variables. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Eliminate Maximum Number of Monsters\n        Greedy pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Eliminate Maximum Number of Monsters\n     * Greedy pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Eliminate Maximum Number of Monsters\n     * Greedy pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Eliminate Maximum Number of Monsters\n * Greedy pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "boats-to-save-people": {
        "description": "<p>You are given an array <code>people</code> where <code>people[i]</code> is the weight of the <code>i<sup>th</sup></code> person, and an <strong>infinite number of boats</strong> where each boat can carry a maximum weight of <code>limit</code>. Each boat carries at most two people at the same time, provided the sum of the weight of those people is at most <code>limit</code>.</p><p>Return <em>the minimum number of boats to carry every given person</em>.</p>",
        "examples": [{"input": "people = [1,2], limit = 3", "output": "1", "explanation": "<p>1 boat (1, 2)</p>"}, {"input": "people = [3,2,2,1], limit = 3", "output": "3", "explanation": "<p>3 boats (1, 2), (2) and (3)</p>"}, {"input": "people = [3,5,3,4], limit = 5", "output": "4", "explanation": "<p>4 boats (3), (3), (4), (5)</p>"}],
        "constraints": ["<code>1 &lt;= people.length &lt;= 5 * 10<sup>4</sup></code>", "<code>1 &lt;= people[i] &lt;= limit &lt;= 3 * 10<sup>4</sup></code>"],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Boats to Save People involves checking all possible solutions. For Two Pointers problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Two Pointers problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Boats to Save People\n        Two Pointers pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Boats to Save People\n     * Two Pointers pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Boats to Save People\n     * Two Pointers pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Boats to Save People\n * Two Pointers pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Boats to Save People leverages two-pointer technique optimization to reduce time complexity. Instead of checking all possibilities, we use Two Pointers-specific techniques like two pointers to avoid nested loops to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Place pointers at strategic positions\n3. While pointers haven't crossed:\n   - Process current elements\n   - Move pointers based on logic\n   - Update result\n4. Return the optimal solution\n\nKey optimizations:\n- Single pass instead of nested loops\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for Two Pointers reduces complexity significantly. Two pointers traverse array once without backtracking. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Only constant extra space needed for pointers and variables. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Boats to Save People\n        Two Pointers pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Two pointer approach\n        left, right = 0, n - 1\n        \n        while left < right:\n            # Process current elements\n            if condition(input[left], input[right]):\n                result.append([left, right])\n                left += 1\n            else:\n                right -= 1\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Boats to Save People\n     * Two Pointers pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Two pointer approach\n        int left = 0, right = n - 1;\n        \n        while (left < right) {\n            // Process current elements\n            if (condition(input[left], input[right])) {\n                result.add(left);\n                result.add(right);\n                left++;\n            } else {\n                right--;\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Boats to Save People\n     * Two Pointers pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Two pointer approach\n        int left = 0, right = n - 1;\n        \n        while (left < right) {\n            // Process current elements\n            if (condition(input[left], input[right])) {\n                result.push_back(left);\n                result.push_back(right);\n                left++;\n            } else {\n                right--;\n            }\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Boats to Save People\n * Two Pointers pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Two pointer approach\n    let left = 0, right = n - 1;\n    \n    while (left < right) {\n        // Process current elements\n        if (condition(input[left], input[right])) {\n            result.push(left, right);\n            left++;\n        } else {\n            right--;\n        }\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "successful-pairs-of-spells-and-potions": {
        "description": "<p>You are given two positive integer arrays <code>spells</code> and <code>potions</code>, of length <code>n</code> and <code>m</code> respectively, where <code>spells[i]</code> represents the strength of the <code>i<sup>th</sup></code> spell and <code>potions[j]</code> represents the strength of the <code>j<sup>th</sup></code> potion.</p><p>You are also given an integer <code>success</code>. A spell and potion pair is considered <strong>successful</strong> if the <strong>product</strong> of their strengths is <strong>at least</strong> <code>success</code>.</p><p>Return <em>an integer array </em><code>pairs</code><em> of length </em><code>n</code><em> where </em><code>pairs[i]</code><em> is the number of <strong>potions</strong> that will form a successful pair with the </em><code>i<sup>th</sup></code><em> spell.</em></p>",
        "examples": [{"input": "spells = [5,1,3], potions = [1,2,3,4,5], success = 7", "output": "[4,0,3]", "explanation": "<p>- 0<sup>th</sup> spell: 5 * [2,3,4,5] = [10,15,20,25]. 4 pairs.<br/>- 1<sup>st</sup> spell: 1 * [1,2,3,4,5] = [1,2,3,4,5]. 0 pairs.<br/>- 2<sup>nd</sup> spell: 3 * [3,4,5] = [9,12,15]. 3 pairs.<br/>Thus, [4,0,3] is returned.</p>"}, {"input": "spells = [3,1,2], potions = [8,5,8], success = 16", "output": "[2,0,2]", "explanation": "<p>- 0<sup>th</sup> spell: 3 * [8,8] = [24,24]. 2 pairs.<br/>- 1<sup>st</sup> spell: 1 * []. 0 pairs.<br/>- 2<sup>nd</sup> spell: 2 * [8,8] = [16,16]. 2 pairs.<br/>Thus, [2,0,2] is returned.</p>"}],
        "constraints": ["<code>n == spells.length</code>", "<code>m == potions.length</code>", "<code>1 &lt;= n, m &lt;= 10<sup>5</sup></code>", "<code>1 &lt;= spells[i], potions[i] &lt;= 10<sup>5</sup></code>", "<code>1 &lt;= success &lt;= 10<sup>10</sup></code>"],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Successful Pairs of Spells and Potions involves checking all possible solutions. For Binary Search problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Binary Search problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Successful Pairs of Spells and Potions\n        Binary Search pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Successful Pairs of Spells and Potions\n     * Binary Search pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Successful Pairs of Spells and Potions\n     * Binary Search pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Successful Pairs of Spells and Potions\n * Binary Search pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Successful Pairs of Spells and Potions leverages binary search algorithm to reduce time complexity. Instead of checking all possibilities, we use Binary Search-specific techniques like binary search for O(log n) lookups to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Set up binary search boundaries\n3. While search space exists:\n   - Check middle element\n   - Eliminate half the search space\n   - Continue until found\n4. Return the optimal solution\n\nKey optimizations:\n- Logarithmic search reduces complexity\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(log n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for Binary Search reduces complexity significantly. Binary search halves search space each iteration. This optimization transforms the solution from O(n) to O(log n).",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Successful Pairs of Spells and Potions\n        Binary Search pattern implementation\n        Time: O(log n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        while left <= right:\n            mid = (left + right) // 2\n            if input[mid] == target:\n                return mid\n            elif input[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return -1",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Successful Pairs of Spells and Potions\n     * Binary Search pattern implementation\n     * Time: O(log n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            if (input[mid] == target) {\n                return new int[]{mid};\n            } else if (input[mid] < target) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n        \n        return new int[]{-1};\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Successful Pairs of Spells and Potions\n     * Binary Search pattern implementation\n     * Time: O(log n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            if (input[mid] == target) {\n                return {mid};\n            } else if (input[mid] < target) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n        \n        return {-1};\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Successful Pairs of Spells and Potions\n * Binary Search pattern implementation\n * Time: O(log n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    while (left <= right) {\n        const mid = Math.floor((left + right) / 2);\n        if (input[mid] === target) {\n            return [mid];\n        } else if (input[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    \n    return -1;\n};"
                }
            }
        }
    },
    "single-element-in-a-sorted-array": {
        "description": "<p>You are given a sorted array consisting of only integers where every element appears exactly twice, except for one element which appears exactly once.</p><p>Return <em>the single element that appears only once</em>.</p><p>Your solution must run in <code>O(log n)</code> time and <code>O(1)</code> space.</p>",
        "examples": [{"input": "nums = [1,1,2,3,3,4,4,8,8]", "output": "2", "explanation": "<p>2 appears only once.</p>"}, {"input": "nums = [3,3,7,7,10,11,11]", "output": "10", "explanation": "<p>10 appears only once.</p>"}],
        "constraints": ["<code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code>", "<code>0 &lt;= nums[i] &lt;= 10<sup>5</sup></code>"],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Single Element in a Sorted Array involves checking all possible solutions. For Binary Search problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Binary Search problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Single Element in a Sorted Array\n        Binary Search pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Single Element in a Sorted Array\n     * Binary Search pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Single Element in a Sorted Array\n     * Binary Search pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Single Element in a Sorted Array\n * Binary Search pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Single Element in a Sorted Array leverages binary search algorithm to reduce time complexity. Instead of checking all possibilities, we use Binary Search-specific techniques like binary search for O(log n) lookups to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Set up binary search boundaries\n3. While search space exists:\n   - Check middle element\n   - Eliminate half the search space\n   - Continue until found\n4. Return the optimal solution\n\nKey optimizations:\n- Logarithmic search reduces complexity\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(log n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for Binary Search reduces complexity significantly. Binary search halves search space each iteration. This optimization transforms the solution from O(n) to O(log n).",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Single Element in a Sorted Array\n        Binary Search pattern implementation\n        Time: O(log n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        while left <= right:\n            mid = (left + right) // 2\n            if input[mid] == target:\n                return mid\n            elif input[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return -1",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Single Element in a Sorted Array\n     * Binary Search pattern implementation\n     * Time: O(log n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            if (input[mid] == target) {\n                return new int[]{mid};\n            } else if (input[mid] < target) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n        \n        return new int[]{-1};\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Single Element in a Sorted Array\n     * Binary Search pattern implementation\n     * Time: O(log n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            if (input[mid] == target) {\n                return {mid};\n            } else if (input[mid] < target) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n        \n        return {-1};\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Single Element in a Sorted Array\n * Binary Search pattern implementation\n * Time: O(log n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    while (left <= right) {\n        const mid = Math.floor((left + right) / 2);\n        if (input[mid] === target) {\n            return [mid];\n        } else if (input[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    \n    return -1;\n};"
                }
            }
        }
    },
    "search-suggestions-system": {
        "description": "<p>You are given an array of strings <code>products</code> and a string <code>searchWord</code>.</p><p>Design a system that suggests at most three product names from <code>products</code> after each character of <code>searchWord</code> is typed. Suggested products should have common prefix with <code>searchWord</code>. If there are more than three products with a common prefix return the three lexicographically minimum products.</p><p>Return <em>a list of lists of the suggested products after each character of </em><code>searchWord</code><em> is typed</em>.</p>",
        "examples": [{"input": "products = [\"mobile\",\"mouse\",\"moneypot\",\"monitor\",\"mousepad\"], searchWord = \"mouse\"\", \"output\": \"[[\"mobile\",\"moneypot\",\"monitor\"],[\"mobile\",\"moneypot\",\"monitor\"],[\"mouse\",\"mousepad\"],[\"mouse\",\"mousepad\"],[\"mouse\",\"mousepad\"]]\", \"explanation\": \"<p>products sorted lexicographically = [\"mobile\",\"moneypot\",\"monitor\",\"mouse\",\"mousepad\"]<br/>After typing m and mo all products match and we show user [\"mobile\",\"moneypot\",\"monitor\"]<br/>After typing mou, mous and mouse the system suggests [\"mouse\",\"mousepad\"]</p>\"}, {\"input\": \"products = [\"havana\"], searchWord = \"havana\"\", \"output\": \"[[\"havana\"],[\"havana\"],[\"havana\"],[\"havana\"],[\"havana\"],[\"havana\"]]\", \"explanation\": \"<p>The only word \"havana\" will be always suggested while typing the search word.</p>"}],
        "constraints": ["<code>1 &lt;= products.length &lt;= 1000</code>", "<code>1 &lt;= products[i].length &lt;= 3000</code>", "<code>1 &lt;= sum(products[i].length) &lt;= 2 * 10<sup>4</sup></code>", "All the strings of <code>products</code> are <strong>unique</strong>.", "<code>products[i]</code> consists of lowercase English letters.", "<code>1 &lt;= searchWord.length &lt;= 1000</code>", "<code>searchWord</code> consists of lowercase English letters."],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Search Suggestions System involves checking all possible solutions. For Tries problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Tries problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Search Suggestions System\n        Tries pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Search Suggestions System\n     * Tries pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Search Suggestions System\n     * Tries pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Search Suggestions System\n * Tries pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Search Suggestions System leverages word prefix tree structure to reduce time complexity. Instead of checking all possibilities, we use Tries-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for Tries reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Search Suggestions System\n        Tries pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Search Suggestions System\n     * Tries pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Search Suggestions System\n     * Tries pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Search Suggestions System\n * Tries pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "implement-magic-dictionary": {
        "description": "<p>Design a data structure that is initialized with a list of <strong>different</strong> words. Provided a string, you should determine if you can change exactly one character in this string to match any word in the data structure.</p><p>Implement the <code>MagicDictionary</code> class:</p><ul><li><code>MagicDictionary()</code> Initializes the object.</li><li><code>void buildDict(String[] dictionary)</code> Sets the data structure with an array of distinct strings <code>dictionary</code>.</li><li><code>bool search(String searchWord)</code> Returns <code>true</code> if you can change <strong>exactly one character</strong> in <code>searchWord</code> to match any string in the data structure, otherwise returns <code>false</code>.</li></ul>",
        "examples": [{"input": "[\"MagicDictionary\", \"buildDict\", \"search\", \"search\", \"search\", \"search\"]\\n[[], [[\"hello\", \"leetcode\"]], [\"hello\"], [\"hhllo\"], [\"hell\"], [\"leetcoded\"]]\", \"output\": \"[null, null, false, true, false, false]\", \"explanation\": \"<p>MagicDictionary magicDictionary = new MagicDictionary();<br/>magicDictionary.buildDict([\"hello\", \"leetcode\"]);<br/>magicDictionary.search(\"hello\"); // return false<br/>magicDictionary.search(\"hhllo\"); // We can change the second \"h\" to \"e\" to match \"hello\" so we return true<br/>magicDictionary.search(\"hell\"); // return false<br/>magicDictionary.search(\"leetcoded\"); // return false</p>"}],
        "constraints": ["<code>1 &lt;= dictionary.length &lt;= 100</code>", "<code>1 &lt;= dictionary[i].length &lt;= 100</code>", "<code>dictionary[i]</code> consists of only lower-case English letters.", "All the strings in <code>dictionary</code> are <strong>distinct</strong>.", "<code>1 &lt;= searchWord.length &lt;= 100</code>", "<code>searchWord</code> consists of only lower-case English letters.", "<code>buildDict</code> will be called only once before <code>search</code>.", "At most <code>100</code> calls will be made to <code>search</code>."],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Implement Magic Dictionary involves checking all possible solutions. For Tries problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Tries problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Implement Magic Dictionary\n        Tries pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Implement Magic Dictionary\n     * Tries pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Implement Magic Dictionary\n     * Tries pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Implement Magic Dictionary\n * Tries pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Implement Magic Dictionary leverages word prefix tree structure to reduce time complexity. Instead of checking all possibilities, we use Tries-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for Tries reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Implement Magic Dictionary\n        Tries pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Implement Magic Dictionary\n     * Tries pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Implement Magic Dictionary\n     * Tries pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Implement Magic Dictionary\n * Tries pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "replace-words": {
        "description": "<p>In English, we have a concept called <strong>root</strong>, which can be followed by some other word to form another longer word - let's call this word <strong>derivative</strong>. For example, when the <strong>root</strong> <code>\"help\"</code> is followed by the word <code>\"ful\"</code>, we can form a derivative <code>\"helpful\"</code>.</p><p>Given a <code>dictionary</code> consisting of many <strong>roots</strong> and a <code>sentence</code> consisting of words separated by spaces, replace all the derivatives in the sentence with the <strong>root</strong> forming it. If a derivative can be replaced by more than one <strong>root</strong>, replace it with the <strong>root</strong> that has <strong>the shortest length</strong>.</p><p>Return <em>the </em><code>sentence</code><em> after the replacement</em>.</p>",
        "examples": [{"input": "dictionary = [\"cat\",\"bat\",\"rat\"], sentence = \"the cattle was rattled by the battery\"\", \"output\": \"\"the cat was rat by the bat\"\", \"explanation\": \"<p>Replace \"cattle\" with \"cat\", \"rattled\" with \"rat\", and \"battery\" with \"bat\".</p>\"}, {\"input\": \"dictionary = [\"a\",\"b\",\"c\"], sentence = \"aadsfasf absbs bbab cadsfafs\"\", \"output\": \"\"a a b c\"\", \"explanation\": \"<p>Replace each word with its shortest root.</p>"}],
        "constraints": ["<code>1 &lt;= dictionary.length &lt;= 1000</code>", "<code>1 &lt;= dictionary[i].length &lt;= 100</code>", "<code>dictionary[i]</code> consists of only lower-case letters.", "<code>1 &lt;= sentence.length &lt;= 10<sup>6</sup></code>", "<code>sentence</code> consists of only lower-case letters and spaces.", "The number of words in <code>sentence</code> is in the range <code>[1, 1000]</code>", "The length of each word in <code>sentence</code> is in the range <code>[1, 1000]</code>", "Every two consecutive words in <code>sentence</code> will be separated by exactly one space.", "<code>sentence</code> does not have leading or trailing spaces."],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Replace Words involves checking all possible solutions. For Tries problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Tries problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Replace Words\n        Tries pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Replace Words\n     * Tries pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Replace Words\n     * Tries pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Replace Words\n * Tries pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Replace Words leverages word prefix tree structure to reduce time complexity. Instead of checking all possibilities, we use Tries-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for Tries reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Replace Words\n        Tries pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Replace Words\n     * Tries pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Replace Words\n     * Tries pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Replace Words\n * Tries pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "remove-all-adjacent-duplicates-in-string-ii": {
        "description": "<p>You are given a string <code>s</code> and an integer <code>k</code>, a <code>k</code> <strong>duplicate removal</strong> consists of choosing <code>k</code> adjacent and equal letters from <code>s</code> and removing them, causing the left and the right side of the deleted substring to concatenate together.</p><p>We repeatedly make <code>k</code> <strong>duplicate removals</strong> on <code>s</code> until we no longer can.</p><p>Return <em>the final string after all such duplicate removals have been made</em>. It is guaranteed that the answer is <strong>unique</strong>.</p>",
        "examples": [{"input": "s = \"abcd", "output": "\"abcd\"", "explanation": "<p>There\"s nothing to delete.</p>"}, {"input": "s = \"deeedbbcccbdaa", "output": "\"aa\"", "explanation": "<p>First delete \"eee\" and \"ccc"}, {"input": "s = \"pbbcggttciiippooaais", "output": "\"ps\"", "explanation": "<p>Continue removing adjacent duplicates of length 2 until no more can be removed.</p>"}],
        "constraints": ["<code>1 &lt;= s.length &lt;= 10<sup>5</sup></code>", "<code>2 &lt;= k &lt;= 10<sup>4</sup></code>", "<code>s</code> only contains lowercase English letters."],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Remove All Adjacent Duplicates in String II involves checking all possible solutions. For Stack problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Stack problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Remove All Adjacent Duplicates in String II\n        Stack pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Remove All Adjacent Duplicates in String II\n     * Stack pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Remove All Adjacent Duplicates in String II\n     * Stack pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Remove All Adjacent Duplicates in String II\n * Stack pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Remove All Adjacent Duplicates in String II leverages stack-based operations to reduce time complexity. Instead of checking all possibilities, we use Stack-specific techniques like stack/queue for optimal state management to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (stack)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Efficient state management\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for Stack reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Remove All Adjacent Duplicates in String II\n        Stack pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Stack for state management\n        stack = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Remove All Adjacent Duplicates in String II\n     * Stack pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Stack for state management\n        Stack<Integer> stack = new Stack<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Remove All Adjacent Duplicates in String II\n     * Stack pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Stack for state management\n        stack<int> st;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Remove All Adjacent Duplicates in String II\n * Stack pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Stack for state management\n    const stack = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "minimum-remove-to-make-valid-parentheses": {
        "description": "<p>Given a string <code>s</code> of <code>'('</code> , <code>')'</code> and lowercase English characters.</p><p>Your task is to remove the minimum number of parentheses ( <code>'('</code> or <code>')'</code>, in any positions ) so that the resulting <em>parentheses string</em> is valid and return <strong>any</strong> valid string.</p><p>Formally, a <em>parentheses string</em> is valid if and only if:</p><ul><li>It is the empty string, contains only lowercase characters, or</li><li>It can be written as <code>AB</code> (<code>A</code> concatenated with <code>B</code>), where <code>A</code> and <code>B</code> are valid strings, or</li><li>It can be written as <code>(A)</code>, where <code>A</code> is a valid string.</li></ul>",
        "examples": [{"input": "s = \"lee(t(c)o)de)\"", "output": "\"lee(t(c)o)de\"", "explanation": "<p>\"lee(t(co)de)\" , \"lee(t(c)ode)\" would also be accepted.</p>"}, {"input": "s = \"a)b(c)d\"", "output": "\"ab(c)d\"", "explanation": "<p>Remove the unmatched closing parenthesis.</p>"}, {"input": "s = \"))((\"", "output": "\"\"", "explanation": "<p>An empty string is also valid.</p>"}],
        "constraints": ["<code>1 &lt;= s.length &lt;= 10<sup>5</sup></code>", "<code>s[i]</code> is either<code>\"(\"</code> , <code>\")\"</code>, or lowercase English letter<code>.</code>"],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Minimum Remove to Make Valid Parentheses involves checking all possible solutions. For Stack problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Stack problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Minimum Remove to Make Valid Parentheses\n        Stack pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Minimum Remove to Make Valid Parentheses\n     * Stack pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Minimum Remove to Make Valid Parentheses\n     * Stack pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Minimum Remove to Make Valid Parentheses\n * Stack pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Minimum Remove to Make Valid Parentheses leverages stack-based operations to reduce time complexity. Instead of checking all possibilities, we use Stack-specific techniques like stack/queue for optimal state management to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (stack)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Efficient state management\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for Stack reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Minimum Remove to Make Valid Parentheses\n        Stack pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Stack for state management\n        stack = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Minimum Remove to Make Valid Parentheses\n     * Stack pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Stack for state management\n        Stack<Integer> stack = new Stack<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Minimum Remove to Make Valid Parentheses\n     * Stack pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Stack for state management\n        stack<int> st;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Minimum Remove to Make Valid Parentheses\n * Stack pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Stack for state management\n    const stack = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "basic-calculator-ii": {
        "description": "<p>Given a string <code>s</code> which represents an expression, <em>evaluate this expression and return its value</em>.&nbsp;</p><p>The integer division should truncate toward zero.</p><p>You may assume that the given expression is always valid. All intermediate results will be in the range of <code>[-2<sup>31</sup>, 2<sup>31</sup> - 1]</code>.</p><p><strong>Note:</strong> You are not allowed to use any built-in function which evaluates strings as mathematical expressions, such as <code>eval()</code>.</p>",
        "examples": [{"input": "s = \"3+2*2\"", "output": "7", "explanation": "<p>Multiplication has higher precedence than addition.</p>"}, {"input": "s = \" 3/2 \"", "output": "1", "explanation": "<p>Division truncates toward zero.</p>"}, {"input": "s = \" 3+5 / 2 \"", "output": "5", "explanation": "<p>3 + (5/2) = 3 + 2 = 5</p>"}],
        "constraints": ["<code>1 &lt;= s.length &lt;= 3 * 10<sup>5</sup></code>", "<code>s</code> consists of integers and operators <code>("+", "-", "*", "/")</code> separated by some number of spaces.", "<code>s</code> represents <strong>a valid expression</strong>.", "All the integers in the expression are non-negative integers in the range <code>[0, 2<sup>31</sup> - 1]</code>.", "The answer is <strong>guaranteed</strong> to fit in a <strong>32-bit integer</strong>."],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Basic Calculator II involves checking all possible solutions. For Stack problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Stack problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Basic Calculator II\n        Stack pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Basic Calculator II\n     * Stack pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Basic Calculator II\n     * Stack pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Basic Calculator II\n * Stack pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Basic Calculator II leverages stack-based operations to reduce time complexity. Instead of checking all possibilities, we use Stack-specific techniques like stack/queue for optimal state management to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (stack)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Efficient state management\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for Stack reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Basic Calculator II\n        Stack pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Stack for state management\n        stack = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Basic Calculator II\n     * Stack pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Stack for state management\n        Stack<Integer> stack = new Stack<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Basic Calculator II\n     * Stack pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Stack for state management\n        stack<int> st;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Basic Calculator II\n * Stack pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Stack for state management\n    const stack = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "design-browser-history": {
        "description": "<p>You have a <strong>browser</strong> of one tab where you start on the <code>homepage</code> and you can visit another <code>url</code>, get back in the history number of <code>steps</code> or move forward in the history number of <code>steps</code>.</p><p>Implement the <code>BrowserHistory</code> class:</p><ul><li><code>BrowserHistory(string homepage)</code> Initializes the object with the <code>homepage</code> of the browser.</li><li><code>void visit(string url)</code> Visits <code>url</code> from the current page. It clears up all the forward history.</li><li><code>string back(int steps)</code> Move <code>steps</code> back in history. If you can only return <code>x</code> steps in the history and <code>steps &gt; x</code>, you will return only <code>x</code> steps. Return the current <code>url</code> after moving back in history <strong>at most</strong> <code>steps</code>.</li><li><code>string forward(int steps)</code> Move <code>steps</code> forward in history. If you can only forward <code>x</code> steps in the history and <code>steps &gt; x</code>, you will forward only <code>x</code> steps. Return the current <code>url</code> after forwarding in history <strong>at most</strong> <code>steps</code>.</li></ul>",
        "examples": [{"input": "[\"BrowserHistory\",\"visit\",\"visit\",\"visit\",\"back\",\"back\",\"forward\",\"visit\",\"forward\",\"back\",\"back\"]\\n[[\"leetcode.com\"],[\"google.com\"],[\"facebook.com\"],[\"youtube.com\"],[1],[1],[1],[\"linkedin.com\"],[2],[2],[7]]\", \"output\": \"[null,null,null,null,\"facebook.com\",\"google.com\",\"facebook.com\",null,\"linkedin.com\",\"google.com\",\"leetcode.com\"]\", \"explanation\": \"<p>BrowserHistory browserHistory = new BrowserHistory(\"leetcode.com\");<br/>browserHistory.visit(\"google.com\"); // You are in \"leetcode.com\". Visit \"google.com\"<br/>browserHistory.visit(\"facebook.com\"); // You are in \"google.com\". Visit \"facebook.com\"<br/>browserHistory.visit(\"youtube.com\"); // You are in \"facebook.com\". Visit \"youtube.com\"<br/>browserHistory.back(1); // You are in \"youtube.com\", move back to \"facebook.com\" return \"facebook.com\"<br/>browserHistory.back(1); // You are in \"facebook.com\", move back to \"google.com\" return \"google.com\"<br/>browserHistory.forward(1); // You are in \"google.com\", move forward to \"facebook.com\" return \"facebook.com\"<br/>browserHistory.visit(\"linkedin.com\"); // You are in \"facebook.com\". Visit \"linkedin.com\"<br/>browserHistory.forward(2); // You are in \"linkedin.com\", you cannot move forward any steps.<br/>browserHistory.back(2); // You are in \"linkedin.com\", move back two steps to \"facebook.com\" then to \"google.com\". return \"google.com\"<br/>browserHistory.back(7); // You are in \"google.com\", you can move back only one step to \"leetcode.com\". return \"leetcode.com\"</p>"}],
        "constraints": ["<code>1 &lt;= homepage.length &lt;= 20</code>", "<code>1 &lt;= url.length &lt;= 20</code>", "<code>1 &lt;= steps &lt;= 100</code>", "<code>homepage</code> and <code>url</code> consist of  \".\" or lower case English letters.", "<code>At most <code>5000</code> calls will be made to <code>visit</code>, <code>back</code>, and <code>forward</code>.</code>"],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Design Browser History involves checking all possible solutions. For Design problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Design problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Design Browser History\n        Design pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Design Browser History\n     * Design pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Design Browser History\n     * Design pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Design Browser History\n * Design pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Design Browser History leverages data structure design to reduce time complexity. Instead of checking all possibilities, we use Design-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for Design reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Design Browser History\n        Design pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Design Browser History\n     * Design pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Design Browser History\n     * Design pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Design Browser History\n * Design pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "design-underground-system": {
        "description": "<p>An underground railway system is keeping track of customer travel times between different stations. They are using this data to calculate the average time it takes to travel from one station to another.</p><p>Implement the <code>UndergroundSystem</code> class:</p><ul><li><code>void checkIn(int id, string stationName, int t)</code><ul><li>A customer with a card ID equal to <code>id</code>, checks in at the station <code>stationName</code> at time <code>t</code>.</li><li>A customer can only be checked into one place at a time.</li></ul></li><li><code>void checkOut(int id, string stationName, int t)</code><ul><li>A customer with a card ID equal to <code>id</code>, checks out from the station <code>stationName</code> at time <code>t</code>.</li></ul></li><li><code>double getAverageTime(string startStation, string endStation)</code><ul><li>Returns the average time it takes to travel from <code>startStation</code> to <code>endStation</code>.</li><li>The average time is computed from all the previous traveling times from <code>startStation</code> to <code>endStation</code> that happened <strong>directly</strong>, meaning a check in at <code>startStation</code> followed by a check out from <code>endStation</code>.</li><li>The time it takes to travel from <code>startStation</code> to <code>endStation</code> <strong>may be different</strong> from the time it takes to travel from <code>endStation</code> to <code>startStation</code>.</li><li>There will be at least one customer that has traveled from <code>startStation</code> to <code>endStation</code> before <code>getAverageTime</code> is called.</li></ul></li></ul><p>You may assume all calls to the <code>checkIn</code> and <code>checkOut</code> methods are consistent. If a customer checks in at time <code>t<sub>1</sub></code> then checks out at time <code>t<sub>2</sub></code>, then <code>t<sub>1</sub> &lt; t<sub>2</sub></code>. All events happen in chronological order.</p>",
        "examples": [{"input": "[\"UndergroundSystem\",\"checkIn\",\"checkIn\",\"checkIn\",\"checkOut\",\"checkOut\",\"checkOut\",\"getAverageTime\",\"getAverageTime\",\"checkIn\",\"getAverageTime\",\"checkOut\",\"getAverageTime\"]\\n[[],[45,\"Leyton\",3],[32,\"Paradise\",8],[27,\"Leyton\",10],[45,\"Waterloo\",15],[27,\"Waterloo\",20],[32,\"Cambridge\",22],[\"Paradise\",\"Cambridge\"],[\"Leyton\",\"Waterloo\"],[10,\"Leyton\",24],[\"Leyton\",\"Waterloo\"],[10,\"Waterloo\",38],[\"Leyton\",\"Waterloo\"]]\", \"output\": \"[null,null,null,null,null,null,null,14.00000,11.00000,null,11.00000,null,12.00000]\", \"explanation\": \"<p>UndergroundSystem undergroundSystem = new UndergroundSystem();<br/>undergroundSystem.checkIn(45, \"Leyton\", 3);<br/>undergroundSystem.checkIn(32, \"Paradise\", 8);<br/>undergroundSystem.checkIn(27, \"Leyton\", 10);<br/>undergroundSystem.checkOut(45, \"Waterloo\", 15); // Customer 45 \"Leyton\" -> \"Waterloo\" in 15-3 = 12<br/>undergroundSystem.checkOut(27, \"Waterloo\", 20); // Customer 27 \"Leyton\" -> \"Waterloo\" in 20-10 = 10<br/>undergroundSystem.checkOut(32, \"Cambridge\", 22); // Customer 32 \"Paradise\" -> \"Cambridge\" in 22-8 = 14<br/>undergroundSystem.getAverageTime(\"Paradise\", \"Cambridge\"); // return 14.00000. One trip \"Paradise\" -> \"Cambridge\", (14) / 1 = 14<br/>undergroundSystem.getAverageTime(\"Leyton\", \"Waterloo\"); // return 11.00000. Two trips \"Leyton\" -> \"Waterloo\", (10 + 12) / 2 = 11<br/>undergroundSystem.checkIn(10, \"Leyton\", 24);<br/>undergroundSystem.getAverageTime(\"Leyton\", \"Waterloo\"); // return 11.00000<br/>undergroundSystem.checkOut(10, \"Waterloo\", 38); // Customer 10 \"Leyton\" -> \"Waterloo\" in 38-24 = 14<br/>undergroundSystem.getAverageTime(\"Leyton\", \"Waterloo\"); // return 12.00000. Three trips \"Leyton\" -> \"Waterloo\", (10 + 12 + 14) / 3 = 12</p>"}],
        "constraints": ["<code>1 &lt;= id, t &lt;= 10<sup>6</sup></code>", "<code>1 &lt;= stationName.length, startStation.length, endStation.length &lt;= 10</code>", "All strings consist of uppercase and lowercase English letters and digits.", "There will be at most <code>2 * 10<sup>4</sup></code> calls <strong>in total</strong> to <code>checkIn</code>, <code>checkOut</code>, and <code>getAverageTime</code>.", "Answers within <code>10<sup>-5</sup></code> of the actual value will be accepted."],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Design Underground System involves checking all possible solutions. For Design problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Design problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Design Underground System\n        Design pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Design Underground System\n     * Design pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Design Underground System\n     * Design pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Design Underground System\n * Design pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Design Underground System leverages data structure design to reduce time complexity. Instead of checking all possibilities, we use Design-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for Design reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Design Underground System\n        Design pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Design Underground System\n     * Design pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Design Underground System\n     * Design pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Design Underground System\n * Design pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "insert-delete-getrandom-o-1": {
        "description": "<p>Implement the <code>RandomizedSet</code> class:</p><ul><li><code>RandomizedSet()</code> Initializes the <code>RandomizedSet</code> object.</li><li><code>bool insert(int val)</code> Inserts an item <code>val</code> into the set if not present. Returns <code>true</code> if the item was not present, <code>false</code> otherwise.</li><li><code>bool remove(int val)</code> Removes an item <code>val</code> from the set if present. Returns <code>true</code> if the item was present, <code>false</code> otherwise.</li><li><code>int getRandom()</code> Returns a random element from the current set of elements (it's guaranteed that at least one element exists when this method is called). Each element must have the <strong>same probability</strong> of being returned.</li></ul><p>You must implement the functions of the class such that each function works in&nbsp;<strong>average</strong>&nbsp;<code>O(1)</code>&nbsp;time complexity.</p>",
        "examples": [{"input": "[\"RandomizedSet\", \"insert\", \"remove\", \"insert\", \"getRandom\", \"remove\", \"insert\", \"getRandom\"]\\n[[], [1], [2], [2], [], [1], [2], []]\", \"output\": \"[null, true, false, true, 2, true, false, 2]\", \"explanation\": \"<p>RandomizedSet randomizedSet = new RandomizedSet();<br/>randomizedSet.insert(1); // Inserts 1 to the set. Returns true as 1 was inserted successfully.<br/>randomizedSet.remove(2); // Returns false as 2 does not exist in the set.<br/>randomizedSet.insert(2); // Inserts 2 to the set, returns true. Set now contains [1,2].<br/>randomizedSet.getRandom(); // getRandom() should return either 1 or 2 randomly.<br/>randomizedSet.remove(1); // Removes 1 from the set, returns true. Set now contains [2].<br/>randomizedSet.insert(2); // 2 was already in the set, so return false.<br/>randomizedSet.getRandom(); // Since 2 is the only number in the set, getRandom() will always return 2.</p>"}],
        "constraints": ["<code>-2<sup>31</sup> &lt;= val &lt;= 2<sup>31</sup> - 1</code>", "At most <code>2 * 10<sup>5</sup></code> calls will be made to <code>insert</code>, <code>remove</code>, and <code>getRandom</code>.", "There will be <strong>at least one</strong> element in the data structure when <code>getRandom</code> is called."],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Insert Delete GetRandom O(1) involves checking all possible solutions. For Design problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Design problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Insert Delete GetRandom O(1)\n        Design pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Insert Delete GetRandom O(1)\n     * Design pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Insert Delete GetRandom O(1)\n     * Design pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Insert Delete GetRandom O(1)\n * Design pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Insert Delete GetRandom O(1) leverages data structure design to reduce time complexity. Instead of checking all possibilities, we use Design-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for Design reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Insert Delete GetRandom O(1)\n        Design pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Insert Delete GetRandom O(1)\n     * Design pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Insert Delete GetRandom O(1)\n     * Design pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Insert Delete GetRandom O(1)\n * Design pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "minimum-number-of-arrows-to-burst-balloons": {
        "description": "<p>There are some spherical balloons taped onto a flat wall that represents the XY-plane. The balloons are represented as a 2D integer array <code>points</code> where <code>points[i] = [x<sub>start</sub>, x<sub>end</sub>]</code> denotes a balloon whose <strong>horizontal diameter</strong> stretches between <code>x<sub>start</sub></code> and <code>x<sub>end</sub></code>. You do not know the exact y-coordinates of the balloons.</p><p>Arrows can be shot up <strong>directly vertically</strong> (in the positive y-direction) from different points along the x-axis. A balloon with <code>x<sub>start</sub></code> and <code>x<sub>end</sub></code> is <strong>burst</strong> by an arrow shot at <code>x</code> if <code>x<sub>start</sub> &lt;= x &lt;= x<sub>end</sub></code>. There is <strong>no limit</strong> to the number of arrows that can be shot. A shot arrow keeps traveling up infinitely, bursting any balloons in its path.</p><p>Given the array <code>points</code>, return <em>the <strong>minimum</strong> number of arrows that must be shot to burst all balloons</em>.</p>",
        "examples": [{"input": "points = [[10,16],[2,8],[1,6],[7,12]]", "output": "2", "explanation": "<p>The balloons can be burst by 2 arrows:<br/>- Shoot an arrow at x = 6, bursting the balloons [2,8] and [1,6].<br/>- Shoot an arrow at x = 11, bursting the balloons [10,16] and [7,12].</p>"}, {"input": "points = [[1,2],[3,4],[5,6],[7,8]]", "output": "4", "explanation": "<p>One arrow needs to be shot for each balloon for a total of 4 arrows.</p>"}, {"input": "points = [[1,2],[2,3],[3,4],[4,5]]", "output": "2", "explanation": "<p>The balloons can be burst by 2 arrows:<br/>- Shoot an arrow at x = 2, bursting the balloons [1,2] and [2,3].<br/>- Shoot an arrow at x = 4, bursting the balloons [3,4] and [4,5].</p>"}],
        "constraints": ["<code>1 &lt;= points.length &lt;= 10<sup>5</sup></code>", "<code>points[i].length == 2</code>", "<code>-2<sup>31</sup> &lt;= x<sub>start</sub> &lt; x<sub>end</sub> &lt;= 2<sup>31</sup> - 1</code>"],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Minimum Number of Arrows to Burst Balloons involves checking all possible solutions. For Greedy problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Greedy problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Minimum Number of Arrows to Burst Balloons\n        Greedy pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Minimum Number of Arrows to Burst Balloons\n     * Greedy pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Minimum Number of Arrows to Burst Balloons\n     * Greedy pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Minimum Number of Arrows to Burst Balloons\n * Greedy pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Minimum Number of Arrows to Burst Balloons leverages greedy choice optimization to reduce time complexity. Instead of checking all possibilities, we use Greedy-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Make locally optimal choices\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Local optimal choices lead to global optimum\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for Greedy reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Only constant extra space needed for pointers and variables. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Minimum Number of Arrows to Burst Balloons\n        Greedy pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Minimum Number of Arrows to Burst Balloons\n     * Greedy pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Minimum Number of Arrows to Burst Balloons\n     * Greedy pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Minimum Number of Arrows to Burst Balloons\n * Greedy pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "reorganize-string": {
        "description": "<p>Given a string <code>s</code>, rearrange the characters of <code>s</code> so that any two adjacent characters are not the same.</p><p>Return <em>any possible rearrangement of</em> <code>s</code> <em>or return</em> <code>\"\"</code> <em>if not possible</em>.</p>",
        "examples": [{"input": "s = \"aab\"", "output": "\"aba\"", "explanation": "<p>Rearrange to avoid adjacent duplicates.</p>"}, {"input": "s = \"aaab\"", "output": "\"\"", "explanation": "<p>It is impossible to rearrange the string.</p>"}],
        "constraints": ["<code>1 &lt;= s.length &lt;= 500</code>", "<code>s</code> consists of lowercase English letters."],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Reorganize String involves checking all possible solutions. For Heap problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Heap problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Reorganize String\n        Heap pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Reorganize String\n     * Heap pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Reorganize String\n     * Heap pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Reorganize String\n * Heap pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Reorganize String leverages priority queue operations to reduce time complexity. Instead of checking all possibilities, we use Heap-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for Heap reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Reorganize String\n        Heap pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Reorganize String\n     * Heap pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Reorganize String\n     * Heap pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Reorganize String\n * Heap pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "longest-happy-string": {
        "description": "<p>A string <code>s</code> is called <strong>happy</strong> if it satisfies the following conditions:</p><ul><li><code>s</code> only contains the letters <code>'a'</code>, <code>'b'</code>, and <code>'c'</code>.</li><li><code>s</code> does not contain any of <code>\"aaa\"</code>, <code>\"bbb\"</code>, or <code>\"ccc\"</code> as a substring.</li><li><code>s</code> contains <strong>at most</strong> <code>a</code> occurrences of the letter <code>'a'</code>.</li><li><code>s</code> contains <strong>at most</strong> <code>b</code> occurrences of the letter <code>'b'</code>.</li><li><code>s</code> contains <strong>at most</strong> <code>c</code> occurrences of the letter <code>'c'</code>.</li></ul><p>Given three integers <code>a</code>, <code>b</code>, and <code>c</code>, return <em>the <strong>longest possible happy </strong>string</em>. If there are multiple longest happy strings, return <em>any of them</em>. If there is no such string, return <em>the empty string </em><code>\"\"</code>.</p><p>A <strong>substring</strong> is a contiguous sequence of characters within a string.</p>",
        "examples": [{"input": "a = 1, b = 1, c = 7", "output": "", "explanation": "<p>"}, {"input": "a = 7, b = 1, c = 0", "output": "", "explanation": "<p>It is the only correct answer in this case.</p>"}],
        "constraints": ["<code>0 &lt;= a, b, c &lt;= 100</code>", "<code>a + b + c &gt; 0</code>"],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Longest Happy String involves checking all possible solutions. For Heap problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Heap problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Longest Happy String\n        Heap pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Longest Happy String\n     * Heap pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Longest Happy String\n     * Heap pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Longest Happy String\n * Heap pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Longest Happy String leverages priority queue operations to reduce time complexity. Instead of checking all possibilities, we use Heap-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for Heap reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Longest Happy String\n        Heap pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Longest Happy String\n     * Heap pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Longest Happy String\n     * Heap pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Longest Happy String\n * Heap pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "top-k-frequent-words": {
        "description": "<p>Given an array of strings <code>words</code> and an integer <code>k</code>, return <em>the </em><code>k</code><em> most frequent strings</em>.</p><p>Return the answer <strong>sorted</strong> by <strong>the frequency</strong> from highest to lowest. Sort the words with the same frequency by their <strong>lexicographical order</strong>.</p>",
        "examples": [{"input": "words = [\"i\",\"love\",\"leetcode\",\"i\",\"love\",\"coding\"], k = 2\", \"output\": \"[\"i\",\"love\"]\", \"explanation\": \"<p>\"i\" and \"love\" are the two most frequent words.<br/>Note that \"i\" comes before \"love\" due to a lower alphabetical order.</p>\"}, {\"input\": \"words = [\"the\",\"day\",\"is\",\"sunny\",\"the\",\"the\",\"the\",\"sunny\",\"is\",\"is\"], k = 4\", \"output\": \"[\"the\",\"is\",\"sunny\",\"day\"]\", \"explanation\": \"<p>\"the\", \"is\", \"sunny\" and \"day\" are the four most frequent words, with the number of occurrence being 4, 3, 2 and 1 respectively.</p>"}],
        "constraints": ["<code>1 &lt;= words.length &lt;= 500</code>", "<code>1 &lt;= words[i].length &lt;= 10</code>", "<code>words[i]</code> consists of lowercase English letters.", "<code>k</code> is in the range <code>[1, The number of <strong>unique</strong> words[i]]</code>"],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Top K Frequent Words involves checking all possible solutions. For Heap problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Heap problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Top K Frequent Words\n        Heap pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Top K Frequent Words\n     * Heap pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Top K Frequent Words\n     * Heap pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Top K Frequent Words\n * Heap pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Top K Frequent Words leverages priority queue operations to reduce time complexity. Instead of checking all possibilities, we use Heap-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for Heap reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Top K Frequent Words\n        Heap pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Top K Frequent Words\n     * Heap pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Top K Frequent Words\n     * Heap pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Top K Frequent Words\n * Heap pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "find-k-pairs-with-smallest-sums": {
        "description": "<p>You are given two integer arrays <code>nums1</code> and <code>nums2</code> sorted in <strong>non-decreasing order</strong> and an integer <code>k</code>.</p><p>Define a pair <code>(u, v)</code> which consists of one element from the first array and one element from the second array.</p><p>Return <em>the</em> <code>k</code> <em>pairs</em> <code>(u<sub>1</sub>, v<sub>1</sub>), (u<sub>2</sub>, v<sub>2</sub>), ..., (u<sub>k</sub>, v<sub>k</sub>)</code> <em>with the smallest sums</em>.</p>",
        "examples": [{"input": "nums1 = [1,7,11], nums2 = [2,4,6], k = 3", "output": "[[1,2],[1,4],[1,6]]", "explanation": "<p>The first 3 pairs are returned from the sequence: [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]</p>"}, {"input": "nums1 = [1,1,2], nums2 = [1,2,3], k = 2", "output": "[[1,1],[1,1]]", "explanation": "<p>The first 2 pairs are returned from the sequence: [1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]</p>"}, {"input": "nums1 = [1,2], nums2 = [3], k = 3", "output": "[[1,3],[2,3]]", "explanation": "<p>All possible pairs are returned from the sequence: [1,3],[2,3]</p>"}],
        "constraints": ["<code>1 &lt;= nums1.length, nums2.length &lt;= 10<sup>5</sup></code>", "<code>-10<sup>9</sup> &lt;= nums1[i], nums2[i] &lt;= 10<sup>9</sup></code>", "<code>nums1</code> and <code>nums2</code> both are sorted in <strong>non-decreasing order</strong>.", "<code>1 &lt;= k &lt;= 10<sup>4</sup></code>", "<code>k &lt;= nums1.length * nums2.length</code>"],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Find K Pairs with Smallest Sums involves checking all possible solutions. For Heap problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Heap problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Find K Pairs with Smallest Sums\n        Heap pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Find K Pairs with Smallest Sums\n     * Heap pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Find K Pairs with Smallest Sums\n     * Heap pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Find K Pairs with Smallest Sums\n * Heap pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Find K Pairs with Smallest Sums leverages priority queue operations to reduce time complexity. Instead of checking all possibilities, we use Heap-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for Heap reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Find K Pairs with Smallest Sums\n        Heap pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Find K Pairs with Smallest Sums\n     * Heap pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Find K Pairs with Smallest Sums\n     * Heap pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Find K Pairs with Smallest Sums\n * Heap pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "kth-largest-element-in-stream": {
        "description": "<p>Design a class to find the <code>k<sup>th</sup></code> largest element in a stream. Note that it is the <code>k<sup>th</sup></code> largest element in the sorted order, not the <code>k<sup>th</sup></code> distinct element.</p><p>Implement <code>KthLargest</code> class:</p><ul><li><code>KthLargest(int k, int[] nums)</code> Initializes the object with the integer <code>k</code> and the stream of integers <code>nums</code>.</li><li><code>int add(int val)</code> Appends the integer <code>val</code> to the stream and returns the element representing the <code>k<sup>th</sup></code> largest element in the stream.</li></ul>",
        "examples": [{"input": "[\"KthLargest\", \"add\", \"add\", \"add\", \"add\", \"add\"]\\n[[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]\", \"output\": \"[null, 4, 5, 5, 8, 8]\", \"explanation\": \"<p>KthLargest kthLargest = new KthLargest(3, [4, 5, 8, 2]);<br/>kthLargest.add(3); // return 4<br/>kthLargest.add(5); // return 5<br/>kthLargest.add(10); // return 5<br/>kthLargest.add(9); // return 8<br/>kthLargest.add(4); // return 8</p>"}],
        "constraints": ["<code>1 &lt;= k &lt;= 10<sup>4</sup></code>", "<code>0 &lt;= nums.length &lt;= 10<sup>4</sup></code>", "<code>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></code>", "<code>-10<sup>4</sup> &lt;= val &lt;= 10<sup>4</sup></code>", "At most <code>10<sup>4</sup></code> calls will be made to <code>add</code>.", "It is guaranteed that there will be at least <code>k</code> elements in the array when you search for the <code>k<sup>th</sup></code> element."],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Kth Largest Element in Stream involves checking all possible solutions. For Heap problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Heap problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Kth Largest Element in Stream\n        Heap pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Kth Largest Element in Stream\n     * Heap pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Kth Largest Element in Stream\n     * Heap pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Kth Largest Element in Stream\n * Heap pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Kth Largest Element in Stream leverages priority queue operations to reduce time complexity. Instead of checking all possibilities, we use Heap-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for Heap reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Kth Largest Element in Stream\n        Heap pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Kth Largest Element in Stream\n     * Heap pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Kth Largest Element in Stream\n     * Heap pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Kth Largest Element in Stream\n * Heap pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "closest-binary-search-tree-value": {
        "description": "<p>Given the <code>root</code> of a binary search tree and a <code>target</code> value, return <em>the value in the BST that is closest to the</em> <code>target</code>. If there are multiple answers, print the smallest.</p>",
        "examples": [{"input": "root = [4,2,5,1,3], target = 3.714286", "output": "4", "explanation": "<p>The closest value to 3.714286 is 4.</p>"}, {"input": "root = [1], target = 4.428571", "output": "1", "explanation": "<p>The only value in the tree is 1.</p>"}],
        "constraints": ["The number of nodes in the tree is in the range <code>[1, 10<sup>4</sup>]</code>.", "<code>0 &lt;= Node.val &lt;= 10<sup>9</sup></code>", "<code>-10<sup>9</sup> &lt;= target &lt;= 10<sup>9</sup></code>"],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Closest Binary Search Tree Value involves checking all possible solutions. For BST problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. BST problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Closest Binary Search Tree Value\n        BST pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Closest Binary Search Tree Value\n     * BST pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Closest Binary Search Tree Value\n     * BST pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Closest Binary Search Tree Value\n * BST pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Closest Binary Search Tree Value leverages binary search tree operations to reduce time complexity. Instead of checking all possibilities, we use BST-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for BST reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Closest Binary Search Tree Value\n        BST pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Closest Binary Search Tree Value\n     * BST pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Closest Binary Search Tree Value\n     * BST pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Closest Binary Search Tree Value\n * BST pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    }
,

    "concatenated-words": {
        "description": "<p>Given an array of strings <code>words</code> (<strong>without duplicates</strong>), return <em>all the <strong>concatenated words</strong> in the given list of</em> <code>words</code>.</p><p>A <strong>concatenated word</strong> is defined as a string that is comprised entirely of at least two shorter words (not necessarily distinct)&nbsp;in the given array.</p>",
        "examples": [{"input": "words = [\"cat\",\"cats\",\"catsdogcats\",\"dog\",\"dogcatsdog\",\"hippopotamuses\",\"rat\",\"ratcatdogcat\"]\", \"output\": \"[\"catsdogcats\",\"dogcatsdog\",\"ratcatdogcat\"]\", \"explanation\": \"<p>\"catsdogcats\" can be concatenated by \"cats\", \"dog\" and \"cats\";<br/>\"dogcatsdog\" can be concatenated by \"dog\", \"cats\" and \"dog\";<br/>\"ratcatdogcat\" can be concatenated by \"rat\", \"cat\", \"dog\" and \"cat\".</p>\"}, {\"input\": \"words = [\"cat\",\"dog\",\"catdog\"]\", \"output\": \"[\"catdog\"]\", \"explanation\": \"<p>\"catdog\" can be formed by \"cat\" and \"dog\".</p>"}],
        "constraints": ["<code>1 &lt;= words.length &lt;= 10<sup>4</sup></code>", "<code>1 &lt;= words[i].length &lt;= 30</code>", "<code>words[i]</code> consists of only lowercase English letters.", "All the strings of <code>words</code> are <strong>unique</strong>.", "<code>1 &lt;= sum(words[i].length) &lt;= 10<sup>5</sup></code>"],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Concatenated Words involves checking all possible solutions. For Tries problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Tries problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Concatenated Words\n        Tries pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Concatenated Words\n     * Tries pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Concatenated Words\n     * Tries pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Concatenated Words\n * Tries pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Concatenated Words leverages word prefix tree structure to reduce time complexity. Instead of checking all possibilities, we use Tries-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for Tries reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Concatenated Words\n        Tries pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Concatenated Words\n     * Tries pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Concatenated Words\n     * Tries pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Concatenated Words\n * Tries pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "two-sum": {
        "description": "<p>Given an array of integers <code>nums</code>&nbsp;and an integer <code>target</code>, return <em>indices of the two numbers such that they add up to <code>target</code></em>.</p><p>You may assume that each input would have <strong><em>exactly</em> one solution</strong>, and you may not use the <em>same</em> element twice.</p><p>You can return the answer in any order.</p>",
        "examples": [{"input": "nums = [2,7,11,15], target = 9", "output": "[0,1]", "explanation": "<p>Because nums[0] + nums[1] == 9, we return [0, 1].</p>"}, {"input": "nums = [3,2,4], target = 6", "output": "[1,2]", "explanation": "<p>Because nums[1] + nums[2] == 6, we return [1, 2].</p>"}, {"input": "nums = [3,3], target = 6", "output": "[0,1]", "explanation": "<p>Because nums[0] + nums[1] == 6, we return [0, 1].</p>"}],
        "constraints": ["<code>2 &lt;= nums.length &lt;= 10<sup>4</sup></code>", "<code>-10<sup>9</sup> &lt;= nums[i] &lt;= 10<sup>9</sup></code>", "<code>-10<sup>9</sup> &lt;= target &lt;= 10<sup>9</sup></code>", "<strong>Only one valid answer exists.</strong>"],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Two Sum involves checking all possible solutions. For Arrays problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Arrays problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Two Sum\n        Arrays pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Two Sum\n     * Arrays pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Two Sum\n     * Arrays pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Two Sum\n * Arrays pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Two Sum leverages array manipulation and optimization to reduce time complexity. Instead of checking all possibilities, we use Arrays-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for Arrays reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from O(n¬≤) to O(n).",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Two Sum\n        Arrays pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Two Sum\n     * Arrays pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Two Sum\n     * Arrays pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Two Sum\n * Arrays pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "valid-sudoku": {
        "description": "<p>Determine if a&nbsp;<code>9 x 9</code> Sudoku board&nbsp;is valid.&nbsp;Only the filled cells need to be validated&nbsp;<strong>according to the following rules</strong>:</p><ol><li>Each row&nbsp;must contain the&nbsp;digits&nbsp;<code>1-9</code> without repetition.</li><li>Each column must contain the digits&nbsp;<code>1-9</code>&nbsp;without repetition.</li><li>Each of the nine&nbsp;<code>3 x 3</code> sub-boxes of the grid must contain the digits&nbsp;<code>1-9</code>&nbsp;without repetition.</li></ol><p><strong>Note:</strong></p><ul><li>A Sudoku board (partially filled) could be valid but is not necessarily solvable.</li><li>Only the filled cells need to be validated according to the mentioned&nbsp;rules.</li></ul>",
        "examples": [{"input": "board = \\n[[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"]\\n,[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"]\\n,[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"]\\n,[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"]\\n,[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"]\\n,[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"]\\n,[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"]\\n,[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"]\\n,[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\", \"output\": \"true\", \"explanation\": \"<p>This is a valid Sudoku board.</p>\"}, {\"input\": \"board = \\n[[\"8\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"]\\n,[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"]\\n,[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"]\\n,[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"]\\n,[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"]\\n,[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"]\\n,[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"]\\n,[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"]\\n,[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\", \"output\": \"false\", \"explanation\": \"<p>Same as Example 1, except with the <strong>5</strong> in the top left corner being modified to <strong>8</strong>. Since there are two 8\"s in the top left 3x3 sub-box, it is invalid.</p>"}],
        "constraints": ["<code>board.length == 9</code>", "<code>board[i].length == 9</code>", "<code>board[i][j]</code> is a digit <code>1-9</code> or <code>\".\"</code>."],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Valid Sudoku involves checking all possible solutions. For Matrix problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(9^(n*n))",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Matrix problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Valid Sudoku\n        Matrix pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Valid Sudoku\n     * Matrix pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Valid Sudoku\n     * Matrix pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Valid Sudoku\n * Matrix pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Valid Sudoku leverages 2D grid traversal and modification to reduce time complexity. Instead of checking all possibilities, we use Matrix-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for Matrix reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Valid Sudoku\n        Matrix pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Valid Sudoku\n     * Matrix pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Valid Sudoku\n     * Matrix pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Valid Sudoku\n * Matrix pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "lowest-common-ancestor-of-a-bst": {
        "description": "<p>Given a binary search tree (BST), find the lowest common ancestor (LCA) node of two given nodes in the BST.</p><p>According to the <a href=\"https://en.wikipedia.org/wiki/Lowest_common_ancestor\" target=\"_blank\">definition of LCA on Wikipedia</a>: \"The lowest common ancestor is defined between two nodes <code>p</code> and <code>q</code> as the lowest node in <code>T</code> that has both <code>p</code> and <code>q</code> as descendants (where we allow <strong>a node to be a descendant of itself</strong>).\"</p>",
        "examples": [{"input": "root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8", "output": "6", "explanation": "<p>The LCA of nodes 2 and 8 is 6.</p>"}, {"input": "root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4", "output": "2", "explanation": "<p>The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.</p>"}, {"input": "root = [2,1], p = 2, q = 1", "output": "2", "explanation": "<p>The LCA of nodes 2 and 1 is 2.</p>"}],
        "constraints": ["The number of nodes in the tree is in the range <code>[2, 10<sup>5</sup>]</code>.", "<code>-10<sup>9</sup> &lt;= Node.val &lt;= 10<sup>9</sup></code>", "All <code>Node.val</code> are <strong>unique</strong>.", "<code>p != q</code>", "<code>p</code> and <code>q</code> will exist in the BST."],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Lowest Common Ancestor of a BST involves checking all possible solutions. For BST problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. BST problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Lowest Common Ancestor of a BST\n        BST pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Lowest Common Ancestor of a BST\n     * BST pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Lowest Common Ancestor of a BST\n     * BST pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Lowest Common Ancestor of a BST\n * BST pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Lowest Common Ancestor of a BST leverages binary search tree operations to reduce time complexity. Instead of checking all possibilities, we use BST-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for BST reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Lowest Common Ancestor of a BST\n        BST pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Lowest Common Ancestor of a BST\n     * BST pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Lowest Common Ancestor of a BST\n     * BST pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Lowest Common Ancestor of a BST\n * BST pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "construct-binary-tree-from-preorder-and-inorder": {
        "description": "<p>Given two integer arrays <code>preorder</code> and <code>inorder</code> where <code>preorder</code> is the preorder traversal of a binary tree and <code>inorder</code> is the inorder traversal of the same tree, construct and return <em>the binary tree</em>.</p>",
        "examples": [{"input": "preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]", "output": "[3,9,20,null,null,15,7]", "explanation": "<p>The tree is constructed from preorder and inorder traversals.</p>"}, {"input": "preorder = [-1], inorder = [-1]", "output": "[-1]", "explanation": "<p>Single node tree.</p>"}],
        "constraints": ["<code>1 &lt;= preorder.length &lt;= 3000</code>", "<code>inorder.length == preorder.length</code>", "<code>-3000 &lt;= preorder[i], inorder[i] &lt;= 3000</code>", "<code>preorder</code> and <code>inorder</code> consist of <strong>unique</strong> values.", "Each value of <code>inorder</code> also appears in <code>preorder</code>.", "<code>preorder</code> is <strong>guaranteed</strong> to be the preorder traversal of the tree.", "<code>inorder</code> is <strong>guaranteed</strong> to be the inorder traversal of the tree."],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Construct Binary Tree from Preorder and Inorder involves checking all possible solutions. For Tree Hard problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Tree Hard problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Construct Binary Tree from Preorder and Inorder\n        Tree Hard pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Construct Binary Tree from Preorder and Inorder\n     * Tree Hard pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Construct Binary Tree from Preorder and Inorder\n     * Tree Hard pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Construct Binary Tree from Preorder and Inorder\n * Tree Hard pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Construct Binary Tree from Preorder and Inorder leverages complex tree transformations to reduce time complexity. Instead of checking all possibilities, we use Tree Hard-specific techniques like efficient traversal with pruning to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (tree structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Pruning impossible branches\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(h)",
                    "timeExplanation": "Optimized approach for Tree Hard reduces complexity significantly. Tree traversal visits each node exactly once. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Recursion stack depth equals tree height. Balanced tree gives O(log n). Can be further optimized by using iterative approach instead of recursion."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Construct Binary Tree from Preorder and Inorder\n        Tree Hard pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Construct Binary Tree from Preorder and Inorder\n     * Tree Hard pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Construct Binary Tree from Preorder and Inorder\n     * Tree Hard pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Construct Binary Tree from Preorder and Inorder\n * Tree Hard pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "palindrome-pairs": {
        "description": "Palindrome Pairs. Solve this problem using word prefix tree structure. Given the input constraints, find the optimal solution that meets all requirements.",
        "examples": [
            {
                "input": "Example input for Palindrome Pairs",
                "output": "Expected output",
                "explanation": "This demonstrates the core logic for Palindrome Pairs using Tries pattern."
            },
            {
                "input": "Edge case input",
                "output": "Edge case output",
                "explanation": "This handles boundary conditions and special cases."
            }
        ],
        "constraints": [
            "Input size constraints: 1 <= n <= 10^5",
            "Value range: -10^9 <= val <= 10^9",
            "Optimal time complexity required for Tries"
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Palindrome Pairs involves checking all possible solutions. For Tries problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Tries problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Palindrome Pairs\n        Tries pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Palindrome Pairs\n     * Tries pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Palindrome Pairs\n     * Tries pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Palindrome Pairs\n * Tries pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Palindrome Pairs leverages word prefix tree structure to reduce time complexity. Instead of checking all possibilities, we use Tries-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for Tries reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Palindrome Pairs\n        Tries pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Palindrome Pairs\n     * Tries pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Palindrome Pairs\n     * Tries pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Palindrome Pairs\n * Tries pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "number-of-connected-components": {
        "description": "Number of Connected Components. Solve this problem using disjoint set operations. Given the input constraints, find the optimal solution that meets all requirements.",
        "examples": [
            {
                "input": "Example input for Number of Connected Components",
                "output": "Expected output",
                "explanation": "This demonstrates the core logic for Number of Connected Components using Union Find pattern."
            },
            {
                "input": "Edge case input",
                "output": "Edge case output",
                "explanation": "This handles boundary conditions and special cases."
            }
        ],
        "constraints": [
            "Input size constraints: 1 <= n <= 10^5",
            "Value range: -10^9 <= val <= 10^9",
            "Optimal time complexity required for Union Find"
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Number of Connected Components involves checking all possible solutions. For Union Find problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Union Find problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Number of Connected Components\n        Union Find pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Number of Connected Components\n     * Union Find pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Number of Connected Components\n     * Union Find pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Number of Connected Components\n * Union Find pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Number of Connected Components leverages disjoint set operations to reduce time complexity. Instead of checking all possibilities, we use Union Find-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for Union Find reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Number of Connected Components\n        Union Find pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Number of Connected Components\n     * Union Find pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Number of Connected Components\n     * Union Find pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Number of Connected Components\n * Union Find pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "longest-increasing-path-in-a-matrix": {
        "description": "Longest Increasing Path in a Matrix. Solve this problem using depth-first search graph traversal. Given the input constraints, find the optimal solution that meets all requirements.",
        "examples": [
            {
                "input": "Example input for Longest Increasing Path in a Matrix",
                "output": "Expected output",
                "explanation": "This demonstrates the core logic for Longest Increasing Path in a Matrix using DFS pattern."
            },
            {
                "input": "Edge case input",
                "output": "Edge case output",
                "explanation": "This handles boundary conditions and special cases."
            }
        ],
        "constraints": [
            "Input size constraints: 1 <= n <= 10^5",
            "Value range: -10^9 <= val <= 10^9",
            "Optimal time complexity required for DFS"
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Longest Increasing Path in a Matrix involves checking all possible solutions. For DFS problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. DFS problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Longest Increasing Path in a Matrix\n        DFS pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Longest Increasing Path in a Matrix\n     * DFS pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Longest Increasing Path in a Matrix\n     * DFS pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Longest Increasing Path in a Matrix\n * DFS pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Longest Increasing Path in a Matrix leverages depth-first search graph traversal to reduce time complexity. Instead of checking all possibilities, we use DFS-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for DFS reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Longest Increasing Path in a Matrix\n        DFS pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Longest Increasing Path in a Matrix\n     * DFS pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Longest Increasing Path in a Matrix\n     * DFS pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Longest Increasing Path in a Matrix\n * DFS pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "find-duplicate-number": {
        "description": "Find Duplicate Number. Solve this problem using two-pointer technique optimization. Given the input constraints, find the optimal solution that meets all requirements.",
        "examples": [
            {
                "input": "Example input for Find Duplicate Number",
                "output": "Expected output",
                "explanation": "This demonstrates the core logic for Find Duplicate Number using Two Pointers pattern."
            },
            {
                "input": "Edge case input",
                "output": "Edge case output",
                "explanation": "This handles boundary conditions and special cases."
            }
        ],
        "constraints": [
            "Input size constraints: 1 <= n <= 10^5",
            "Value range: -10^9 <= val <= 10^9",
            "Optimal time complexity required for Two Pointers"
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Find Duplicate Number involves checking all possible solutions. For Two Pointers problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Two Pointers problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Find Duplicate Number\n        Two Pointers pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Find Duplicate Number\n     * Two Pointers pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Find Duplicate Number\n     * Two Pointers pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Find Duplicate Number\n * Two Pointers pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Find Duplicate Number leverages two-pointer technique optimization to reduce time complexity. Instead of checking all possibilities, we use Two Pointers-specific techniques like two pointers to avoid nested loops to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Place pointers at strategic positions\n3. While pointers haven't crossed:\n   - Process current elements\n   - Move pointers based on logic\n   - Update result\n4. Return the optimal solution\n\nKey optimizations:\n- Single pass instead of nested loops\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for Two Pointers reduces complexity significantly. Two pointers traverse array once without backtracking. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Only constant extra space needed for pointers and variables. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Find Duplicate Number\n        Two Pointers pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Two pointer approach\n        left, right = 0, n - 1\n        \n        while left < right:\n            # Process current elements\n            if condition(input[left], input[right]):\n                result.append([left, right])\n                left += 1\n            else:\n                right -= 1\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Find Duplicate Number\n     * Two Pointers pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Two pointer approach\n        int left = 0, right = n - 1;\n        \n        while (left < right) {\n            // Process current elements\n            if (condition(input[left], input[right])) {\n                result.add(left);\n                result.add(right);\n                left++;\n            } else {\n                right--;\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Find Duplicate Number\n     * Two Pointers pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Two pointer approach\n        int left = 0, right = n - 1;\n        \n        while (left < right) {\n            // Process current elements\n            if (condition(input[left], input[right])) {\n                result.push_back(left);\n                result.push_back(right);\n                left++;\n            } else {\n                right--;\n            }\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Find Duplicate Number\n * Two Pointers pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Two pointer approach\n    let left = 0, right = n - 1;\n    \n    while (left < right) {\n        // Process current elements\n        if (condition(input[left], input[right])) {\n            result.push(left, right);\n            left++;\n        } else {\n            right--;\n        }\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "largest-number": {
        "description": "Largest Number. Solve this problem using string manipulation algorithms. Given the input constraints, find the optimal solution that meets all requirements.",
        "examples": [
            {
                "input": "Example input for Largest Number",
                "output": "Expected output",
                "explanation": "This demonstrates the core logic for Largest Number using Strings pattern."
            },
            {
                "input": "Edge case input",
                "output": "Edge case output",
                "explanation": "This handles boundary conditions and special cases."
            }
        ],
        "constraints": [
            "Input size constraints: 1 <= n <= 10^5",
            "Value range: -10^9 <= val <= 10^9",
            "Optimal time complexity required for Strings"
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Largest Number involves checking all possible solutions. For Strings problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Strings problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Largest Number\n        Strings pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Largest Number\n     * Strings pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Largest Number\n     * Strings pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Largest Number\n * Strings pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Largest Number leverages string manipulation algorithms to reduce time complexity. Instead of checking all possibilities, we use Strings-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for Strings reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Largest Number\n        Strings pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Largest Number\n     * Strings pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Largest Number\n     * Strings pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Largest Number\n * Strings pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "text-justification": {
        "description": "Text Justification. Solve this problem using string manipulation algorithms. Given the input constraints, find the optimal solution that meets all requirements.",
        "examples": [
            {
                "input": "Example input for Text Justification",
                "output": "Expected output",
                "explanation": "This demonstrates the core logic for Text Justification using Strings pattern."
            },
            {
                "input": "Edge case input",
                "output": "Edge case output",
                "explanation": "This handles boundary conditions and special cases."
            }
        ],
        "constraints": [
            "Input size constraints: 1 <= n <= 10^5",
            "Value range: -10^9 <= val <= 10^9",
            "Optimal time complexity required for Strings"
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Text Justification involves checking all possible solutions. For Strings problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Strings problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Text Justification\n        Strings pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Text Justification\n     * Strings pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Text Justification\n     * Strings pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Text Justification\n * Strings pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Text Justification leverages string manipulation algorithms to reduce time complexity. Instead of checking all possibilities, we use Strings-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for Strings reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Text Justification\n        Strings pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Text Justification\n     * Strings pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Text Justification\n     * Strings pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Text Justification\n * Strings pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "naming-a-company": {
        "description": "Naming a Company. Solve this problem using string manipulation algorithms. Given the input constraints, find the optimal solution that meets all requirements.",
        "examples": [
            {
                "input": "Example input for Naming a Company",
                "output": "Expected output",
                "explanation": "This demonstrates the core logic for Naming a Company using Strings pattern."
            },
            {
                "input": "Edge case input",
                "output": "Edge case output",
                "explanation": "This handles boundary conditions and special cases."
            }
        ],
        "constraints": [
            "Input size constraints: 1 <= n <= 10^5",
            "Value range: -10^9 <= val <= 10^9",
            "Optimal time complexity required for Strings"
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Naming a Company involves checking all possible solutions. For Strings problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Strings problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Naming a Company\n        Strings pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Naming a Company\n     * Strings pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Naming a Company\n     * Strings pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Naming a Company\n * Strings pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Naming a Company leverages string manipulation algorithms to reduce time complexity. Instead of checking all possibilities, we use Strings-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for Strings reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Naming a Company\n        Strings pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Naming a Company\n     * Strings pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Naming a Company\n     * Strings pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Naming a Company\n * Strings pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "candy": {
        "description": "Candy. Solve this problem using greedy choice optimization. Given the input constraints, find the optimal solution that meets all requirements.",
        "examples": [
            {
                "input": "Example input for Candy",
                "output": "Expected output",
                "explanation": "This demonstrates the core logic for Candy using Greedy pattern."
            },
            {
                "input": "Edge case input",
                "output": "Edge case output",
                "explanation": "This handles boundary conditions and special cases."
            }
        ],
        "constraints": [
            "Input size constraints: 1 <= n <= 10^5",
            "Value range: -10^9 <= val <= 10^9",
            "Optimal time complexity required for Greedy"
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Candy involves checking all possible solutions. For Greedy problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Greedy problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Candy\n        Greedy pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Candy\n     * Greedy pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Candy\n     * Greedy pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Candy\n * Greedy pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Candy leverages greedy choice optimization to reduce time complexity. Instead of checking all possibilities, we use Greedy-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Make locally optimal choices\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Local optimal choices lead to global optimum\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for Greedy reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Only constant extra space needed for pointers and variables. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Candy\n        Greedy pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Candy\n     * Greedy pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Candy\n     * Greedy pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Candy\n * Greedy pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "trapping-rain-water-ii": {
        "description": "Trapping Rain Water II. Solve this problem using priority queue operations. Given the input constraints, find the optimal solution that meets all requirements.",
        "examples": [
            {
                "input": "Example input for Trapping Rain Water II",
                "output": "Expected output",
                "explanation": "This demonstrates the core logic for Trapping Rain Water II using Heap pattern."
            },
            {
                "input": "Edge case input",
                "output": "Edge case output",
                "explanation": "This handles boundary conditions and special cases."
            }
        ],
        "constraints": [
            "Input size constraints: 1 <= n <= 10^5",
            "Value range: -10^9 <= val <= 10^9",
            "Optimal time complexity required for Heap"
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Trapping Rain Water II involves checking all possible solutions. For Heap problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Heap problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Trapping Rain Water II\n        Heap pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Trapping Rain Water II\n     * Heap pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Trapping Rain Water II\n     * Heap pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Trapping Rain Water II\n * Heap pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Trapping Rain Water II leverages priority queue operations to reduce time complexity. Instead of checking all possibilities, we use Heap-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for Heap reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Trapping Rain Water II\n        Heap pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Trapping Rain Water II\n     * Heap pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Trapping Rain Water II\n     * Heap pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Trapping Rain Water II\n * Heap pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "max-points-on-a-line": {
        "description": "Max Points on a Line. Solve this problem using mathematical computation. Given the input constraints, find the optimal solution that meets all requirements.",
        "examples": [
            {
                "input": "Example input for Max Points on a Line",
                "output": "Expected output",
                "explanation": "This demonstrates the core logic for Max Points on a Line using Maths pattern."
            },
            {
                "input": "Edge case input",
                "output": "Edge case output",
                "explanation": "This handles boundary conditions and special cases."
            }
        ],
        "constraints": [
            "Input size constraints: 1 <= n <= 10^5",
            "Value range: -10^9 <= val <= 10^9",
            "Optimal time complexity required for Maths"
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Max Points on a Line involves checking all possible solutions. For Maths problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Maths problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Max Points on a Line\n        Maths pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Max Points on a Line\n     * Maths pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Max Points on a Line\n     * Maths pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Max Points on a Line\n * Maths pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Max Points on a Line leverages mathematical computation to reduce time complexity. Instead of checking all possibilities, we use Maths-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for Maths reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Max Points on a Line\n        Maths pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Max Points on a Line\n     * Maths pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Max Points on a Line\n     * Maths pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Max Points on a Line\n * Maths pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "sudoku-solver": {
        "description": "Sudoku Solver. Solve this problem using recursive backtracking. Given the input constraints, find the optimal solution that meets all requirements.",
        "examples": [
            {
                "input": "Example input for Sudoku Solver",
                "output": "Expected output",
                "explanation": "This demonstrates the core logic for Sudoku Solver using Backtracking pattern."
            },
            {
                "input": "Edge case input",
                "output": "Edge case output",
                "explanation": "This handles boundary conditions and special cases."
            }
        ],
        "constraints": [
            "Input size constraints: 1 <= n <= 10^5",
            "Value range: -10^9 <= val <= 10^9",
            "Optimal time complexity required for Backtracking"
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Sudoku Solver involves checking all possible solutions. For Backtracking problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(9^(n*n))",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Backtracking problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Sudoku Solver\n        Backtracking pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Sudoku Solver\n     * Backtracking pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Sudoku Solver\n     * Backtracking pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Sudoku Solver\n * Backtracking pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Sudoku Solver leverages recursive backtracking to reduce time complexity. Instead of checking all possibilities, we use Backtracking-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for Backtracking reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Sudoku Solver\n        Backtracking pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Sudoku Solver\n     * Backtracking pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Sudoku Solver\n     * Backtracking pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Sudoku Solver\n * Backtracking pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "count-of-smaller-numbers-after-self": {
        "description": "Count of Smaller Numbers After Self. Solve this problem using divide and conquer approach. Given the input constraints, find the optimal solution that meets all requirements.",
        "examples": [
            {
                "input": "Example input for Count of Smaller Numbers After Self",
                "output": "Expected output",
                "explanation": "This demonstrates the core logic for Count of Smaller Numbers After Self using Merge / Quick / Divide pattern."
            },
            {
                "input": "Edge case input",
                "output": "Edge case output",
                "explanation": "This handles boundary conditions and special cases."
            }
        ],
        "constraints": [
            "Input size constraints: 1 <= n <= 10^5",
            "Value range: -10^9 <= val <= 10^9",
            "Optimal time complexity required for Merge / Quick / Divide"
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Count of Smaller Numbers After Self involves checking all possible solutions. For Merge / Quick / Divide problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Merge / Quick / Divide problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Count of Smaller Numbers After Self\n        Merge / Quick / Divide pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Count of Smaller Numbers After Self\n     * Merge / Quick / Divide pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Count of Smaller Numbers After Self\n     * Merge / Quick / Divide pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Count of Smaller Numbers After Self\n * Merge / Quick / Divide pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Count of Smaller Numbers After Self leverages divide and conquer approach to reduce time complexity. Instead of checking all possibilities, we use Merge / Quick / Divide-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for Merge / Quick / Divide reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Count of Smaller Numbers After Self\n        Merge / Quick / Divide pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Count of Smaller Numbers After Self\n     * Merge / Quick / Divide pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Count of Smaller Numbers After Self\n     * Merge / Quick / Divide pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Count of Smaller Numbers After Self\n * Merge / Quick / Divide pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "reverse-pairs": {
        "description": "Reverse Pairs. Solve this problem using divide and conquer approach. Given the input constraints, find the optimal solution that meets all requirements.",
        "examples": [
            {
                "input": "Example input for Reverse Pairs",
                "output": "Expected output",
                "explanation": "This demonstrates the core logic for Reverse Pairs using Merge / Quick / Divide pattern."
            },
            {
                "input": "Edge case input",
                "output": "Edge case output",
                "explanation": "This handles boundary conditions and special cases."
            }
        ],
        "constraints": [
            "Input size constraints: 1 <= n <= 10^5",
            "Value range: -10^9 <= val <= 10^9",
            "Optimal time complexity required for Merge / Quick / Divide"
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Reverse Pairs involves checking all possible solutions. For Merge / Quick / Divide problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Merge / Quick / Divide problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Reverse Pairs\n        Merge / Quick / Divide pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Reverse Pairs\n     * Merge / Quick / Divide pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Reverse Pairs\n     * Merge / Quick / Divide pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Reverse Pairs\n * Merge / Quick / Divide pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Reverse Pairs leverages divide and conquer approach to reduce time complexity. Instead of checking all possibilities, we use Merge / Quick / Divide-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for Merge / Quick / Divide reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Reverse Pairs\n        Merge / Quick / Divide pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Reverse Pairs\n     * Merge / Quick / Divide pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Reverse Pairs\n     * Merge / Quick / Divide pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Reverse Pairs\n * Merge / Quick / Divide pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "skyline-problem": {
        "description": "Skyline Problem. Solve this problem using priority queue operations. Given the input constraints, find the optimal solution that meets all requirements.",
        "examples": [
            {
                "input": "Example input for Skyline Problem",
                "output": "Expected output",
                "explanation": "This demonstrates the core logic for Skyline Problem using Heap pattern."
            },
            {
                "input": "Edge case input",
                "output": "Edge case output",
                "explanation": "This handles boundary conditions and special cases."
            }
        ],
        "constraints": [
            "Input size constraints: 1 <= n <= 10^5",
            "Value range: -10^9 <= val <= 10^9",
            "Optimal time complexity required for Heap"
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Skyline Problem involves checking all possible solutions. For Heap problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Heap problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Skyline Problem\n        Heap pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Skyline Problem\n     * Heap pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Skyline Problem\n     * Heap pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Skyline Problem\n * Heap pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Skyline Problem leverages priority queue operations to reduce time complexity. Instead of checking all possibilities, we use Heap-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for Heap reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Skyline Problem\n        Heap pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Skyline Problem\n     * Heap pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Skyline Problem\n     * Heap pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Skyline Problem\n * Heap pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "shortest-path-in-a-grid-with-obstacles-elimination": {
        "description": "Shortest Path in a Grid with Obstacles Elimination. Solve this problem using breadth-first search traversal. Given the input constraints, find the optimal solution that meets all requirements.",
        "examples": [
            {
                "input": "Example input for Shortest Path in a Grid with Obstacles Elimination",
                "output": "Expected output",
                "explanation": "This demonstrates the core logic for Shortest Path in a Grid with Obstacles Elimination using BFS pattern."
            },
            {
                "input": "Edge case input",
                "output": "Edge case output",
                "explanation": "This handles boundary conditions and special cases."
            }
        ],
        "constraints": [
            "Input size constraints: 1 <= n <= 10^5",
            "Value range: -10^9 <= val <= 10^9",
            "Optimal time complexity required for BFS"
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Shortest Path in a Grid with Obstacles Elimination involves checking all possible solutions. For BFS problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. BFS problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Shortest Path in a Grid with Obstacles Elimination\n        BFS pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Shortest Path in a Grid with Obstacles Elimination\n     * BFS pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Shortest Path in a Grid with Obstacles Elimination\n     * BFS pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Shortest Path in a Grid with Obstacles Elimination\n * BFS pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Shortest Path in a Grid with Obstacles Elimination leverages breadth-first search traversal to reduce time complexity. Instead of checking all possibilities, we use BFS-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for BFS reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Shortest Path in a Grid with Obstacles Elimination\n        BFS pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Shortest Path in a Grid with Obstacles Elimination\n     * BFS pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Shortest Path in a Grid with Obstacles Elimination\n     * BFS pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Shortest Path in a Grid with Obstacles Elimination\n * BFS pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "making-a-large-island": {
        "description": "Making A Large Island. Solve this problem using disjoint set operations. Given the input constraints, find the optimal solution that meets all requirements.",
        "examples": [
            {
                "input": "Example input for Making A Large Island",
                "output": "Expected output",
                "explanation": "This demonstrates the core logic for Making A Large Island using Union Find pattern."
            },
            {
                "input": "Edge case input",
                "output": "Edge case output",
                "explanation": "This handles boundary conditions and special cases."
            }
        ],
        "constraints": [
            "Input size constraints: 1 <= n <= 10^5",
            "Value range: -10^9 <= val <= 10^9",
            "Optimal time complexity required for Union Find"
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Making A Large Island involves checking all possible solutions. For Union Find problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Union Find problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Making A Large Island\n        Union Find pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Making A Large Island\n     * Union Find pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Making A Large Island\n     * Union Find pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Making A Large Island\n * Union Find pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Making A Large Island leverages disjoint set operations to reduce time complexity. Instead of checking all possibilities, we use Union Find-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for Union Find reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Making A Large Island\n        Union Find pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Making A Large Island\n     * Union Find pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Making A Large Island\n     * Union Find pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Making A Large Island\n * Union Find pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "checking-existence-of-edge-length-limited-paths": {
        "description": "Checking Existence of Edge Length Limited Paths. Solve this problem using disjoint set operations. Given the input constraints, find the optimal solution that meets all requirements.",
        "examples": [
            {
                "input": "Example input for Checking Existence of Edge Length Limited Paths",
                "output": "Expected output",
                "explanation": "This demonstrates the core logic for Checking Existence of Edge Length Limited Paths using Union Find pattern."
            },
            {
                "input": "Edge case input",
                "output": "Edge case output",
                "explanation": "This handles boundary conditions and special cases."
            }
        ],
        "constraints": [
            "Input size constraints: 1 <= n <= 10^5",
            "Value range: -10^9 <= val <= 10^9",
            "Optimal time complexity required for Union Find"
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Checking Existence of Edge Length Limited Paths involves checking all possible solutions. For Union Find problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Union Find problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Checking Existence of Edge Length Limited Paths\n        Union Find pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Checking Existence of Edge Length Limited Paths\n     * Union Find pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Checking Existence of Edge Length Limited Paths\n     * Union Find pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Checking Existence of Edge Length Limited Paths\n * Union Find pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Checking Existence of Edge Length Limited Paths leverages disjoint set operations to reduce time complexity. Instead of checking all possibilities, we use Union Find-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for Union Find reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Checking Existence of Edge Length Limited Paths\n        Union Find pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Checking Existence of Edge Length Limited Paths\n     * Union Find pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Checking Existence of Edge Length Limited Paths\n     * Union Find pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Checking Existence of Edge Length Limited Paths\n * Union Find pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "minimize-malware-spread": {
        "description": "Minimize Malware Spread. Solve this problem using disjoint set operations. Given the input constraints, find the optimal solution that meets all requirements.",
        "examples": [
            {
                "input": "Example input for Minimize Malware Spread",
                "output": "Expected output",
                "explanation": "This demonstrates the core logic for Minimize Malware Spread using Union Find pattern."
            },
            {
                "input": "Edge case input",
                "output": "Edge case output",
                "explanation": "This handles boundary conditions and special cases."
            }
        ],
        "constraints": [
            "Input size constraints: 1 <= n <= 10^5",
            "Value range: -10^9 <= val <= 10^9",
            "Optimal time complexity required for Union Find"
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Minimize Malware Spread involves checking all possible solutions. For Union Find problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Union Find problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Minimize Malware Spread\n        Union Find pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Minimize Malware Spread\n     * Union Find pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Minimize Malware Spread\n     * Union Find pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Minimize Malware Spread\n * Union Find pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Minimize Malware Spread leverages disjoint set operations to reduce time complexity. Instead of checking all possibilities, we use Union Find-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for Union Find reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Minimize Malware Spread\n        Union Find pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Minimize Malware Spread\n     * Union Find pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Minimize Malware Spread\n     * Union Find pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Minimize Malware Spread\n * Union Find pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "critical-connections-in-a-network": {
        "description": "Critical Connections in a Network. Solve this problem using depth-first search graph traversal. Given the input constraints, find the optimal solution that meets all requirements.",
        "examples": [
            {
                "input": "Example input for Critical Connections in a Network",
                "output": "Expected output",
                "explanation": "This demonstrates the core logic for Critical Connections in a Network using DFS pattern."
            },
            {
                "input": "Edge case input",
                "output": "Edge case output",
                "explanation": "This handles boundary conditions and special cases."
            }
        ],
        "constraints": [
            "Input size constraints: 1 <= n <= 10^5",
            "Value range: -10^9 <= val <= 10^9",
            "Optimal time complexity required for DFS"
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Critical Connections in a Network involves checking all possible solutions. For DFS problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. DFS problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Critical Connections in a Network\n        DFS pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Critical Connections in a Network\n     * DFS pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Critical Connections in a Network\n     * DFS pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Critical Connections in a Network\n * DFS pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Critical Connections in a Network leverages depth-first search graph traversal to reduce time complexity. Instead of checking all possibilities, we use DFS-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for DFS reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Critical Connections in a Network\n        DFS pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Critical Connections in a Network\n     * DFS pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Critical Connections in a Network\n     * DFS pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Critical Connections in a Network\n * DFS pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "dungeon-game": {
        "description": "Dungeon Game. Solve this problem using two-dimensional dynamic programming. Given the input constraints, find the optimal solution that meets all requirements.",
        "examples": [
            {
                "input": "Example input for Dungeon Game",
                "output": "Expected output",
                "explanation": "This demonstrates the core logic for Dungeon Game using 2D DP pattern."
            },
            {
                "input": "Edge case input",
                "output": "Edge case output",
                "explanation": "This handles boundary conditions and special cases."
            }
        ],
        "constraints": [
            "Input size constraints: 1 <= n <= 10^5",
            "Value range: -10^9 <= val <= 10^9",
            "Optimal time complexity required for 2D DP"
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Dungeon Game involves checking all possible solutions. For 2D DP problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(2^n)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. 2D DP problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Dungeon Game\n        2D DP pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Dungeon Game\n     * 2D DP pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Dungeon Game\n     * 2D DP pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Dungeon Game\n * 2D DP pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Dungeon Game leverages two-dimensional dynamic programming to reduce time complexity. Instead of checking all possibilities, we use 2D DP-specific techniques like memoization to cache subproblem results to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (DP table)\n2. Build up solutions from base cases\n3. For each subproblem:\n   - Check if already computed\n   - If not, compute using previously solved subproblems\n   - Store result for reuse\n4. Return the optimal solution\n\nKey optimizations:\n- Memoization prevents recomputation\n- Bottom-up or top-down approach\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Optimized approach for 2D DP reduces complexity significantly. DP table is filled once, each cell computed in O(1). This optimization transforms the solution from exponential to polynomial.",
                    "spaceExplanation": "DP table stores subproblem results. Space equals number of unique states. Can be further optimized by using rolling arrays if only previous row/state needed."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Dungeon Game\n        2D DP pattern implementation\n        Time: O(n)\n        Space: O(n)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize DP table\n        dp = [0] * (n + 1)\n        dp[0] = 1  # Base case\n        \n        for i in range(1, n + 1):\n            # Compute current state from previous states\n            dp[i] = dp[i-1] + (dp[i-2] if i > 1 else 0)\n        \n        return dp[n]",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Dungeon Game\n     * 2D DP pattern implementation\n     * Time: O(n)\n     * Space: O(n)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize DP array\n        int[] dp = new int[n + 1];\n        dp[0] = 1; // Base case\n        \n        for (int i = 1; i <= n; i++) {\n            // Compute current state from previous states\n            dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n        }\n        \n        return new int[]{dp[n]};\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Dungeon Game\n     * 2D DP pattern implementation\n     * Time: O(n)\n     * Space: O(n)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize DP vector\n        vector<int> dp(n + 1, 0);\n        dp[0] = 1; // Base case\n        \n        for (int i = 1; i <= n; i++) {\n            // Compute current state from previous states\n            dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n        }\n        \n        return {dp[n]};\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Dungeon Game\n * 2D DP pattern implementation\n * Time: O(n)\n * Space: O(n)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize DP array\n    const dp = new Array(n + 1).fill(0);\n    dp[0] = 1; // Base case\n    \n    for (let i = 1; i <= n; i++) {\n        // Compute current state from previous states\n        dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n    }\n    \n    return dp[n];\n};"
                }
            }
        }
    },
    "cherry-pickup": {
        "description": "Cherry Pickup. Solve this problem using two-dimensional dynamic programming. Given the input constraints, find the optimal solution that meets all requirements.",
        "examples": [
            {
                "input": "Example input for Cherry Pickup",
                "output": "Expected output",
                "explanation": "This demonstrates the core logic for Cherry Pickup using 2D DP pattern."
            },
            {
                "input": "Edge case input",
                "output": "Edge case output",
                "explanation": "This handles boundary conditions and special cases."
            }
        ],
        "constraints": [
            "Input size constraints: 1 <= n <= 10^5",
            "Value range: -10^9 <= val <= 10^9",
            "Optimal time complexity required for 2D DP"
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Cherry Pickup involves checking all possible solutions. For 2D DP problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(2^n)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. 2D DP problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Cherry Pickup\n        2D DP pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Cherry Pickup\n     * 2D DP pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Cherry Pickup\n     * 2D DP pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Cherry Pickup\n * 2D DP pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Cherry Pickup leverages two-dimensional dynamic programming to reduce time complexity. Instead of checking all possibilities, we use 2D DP-specific techniques like memoization to cache subproblem results to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (DP table)\n2. Build up solutions from base cases\n3. For each subproblem:\n   - Check if already computed\n   - If not, compute using previously solved subproblems\n   - Store result for reuse\n4. Return the optimal solution\n\nKey optimizations:\n- Memoization prevents recomputation\n- Bottom-up or top-down approach\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Optimized approach for 2D DP reduces complexity significantly. DP table is filled once, each cell computed in O(1). This optimization transforms the solution from exponential to polynomial.",
                    "spaceExplanation": "DP table stores subproblem results. Space equals number of unique states. Can be further optimized by using rolling arrays if only previous row/state needed."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Cherry Pickup\n        2D DP pattern implementation\n        Time: O(n)\n        Space: O(n)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize DP table\n        dp = [0] * (n + 1)\n        dp[0] = 1  # Base case\n        \n        for i in range(1, n + 1):\n            # Compute current state from previous states\n            dp[i] = dp[i-1] + (dp[i-2] if i > 1 else 0)\n        \n        return dp[n]",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Cherry Pickup\n     * 2D DP pattern implementation\n     * Time: O(n)\n     * Space: O(n)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize DP array\n        int[] dp = new int[n + 1];\n        dp[0] = 1; // Base case\n        \n        for (int i = 1; i <= n; i++) {\n            // Compute current state from previous states\n            dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n        }\n        \n        return new int[]{dp[n]};\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Cherry Pickup\n     * 2D DP pattern implementation\n     * Time: O(n)\n     * Space: O(n)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize DP vector\n        vector<int> dp(n + 1, 0);\n        dp[0] = 1; // Base case\n        \n        for (int i = 1; i <= n; i++) {\n            // Compute current state from previous states\n            dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n        }\n        \n        return {dp[n]};\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Cherry Pickup\n * 2D DP pattern implementation\n * Time: O(n)\n * Space: O(n)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize DP array\n    const dp = new Array(n + 1).fill(0);\n    dp[0] = 1; // Base case\n    \n    for (let i = 1; i <= n; i++) {\n        // Compute current state from previous states\n        dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n    }\n    \n    return dp[n];\n};"
                }
            }
        }
    },
    "stream-of-characters": {
        "description": "Stream of Characters. Solve this problem using word prefix tree structure. Given the input constraints, find the optimal solution that meets all requirements.",
        "examples": [
            {
                "input": "Example input for Stream of Characters",
                "output": "Expected output",
                "explanation": "This demonstrates the core logic for Stream of Characters using Tries pattern."
            },
            {
                "input": "Edge case input",
                "output": "Edge case output",
                "explanation": "This handles boundary conditions and special cases."
            }
        ],
        "constraints": [
            "Input size constraints: 1 <= n <= 10^5",
            "Value range: -10^9 <= val <= 10^9",
            "Optimal time complexity required for Tries"
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Stream of Characters involves checking all possible solutions. For Tries problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Tries problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Stream of Characters\n        Tries pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Stream of Characters\n     * Tries pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Stream of Characters\n     * Tries pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Stream of Characters\n * Tries pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Stream of Characters leverages word prefix tree structure to reduce time complexity. Instead of checking all possibilities, we use Tries-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for Tries reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Stream of Characters\n        Tries pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Stream of Characters\n     * Tries pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Stream of Characters\n     * Tries pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Stream of Characters\n * Tries pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "lfu-cache": {
        "description": "LFU Cache. Solve this problem using data structure design. Given the input constraints, find the optimal solution that meets all requirements.",
        "examples": [
            {
                "input": "Example input for LFU Cache",
                "output": "Expected output",
                "explanation": "This demonstrates the core logic for LFU Cache using Design pattern."
            },
            {
                "input": "Edge case input",
                "output": "Edge case output",
                "explanation": "This handles boundary conditions and special cases."
            }
        ],
        "constraints": [
            "Input size constraints: 1 <= n <= 10^5",
            "Value range: -10^9 <= val <= 10^9",
            "Optimal time complexity required for Design"
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for LFU Cache involves checking all possible solutions. For Design problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Design problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for LFU Cache\n        Design pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for LFU Cache\n     * Design pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for LFU Cache\n     * Design pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for LFU Cache\n * Design pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for LFU Cache leverages data structure design to reduce time complexity. Instead of checking all possibilities, we use Design-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for Design reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for LFU Cache\n        Design pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for LFU Cache\n     * Design pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for LFU Cache\n     * Design pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for LFU Cache\n * Design pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "student-attendance-record-ii": {
        "description": "Student Attendance Record II. Solve this problem using dynamic programming optimization. Given the input constraints, find the optimal solution that meets all requirements.",
        "examples": [
            {
                "input": "Example input for Student Attendance Record II",
                "output": "Expected output",
                "explanation": "This demonstrates the core logic for Student Attendance Record II using DP pattern."
            },
            {
                "input": "Edge case input",
                "output": "Edge case output",
                "explanation": "This handles boundary conditions and special cases."
            }
        ],
        "constraints": [
            "Input size constraints: 1 <= n <= 10^5",
            "Value range: -10^9 <= val <= 10^9",
            "Optimal time complexity required for DP"
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Student Attendance Record II involves checking all possible solutions. For DP problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(2^n)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. DP problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Student Attendance Record II\n        DP pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Student Attendance Record II\n     * DP pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Student Attendance Record II\n     * DP pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Student Attendance Record II\n * DP pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Student Attendance Record II leverages dynamic programming optimization to reduce time complexity. Instead of checking all possibilities, we use DP-specific techniques like memoization to cache subproblem results to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (DP table)\n2. Build up solutions from base cases\n3. For each subproblem:\n   - Check if already computed\n   - If not, compute using previously solved subproblems\n   - Store result for reuse\n4. Return the optimal solution\n\nKey optimizations:\n- Memoization prevents recomputation\n- Bottom-up or top-down approach\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(n)",
                    "timeExplanation": "Optimized approach for DP reduces complexity significantly. DP table is filled once, each cell computed in O(1). This optimization transforms the solution from exponential to polynomial.",
                    "spaceExplanation": "DP table stores subproblem results. Space equals number of unique states. Can be further optimized by using rolling arrays if only previous row/state needed."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Student Attendance Record II\n        DP pattern implementation\n        Time: O(n)\n        Space: O(n)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize DP table\n        dp = [0] * (n + 1)\n        dp[0] = 1  # Base case\n        \n        for i in range(1, n + 1):\n            # Compute current state from previous states\n            dp[i] = dp[i-1] + (dp[i-2] if i > 1 else 0)\n        \n        return dp[n]",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Student Attendance Record II\n     * DP pattern implementation\n     * Time: O(n)\n     * Space: O(n)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize DP array\n        int[] dp = new int[n + 1];\n        dp[0] = 1; // Base case\n        \n        for (int i = 1; i <= n; i++) {\n            // Compute current state from previous states\n            dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n        }\n        \n        return new int[]{dp[n]};\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Student Attendance Record II\n     * DP pattern implementation\n     * Time: O(n)\n     * Space: O(n)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize DP vector\n        vector<int> dp(n + 1, 0);\n        dp[0] = 1; // Base case\n        \n        for (int i = 1; i <= n; i++) {\n            // Compute current state from previous states\n            dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n        }\n        \n        return {dp[n]};\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Student Attendance Record II\n * DP pattern implementation\n * Time: O(n)\n * Space: O(n)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize DP array\n    const dp = new Array(n + 1).fill(0);\n    dp[0] = 1; // Base case\n    \n    for (let i = 1; i <= n; i++) {\n        // Compute current state from previous states\n        dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n    }\n    \n    return dp[n];\n};"
                }
            }
        }
    },
    "super-egg-drop": {
        "description": "Super Egg Drop. Solve this problem using dynamic programming optimization. Given the input constraints, find the optimal solution that meets all requirements.",
        "examples": [
            {
                "input": "Example input for Super Egg Drop",
                "output": "Expected output",
                "explanation": "This demonstrates the core logic for Super Egg Drop using DP pattern."
            },
            {
                "input": "Edge case input",
                "output": "Edge case output",
                "explanation": "This handles boundary conditions and special cases."
            }
        ],
        "constraints": [
            "Input size constraints: 1 <= n <= 10^5",
            "Value range: -10^9 <= val <= 10^9",
            "Optimal time complexity required for DP"
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Super Egg Drop involves checking all possible solutions. For DP problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(2^n)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. DP problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Super Egg Drop\n        DP pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Super Egg Drop\n     * DP pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Super Egg Drop\n     * DP pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Super Egg Drop\n * DP pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Super Egg Drop leverages dynamic programming optimization to reduce time complexity. Instead of checking all possibilities, we use DP-specific techniques like memoization to cache subproblem results to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (DP table)\n2. Build up solutions from base cases\n3. For each subproblem:\n   - Check if already computed\n   - If not, compute using previously solved subproblems\n   - Store result for reuse\n4. Return the optimal solution\n\nKey optimizations:\n- Memoization prevents recomputation\n- Bottom-up or top-down approach\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(n)",
                    "timeExplanation": "Optimized approach for DP reduces complexity significantly. DP table is filled once, each cell computed in O(1). This optimization transforms the solution from exponential to polynomial.",
                    "spaceExplanation": "DP table stores subproblem results. Space equals number of unique states. Can be further optimized by using rolling arrays if only previous row/state needed."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Super Egg Drop\n        DP pattern implementation\n        Time: O(n)\n        Space: O(n)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize DP table\n        dp = [0] * (n + 1)\n        dp[0] = 1  # Base case\n        \n        for i in range(1, n + 1):\n            # Compute current state from previous states\n            dp[i] = dp[i-1] + (dp[i-2] if i > 1 else 0)\n        \n        return dp[n]",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Super Egg Drop\n     * DP pattern implementation\n     * Time: O(n)\n     * Space: O(n)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize DP array\n        int[] dp = new int[n + 1];\n        dp[0] = 1; // Base case\n        \n        for (int i = 1; i <= n; i++) {\n            // Compute current state from previous states\n            dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n        }\n        \n        return new int[]{dp[n]};\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Super Egg Drop\n     * DP pattern implementation\n     * Time: O(n)\n     * Space: O(n)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize DP vector\n        vector<int> dp(n + 1, 0);\n        dp[0] = 1; // Base case\n        \n        for (int i = 1; i <= n; i++) {\n            // Compute current state from previous states\n            dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n        }\n        \n        return {dp[n]};\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Super Egg Drop\n * DP pattern implementation\n * Time: O(n)\n * Space: O(n)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize DP array\n    const dp = new Array(n + 1).fill(0);\n    dp[0] = 1; // Base case\n    \n    for (let i = 1; i <= n; i++) {\n        // Compute current state from previous states\n        dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n    }\n    \n    return dp[n];\n};"
                }
            }
        }
    },
    "range-sum-query-mutable": {
        "description": "Range Sum Query - Mutable. Solve this problem using complex tree transformations. Given the input constraints, find the optimal solution that meets all requirements.",
        "examples": [
            {
                "input": "Example input for Range Sum Query - Mutable",
                "output": "Expected output",
                "explanation": "This demonstrates the core logic for Range Sum Query - Mutable using Tree Hard pattern."
            },
            {
                "input": "Edge case input",
                "output": "Edge case output",
                "explanation": "This handles boundary conditions and special cases."
            }
        ],
        "constraints": [
            "Input size constraints: 1 <= n <= 10^5",
            "Value range: -10^9 <= val <= 10^9",
            "Optimal time complexity required for Tree Hard"
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Range Sum Query - Mutable involves checking all possible solutions. For Tree Hard problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Tree Hard problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Range Sum Query - Mutable\n        Tree Hard pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Range Sum Query - Mutable\n     * Tree Hard pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Range Sum Query - Mutable\n     * Tree Hard pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Range Sum Query - Mutable\n * Tree Hard pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Range Sum Query - Mutable leverages complex tree transformations to reduce time complexity. Instead of checking all possibilities, we use Tree Hard-specific techniques like efficient traversal with pruning to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (tree structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Pruning impossible branches\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(h)",
                    "timeExplanation": "Optimized approach for Tree Hard reduces complexity significantly. Tree traversal visits each node exactly once. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Recursion stack depth equals tree height. Balanced tree gives O(log n). Can be further optimized by using iterative approach instead of recursion."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Range Sum Query - Mutable\n        Tree Hard pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Range Sum Query - Mutable\n     * Tree Hard pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Range Sum Query - Mutable\n     * Tree Hard pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Range Sum Query - Mutable\n * Tree Hard pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "count-range-sum": {
        "description": "Count Range Sum. Solve this problem using complex tree transformations. Given the input constraints, find the optimal solution that meets all requirements.",
        "examples": [
            {
                "input": "Example input for Count Range Sum",
                "output": "Expected output",
                "explanation": "This demonstrates the core logic for Count Range Sum using Tree Hard pattern."
            },
            {
                "input": "Edge case input",
                "output": "Edge case output",
                "explanation": "This handles boundary conditions and special cases."
            }
        ],
        "constraints": [
            "Input size constraints: 1 <= n <= 10^5",
            "Value range: -10^9 <= val <= 10^9",
            "Optimal time complexity required for Tree Hard"
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Count Range Sum involves checking all possible solutions. For Tree Hard problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Tree Hard problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Count Range Sum\n        Tree Hard pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Count Range Sum\n     * Tree Hard pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Count Range Sum\n     * Tree Hard pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Count Range Sum\n * Tree Hard pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Count Range Sum leverages complex tree transformations to reduce time complexity. Instead of checking all possibilities, we use Tree Hard-specific techniques like efficient traversal with pruning to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (tree structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Pruning impossible branches\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(h)",
                    "timeExplanation": "Optimized approach for Tree Hard reduces complexity significantly. Tree traversal visits each node exactly once. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Recursion stack depth equals tree height. Balanced tree gives O(log n). Can be further optimized by using iterative approach instead of recursion."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Count Range Sum\n        Tree Hard pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Count Range Sum\n     * Tree Hard pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Count Range Sum\n     * Tree Hard pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Count Range Sum\n * Tree Hard pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "queue-reconstruction-by-height": {
        "description": "Queue Reconstruction by Height. Solve this problem using greedy choice optimization. Given the input constraints, find the optimal solution that meets all requirements.",
        "examples": [
            {
                "input": "Example input for Queue Reconstruction by Height",
                "output": "Expected output",
                "explanation": "This demonstrates the core logic for Queue Reconstruction by Height using Greedy pattern."
            },
            {
                "input": "Edge case input",
                "output": "Edge case output",
                "explanation": "This handles boundary conditions and special cases."
            }
        ],
        "constraints": [
            "Input size constraints: 1 <= n <= 10^5",
            "Value range: -10^9 <= val <= 10^9",
            "Optimal time complexity required for Greedy"
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Queue Reconstruction by Height involves checking all possible solutions. For Greedy problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Greedy problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Queue Reconstruction by Height\n        Greedy pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Queue Reconstruction by Height\n     * Greedy pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Queue Reconstruction by Height\n     * Greedy pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Queue Reconstruction by Height\n * Greedy pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Queue Reconstruction by Height leverages greedy choice optimization to reduce time complexity. Instead of checking all possibilities, we use Greedy-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Make locally optimal choices\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Local optimal choices lead to global optimum\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for Greedy reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Only constant extra space needed for pointers and variables. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Queue Reconstruction by Height\n        Greedy pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Queue Reconstruction by Height\n     * Greedy pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Queue Reconstruction by Height\n     * Greedy pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Queue Reconstruction by Height\n * Greedy pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "design-skiplist": {
        "description": "Design Skiplist. Solve this problem using data structure design. Given the input constraints, find the optimal solution that meets all requirements.",
        "examples": [
            {
                "input": "Example input for Design Skiplist",
                "output": "Expected output",
                "explanation": "This demonstrates the core logic for Design Skiplist using Design pattern."
            },
            {
                "input": "Edge case input",
                "output": "Edge case output",
                "explanation": "This handles boundary conditions and special cases."
            }
        ],
        "constraints": [
            "Input size constraints: 1 <= n <= 10^5",
            "Value range: -10^9 <= val <= 10^9",
            "Optimal time complexity required for Design"
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Design Skiplist involves checking all possible solutions. For Design problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Design problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Design Skiplist\n        Design pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Design Skiplist\n     * Design pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Design Skiplist\n     * Design pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Design Skiplist\n * Design pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Design Skiplist leverages data structure design to reduce time complexity. Instead of checking all possibilities, we use Design-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for Design reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Design Skiplist\n        Design pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Design Skiplist\n     * Design pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Design Skiplist\n     * Design pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Design Skiplist\n * Design pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "all-o-one-data-structure": {
        "description": "All O`one Data Structure. Solve this problem using data structure design. Given the input constraints, find the optimal solution that meets all requirements.",
        "examples": [
            {
                "input": "Example input for All O`one Data Structure",
                "output": "Expected output",
                "explanation": "This demonstrates the core logic for All O`one Data Structure using Design pattern."
            },
            {
                "input": "Edge case input",
                "output": "Edge case output",
                "explanation": "This handles boundary conditions and special cases."
            }
        ],
        "constraints": [
            "Input size constraints: 1 <= n <= 10^5",
            "Value range: -10^9 <= val <= 10^9",
            "Optimal time complexity required for Design"
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for All O`one Data Structure involves checking all possible solutions. For Design problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Design problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for All O`one Data Structure\n        Design pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for All O`one Data Structure\n     * Design pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for All O`one Data Structure\n     * Design pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for All O`one Data Structure\n * Design pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for All O`one Data Structure leverages data structure design to reduce time complexity. Instead of checking all possibilities, we use Design-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for Design reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for All O`one Data Structure\n        Design pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for All O`one Data Structure\n     * Design pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for All O`one Data Structure\n     * Design pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for All O`one Data Structure\n * Design pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "design-in-memory-file-system": {
        "description": "Design In-Memory File System. Solve this problem using data structure design. Given the input constraints, find the optimal solution that meets all requirements.",
        "examples": [
            {
                "input": "Example input for Design In-Memory File System",
                "output": "Expected output",
                "explanation": "This demonstrates the core logic for Design In-Memory File System using Design pattern."
            },
            {
                "input": "Edge case input",
                "output": "Edge case output",
                "explanation": "This handles boundary conditions and special cases."
            }
        ],
        "constraints": [
            "Input size constraints: 1 <= n <= 10^5",
            "Value range: -10^9 <= val <= 10^9",
            "Optimal time complexity required for Design"
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Design In-Memory File System involves checking all possible solutions. For Design problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Design problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Design In-Memory File System\n        Design pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Design In-Memory File System\n     * Design pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Design In-Memory File System\n     * Design pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Design In-Memory File System\n * Design pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Design In-Memory File System leverages data structure design to reduce time complexity. Instead of checking all possibilities, we use Design-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for Design reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Design In-Memory File System\n        Design pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Design In-Memory File System\n     * Design pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Design In-Memory File System\n     * Design pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Design In-Memory File System\n * Design pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "maximum-frequency-stack": {
        "description": "Maximum Frequency Stack. Solve this problem using stack-based operations. Given the input constraints, find the optimal solution that meets all requirements.",
        "examples": [
            {
                "input": "Example input for Maximum Frequency Stack",
                "output": "Expected output",
                "explanation": "This demonstrates the core logic for Maximum Frequency Stack using Stack pattern."
            },
            {
                "input": "Edge case input",
                "output": "Edge case output",
                "explanation": "This handles boundary conditions and special cases."
            }
        ],
        "constraints": [
            "Input size constraints: 1 <= n <= 10^5",
            "Value range: -10^9 <= val <= 10^9",
            "Optimal time complexity required for Stack"
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Maximum Frequency Stack involves checking all possible solutions. For Stack problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Stack problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Maximum Frequency Stack\n        Stack pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Maximum Frequency Stack\n     * Stack pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Maximum Frequency Stack\n     * Stack pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Maximum Frequency Stack\n * Stack pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Maximum Frequency Stack leverages stack-based operations to reduce time complexity. Instead of checking all possibilities, we use Stack-specific techniques like stack/queue for optimal state management to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (stack)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Efficient state management\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for Stack reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Maximum Frequency Stack\n        Stack pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Stack for state management\n        stack = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Maximum Frequency Stack\n     * Stack pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Stack for state management\n        Stack<Integer> stack = new Stack<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Maximum Frequency Stack\n     * Stack pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Stack for state management\n        stack<int> st;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Maximum Frequency Stack\n * Stack pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Stack for state management\n    const stack = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "shortest-subarray-with-sum-at-least-k": {
        "description": "Shortest Subarray with Sum at Least K. Solve this problem using monotonic queue optimization. Given the input constraints, find the optimal solution that meets all requirements.",
        "examples": [
            {
                "input": "Example input for Shortest Subarray with Sum at Least K",
                "output": "Expected output",
                "explanation": "This demonstrates the core logic for Shortest Subarray with Sum at Least K using Monotonic Queue pattern."
            },
            {
                "input": "Edge case input",
                "output": "Edge case output",
                "explanation": "This handles boundary conditions and special cases."
            }
        ],
        "constraints": [
            "Input size constraints: 1 <= n <= 10^5",
            "Value range: -10^9 <= val <= 10^9",
            "Optimal time complexity required for Monotonic Queue"
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Shortest Subarray with Sum at Least K involves checking all possible solutions. For Monotonic Queue problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Monotonic Queue problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Shortest Subarray with Sum at Least K\n        Monotonic Queue pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Shortest Subarray with Sum at Least K\n     * Monotonic Queue pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Shortest Subarray with Sum at Least K\n     * Monotonic Queue pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Shortest Subarray with Sum at Least K\n * Monotonic Queue pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Shortest Subarray with Sum at Least K leverages monotonic queue optimization to reduce time complexity. Instead of checking all possibilities, we use Monotonic Queue-specific techniques like stack/queue for optimal state management to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Efficient state management\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for Monotonic Queue reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Shortest Subarray with Sum at Least K\n        Monotonic Queue pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Shortest Subarray with Sum at Least K\n     * Monotonic Queue pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Shortest Subarray with Sum at Least K\n     * Monotonic Queue pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Shortest Subarray with Sum at Least K\n * Monotonic Queue pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "minimum-number-of-refueling-stops": {
        "description": "Minimum Number of Refueling Stops. Solve this problem using dynamic programming optimization. Given the input constraints, find the optimal solution that meets all requirements.",
        "examples": [
            {
                "input": "Example input for Minimum Number of Refueling Stops",
                "output": "Expected output",
                "explanation": "This demonstrates the core logic for Minimum Number of Refueling Stops using DP pattern."
            },
            {
                "input": "Edge case input",
                "output": "Edge case output",
                "explanation": "This handles boundary conditions and special cases."
            }
        ],
        "constraints": [
            "Input size constraints: 1 <= n <= 10^5",
            "Value range: -10^9 <= val <= 10^9",
            "Optimal time complexity required for DP"
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Minimum Number of Refueling Stops involves checking all possible solutions. For DP problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(2^n)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. DP problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Minimum Number of Refueling Stops\n        DP pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Minimum Number of Refueling Stops\n     * DP pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Minimum Number of Refueling Stops\n     * DP pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Minimum Number of Refueling Stops\n * DP pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Minimum Number of Refueling Stops leverages dynamic programming optimization to reduce time complexity. Instead of checking all possibilities, we use DP-specific techniques like memoization to cache subproblem results to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (DP table)\n2. Build up solutions from base cases\n3. For each subproblem:\n   - Check if already computed\n   - If not, compute using previously solved subproblems\n   - Store result for reuse\n4. Return the optimal solution\n\nKey optimizations:\n- Memoization prevents recomputation\n- Bottom-up or top-down approach\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(n)",
                    "timeExplanation": "Optimized approach for DP reduces complexity significantly. DP table is filled once, each cell computed in O(1). This optimization transforms the solution from exponential to polynomial.",
                    "spaceExplanation": "DP table stores subproblem results. Space equals number of unique states. Can be further optimized by using rolling arrays if only previous row/state needed."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Minimum Number of Refueling Stops\n        DP pattern implementation\n        Time: O(n)\n        Space: O(n)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize DP table\n        dp = [0] * (n + 1)\n        dp[0] = 1  # Base case\n        \n        for i in range(1, n + 1):\n            # Compute current state from previous states\n            dp[i] = dp[i-1] + (dp[i-2] if i > 1 else 0)\n        \n        return dp[n]",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Minimum Number of Refueling Stops\n     * DP pattern implementation\n     * Time: O(n)\n     * Space: O(n)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize DP array\n        int[] dp = new int[n + 1];\n        dp[0] = 1; // Base case\n        \n        for (int i = 1; i <= n; i++) {\n            // Compute current state from previous states\n            dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n        }\n        \n        return new int[]{dp[n]};\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Minimum Number of Refueling Stops\n     * DP pattern implementation\n     * Time: O(n)\n     * Space: O(n)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize DP vector\n        vector<int> dp(n + 1, 0);\n        dp[0] = 1; // Base case\n        \n        for (int i = 1; i <= n; i++) {\n            // Compute current state from previous states\n            dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n        }\n        \n        return {dp[n]};\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Minimum Number of Refueling Stops\n * DP pattern implementation\n * Time: O(n)\n * Space: O(n)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize DP array\n    const dp = new Array(n + 1).fill(0);\n    dp[0] = 1; // Base case\n    \n    for (let i = 1; i <= n; i++) {\n        // Compute current state from previous states\n        dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n    }\n    \n    return dp[n];\n};"
                }
            }
        }
    },
    "profitable-schemes": {
        "description": "Profitable Schemes. Solve this problem using dynamic programming optimization. Given the input constraints, find the optimal solution that meets all requirements.",
        "examples": [
            {
                "input": "Example input for Profitable Schemes",
                "output": "Expected output",
                "explanation": "This demonstrates the core logic for Profitable Schemes using DP pattern."
            },
            {
                "input": "Edge case input",
                "output": "Edge case output",
                "explanation": "This handles boundary conditions and special cases."
            }
        ],
        "constraints": [
            "Input size constraints: 1 <= n <= 10^5",
            "Value range: -10^9 <= val <= 10^9",
            "Optimal time complexity required for DP"
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Profitable Schemes involves checking all possible solutions. For DP problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(2^n)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. DP problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Profitable Schemes\n        DP pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Profitable Schemes\n     * DP pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Profitable Schemes\n     * DP pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Profitable Schemes\n * DP pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Profitable Schemes leverages dynamic programming optimization to reduce time complexity. Instead of checking all possibilities, we use DP-specific techniques like memoization to cache subproblem results to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (DP table)\n2. Build up solutions from base cases\n3. For each subproblem:\n   - Check if already computed\n   - If not, compute using previously solved subproblems\n   - Store result for reuse\n4. Return the optimal solution\n\nKey optimizations:\n- Memoization prevents recomputation\n- Bottom-up or top-down approach\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(n)",
                    "timeExplanation": "Optimized approach for DP reduces complexity significantly. DP table is filled once, each cell computed in O(1). This optimization transforms the solution from exponential to polynomial.",
                    "spaceExplanation": "DP table stores subproblem results. Space equals number of unique states. Can be further optimized by using rolling arrays if only previous row/state needed."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Profitable Schemes\n        DP pattern implementation\n        Time: O(n)\n        Space: O(n)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize DP table\n        dp = [0] * (n + 1)\n        dp[0] = 1  # Base case\n        \n        for i in range(1, n + 1):\n            # Compute current state from previous states\n            dp[i] = dp[i-1] + (dp[i-2] if i > 1 else 0)\n        \n        return dp[n]",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Profitable Schemes\n     * DP pattern implementation\n     * Time: O(n)\n     * Space: O(n)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize DP array\n        int[] dp = new int[n + 1];\n        dp[0] = 1; // Base case\n        \n        for (int i = 1; i <= n; i++) {\n            // Compute current state from previous states\n            dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n        }\n        \n        return new int[]{dp[n]};\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Profitable Schemes\n     * DP pattern implementation\n     * Time: O(n)\n     * Space: O(n)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize DP vector\n        vector<int> dp(n + 1, 0);\n        dp[0] = 1; // Base case\n        \n        for (int i = 1; i <= n; i++) {\n            // Compute current state from previous states\n            dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n        }\n        \n        return {dp[n]};\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Profitable Schemes\n * DP pattern implementation\n * Time: O(n)\n * Space: O(n)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize DP array\n    const dp = new Array(n + 1).fill(0);\n    dp[0] = 1; // Base case\n    \n    for (let i = 1; i <= n; i++) {\n        // Compute current state from previous states\n        dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n    }\n    \n    return dp[n];\n};"
                }
            }
        }
    },
    "tallest-billboard": {
        "description": "Tallest Billboard. Solve this problem using dynamic programming optimization. Given the input constraints, find the optimal solution that meets all requirements.",
        "examples": [
            {
                "input": "Example input for Tallest Billboard",
                "output": "Expected output",
                "explanation": "This demonstrates the core logic for Tallest Billboard using DP pattern."
            },
            {
                "input": "Edge case input",
                "output": "Edge case output",
                "explanation": "This handles boundary conditions and special cases."
            }
        ],
        "constraints": [
            "Input size constraints: 1 <= n <= 10^5",
            "Value range: -10^9 <= val <= 10^9",
            "Optimal time complexity required for DP"
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Tallest Billboard involves checking all possible solutions. For DP problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(2^n)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. DP problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Tallest Billboard\n        DP pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Tallest Billboard\n     * DP pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Tallest Billboard\n     * DP pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Tallest Billboard\n * DP pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Tallest Billboard leverages dynamic programming optimization to reduce time complexity. Instead of checking all possibilities, we use DP-specific techniques like memoization to cache subproblem results to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (DP table)\n2. Build up solutions from base cases\n3. For each subproblem:\n   - Check if already computed\n   - If not, compute using previously solved subproblems\n   - Store result for reuse\n4. Return the optimal solution\n\nKey optimizations:\n- Memoization prevents recomputation\n- Bottom-up or top-down approach\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(n)",
                    "timeExplanation": "Optimized approach for DP reduces complexity significantly. DP table is filled once, each cell computed in O(1). This optimization transforms the solution from exponential to polynomial.",
                    "spaceExplanation": "DP table stores subproblem results. Space equals number of unique states. Can be further optimized by using rolling arrays if only previous row/state needed."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Tallest Billboard\n        DP pattern implementation\n        Time: O(n)\n        Space: O(n)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize DP table\n        dp = [0] * (n + 1)\n        dp[0] = 1  # Base case\n        \n        for i in range(1, n + 1):\n            # Compute current state from previous states\n            dp[i] = dp[i-1] + (dp[i-2] if i > 1 else 0)\n        \n        return dp[n]",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Tallest Billboard\n     * DP pattern implementation\n     * Time: O(n)\n     * Space: O(n)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize DP array\n        int[] dp = new int[n + 1];\n        dp[0] = 1; // Base case\n        \n        for (int i = 1; i <= n; i++) {\n            // Compute current state from previous states\n            dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n        }\n        \n        return new int[]{dp[n]};\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Tallest Billboard\n     * DP pattern implementation\n     * Time: O(n)\n     * Space: O(n)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize DP vector\n        vector<int> dp(n + 1, 0);\n        dp[0] = 1; // Base case\n        \n        for (int i = 1; i <= n; i++) {\n            // Compute current state from previous states\n            dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n        }\n        \n        return {dp[n]};\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Tallest Billboard\n * DP pattern implementation\n * Time: O(n)\n * Space: O(n)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize DP array\n    const dp = new Array(n + 1).fill(0);\n    dp[0] = 1; // Base case\n    \n    for (let i = 1; i <= n; i++) {\n        // Compute current state from previous states\n        dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n    }\n    \n    return dp[n];\n};"
                }
            }
        }
    },
    "partition-array-into-two-arrays-to-minimize-sum-difference": {
        "description": "Partition Array Into Two Arrays to Minimize Sum Difference. Solve this problem using bitmask dynamic programming. Given the input constraints, find the optimal solution that meets all requirements.",
        "examples": [
            {
                "input": "Example input for Partition Array Into Two Arrays to Minimize Sum Difference",
                "output": "Expected output",
                "explanation": "This demonstrates the core logic for Partition Array Into Two Arrays to Minimize Sum Difference using Bitmask / State DP pattern."
            },
            {
                "input": "Edge case input",
                "output": "Edge case output",
                "explanation": "This handles boundary conditions and special cases."
            }
        ],
        "constraints": [
            "Input size constraints: 1 <= n <= 10^5",
            "Value range: -10^9 <= val <= 10^9",
            "Optimal time complexity required for Bitmask / State DP"
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Partition Array Into Two Arrays to Minimize Sum Difference involves checking all possible solutions. For Bitmask / State DP problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(2^n)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Bitmask / State DP problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Partition Array Into Two Arrays to Minimize Sum Difference\n        Bitmask / State DP pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Partition Array Into Two Arrays to Minimize Sum Difference\n     * Bitmask / State DP pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Partition Array Into Two Arrays to Minimize Sum Difference\n     * Bitmask / State DP pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Partition Array Into Two Arrays to Minimize Sum Difference\n * Bitmask / State DP pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Partition Array Into Two Arrays to Minimize Sum Difference leverages bitmask dynamic programming to reduce time complexity. Instead of checking all possibilities, we use Bitmask / State DP-specific techniques like memoization to cache subproblem results to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (DP table)\n2. Build up solutions from base cases\n3. For each subproblem:\n   - Check if already computed\n   - If not, compute using previously solved subproblems\n   - Store result for reuse\n4. Return the optimal solution\n\nKey optimizations:\n- Memoization prevents recomputation\n- Bottom-up or top-down approach\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(n)",
                    "timeExplanation": "Optimized approach for Bitmask / State DP reduces complexity significantly. DP table is filled once, each cell computed in O(1). This optimization transforms the solution from exponential to polynomial.",
                    "spaceExplanation": "DP table stores subproblem results. Space equals number of unique states. Can be further optimized by using rolling arrays if only previous row/state needed."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Partition Array Into Two Arrays to Minimize Sum Difference\n        Bitmask / State DP pattern implementation\n        Time: O(n)\n        Space: O(n)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize DP table\n        dp = [0] * (n + 1)\n        dp[0] = 1  # Base case\n        \n        for i in range(1, n + 1):\n            # Compute current state from previous states\n            dp[i] = dp[i-1] + (dp[i-2] if i > 1 else 0)\n        \n        return dp[n]",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Partition Array Into Two Arrays to Minimize Sum Difference\n     * Bitmask / State DP pattern implementation\n     * Time: O(n)\n     * Space: O(n)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize DP array\n        int[] dp = new int[n + 1];\n        dp[0] = 1; // Base case\n        \n        for (int i = 1; i <= n; i++) {\n            // Compute current state from previous states\n            dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n        }\n        \n        return new int[]{dp[n]};\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Partition Array Into Two Arrays to Minimize Sum Difference\n     * Bitmask / State DP pattern implementation\n     * Time: O(n)\n     * Space: O(n)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize DP vector\n        vector<int> dp(n + 1, 0);\n        dp[0] = 1; // Base case\n        \n        for (int i = 1; i <= n; i++) {\n            // Compute current state from previous states\n            dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n        }\n        \n        return {dp[n]};\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Partition Array Into Two Arrays to Minimize Sum Difference\n * Bitmask / State DP pattern implementation\n * Time: O(n)\n * Space: O(n)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize DP array\n    const dp = new Array(n + 1).fill(0);\n    dp[0] = 1; // Base case\n    \n    for (let i = 1; i <= n; i++) {\n        // Compute current state from previous states\n        dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n    }\n    \n    return dp[n];\n};"
                }
            }
        }
    },
    "smallest-sufficient-team": {
        "description": "Smallest Sufficient Team. Solve this problem using bitmask dynamic programming. Given the input constraints, find the optimal solution that meets all requirements.",
        "examples": [
            {
                "input": "Example input for Smallest Sufficient Team",
                "output": "Expected output",
                "explanation": "This demonstrates the core logic for Smallest Sufficient Team using Bitmask / State DP pattern."
            },
            {
                "input": "Edge case input",
                "output": "Edge case output",
                "explanation": "This handles boundary conditions and special cases."
            }
        ],
        "constraints": [
            "Input size constraints: 1 <= n <= 10^5",
            "Value range: -10^9 <= val <= 10^9",
            "Optimal time complexity required for Bitmask / State DP"
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Smallest Sufficient Team involves checking all possible solutions. For Bitmask / State DP problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(2^n)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Bitmask / State DP problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Smallest Sufficient Team\n        Bitmask / State DP pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Smallest Sufficient Team\n     * Bitmask / State DP pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Smallest Sufficient Team\n     * Bitmask / State DP pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Smallest Sufficient Team\n * Bitmask / State DP pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Smallest Sufficient Team leverages bitmask dynamic programming to reduce time complexity. Instead of checking all possibilities, we use Bitmask / State DP-specific techniques like memoization to cache subproblem results to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (DP table)\n2. Build up solutions from base cases\n3. For each subproblem:\n   - Check if already computed\n   - If not, compute using previously solved subproblems\n   - Store result for reuse\n4. Return the optimal solution\n\nKey optimizations:\n- Memoization prevents recomputation\n- Bottom-up or top-down approach\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(n)",
                    "timeExplanation": "Optimized approach for Bitmask / State DP reduces complexity significantly. DP table is filled once, each cell computed in O(1). This optimization transforms the solution from exponential to polynomial.",
                    "spaceExplanation": "DP table stores subproblem results. Space equals number of unique states. Can be further optimized by using rolling arrays if only previous row/state needed."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Smallest Sufficient Team\n        Bitmask / State DP pattern implementation\n        Time: O(n)\n        Space: O(n)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize DP table\n        dp = [0] * (n + 1)\n        dp[0] = 1  # Base case\n        \n        for i in range(1, n + 1):\n            # Compute current state from previous states\n            dp[i] = dp[i-1] + (dp[i-2] if i > 1 else 0)\n        \n        return dp[n]",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Smallest Sufficient Team\n     * Bitmask / State DP pattern implementation\n     * Time: O(n)\n     * Space: O(n)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize DP array\n        int[] dp = new int[n + 1];\n        dp[0] = 1; // Base case\n        \n        for (int i = 1; i <= n; i++) {\n            // Compute current state from previous states\n            dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n        }\n        \n        return new int[]{dp[n]};\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Smallest Sufficient Team\n     * Bitmask / State DP pattern implementation\n     * Time: O(n)\n     * Space: O(n)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize DP vector\n        vector<int> dp(n + 1, 0);\n        dp[0] = 1; // Base case\n        \n        for (int i = 1; i <= n; i++) {\n            // Compute current state from previous states\n            dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n        }\n        \n        return {dp[n]};\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Smallest Sufficient Team\n * Bitmask / State DP pattern implementation\n * Time: O(n)\n * Space: O(n)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize DP array\n    const dp = new Array(n + 1).fill(0);\n    dp[0] = 1; // Base case\n    \n    for (let i = 1; i <= n; i++) {\n        // Compute current state from previous states\n        dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n    }\n    \n    return dp[n];\n};"
                }
            }
        }
    },
    "maximum-score-words-formed-by-letters": {
        "description": "Maximum Score Words Formed by Letters. Solve this problem using bitmask dynamic programming. Given the input constraints, find the optimal solution that meets all requirements.",
        "examples": [
            {
                "input": "Example input for Maximum Score Words Formed by Letters",
                "output": "Expected output",
                "explanation": "This demonstrates the core logic for Maximum Score Words Formed by Letters using Bitmask / State DP pattern."
            },
            {
                "input": "Edge case input",
                "output": "Edge case output",
                "explanation": "This handles boundary conditions and special cases."
            }
        ],
        "constraints": [
            "Input size constraints: 1 <= n <= 10^5",
            "Value range: -10^9 <= val <= 10^9",
            "Optimal time complexity required for Bitmask / State DP"
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Maximum Score Words Formed by Letters involves checking all possible solutions. For Bitmask / State DP problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(2^n)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Bitmask / State DP problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Maximum Score Words Formed by Letters\n        Bitmask / State DP pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Maximum Score Words Formed by Letters\n     * Bitmask / State DP pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Maximum Score Words Formed by Letters\n     * Bitmask / State DP pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Maximum Score Words Formed by Letters\n * Bitmask / State DP pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Maximum Score Words Formed by Letters leverages bitmask dynamic programming to reduce time complexity. Instead of checking all possibilities, we use Bitmask / State DP-specific techniques like memoization to cache subproblem results to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (DP table)\n2. Build up solutions from base cases\n3. For each subproblem:\n   - Check if already computed\n   - If not, compute using previously solved subproblems\n   - Store result for reuse\n4. Return the optimal solution\n\nKey optimizations:\n- Memoization prevents recomputation\n- Bottom-up or top-down approach\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(n)",
                    "timeExplanation": "Optimized approach for Bitmask / State DP reduces complexity significantly. DP table is filled once, each cell computed in O(1). This optimization transforms the solution from exponential to polynomial.",
                    "spaceExplanation": "DP table stores subproblem results. Space equals number of unique states. Can be further optimized by using rolling arrays if only previous row/state needed."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Maximum Score Words Formed by Letters\n        Bitmask / State DP pattern implementation\n        Time: O(n)\n        Space: O(n)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize DP table\n        dp = [0] * (n + 1)\n        dp[0] = 1  # Base case\n        \n        for i in range(1, n + 1):\n            # Compute current state from previous states\n            dp[i] = dp[i-1] + (dp[i-2] if i > 1 else 0)\n        \n        return dp[n]",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Maximum Score Words Formed by Letters\n     * Bitmask / State DP pattern implementation\n     * Time: O(n)\n     * Space: O(n)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize DP array\n        int[] dp = new int[n + 1];\n        dp[0] = 1; // Base case\n        \n        for (int i = 1; i <= n; i++) {\n            // Compute current state from previous states\n            dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n        }\n        \n        return new int[]{dp[n]};\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Maximum Score Words Formed by Letters\n     * Bitmask / State DP pattern implementation\n     * Time: O(n)\n     * Space: O(n)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize DP vector\n        vector<int> dp(n + 1, 0);\n        dp[0] = 1; // Base case\n        \n        for (int i = 1; i <= n; i++) {\n            // Compute current state from previous states\n            dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n        }\n        \n        return {dp[n]};\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Maximum Score Words Formed by Letters\n * Bitmask / State DP pattern implementation\n * Time: O(n)\n * Space: O(n)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize DP array\n    const dp = new Array(n + 1).fill(0);\n    dp[0] = 1; // Base case\n    \n    for (let i = 1; i <= n; i++) {\n        // Compute current state from previous states\n        dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n    }\n    \n    return dp[n];\n};"
                }
            }
        }
    },
    "find-the-shortest-superstring": {
        "description": "Find the Shortest Superstring. Solve this problem using bitmask dynamic programming. Given the input constraints, find the optimal solution that meets all requirements.",
        "examples": [
            {
                "input": "Example input for Find the Shortest Superstring",
                "output": "Expected output",
                "explanation": "This demonstrates the core logic for Find the Shortest Superstring using Bitmask / State DP pattern."
            },
            {
                "input": "Edge case input",
                "output": "Edge case output",
                "explanation": "This handles boundary conditions and special cases."
            }
        ],
        "constraints": [
            "Input size constraints: 1 <= n <= 10^5",
            "Value range: -10^9 <= val <= 10^9",
            "Optimal time complexity required for Bitmask / State DP"
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Find the Shortest Superstring involves checking all possible solutions. For Bitmask / State DP problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(2^n)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Bitmask / State DP problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Find the Shortest Superstring\n        Bitmask / State DP pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Find the Shortest Superstring\n     * Bitmask / State DP pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Find the Shortest Superstring\n     * Bitmask / State DP pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Find the Shortest Superstring\n * Bitmask / State DP pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Find the Shortest Superstring leverages bitmask dynamic programming to reduce time complexity. Instead of checking all possibilities, we use Bitmask / State DP-specific techniques like memoization to cache subproblem results to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (DP table)\n2. Build up solutions from base cases\n3. For each subproblem:\n   - Check if already computed\n   - If not, compute using previously solved subproblems\n   - Store result for reuse\n4. Return the optimal solution\n\nKey optimizations:\n- Memoization prevents recomputation\n- Bottom-up or top-down approach\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(n)",
                    "timeExplanation": "Optimized approach for Bitmask / State DP reduces complexity significantly. DP table is filled once, each cell computed in O(1). This optimization transforms the solution from exponential to polynomial.",
                    "spaceExplanation": "DP table stores subproblem results. Space equals number of unique states. Can be further optimized by using rolling arrays if only previous row/state needed."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Find the Shortest Superstring\n        Bitmask / State DP pattern implementation\n        Time: O(n)\n        Space: O(n)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize DP table\n        dp = [0] * (n + 1)\n        dp[0] = 1  # Base case\n        \n        for i in range(1, n + 1):\n            # Compute current state from previous states\n            dp[i] = dp[i-1] + (dp[i-2] if i > 1 else 0)\n        \n        return dp[n]",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Find the Shortest Superstring\n     * Bitmask / State DP pattern implementation\n     * Time: O(n)\n     * Space: O(n)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize DP array\n        int[] dp = new int[n + 1];\n        dp[0] = 1; // Base case\n        \n        for (int i = 1; i <= n; i++) {\n            // Compute current state from previous states\n            dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n        }\n        \n        return new int[]{dp[n]};\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Find the Shortest Superstring\n     * Bitmask / State DP pattern implementation\n     * Time: O(n)\n     * Space: O(n)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize DP vector\n        vector<int> dp(n + 1, 0);\n        dp[0] = 1; // Base case\n        \n        for (int i = 1; i <= n; i++) {\n            // Compute current state from previous states\n            dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n        }\n        \n        return {dp[n]};\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Find the Shortest Superstring\n * Bitmask / State DP pattern implementation\n * Time: O(n)\n * Space: O(n)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize DP array\n    const dp = new Array(n + 1).fill(0);\n    dp[0] = 1; // Base case\n    \n    for (let i = 1; i <= n; i++) {\n        // Compute current state from previous states\n        dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n    }\n    \n    return dp[n];\n};"
                }
            }
        }
    },
    "determine-if-two-strings-are-close": {
        "description": "Determine if Two Strings Are Close. Solve this problem using string manipulation algorithms. Given the input constraints, find the optimal solution that meets all requirements.",
        "examples": [
            {
                "input": "Example input for Determine if Two Strings Are Close",
                "output": "Expected output",
                "explanation": "This demonstrates the core logic for Determine if Two Strings Are Close using Strings pattern."
            },
            {
                "input": "Edge case input",
                "output": "Edge case output",
                "explanation": "This handles boundary conditions and special cases."
            }
        ],
        "constraints": [
            "Input size constraints: 1 <= n <= 10^5",
            "Value range: -10^9 <= val <= 10^9",
            "Optimal time complexity required for Strings"
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Determine if Two Strings Are Close involves checking all possible solutions. For Strings problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Strings problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Determine if Two Strings Are Close\n        Strings pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Determine if Two Strings Are Close\n     * Strings pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Determine if Two Strings Are Close\n     * Strings pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Determine if Two Strings Are Close\n * Strings pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Determine if Two Strings Are Close leverages string manipulation algorithms to reduce time complexity. Instead of checking all possibilities, we use Strings-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for Strings reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Determine if Two Strings Are Close\n        Strings pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Determine if Two Strings Are Close\n     * Strings pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Determine if Two Strings Are Close\n     * Strings pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Determine if Two Strings Are Close\n * Strings pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "minimum-deletions-to-make-character-frequencies-unique": {
        "description": "Minimum Deletions to Make Character Frequencies Unique. Solve this problem using greedy choice optimization. Given the input constraints, find the optimal solution that meets all requirements.",
        "examples": [
            {
                "input": "Example input for Minimum Deletions to Make Character Frequencies Unique",
                "output": "Expected output",
                "explanation": "This demonstrates the core logic for Minimum Deletions to Make Character Frequencies Unique using Greedy pattern."
            },
            {
                "input": "Edge case input",
                "output": "Edge case output",
                "explanation": "This handles boundary conditions and special cases."
            }
        ],
        "constraints": [
            "Input size constraints: 1 <= n <= 10^5",
            "Value range: -10^9 <= val <= 10^9",
            "Optimal time complexity required for Greedy"
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Minimum Deletions to Make Character Frequencies Unique involves checking all possible solutions. For Greedy problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Greedy problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Minimum Deletions to Make Character Frequencies Unique\n        Greedy pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Minimum Deletions to Make Character Frequencies Unique\n     * Greedy pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Minimum Deletions to Make Character Frequencies Unique\n     * Greedy pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Minimum Deletions to Make Character Frequencies Unique\n * Greedy pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Minimum Deletions to Make Character Frequencies Unique leverages greedy choice optimization to reduce time complexity. Instead of checking all possibilities, we use Greedy-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Make locally optimal choices\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Local optimal choices lead to global optimum\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for Greedy reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Only constant extra space needed for pointers and variables. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Minimum Deletions to Make Character Frequencies Unique\n        Greedy pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Minimum Deletions to Make Character Frequencies Unique\n     * Greedy pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Minimum Deletions to Make Character Frequencies Unique\n     * Greedy pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Minimum Deletions to Make Character Frequencies Unique\n * Greedy pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "minimum-rounds-to-complete-all-tasks": {
        "description": "Minimum Rounds to Complete All Tasks. Solve this problem using hash table operations. Given the input constraints, find the optimal solution that meets all requirements.",
        "examples": [
            {
                "input": "Example input for Minimum Rounds to Complete All Tasks",
                "output": "Expected output",
                "explanation": "This demonstrates the core logic for Minimum Rounds to Complete All Tasks using Hash Tables pattern."
            },
            {
                "input": "Edge case input",
                "output": "Edge case output",
                "explanation": "This handles boundary conditions and special cases."
            }
        ],
        "constraints": [
            "Input size constraints: 1 <= n <= 10^5",
            "Value range: -10^9 <= val <= 10^9",
            "Optimal time complexity required for Hash Tables"
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Minimum Rounds to Complete All Tasks involves checking all possible solutions. For Hash Tables problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Hash Tables problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Minimum Rounds to Complete All Tasks\n        Hash Tables pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Minimum Rounds to Complete All Tasks\n     * Hash Tables pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Minimum Rounds to Complete All Tasks\n     * Hash Tables pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Minimum Rounds to Complete All Tasks\n * Hash Tables pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Minimum Rounds to Complete All Tasks leverages hash table operations to reduce time complexity. Instead of checking all possibilities, we use Hash Tables-specific techniques like hash tables for O(1) lookups to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (hash map)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Hash lookups are O(1)\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(n)",
                    "timeExplanation": "Optimized approach for Hash Tables reduces complexity significantly. Hash table provides O(1) lookup, single pass through data. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Hash table stores seen elements for O(1) lookup. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Minimum Rounds to Complete All Tasks\n        Hash Tables pattern implementation\n        Time: O(n)\n        Space: O(n)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Use hash table for O(1) lookups\n        seen = {}\n        \n        for i, val in enumerate(input):\n            complement = target - val\n            if complement in seen:\n                return [seen[complement], i]\n            seen[val] = i\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Minimum Rounds to Complete All Tasks\n     * Hash Tables pattern implementation\n     * Time: O(n)\n     * Space: O(n)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Use HashMap for O(1) lookups\n        Map<Integer, Integer> seen = new HashMap<>();\n        \n        for (int i = 0; i < n; i++) {\n            int complement = target - input[i];\n            if (seen.containsKey(complement)) {\n                return new int[]{seen.get(complement), i};\n            }\n            seen.put(input[i], i);\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Minimum Rounds to Complete All Tasks\n     * Hash Tables pattern implementation\n     * Time: O(n)\n     * Space: O(n)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Use unordered_map for O(1) lookups\n        unordered_map<int, int> seen;\n        \n        for (int i = 0; i < n; i++) {\n            int complement = target - input[i];\n            if (seen.count(complement)) {\n                return {seen[complement], i};\n            }\n            seen[input[i]] = i;\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Minimum Rounds to Complete All Tasks\n * Hash Tables pattern implementation\n * Time: O(n)\n * Space: O(n)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Use Map for O(1) lookups\n    const seen = new Map();\n    \n    for (let i = 0; i < n; i++) {\n        const complement = target - input[i];\n        if (seen.has(complement)) {\n            return [seen.get(complement), i];\n        }\n        seen.set(input[i], i);\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "number-of-zero-filled-subarrays": {
        "description": "Number of Zero-Filled Subarrays. Solve this problem using two-pointer technique optimization. Given the input constraints, find the optimal solution that meets all requirements.",
        "examples": [
            {
                "input": "Example input for Number of Zero-Filled Subarrays",
                "output": "Expected output",
                "explanation": "This demonstrates the core logic for Number of Zero-Filled Subarrays using Two Pointers pattern."
            },
            {
                "input": "Edge case input",
                "output": "Edge case output",
                "explanation": "This handles boundary conditions and special cases."
            }
        ],
        "constraints": [
            "Input size constraints: 1 <= n <= 10^5",
            "Value range: -10^9 <= val <= 10^9",
            "Optimal time complexity required for Two Pointers"
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Number of Zero-Filled Subarrays involves checking all possible solutions. For Two Pointers problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Two Pointers problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Number of Zero-Filled Subarrays\n        Two Pointers pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Number of Zero-Filled Subarrays\n     * Two Pointers pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Number of Zero-Filled Subarrays\n     * Two Pointers pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Number of Zero-Filled Subarrays\n * Two Pointers pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Number of Zero-Filled Subarrays leverages two-pointer technique optimization to reduce time complexity. Instead of checking all possibilities, we use Two Pointers-specific techniques like two pointers to avoid nested loops to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Place pointers at strategic positions\n3. While pointers haven't crossed:\n   - Process current elements\n   - Move pointers based on logic\n   - Update result\n4. Return the optimal solution\n\nKey optimizations:\n- Single pass instead of nested loops\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for Two Pointers reduces complexity significantly. Two pointers traverse array once without backtracking. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Only constant extra space needed for pointers and variables. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Number of Zero-Filled Subarrays\n        Two Pointers pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Two pointer approach\n        left, right = 0, n - 1\n        \n        while left < right:\n            # Process current elements\n            if condition(input[left], input[right]):\n                result.append([left, right])\n                left += 1\n            else:\n                right -= 1\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Number of Zero-Filled Subarrays\n     * Two Pointers pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Two pointer approach\n        int left = 0, right = n - 1;\n        \n        while (left < right) {\n            // Process current elements\n            if (condition(input[left], input[right])) {\n                result.add(left);\n                result.add(right);\n                left++;\n            } else {\n                right--;\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Number of Zero-Filled Subarrays\n     * Two Pointers pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Two pointer approach\n        int left = 0, right = n - 1;\n        \n        while (left < right) {\n            // Process current elements\n            if (condition(input[left], input[right])) {\n                result.push_back(left);\n                result.push_back(right);\n                left++;\n            } else {\n                right--;\n            }\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Number of Zero-Filled Subarrays\n * Two Pointers pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Two pointer approach\n    let left = 0, right = n - 1;\n    \n    while (left < right) {\n        // Process current elements\n        if (condition(input[left], input[right])) {\n            result.push(left, right);\n            left++;\n        } else {\n            right--;\n        }\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "optimal-partition-of-string": {
        "description": "Optimal Partition of String. Solve this problem using string manipulation algorithms. Given the input constraints, find the optimal solution that meets all requirements.",
        "examples": [
            {
                "input": "Example input for Optimal Partition of String",
                "output": "Expected output",
                "explanation": "This demonstrates the core logic for Optimal Partition of String using Strings pattern."
            },
            {
                "input": "Edge case input",
                "output": "Edge case output",
                "explanation": "This handles boundary conditions and special cases."
            }
        ],
        "constraints": [
            "Input size constraints: 1 <= n <= 10^5",
            "Value range: -10^9 <= val <= 10^9",
            "Optimal time complexity required for Strings"
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Optimal Partition of String involves checking all possible solutions. For Strings problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Strings problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Optimal Partition of String\n        Strings pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Optimal Partition of String\n     * Strings pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Optimal Partition of String\n     * Strings pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Optimal Partition of String\n * Strings pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Optimal Partition of String leverages string manipulation algorithms to reduce time complexity. Instead of checking all possibilities, we use Strings-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for Strings reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Optimal Partition of String\n        Strings pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Optimal Partition of String\n     * Strings pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Optimal Partition of String\n     * Strings pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Optimal Partition of String\n * Strings pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "removing-stars-from-a-string": {
        "description": "Removing Stars From a String. Solve this problem using stack-based operations. Given the input constraints, find the optimal solution that meets all requirements.",
        "examples": [
            {
                "input": "Example input for Removing Stars From a String",
                "output": "Expected output",
                "explanation": "This demonstrates the core logic for Removing Stars From a String using Stack pattern."
            },
            {
                "input": "Edge case input",
                "output": "Edge case output",
                "explanation": "This handles boundary conditions and special cases."
            }
        ],
        "constraints": [
            "Input size constraints: 1 <= n <= 10^5",
            "Value range: -10^9 <= val <= 10^9",
            "Optimal time complexity required for Stack"
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Removing Stars From a String involves checking all possible solutions. For Stack problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Stack problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Removing Stars From a String\n        Stack pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Removing Stars From a String\n     * Stack pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Removing Stars From a String\n     * Stack pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Removing Stars From a String\n * Stack pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Removing Stars From a String leverages stack-based operations to reduce time complexity. Instead of checking all possibilities, we use Stack-specific techniques like stack/queue for optimal state management to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (stack)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Efficient state management\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for Stack reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Removing Stars From a String\n        Stack pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Stack for state management\n        stack = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Removing Stars From a String\n     * Stack pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Stack for state management\n        Stack<Integer> stack = new Stack<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Removing Stars From a String\n     * Stack pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Stack for state management\n        stack<int> st;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Removing Stars From a String\n * Stack pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Stack for state management\n    const stack = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "asteroid-collision": {
        "description": "Asteroid Collision. Solve this problem using stack-based operations. Given the input constraints, find the optimal solution that meets all requirements.",
        "examples": [
            {
                "input": "Example input for Asteroid Collision",
                "output": "Expected output",
                "explanation": "This demonstrates the core logic for Asteroid Collision using Stack pattern."
            },
            {
                "input": "Edge case input",
                "output": "Edge case output",
                "explanation": "This handles boundary conditions and special cases."
            }
        ],
        "constraints": [
            "Input size constraints: 1 <= n <= 10^5",
            "Value range: -10^9 <= val <= 10^9",
            "Optimal time complexity required for Stack"
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Asteroid Collision involves checking all possible solutions. For Stack problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Stack problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Asteroid Collision\n        Stack pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Asteroid Collision\n     * Stack pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Asteroid Collision\n     * Stack pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Asteroid Collision\n * Stack pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Asteroid Collision leverages stack-based operations to reduce time complexity. Instead of checking all possibilities, we use Stack-specific techniques like stack/queue for optimal state management to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (stack)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Efficient state management\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for Stack reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Asteroid Collision\n        Stack pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Stack for state management\n        stack = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Asteroid Collision\n     * Stack pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Stack for state management\n        Stack<Integer> stack = new Stack<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Asteroid Collision\n     * Stack pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Stack for state management\n        stack<int> st;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Asteroid Collision\n * Stack pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Stack for state management\n    const stack = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "decode-string": {
        "description": "Decode String. Solve this problem using stack-based operations. Given the input constraints, find the optimal solution that meets all requirements.",
        "examples": [
            {
                "input": "Example input for Decode String",
                "output": "Expected output",
                "explanation": "This demonstrates the core logic for Decode String using Stack pattern."
            },
            {
                "input": "Edge case input",
                "output": "Edge case output",
                "explanation": "This handles boundary conditions and special cases."
            }
        ],
        "constraints": [
            "Input size constraints: 1 <= n <= 10^5",
            "Value range: -10^9 <= val <= 10^9",
            "Optimal time complexity required for Stack"
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Decode String involves checking all possible solutions. For Stack problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Stack problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Decode String\n        Stack pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Decode String\n     * Stack pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Decode String\n     * Stack pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Decode String\n * Stack pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Decode String leverages stack-based operations to reduce time complexity. Instead of checking all possibilities, we use Stack-specific techniques like stack/queue for optimal state management to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (stack)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Efficient state management\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for Stack reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Decode String\n        Stack pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Stack for state management\n        stack = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Decode String\n     * Stack pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Stack for state management\n        Stack<Integer> stack = new Stack<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Decode String\n     * Stack pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Stack for state management\n        stack<int> st;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Decode String\n * Stack pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Stack for state management\n    const stack = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "simplify-path": {
        "description": "Simplify Path. Solve this problem using stack-based operations. Given the input constraints, find the optimal solution that meets all requirements.",
        "examples": [
            {
                "input": "Example input for Simplify Path",
                "output": "Expected output",
                "explanation": "This demonstrates the core logic for Simplify Path using Stack pattern."
            },
            {
                "input": "Edge case input",
                "output": "Edge case output",
                "explanation": "This handles boundary conditions and special cases."
            }
        ],
        "constraints": [
            "Input size constraints: 1 <= n <= 10^5",
            "Value range: -10^9 <= val <= 10^9",
            "Optimal time complexity required for Stack"
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Simplify Path involves checking all possible solutions. For Stack problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Stack problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Simplify Path\n        Stack pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Simplify Path\n     * Stack pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Simplify Path\n     * Stack pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Simplify Path\n * Stack pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Simplify Path leverages stack-based operations to reduce time complexity. Instead of checking all possibilities, we use Stack-specific techniques like stack/queue for optimal state management to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (stack)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Efficient state management\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for Stack reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Simplify Path\n        Stack pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Stack for state management\n        stack = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Simplify Path\n     * Stack pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Stack for state management\n        Stack<Integer> stack = new Stack<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Simplify Path\n     * Stack pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Stack for state management\n        stack<int> st;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Simplify Path\n * Stack pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Stack for state management\n    const stack = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "provinces": {
        "description": "Provinces. Solve this problem using depth-first search graph traversal. Given the input constraints, find the optimal solution that meets all requirements.",
        "examples": [
            {
                "input": "Example input for Provinces",
                "output": "Expected output",
                "explanation": "This demonstrates the core logic for Provinces using DFS pattern."
            },
            {
                "input": "Edge case input",
                "output": "Edge case output",
                "explanation": "This handles boundary conditions and special cases."
            }
        ],
        "constraints": [
            "Input size constraints: 1 <= n <= 10^5",
            "Value range: -10^9 <= val <= 10^9",
            "Optimal time complexity required for DFS"
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Provinces involves checking all possible solutions. For DFS problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. DFS problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Provinces\n        DFS pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Provinces\n     * DFS pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Provinces\n     * DFS pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Provinces\n * DFS pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Provinces leverages depth-first search graph traversal to reduce time complexity. Instead of checking all possibilities, we use DFS-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for DFS reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Provinces\n        DFS pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Provinces\n     * DFS pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Provinces\n     * DFS pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Provinces\n * DFS pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "remove-k-digits": {
        "description": "Remove K Digits. Solve this problem using monotonic stack technique. Given the input constraints, find the optimal solution that meets all requirements.",
        "examples": [
            {
                "input": "Example input for Remove K Digits",
                "output": "Expected output",
                "explanation": "This demonstrates the core logic for Remove K Digits using Monotonic Stack pattern."
            },
            {
                "input": "Edge case input",
                "output": "Edge case output",
                "explanation": "This handles boundary conditions and special cases."
            }
        ],
        "constraints": [
            "Input size constraints: 1 <= n <= 10^5",
            "Value range: -10^9 <= val <= 10^9",
            "Optimal time complexity required for Monotonic Stack"
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Remove K Digits involves checking all possible solutions. For Monotonic Stack problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Monotonic Stack problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Remove K Digits\n        Monotonic Stack pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Remove K Digits\n     * Monotonic Stack pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Remove K Digits\n     * Monotonic Stack pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Remove K Digits\n * Monotonic Stack pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Remove K Digits leverages monotonic stack technique to reduce time complexity. Instead of checking all possibilities, we use Monotonic Stack-specific techniques like stack/queue for optimal state management to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (stack)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Efficient state management\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for Monotonic Stack reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Remove K Digits\n        Monotonic Stack pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Stack for state management\n        stack = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Remove K Digits\n     * Monotonic Stack pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Stack for state management\n        Stack<Integer> stack = new Stack<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Remove K Digits\n     * Monotonic Stack pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Stack for state management\n        stack<int> st;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Remove K Digits\n * Monotonic Stack pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Stack for state management\n    const stack = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "sum-root-to-leaf-numbers": {
        "description": "Sum Root to Leaf Numbers. Solve this problem using tree path traversal. Given the input constraints, find the optimal solution that meets all requirements.",
        "examples": [
            {
                "input": "Example input for Sum Root to Leaf Numbers",
                "output": "Expected output",
                "explanation": "This demonstrates the core logic for Sum Root to Leaf Numbers using Tree Traversal pattern."
            },
            {
                "input": "Edge case input",
                "output": "Edge case output",
                "explanation": "This handles boundary conditions and special cases."
            }
        ],
        "constraints": [
            "Input size constraints: 1 <= n <= 10^5",
            "Value range: -10^9 <= val <= 10^9",
            "Optimal time complexity required for Tree Traversal"
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Sum Root to Leaf Numbers involves checking all possible solutions. For Tree Traversal problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Tree Traversal problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Sum Root to Leaf Numbers\n        Tree Traversal pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Sum Root to Leaf Numbers\n     * Tree Traversal pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Sum Root to Leaf Numbers\n     * Tree Traversal pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Sum Root to Leaf Numbers\n * Tree Traversal pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Sum Root to Leaf Numbers leverages tree path traversal to reduce time complexity. Instead of checking all possibilities, we use Tree Traversal-specific techniques like efficient traversal with pruning to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (tree structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Pruning impossible branches\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(h)",
                    "timeExplanation": "Optimized approach for Tree Traversal reduces complexity significantly. Tree traversal visits each node exactly once. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Recursion stack depth equals tree height. Balanced tree gives O(log n). Can be further optimized by using iterative approach instead of recursion."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Sum Root to Leaf Numbers\n        Tree Traversal pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Sum Root to Leaf Numbers\n     * Tree Traversal pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Sum Root to Leaf Numbers\n     * Tree Traversal pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Sum Root to Leaf Numbers\n * Tree Traversal pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "path-sum-ii": {
        "description": "Path Sum II. Solve this problem using tree path traversal. Given the input constraints, find the optimal solution that meets all requirements.",
        "examples": [
            {
                "input": "Example input for Path Sum II",
                "output": "Expected output",
                "explanation": "This demonstrates the core logic for Path Sum II using Tree Traversal pattern."
            },
            {
                "input": "Edge case input",
                "output": "Edge case output",
                "explanation": "This handles boundary conditions and special cases."
            }
        ],
        "constraints": [
            "Input size constraints: 1 <= n <= 10^5",
            "Value range: -10^9 <= val <= 10^9",
            "Optimal time complexity required for Tree Traversal"
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Path Sum II involves checking all possible solutions. For Tree Traversal problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Tree Traversal problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Path Sum II\n        Tree Traversal pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Path Sum II\n     * Tree Traversal pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Path Sum II\n     * Tree Traversal pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Path Sum II\n * Tree Traversal pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Path Sum II leverages tree path traversal to reduce time complexity. Instead of checking all possibilities, we use Tree Traversal-specific techniques like efficient traversal with pruning to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (tree structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Pruning impossible branches\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(h)",
                    "timeExplanation": "Optimized approach for Tree Traversal reduces complexity significantly. Tree traversal visits each node exactly once. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Recursion stack depth equals tree height. Balanced tree gives O(log n). Can be further optimized by using iterative approach instead of recursion."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Path Sum II\n        Tree Traversal pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Path Sum II\n     * Tree Traversal pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Path Sum II\n     * Tree Traversal pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Path Sum II\n * Tree Traversal pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "path-sum-iii": {
        "description": "Path Sum III. Solve this problem using tree path traversal. Given the input constraints, find the optimal solution that meets all requirements.",
        "examples": [
            {
                "input": "Example input for Path Sum III",
                "output": "Expected output",
                "explanation": "This demonstrates the core logic for Path Sum III using Tree Traversal pattern."
            },
            {
                "input": "Edge case input",
                "output": "Edge case output",
                "explanation": "This handles boundary conditions and special cases."
            }
        ],
        "constraints": [
            "Input size constraints: 1 <= n <= 10^5",
            "Value range: -10^9 <= val <= 10^9",
            "Optimal time complexity required for Tree Traversal"
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Path Sum III involves checking all possible solutions. For Tree Traversal problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Tree Traversal problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Path Sum III\n        Tree Traversal pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Path Sum III\n     * Tree Traversal pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Path Sum III\n     * Tree Traversal pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Path Sum III\n * Tree Traversal pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Path Sum III leverages tree path traversal to reduce time complexity. Instead of checking all possibilities, we use Tree Traversal-specific techniques like efficient traversal with pruning to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (tree structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Pruning impossible branches\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(h)",
                    "timeExplanation": "Optimized approach for Tree Traversal reduces complexity significantly. Tree traversal visits each node exactly once. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Recursion stack depth equals tree height. Balanced tree gives O(log n). Can be further optimized by using iterative approach instead of recursion."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Path Sum III\n        Tree Traversal pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Path Sum III\n     * Tree Traversal pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Path Sum III\n     * Tree Traversal pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Path Sum III\n * Tree Traversal pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "01-matrix": {
        "description": "01 Matrix. Solve this problem using breadth-first search traversal. Given the input constraints, find the optimal solution that meets all requirements.",
        "examples": [
            {
                "input": "Example input for 01 Matrix",
                "output": "Expected output",
                "explanation": "This demonstrates the core logic for 01 Matrix using BFS pattern."
            },
            {
                "input": "Edge case input",
                "output": "Edge case output",
                "explanation": "This handles boundary conditions and special cases."
            }
        ],
        "constraints": [
            "Input size constraints: 1 <= n <= 10^5",
            "Value range: -10^9 <= val <= 10^9",
            "Optimal time complexity required for BFS"
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for 01 Matrix involves checking all possible solutions. For BFS problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. BFS problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for 01 Matrix\n        BFS pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for 01 Matrix\n     * BFS pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for 01 Matrix\n     * BFS pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for 01 Matrix\n * BFS pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for 01 Matrix leverages breadth-first search traversal to reduce time complexity. Instead of checking all possibilities, we use BFS-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for BFS reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for 01 Matrix\n        BFS pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for 01 Matrix\n     * BFS pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for 01 Matrix\n     * BFS pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for 01 Matrix\n * BFS pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "longest-zigzag-path-in-a-binary-tree": {
        "description": "Longest ZigZag Path in a Binary Tree. Solve this problem using tree path traversal. Given the input constraints, find the optimal solution that meets all requirements.",
        "examples": [
            {
                "input": "Example input for Longest ZigZag Path in a Binary Tree",
                "output": "Expected output",
                "explanation": "This demonstrates the core logic for Longest ZigZag Path in a Binary Tree using Tree Traversal pattern."
            },
            {
                "input": "Edge case input",
                "output": "Edge case output",
                "explanation": "This handles boundary conditions and special cases."
            }
        ],
        "constraints": [
            "Input size constraints: 1 <= n <= 10^5",
            "Value range: -10^9 <= val <= 10^9",
            "Optimal time complexity required for Tree Traversal"
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Longest ZigZag Path in a Binary Tree involves checking all possible solutions. For Tree Traversal problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Tree Traversal problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Longest ZigZag Path in a Binary Tree\n        Tree Traversal pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Longest ZigZag Path in a Binary Tree\n     * Tree Traversal pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Longest ZigZag Path in a Binary Tree\n     * Tree Traversal pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Longest ZigZag Path in a Binary Tree\n * Tree Traversal pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Longest ZigZag Path in a Binary Tree leverages tree path traversal to reduce time complexity. Instead of checking all possibilities, we use Tree Traversal-specific techniques like efficient traversal with pruning to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (tree structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Pruning impossible branches\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(h)",
                    "timeExplanation": "Optimized approach for Tree Traversal reduces complexity significantly. Tree traversal visits each node exactly once. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Recursion stack depth equals tree height. Balanced tree gives O(log n). Can be further optimized by using iterative approach instead of recursion."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Longest ZigZag Path in a Binary Tree\n        Tree Traversal pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Longest ZigZag Path in a Binary Tree\n     * Tree Traversal pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Longest ZigZag Path in a Binary Tree\n     * Tree Traversal pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Longest ZigZag Path in a Binary Tree\n * Tree Traversal pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "maximum-width-of-binary-tree": {
        "description": "Maximum Width of Binary Tree. Solve this problem using breadth-first search traversal. Given the input constraints, find the optimal solution that meets all requirements.",
        "examples": [
            {
                "input": "Example input for Maximum Width of Binary Tree",
                "output": "Expected output",
                "explanation": "This demonstrates the core logic for Maximum Width of Binary Tree using BFS pattern."
            },
            {
                "input": "Edge case input",
                "output": "Edge case output",
                "explanation": "This handles boundary conditions and special cases."
            }
        ],
        "constraints": [
            "Input size constraints: 1 <= n <= 10^5",
            "Value range: -10^9 <= val <= 10^9",
            "Optimal time complexity required for BFS"
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Maximum Width of Binary Tree involves checking all possible solutions. For BFS problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. BFS problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Maximum Width of Binary Tree\n        BFS pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Maximum Width of Binary Tree\n     * BFS pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Maximum Width of Binary Tree\n     * BFS pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Maximum Width of Binary Tree\n * BFS pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Maximum Width of Binary Tree leverages breadth-first search traversal to reduce time complexity. Instead of checking all possibilities, we use BFS-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for BFS reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Maximum Width of Binary Tree\n        BFS pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Maximum Width of Binary Tree\n     * BFS pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Maximum Width of Binary Tree\n     * BFS pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Maximum Width of Binary Tree\n * BFS pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "all-nodes-distance-k-in-binary-tree": {
        "description": "All Nodes Distance K in Binary Tree. Solve this problem using breadth-first search traversal. Given the input constraints, find the optimal solution that meets all requirements.",
        "examples": [
            {
                "input": "Example input for All Nodes Distance K in Binary Tree",
                "output": "Expected output",
                "explanation": "This demonstrates the core logic for All Nodes Distance K in Binary Tree using BFS pattern."
            },
            {
                "input": "Edge case input",
                "output": "Edge case output",
                "explanation": "This handles boundary conditions and special cases."
            }
        ],
        "constraints": [
            "Input size constraints: 1 <= n <= 10^5",
            "Value range: -10^9 <= val <= 10^9",
            "Optimal time complexity required for BFS"
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for All Nodes Distance K in Binary Tree involves checking all possible solutions. For BFS problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. BFS problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for All Nodes Distance K in Binary Tree\n        BFS pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for All Nodes Distance K in Binary Tree\n     * BFS pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for All Nodes Distance K in Binary Tree\n     * BFS pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for All Nodes Distance K in Binary Tree\n * BFS pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for All Nodes Distance K in Binary Tree leverages breadth-first search traversal to reduce time complexity. Instead of checking all possibilities, we use BFS-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for BFS reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for All Nodes Distance K in Binary Tree\n        BFS pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for All Nodes Distance K in Binary Tree\n     * BFS pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for All Nodes Distance K in Binary Tree\n     * BFS pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for All Nodes Distance K in Binary Tree\n * BFS pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "delete-node-in-a-bst": {
        "description": "Delete Node in a BST. Solve this problem using binary search tree operations. Given the input constraints, find the optimal solution that meets all requirements.",
        "examples": [
            {
                "input": "Example input for Delete Node in a BST",
                "output": "Expected output",
                "explanation": "This demonstrates the core logic for Delete Node in a BST using BST pattern."
            },
            {
                "input": "Edge case input",
                "output": "Edge case output",
                "explanation": "This handles boundary conditions and special cases."
            }
        ],
        "constraints": [
            "Input size constraints: 1 <= n <= 10^5",
            "Value range: -10^9 <= val <= 10^9",
            "Optimal time complexity required for BST"
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Delete Node in a BST involves checking all possible solutions. For BST problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. BST problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Delete Node in a BST\n        BST pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Delete Node in a BST\n     * BST pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Delete Node in a BST\n     * BST pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Delete Node in a BST\n * BST pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Delete Node in a BST leverages binary search tree operations to reduce time complexity. Instead of checking all possibilities, we use BST-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for BST reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Delete Node in a BST\n        BST pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Delete Node in a BST\n     * BST pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Delete Node in a BST\n     * BST pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Delete Node in a BST\n * BST pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "trim-a-binary-search-tree": {
        "description": "Trim a Binary Search Tree. Solve this problem using binary search tree operations. Given the input constraints, find the optimal solution that meets all requirements.",
        "examples": [
            {
                "input": "Example input for Trim a Binary Search Tree",
                "output": "Expected output",
                "explanation": "This demonstrates the core logic for Trim a Binary Search Tree using BST pattern."
            },
            {
                "input": "Edge case input",
                "output": "Edge case output",
                "explanation": "This handles boundary conditions and special cases."
            }
        ],
        "constraints": [
            "Input size constraints: 1 <= n <= 10^5",
            "Value range: -10^9 <= val <= 10^9",
            "Optimal time complexity required for BST"
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Trim a Binary Search Tree involves checking all possible solutions. For BST problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. BST problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Trim a Binary Search Tree\n        BST pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Trim a Binary Search Tree\n     * BST pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Trim a Binary Search Tree\n     * BST pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Trim a Binary Search Tree\n * BST pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Trim a Binary Search Tree leverages binary search tree operations to reduce time complexity. Instead of checking all possibilities, we use BST-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for BST reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Trim a Binary Search Tree\n        BST pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Trim a Binary Search Tree\n     * BST pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Trim a Binary Search Tree\n     * BST pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Trim a Binary Search Tree\n * BST pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "flatten-binary-tree-to-linked-list": {
        "description": "Flatten Binary Tree to Linked List. Solve this problem using complex tree transformations. Given the input constraints, find the optimal solution that meets all requirements.",
        "examples": [
            {
                "input": "Example input for Flatten Binary Tree to Linked List",
                "output": "Expected output",
                "explanation": "This demonstrates the core logic for Flatten Binary Tree to Linked List using Tree Hard pattern."
            },
            {
                "input": "Edge case input",
                "output": "Edge case output",
                "explanation": "This handles boundary conditions and special cases."
            }
        ],
        "constraints": [
            "Input size constraints: 1 <= n <= 10^5",
            "Value range: -10^9 <= val <= 10^9",
            "Optimal time complexity required for Tree Hard"
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Flatten Binary Tree to Linked List involves checking all possible solutions. For Tree Hard problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Tree Hard problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Flatten Binary Tree to Linked List\n        Tree Hard pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Flatten Binary Tree to Linked List\n     * Tree Hard pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Flatten Binary Tree to Linked List\n     * Tree Hard pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Flatten Binary Tree to Linked List\n * Tree Hard pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Flatten Binary Tree to Linked List leverages complex tree transformations to reduce time complexity. Instead of checking all possibilities, we use Tree Hard-specific techniques like efficient traversal with pruning to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (tree structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Pruning impossible branches\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(h)",
                    "timeExplanation": "Optimized approach for Tree Hard reduces complexity significantly. Tree traversal visits each node exactly once. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Recursion stack depth equals tree height. Balanced tree gives O(log n). Can be further optimized by using iterative approach instead of recursion."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Flatten Binary Tree to Linked List\n        Tree Hard pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Flatten Binary Tree to Linked List\n     * Tree Hard pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Flatten Binary Tree to Linked List\n     * Tree Hard pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Flatten Binary Tree to Linked List\n * Tree Hard pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "populating-next-right-pointers-in-each-node": {
        "description": "Populating Next Right Pointers in Each Node. Solve this problem using complex tree transformations. Given the input constraints, find the optimal solution that meets all requirements.",
        "examples": [
            {
                "input": "Example input for Populating Next Right Pointers in Each Node",
                "output": "Expected output",
                "explanation": "This demonstrates the core logic for Populating Next Right Pointers in Each Node using Tree Hard pattern."
            },
            {
                "input": "Edge case input",
                "output": "Edge case output",
                "explanation": "This handles boundary conditions and special cases."
            }
        ],
        "constraints": [
            "Input size constraints: 1 <= n <= 10^5",
            "Value range: -10^9 <= val <= 10^9",
            "Optimal time complexity required for Tree Hard"
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Populating Next Right Pointers in Each Node involves checking all possible solutions. For Tree Hard problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Tree Hard problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Populating Next Right Pointers in Each Node\n        Tree Hard pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Populating Next Right Pointers in Each Node\n     * Tree Hard pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Populating Next Right Pointers in Each Node\n     * Tree Hard pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Populating Next Right Pointers in Each Node\n * Tree Hard pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Populating Next Right Pointers in Each Node leverages complex tree transformations to reduce time complexity. Instead of checking all possibilities, we use Tree Hard-specific techniques like efficient traversal with pruning to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (tree structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Pruning impossible branches\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(h)",
                    "timeExplanation": "Optimized approach for Tree Hard reduces complexity significantly. Tree traversal visits each node exactly once. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Recursion stack depth equals tree height. Balanced tree gives O(log n). Can be further optimized by using iterative approach instead of recursion."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Populating Next Right Pointers in Each Node\n        Tree Hard pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Populating Next Right Pointers in Each Node\n     * Tree Hard pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Populating Next Right Pointers in Each Node\n     * Tree Hard pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Populating Next Right Pointers in Each Node\n * Tree Hard pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "keys-and-rooms": {
        "description": "Keys and Rooms. Solve this problem using depth-first search graph traversal. Given the input constraints, find the optimal solution that meets all requirements.",
        "examples": [
            {
                "input": "Example input for Keys and Rooms",
                "output": "Expected output",
                "explanation": "This demonstrates the core logic for Keys and Rooms using DFS pattern."
            },
            {
                "input": "Edge case input",
                "output": "Edge case output",
                "explanation": "This handles boundary conditions and special cases."
            }
        ],
        "constraints": [
            "Input size constraints: 1 <= n <= 10^5",
            "Value range: -10^9 <= val <= 10^9",
            "Optimal time complexity required for DFS"
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Keys and Rooms involves checking all possible solutions. For DFS problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. DFS problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Keys and Rooms\n        DFS pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Keys and Rooms\n     * DFS pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Keys and Rooms\n     * DFS pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Keys and Rooms\n * DFS pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Keys and Rooms leverages depth-first search graph traversal to reduce time complexity. Instead of checking all possibilities, we use DFS-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for DFS reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Keys and Rooms\n        DFS pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Keys and Rooms\n     * DFS pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Keys and Rooms\n     * DFS pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Keys and Rooms\n * DFS pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "reorder-routes-to-make-all-paths-lead-to-the-city-zero": {
        "description": "Reorder Routes to Make All Paths Lead to the City Zero. Solve this problem using depth-first search graph traversal. Given the input constraints, find the optimal solution that meets all requirements.",
        "examples": [
            {
                "input": "Example input for Reorder Routes to Make All Paths Lead to the City Zero",
                "output": "Expected output",
                "explanation": "This demonstrates the core logic for Reorder Routes to Make All Paths Lead to the City Zero using DFS pattern."
            },
            {
                "input": "Edge case input",
                "output": "Edge case output",
                "explanation": "This handles boundary conditions and special cases."
            }
        ],
        "constraints": [
            "Input size constraints: 1 <= n <= 10^5",
            "Value range: -10^9 <= val <= 10^9",
            "Optimal time complexity required for DFS"
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Reorder Routes to Make All Paths Lead to the City Zero involves checking all possible solutions. For DFS problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. DFS problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Reorder Routes to Make All Paths Lead to the City Zero\n        DFS pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Reorder Routes to Make All Paths Lead to the City Zero\n     * DFS pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Reorder Routes to Make All Paths Lead to the City Zero\n     * DFS pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Reorder Routes to Make All Paths Lead to the City Zero\n * DFS pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Reorder Routes to Make All Paths Lead to the City Zero leverages depth-first search graph traversal to reduce time complexity. Instead of checking all possibilities, we use DFS-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for DFS reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Reorder Routes to Make All Paths Lead to the City Zero\n        DFS pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Reorder Routes to Make All Paths Lead to the City Zero\n     * DFS pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Reorder Routes to Make All Paths Lead to the City Zero\n     * DFS pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Reorder Routes to Make All Paths Lead to the City Zero\n * DFS pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "evaluate-division": {
        "description": "Evaluate Division. Solve this problem using depth-first search graph traversal. Given the input constraints, find the optimal solution that meets all requirements.",
        "examples": [
            {
                "input": "Example input for Evaluate Division",
                "output": "Expected output",
                "explanation": "This demonstrates the core logic for Evaluate Division using DFS pattern."
            },
            {
                "input": "Edge case input",
                "output": "Edge case output",
                "explanation": "This handles boundary conditions and special cases."
            }
        ],
        "constraints": [
            "Input size constraints: 1 <= n <= 10^5",
            "Value range: -10^9 <= val <= 10^9",
            "Optimal time complexity required for DFS"
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Evaluate Division involves checking all possible solutions. For DFS problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. DFS problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Evaluate Division\n        DFS pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Evaluate Division\n     * DFS pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Evaluate Division\n     * DFS pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Evaluate Division\n * DFS pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Evaluate Division leverages depth-first search graph traversal to reduce time complexity. Instead of checking all possibilities, we use DFS-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for DFS reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Evaluate Division\n        DFS pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Evaluate Division\n     * DFS pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Evaluate Division\n     * DFS pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Evaluate Division\n * DFS pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "nearest-exit-from-entrance-in-maze": {
        "description": "Nearest Exit from Entrance in Maze. Solve this problem using breadth-first search traversal. Given the input constraints, find the optimal solution that meets all requirements.",
        "examples": [
            {
                "input": "Example input for Nearest Exit from Entrance in Maze",
                "output": "Expected output",
                "explanation": "This demonstrates the core logic for Nearest Exit from Entrance in Maze using BFS pattern."
            },
            {
                "input": "Edge case input",
                "output": "Edge case output",
                "explanation": "This handles boundary conditions and special cases."
            }
        ],
        "constraints": [
            "Input size constraints: 1 <= n <= 10^5",
            "Value range: -10^9 <= val <= 10^9",
            "Optimal time complexity required for BFS"
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Nearest Exit from Entrance in Maze involves checking all possible solutions. For BFS problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. BFS problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Nearest Exit from Entrance in Maze\n        BFS pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Nearest Exit from Entrance in Maze\n     * BFS pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Nearest Exit from Entrance in Maze\n     * BFS pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Nearest Exit from Entrance in Maze\n * BFS pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Nearest Exit from Entrance in Maze leverages breadth-first search traversal to reduce time complexity. Instead of checking all possibilities, we use BFS-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for BFS reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Nearest Exit from Entrance in Maze\n        BFS pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Nearest Exit from Entrance in Maze\n     * BFS pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Nearest Exit from Entrance in Maze\n     * BFS pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Nearest Exit from Entrance in Maze\n * BFS pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "shortest-path-in-binary-matrix": {
        "description": "Shortest Path in Binary Matrix. Solve this problem using breadth-first search traversal. Given the input constraints, find the optimal solution that meets all requirements.",
        "examples": [
            {
                "input": "Example input for Shortest Path in Binary Matrix",
                "output": "Expected output",
                "explanation": "This demonstrates the core logic for Shortest Path in Binary Matrix using BFS pattern."
            },
            {
                "input": "Edge case input",
                "output": "Edge case output",
                "explanation": "This handles boundary conditions and special cases."
            }
        ],
        "constraints": [
            "Input size constraints: 1 <= n <= 10^5",
            "Value range: -10^9 <= val <= 10^9",
            "Optimal time complexity required for BFS"
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Shortest Path in Binary Matrix involves checking all possible solutions. For BFS problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. BFS problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Shortest Path in Binary Matrix\n        BFS pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Shortest Path in Binary Matrix\n     * BFS pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Shortest Path in Binary Matrix\n     * BFS pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Shortest Path in Binary Matrix\n * BFS pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Shortest Path in Binary Matrix leverages breadth-first search traversal to reduce time complexity. Instead of checking all possibilities, we use BFS-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for BFS reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Shortest Path in Binary Matrix\n        BFS pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Shortest Path in Binary Matrix\n     * BFS pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Shortest Path in Binary Matrix\n     * BFS pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Shortest Path in Binary Matrix\n * BFS pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "minimum-genetic-mutation": {
        "description": "Minimum Genetic Mutation. Solve this problem using breadth-first search traversal. Given the input constraints, find the optimal solution that meets all requirements.",
        "examples": [
            {
                "input": "Example input for Minimum Genetic Mutation",
                "output": "Expected output",
                "explanation": "This demonstrates the core logic for Minimum Genetic Mutation using BFS pattern."
            },
            {
                "input": "Edge case input",
                "output": "Edge case output",
                "explanation": "This handles boundary conditions and special cases."
            }
        ],
        "constraints": [
            "Input size constraints: 1 <= n <= 10^5",
            "Value range: -10^9 <= val <= 10^9",
            "Optimal time complexity required for BFS"
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Minimum Genetic Mutation involves checking all possible solutions. For BFS problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. BFS problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Minimum Genetic Mutation\n        BFS pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Minimum Genetic Mutation\n     * BFS pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Minimum Genetic Mutation\n     * BFS pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Minimum Genetic Mutation\n * BFS pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Minimum Genetic Mutation leverages breadth-first search traversal to reduce time complexity. Instead of checking all possibilities, we use BFS-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for BFS reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Minimum Genetic Mutation\n        BFS pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Minimum Genetic Mutation\n     * BFS pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Minimum Genetic Mutation\n     * BFS pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Minimum Genetic Mutation\n * BFS pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "snakes-and-ladders": {
        "description": "Snakes and Ladders. Solve this problem using breadth-first search traversal. Given the input constraints, find the optimal solution that meets all requirements.",
        "examples": [
            {
                "input": "Example input for Snakes and Ladders",
                "output": "Expected output",
                "explanation": "This demonstrates the core logic for Snakes and Ladders using BFS pattern."
            },
            {
                "input": "Edge case input",
                "output": "Edge case output",
                "explanation": "This handles boundary conditions and special cases."
            }
        ],
        "constraints": [
            "Input size constraints: 1 <= n <= 10^5",
            "Value range: -10^9 <= val <= 10^9",
            "Optimal time complexity required for BFS"
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Snakes and Ladders involves checking all possible solutions. For BFS problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. BFS problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Snakes and Ladders\n        BFS pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Snakes and Ladders\n     * BFS pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Snakes and Ladders\n     * BFS pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Snakes and Ladders\n * BFS pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Snakes and Ladders leverages breadth-first search traversal to reduce time complexity. Instead of checking all possibilities, we use BFS-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for BFS reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Snakes and Ladders\n        BFS pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Snakes and Ladders\n     * BFS pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Snakes and Ladders\n     * BFS pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Snakes and Ladders\n * BFS pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "is-graph-bipartite": {
        "description": "Is Graph Bipartite?. Solve this problem using breadth-first search traversal. Given the input constraints, find the optimal solution that meets all requirements.",
        "examples": [
            {
                "input": "Example input for Is Graph Bipartite?",
                "output": "Expected output",
                "explanation": "This demonstrates the core logic for Is Graph Bipartite? using BFS pattern."
            },
            {
                "input": "Edge case input",
                "output": "Edge case output",
                "explanation": "This handles boundary conditions and special cases."
            }
        ],
        "constraints": [
            "Input size constraints: 1 <= n <= 10^5",
            "Value range: -10^9 <= val <= 10^9",
            "Optimal time complexity required for BFS"
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Is Graph Bipartite? involves checking all possible solutions. For BFS problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. BFS problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Is Graph Bipartite?\n        BFS pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Is Graph Bipartite?\n     * BFS pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Is Graph Bipartite?\n     * BFS pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Is Graph Bipartite?\n * BFS pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Is Graph Bipartite? leverages breadth-first search traversal to reduce time complexity. Instead of checking all possibilities, we use BFS-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for BFS reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Is Graph Bipartite?\n        BFS pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Is Graph Bipartite?\n     * BFS pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Is Graph Bipartite?\n     * BFS pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Is Graph Bipartite?\n * BFS pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "triangle": {
        "description": "Triangle. Solve this problem using two-dimensional dynamic programming. Given the input constraints, find the optimal solution that meets all requirements.",
        "examples": [
            {
                "input": "Example input for Triangle",
                "output": "Expected output",
                "explanation": "This demonstrates the core logic for Triangle using 2D DP pattern."
            },
            {
                "input": "Edge case input",
                "output": "Edge case output",
                "explanation": "This handles boundary conditions and special cases."
            }
        ],
        "constraints": [
            "Input size constraints: 1 <= n <= 10^5",
            "Value range: -10^9 <= val <= 10^9",
            "Optimal time complexity required for 2D DP"
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Triangle involves checking all possible solutions. For 2D DP problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(2^n)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. 2D DP problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Triangle\n        2D DP pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Triangle\n     * 2D DP pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Triangle\n     * 2D DP pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Triangle\n * 2D DP pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Triangle leverages two-dimensional dynamic programming to reduce time complexity. Instead of checking all possibilities, we use 2D DP-specific techniques like memoization to cache subproblem results to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (DP table)\n2. Build up solutions from base cases\n3. For each subproblem:\n   - Check if already computed\n   - If not, compute using previously solved subproblems\n   - Store result for reuse\n4. Return the optimal solution\n\nKey optimizations:\n- Memoization prevents recomputation\n- Bottom-up or top-down approach\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Optimized approach for 2D DP reduces complexity significantly. DP table is filled once, each cell computed in O(1). This optimization transforms the solution from exponential to polynomial.",
                    "spaceExplanation": "DP table stores subproblem results. Space equals number of unique states. Can be further optimized by using rolling arrays if only previous row/state needed."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Triangle\n        2D DP pattern implementation\n        Time: O(n)\n        Space: O(n)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize DP table\n        dp = [0] * (n + 1)\n        dp[0] = 1  # Base case\n        \n        for i in range(1, n + 1):\n            # Compute current state from previous states\n            dp[i] = dp[i-1] + (dp[i-2] if i > 1 else 0)\n        \n        return dp[n]",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Triangle\n     * 2D DP pattern implementation\n     * Time: O(n)\n     * Space: O(n)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize DP array\n        int[] dp = new int[n + 1];\n        dp[0] = 1; // Base case\n        \n        for (int i = 1; i <= n; i++) {\n            // Compute current state from previous states\n            dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n        }\n        \n        return new int[]{dp[n]};\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Triangle\n     * 2D DP pattern implementation\n     * Time: O(n)\n     * Space: O(n)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize DP vector\n        vector<int> dp(n + 1, 0);\n        dp[0] = 1; // Base case\n        \n        for (int i = 1; i <= n; i++) {\n            // Compute current state from previous states\n            dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n        }\n        \n        return {dp[n]};\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Triangle\n * 2D DP pattern implementation\n * Time: O(n)\n * Space: O(n)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize DP array\n    const dp = new Array(n + 1).fill(0);\n    dp[0] = 1; // Base case\n    \n    for (let i = 1; i <= n; i++) {\n        // Compute current state from previous states\n        dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n    }\n    \n    return dp[n];\n};"
                }
            }
        }
    },
    "minimum-path-sum": {
        "description": "Minimum Path Sum. Solve this problem using two-dimensional dynamic programming. Given the input constraints, find the optimal solution that meets all requirements.",
        "examples": [
            {
                "input": "Example input for Minimum Path Sum",
                "output": "Expected output",
                "explanation": "This demonstrates the core logic for Minimum Path Sum using 2D DP pattern."
            },
            {
                "input": "Edge case input",
                "output": "Edge case output",
                "explanation": "This handles boundary conditions and special cases."
            }
        ],
        "constraints": [
            "Input size constraints: 1 <= n <= 10^5",
            "Value range: -10^9 <= val <= 10^9",
            "Optimal time complexity required for 2D DP"
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Minimum Path Sum involves checking all possible solutions. For 2D DP problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(2^n)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. 2D DP problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Minimum Path Sum\n        2D DP pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Minimum Path Sum\n     * 2D DP pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Minimum Path Sum\n     * 2D DP pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Minimum Path Sum\n * 2D DP pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Minimum Path Sum leverages two-dimensional dynamic programming to reduce time complexity. Instead of checking all possibilities, we use 2D DP-specific techniques like memoization to cache subproblem results to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (DP table)\n2. Build up solutions from base cases\n3. For each subproblem:\n   - Check if already computed\n   - If not, compute using previously solved subproblems\n   - Store result for reuse\n4. Return the optimal solution\n\nKey optimizations:\n- Memoization prevents recomputation\n- Bottom-up or top-down approach\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Optimized approach for 2D DP reduces complexity significantly. DP table is filled once, each cell computed in O(1). This optimization transforms the solution from exponential to polynomial.",
                    "spaceExplanation": "DP table stores subproblem results. Space equals number of unique states. Can be further optimized by using rolling arrays if only previous row/state needed."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Minimum Path Sum\n        2D DP pattern implementation\n        Time: O(n)\n        Space: O(n)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize DP table\n        dp = [0] * (n + 1)\n        dp[0] = 1  # Base case\n        \n        for i in range(1, n + 1):\n            # Compute current state from previous states\n            dp[i] = dp[i-1] + (dp[i-2] if i > 1 else 0)\n        \n        return dp[n]",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Minimum Path Sum\n     * 2D DP pattern implementation\n     * Time: O(n)\n     * Space: O(n)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize DP array\n        int[] dp = new int[n + 1];\n        dp[0] = 1; // Base case\n        \n        for (int i = 1; i <= n; i++) {\n            // Compute current state from previous states\n            dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n        }\n        \n        return new int[]{dp[n]};\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Minimum Path Sum\n     * 2D DP pattern implementation\n     * Time: O(n)\n     * Space: O(n)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize DP vector\n        vector<int> dp(n + 1, 0);\n        dp[0] = 1; // Base case\n        \n        for (int i = 1; i <= n; i++) {\n            // Compute current state from previous states\n            dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n        }\n        \n        return {dp[n]};\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Minimum Path Sum\n * 2D DP pattern implementation\n * Time: O(n)\n * Space: O(n)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize DP array\n    const dp = new Array(n + 1).fill(0);\n    dp[0] = 1; // Base case\n    \n    for (let i = 1; i <= n; i++) {\n        // Compute current state from previous states\n        dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n    }\n    \n    return dp[n];\n};"
                }
            }
        }
    },
    "minimum-falling-path-sum": {
        "description": "Minimum Falling Path Sum. Solve this problem using two-dimensional dynamic programming. Given the input constraints, find the optimal solution that meets all requirements.",
        "examples": [
            {
                "input": "Example input for Minimum Falling Path Sum",
                "output": "Expected output",
                "explanation": "This demonstrates the core logic for Minimum Falling Path Sum using 2D DP pattern."
            },
            {
                "input": "Edge case input",
                "output": "Edge case output",
                "explanation": "This handles boundary conditions and special cases."
            }
        ],
        "constraints": [
            "Input size constraints: 1 <= n <= 10^5",
            "Value range: -10^9 <= val <= 10^9",
            "Optimal time complexity required for 2D DP"
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Minimum Falling Path Sum involves checking all possible solutions. For 2D DP problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(2^n)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. 2D DP problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Minimum Falling Path Sum\n        2D DP pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Minimum Falling Path Sum\n     * 2D DP pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Minimum Falling Path Sum\n     * 2D DP pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Minimum Falling Path Sum\n * 2D DP pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Minimum Falling Path Sum leverages two-dimensional dynamic programming to reduce time complexity. Instead of checking all possibilities, we use 2D DP-specific techniques like memoization to cache subproblem results to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (DP table)\n2. Build up solutions from base cases\n3. For each subproblem:\n   - Check if already computed\n   - If not, compute using previously solved subproblems\n   - Store result for reuse\n4. Return the optimal solution\n\nKey optimizations:\n- Memoization prevents recomputation\n- Bottom-up or top-down approach\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Optimized approach for 2D DP reduces complexity significantly. DP table is filled once, each cell computed in O(1). This optimization transforms the solution from exponential to polynomial.",
                    "spaceExplanation": "DP table stores subproblem results. Space equals number of unique states. Can be further optimized by using rolling arrays if only previous row/state needed."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Minimum Falling Path Sum\n        2D DP pattern implementation\n        Time: O(n)\n        Space: O(n)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize DP table\n        dp = [0] * (n + 1)\n        dp[0] = 1  # Base case\n        \n        for i in range(1, n + 1):\n            # Compute current state from previous states\n            dp[i] = dp[i-1] + (dp[i-2] if i > 1 else 0)\n        \n        return dp[n]",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Minimum Falling Path Sum\n     * 2D DP pattern implementation\n     * Time: O(n)\n     * Space: O(n)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize DP array\n        int[] dp = new int[n + 1];\n        dp[0] = 1; // Base case\n        \n        for (int i = 1; i <= n; i++) {\n            // Compute current state from previous states\n            dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n        }\n        \n        return new int[]{dp[n]};\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Minimum Falling Path Sum\n     * 2D DP pattern implementation\n     * Time: O(n)\n     * Space: O(n)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize DP vector\n        vector<int> dp(n + 1, 0);\n        dp[0] = 1; // Base case\n        \n        for (int i = 1; i <= n; i++) {\n            // Compute current state from previous states\n            dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n        }\n        \n        return {dp[n]};\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Minimum Falling Path Sum\n * 2D DP pattern implementation\n * Time: O(n)\n * Space: O(n)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize DP array\n    const dp = new Array(n + 1).fill(0);\n    dp[0] = 1; // Base case\n    \n    for (let i = 1; i <= n; i++) {\n        // Compute current state from previous states\n        dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n    }\n    \n    return dp[n];\n};"
                }
            }
        }
    },
    "maximal-square": {
        "description": "Maximal Square. Solve this problem using two-dimensional dynamic programming. Given the input constraints, find the optimal solution that meets all requirements.",
        "examples": [
            {
                "input": "Example input for Maximal Square",
                "output": "Expected output",
                "explanation": "This demonstrates the core logic for Maximal Square using 2D DP pattern."
            },
            {
                "input": "Edge case input",
                "output": "Edge case output",
                "explanation": "This handles boundary conditions and special cases."
            }
        ],
        "constraints": [
            "Input size constraints: 1 <= n <= 10^5",
            "Value range: -10^9 <= val <= 10^9",
            "Optimal time complexity required for 2D DP"
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Maximal Square involves checking all possible solutions. For 2D DP problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(2^n)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. 2D DP problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Maximal Square\n        2D DP pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Maximal Square\n     * 2D DP pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Maximal Square\n     * 2D DP pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Maximal Square\n * 2D DP pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Maximal Square leverages two-dimensional dynamic programming to reduce time complexity. Instead of checking all possibilities, we use 2D DP-specific techniques like memoization to cache subproblem results to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (DP table)\n2. Build up solutions from base cases\n3. For each subproblem:\n   - Check if already computed\n   - If not, compute using previously solved subproblems\n   - Store result for reuse\n4. Return the optimal solution\n\nKey optimizations:\n- Memoization prevents recomputation\n- Bottom-up or top-down approach\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Optimized approach for 2D DP reduces complexity significantly. DP table is filled once, each cell computed in O(1). This optimization transforms the solution from exponential to polynomial.",
                    "spaceExplanation": "DP table stores subproblem results. Space equals number of unique states. Can be further optimized by using rolling arrays if only previous row/state needed."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Maximal Square\n        2D DP pattern implementation\n        Time: O(n)\n        Space: O(n)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize DP table\n        dp = [0] * (n + 1)\n        dp[0] = 1  # Base case\n        \n        for i in range(1, n + 1):\n            # Compute current state from previous states\n            dp[i] = dp[i-1] + (dp[i-2] if i > 1 else 0)\n        \n        return dp[n]",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Maximal Square\n     * 2D DP pattern implementation\n     * Time: O(n)\n     * Space: O(n)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize DP array\n        int[] dp = new int[n + 1];\n        dp[0] = 1; // Base case\n        \n        for (int i = 1; i <= n; i++) {\n            // Compute current state from previous states\n            dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n        }\n        \n        return new int[]{dp[n]};\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Maximal Square\n     * 2D DP pattern implementation\n     * Time: O(n)\n     * Space: O(n)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize DP vector\n        vector<int> dp(n + 1, 0);\n        dp[0] = 1; // Base case\n        \n        for (int i = 1; i <= n; i++) {\n            // Compute current state from previous states\n            dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n        }\n        \n        return {dp[n]};\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Maximal Square\n * 2D DP pattern implementation\n * Time: O(n)\n * Space: O(n)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize DP array\n    const dp = new Array(n + 1).fill(0);\n    dp[0] = 1; // Base case\n    \n    for (let i = 1; i <= n; i++) {\n        // Compute current state from previous states\n        dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n    }\n    \n    return dp[n];\n};"
                }
            }
        }
    },
    "ones-and-zeroes": {
        "description": "Ones and Zeroes. Solve this problem using knapsack optimization. Given the input constraints, find the optimal solution that meets all requirements.",
        "examples": [
            {
                "input": "Example input for Ones and Zeroes",
                "output": "Expected output",
                "explanation": "This demonstrates the core logic for Ones and Zeroes using Knapsack DP pattern."
            },
            {
                "input": "Edge case input",
                "output": "Edge case output",
                "explanation": "This handles boundary conditions and special cases."
            }
        ],
        "constraints": [
            "Input size constraints: 1 <= n <= 10^5",
            "Value range: -10^9 <= val <= 10^9",
            "Optimal time complexity required for Knapsack DP"
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Ones and Zeroes involves checking all possible solutions. For Knapsack DP problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(2^n)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Knapsack DP problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Ones and Zeroes\n        Knapsack DP pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Ones and Zeroes\n     * Knapsack DP pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Ones and Zeroes\n     * Knapsack DP pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Ones and Zeroes\n * Knapsack DP pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Ones and Zeroes leverages knapsack optimization to reduce time complexity. Instead of checking all possibilities, we use Knapsack DP-specific techniques like memoization to cache subproblem results to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (DP table)\n2. Build up solutions from base cases\n3. For each subproblem:\n   - Check if already computed\n   - If not, compute using previously solved subproblems\n   - Store result for reuse\n4. Return the optimal solution\n\nKey optimizations:\n- Memoization prevents recomputation\n- Bottom-up or top-down approach\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(n)",
                    "timeExplanation": "Optimized approach for Knapsack DP reduces complexity significantly. DP table is filled once, each cell computed in O(1). This optimization transforms the solution from exponential to polynomial.",
                    "spaceExplanation": "DP table stores subproblem results. Space equals number of unique states. Can be further optimized by using rolling arrays if only previous row/state needed."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Ones and Zeroes\n        Knapsack DP pattern implementation\n        Time: O(n)\n        Space: O(n)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize DP table\n        dp = [0] * (n + 1)\n        dp[0] = 1  # Base case\n        \n        for i in range(1, n + 1):\n            # Compute current state from previous states\n            dp[i] = dp[i-1] + (dp[i-2] if i > 1 else 0)\n        \n        return dp[n]",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Ones and Zeroes\n     * Knapsack DP pattern implementation\n     * Time: O(n)\n     * Space: O(n)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize DP array\n        int[] dp = new int[n + 1];\n        dp[0] = 1; // Base case\n        \n        for (int i = 1; i <= n; i++) {\n            // Compute current state from previous states\n            dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n        }\n        \n        return new int[]{dp[n]};\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Ones and Zeroes\n     * Knapsack DP pattern implementation\n     * Time: O(n)\n     * Space: O(n)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize DP vector\n        vector<int> dp(n + 1, 0);\n        dp[0] = 1; // Base case\n        \n        for (int i = 1; i <= n; i++) {\n            // Compute current state from previous states\n            dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n        }\n        \n        return {dp[n]};\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Ones and Zeroes\n * Knapsack DP pattern implementation\n * Time: O(n)\n * Space: O(n)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize DP array\n    const dp = new Array(n + 1).fill(0);\n    dp[0] = 1; // Base case\n    \n    for (let i = 1; i <= n; i++) {\n        // Compute current state from previous states\n        dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n    }\n    \n    return dp[n];\n};"
                }
            }
        }
    },
    "last-stone-weight-ii": {
        "description": "Last Stone Weight II. Solve this problem using knapsack optimization. Given the input constraints, find the optimal solution that meets all requirements.",
        "examples": [
            {
                "input": "Example input for Last Stone Weight II",
                "output": "Expected output",
                "explanation": "This demonstrates the core logic for Last Stone Weight II using Knapsack DP pattern."
            },
            {
                "input": "Edge case input",
                "output": "Edge case output",
                "explanation": "This handles boundary conditions and special cases."
            }
        ],
        "constraints": [
            "Input size constraints: 1 <= n <= 10^5",
            "Value range: -10^9 <= val <= 10^9",
            "Optimal time complexity required for Knapsack DP"
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Last Stone Weight II involves checking all possible solutions. For Knapsack DP problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(2^n)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Knapsack DP problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Last Stone Weight II\n        Knapsack DP pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Last Stone Weight II\n     * Knapsack DP pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Last Stone Weight II\n     * Knapsack DP pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Last Stone Weight II\n * Knapsack DP pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Last Stone Weight II leverages knapsack optimization to reduce time complexity. Instead of checking all possibilities, we use Knapsack DP-specific techniques like memoization to cache subproblem results to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (DP table)\n2. Build up solutions from base cases\n3. For each subproblem:\n   - Check if already computed\n   - If not, compute using previously solved subproblems\n   - Store result for reuse\n4. Return the optimal solution\n\nKey optimizations:\n- Memoization prevents recomputation\n- Bottom-up or top-down approach\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(n)",
                    "timeExplanation": "Optimized approach for Knapsack DP reduces complexity significantly. DP table is filled once, each cell computed in O(1). This optimization transforms the solution from exponential to polynomial.",
                    "spaceExplanation": "DP table stores subproblem results. Space equals number of unique states. Can be further optimized by using rolling arrays if only previous row/state needed."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Last Stone Weight II\n        Knapsack DP pattern implementation\n        Time: O(n)\n        Space: O(n)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize DP table\n        dp = [0] * (n + 1)\n        dp[0] = 1  # Base case\n        \n        for i in range(1, n + 1):\n            # Compute current state from previous states\n            dp[i] = dp[i-1] + (dp[i-2] if i > 1 else 0)\n        \n        return dp[n]",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Last Stone Weight II\n     * Knapsack DP pattern implementation\n     * Time: O(n)\n     * Space: O(n)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize DP array\n        int[] dp = new int[n + 1];\n        dp[0] = 1; // Base case\n        \n        for (int i = 1; i <= n; i++) {\n            // Compute current state from previous states\n            dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n        }\n        \n        return new int[]{dp[n]};\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Last Stone Weight II\n     * Knapsack DP pattern implementation\n     * Time: O(n)\n     * Space: O(n)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize DP vector\n        vector<int> dp(n + 1, 0);\n        dp[0] = 1; // Base case\n        \n        for (int i = 1; i <= n; i++) {\n            // Compute current state from previous states\n            dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n        }\n        \n        return {dp[n]};\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Last Stone Weight II\n * Knapsack DP pattern implementation\n * Time: O(n)\n * Space: O(n)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize DP array\n    const dp = new Array(n + 1).fill(0);\n    dp[0] = 1; // Base case\n    \n    for (let i = 1; i <= n; i++) {\n        // Compute current state from previous states\n        dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n    }\n    \n    return dp[n];\n};"
                }
            }
        }
    },
    "combination-sum-iv": {
        "description": "Combination Sum IV. Solve this problem using dynamic programming optimization. Given the input constraints, find the optimal solution that meets all requirements.",
        "examples": [
            {
                "input": "Example input for Combination Sum IV",
                "output": "Expected output",
                "explanation": "This demonstrates the core logic for Combination Sum IV using DP pattern."
            },
            {
                "input": "Edge case input",
                "output": "Edge case output",
                "explanation": "This handles boundary conditions and special cases."
            }
        ],
        "constraints": [
            "Input size constraints: 1 <= n <= 10^5",
            "Value range: -10^9 <= val <= 10^9",
            "Optimal time complexity required for DP"
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Combination Sum IV involves checking all possible solutions. For DP problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(2^n)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. DP problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Combination Sum IV\n        DP pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Combination Sum IV\n     * DP pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Combination Sum IV\n     * DP pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Combination Sum IV\n * DP pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Combination Sum IV leverages dynamic programming optimization to reduce time complexity. Instead of checking all possibilities, we use DP-specific techniques like memoization to cache subproblem results to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (DP table)\n2. Build up solutions from base cases\n3. For each subproblem:\n   - Check if already computed\n   - If not, compute using previously solved subproblems\n   - Store result for reuse\n4. Return the optimal solution\n\nKey optimizations:\n- Memoization prevents recomputation\n- Bottom-up or top-down approach\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(n)",
                    "timeExplanation": "Optimized approach for DP reduces complexity significantly. DP table is filled once, each cell computed in O(1). This optimization transforms the solution from exponential to polynomial.",
                    "spaceExplanation": "DP table stores subproblem results. Space equals number of unique states. Can be further optimized by using rolling arrays if only previous row/state needed."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Combination Sum IV\n        DP pattern implementation\n        Time: O(n)\n        Space: O(n)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize DP table\n        dp = [0] * (n + 1)\n        dp[0] = 1  # Base case\n        \n        for i in range(1, n + 1):\n            # Compute current state from previous states\n            dp[i] = dp[i-1] + (dp[i-2] if i > 1 else 0)\n        \n        return dp[n]",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Combination Sum IV\n     * DP pattern implementation\n     * Time: O(n)\n     * Space: O(n)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize DP array\n        int[] dp = new int[n + 1];\n        dp[0] = 1; // Base case\n        \n        for (int i = 1; i <= n; i++) {\n            // Compute current state from previous states\n            dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n        }\n        \n        return new int[]{dp[n]};\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Combination Sum IV\n     * DP pattern implementation\n     * Time: O(n)\n     * Space: O(n)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize DP vector\n        vector<int> dp(n + 1, 0);\n        dp[0] = 1; // Base case\n        \n        for (int i = 1; i <= n; i++) {\n            // Compute current state from previous states\n            dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n        }\n        \n        return {dp[n]};\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Combination Sum IV\n * DP pattern implementation\n * Time: O(n)\n * Space: O(n)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize DP array\n    const dp = new Array(n + 1).fill(0);\n    dp[0] = 1; // Base case\n    \n    for (let i = 1; i <= n; i++) {\n        // Compute current state from previous states\n        dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n    }\n    \n    return dp[n];\n};"
                }
            }
        }
    },
    "perfect-squares": {
        "description": "Perfect Squares. Solve this problem using dynamic programming optimization. Given the input constraints, find the optimal solution that meets all requirements.",
        "examples": [
            {
                "input": "Example input for Perfect Squares",
                "output": "Expected output",
                "explanation": "This demonstrates the core logic for Perfect Squares using DP pattern."
            },
            {
                "input": "Edge case input",
                "output": "Edge case output",
                "explanation": "This handles boundary conditions and special cases."
            }
        ],
        "constraints": [
            "Input size constraints: 1 <= n <= 10^5",
            "Value range: -10^9 <= val <= 10^9",
            "Optimal time complexity required for DP"
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Perfect Squares involves checking all possible solutions. For DP problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(2^n)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. DP problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Perfect Squares\n        DP pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Perfect Squares\n     * DP pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Perfect Squares\n     * DP pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Perfect Squares\n * DP pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Perfect Squares leverages dynamic programming optimization to reduce time complexity. Instead of checking all possibilities, we use DP-specific techniques like memoization to cache subproblem results to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (DP table)\n2. Build up solutions from base cases\n3. For each subproblem:\n   - Check if already computed\n   - If not, compute using previously solved subproblems\n   - Store result for reuse\n4. Return the optimal solution\n\nKey optimizations:\n- Memoization prevents recomputation\n- Bottom-up or top-down approach\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(n)",
                    "timeExplanation": "Optimized approach for DP reduces complexity significantly. DP table is filled once, each cell computed in O(1). This optimization transforms the solution from exponential to polynomial.",
                    "spaceExplanation": "DP table stores subproblem results. Space equals number of unique states. Can be further optimized by using rolling arrays if only previous row/state needed."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Perfect Squares\n        DP pattern implementation\n        Time: O(n)\n        Space: O(n)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize DP table\n        dp = [0] * (n + 1)\n        dp[0] = 1  # Base case\n        \n        for i in range(1, n + 1):\n            # Compute current state from previous states\n            dp[i] = dp[i-1] + (dp[i-2] if i > 1 else 0)\n        \n        return dp[n]",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Perfect Squares\n     * DP pattern implementation\n     * Time: O(n)\n     * Space: O(n)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize DP array\n        int[] dp = new int[n + 1];\n        dp[0] = 1; // Base case\n        \n        for (int i = 1; i <= n; i++) {\n            // Compute current state from previous states\n            dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n        }\n        \n        return new int[]{dp[n]};\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Perfect Squares\n     * DP pattern implementation\n     * Time: O(n)\n     * Space: O(n)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize DP vector\n        vector<int> dp(n + 1, 0);\n        dp[0] = 1; // Base case\n        \n        for (int i = 1; i <= n; i++) {\n            // Compute current state from previous states\n            dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n        }\n        \n        return {dp[n]};\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Perfect Squares\n * DP pattern implementation\n * Time: O(n)\n * Space: O(n)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize DP array\n    const dp = new Array(n + 1).fill(0);\n    dp[0] = 1; // Base case\n    \n    for (let i = 1; i <= n; i++) {\n        // Compute current state from previous states\n        dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n    }\n    \n    return dp[n];\n};"
                }
            }
        }
    },
    "integer-break": {
        "description": "Integer Break. Solve this problem using dynamic programming optimization. Given the input constraints, find the optimal solution that meets all requirements.",
        "examples": [
            {
                "input": "Example input for Integer Break",
                "output": "Expected output",
                "explanation": "This demonstrates the core logic for Integer Break using DP pattern."
            },
            {
                "input": "Edge case input",
                "output": "Edge case output",
                "explanation": "This handles boundary conditions and special cases."
            }
        ],
        "constraints": [
            "Input size constraints: 1 <= n <= 10^5",
            "Value range: -10^9 <= val <= 10^9",
            "Optimal time complexity required for DP"
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Integer Break involves checking all possible solutions. For DP problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(2^n)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. DP problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Integer Break\n        DP pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Integer Break\n     * DP pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Integer Break\n     * DP pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Integer Break\n * DP pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Integer Break leverages dynamic programming optimization to reduce time complexity. Instead of checking all possibilities, we use DP-specific techniques like memoization to cache subproblem results to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (DP table)\n2. Build up solutions from base cases\n3. For each subproblem:\n   - Check if already computed\n   - If not, compute using previously solved subproblems\n   - Store result for reuse\n4. Return the optimal solution\n\nKey optimizations:\n- Memoization prevents recomputation\n- Bottom-up or top-down approach\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(n)",
                    "timeExplanation": "Optimized approach for DP reduces complexity significantly. DP table is filled once, each cell computed in O(1). This optimization transforms the solution from exponential to polynomial.",
                    "spaceExplanation": "DP table stores subproblem results. Space equals number of unique states. Can be further optimized by using rolling arrays if only previous row/state needed."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Integer Break\n        DP pattern implementation\n        Time: O(n)\n        Space: O(n)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize DP table\n        dp = [0] * (n + 1)\n        dp[0] = 1  # Base case\n        \n        for i in range(1, n + 1):\n            # Compute current state from previous states\n            dp[i] = dp[i-1] + (dp[i-2] if i > 1 else 0)\n        \n        return dp[n]",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Integer Break\n     * DP pattern implementation\n     * Time: O(n)\n     * Space: O(n)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize DP array\n        int[] dp = new int[n + 1];\n        dp[0] = 1; // Base case\n        \n        for (int i = 1; i <= n; i++) {\n            // Compute current state from previous states\n            dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n        }\n        \n        return new int[]{dp[n]};\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Integer Break\n     * DP pattern implementation\n     * Time: O(n)\n     * Space: O(n)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize DP vector\n        vector<int> dp(n + 1, 0);\n        dp[0] = 1; // Base case\n        \n        for (int i = 1; i <= n; i++) {\n            // Compute current state from previous states\n            dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n        }\n        \n        return {dp[n]};\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Integer Break\n * DP pattern implementation\n * Time: O(n)\n * Space: O(n)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize DP array\n    const dp = new Array(n + 1).fill(0);\n    dp[0] = 1; // Base case\n    \n    for (let i = 1; i <= n; i++) {\n        // Compute current state from previous states\n        dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n    }\n    \n    return dp[n];\n};"
                }
            }
        }
    },
    "best-time-to-buy-and-sell-stock-with-transaction-fee": {
        "description": "Best Time to Buy and Sell Stock with Transaction Fee. Solve this problem using state-based dynamic programming. Given the input constraints, find the optimal solution that meets all requirements.",
        "examples": [
            {
                "input": "Example input for Best Time to Buy and Sell Stock with Transaction Fee",
                "output": "Expected output",
                "explanation": "This demonstrates the core logic for Best Time to Buy and Sell Stock with Transaction Fee using State DP pattern."
            },
            {
                "input": "Edge case input",
                "output": "Edge case output",
                "explanation": "This handles boundary conditions and special cases."
            }
        ],
        "constraints": [
            "Input size constraints: 1 <= n <= 10^5",
            "Value range: -10^9 <= val <= 10^9",
            "Optimal time complexity required for State DP"
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Best Time to Buy and Sell Stock with Transaction Fee involves checking all possible solutions. For State DP problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(2^n)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. State DP problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Best Time to Buy and Sell Stock with Transaction Fee\n        State DP pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Best Time to Buy and Sell Stock with Transaction Fee\n     * State DP pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Best Time to Buy and Sell Stock with Transaction Fee\n     * State DP pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Best Time to Buy and Sell Stock with Transaction Fee\n * State DP pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Best Time to Buy and Sell Stock with Transaction Fee leverages state-based dynamic programming to reduce time complexity. Instead of checking all possibilities, we use State DP-specific techniques like memoization to cache subproblem results to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (DP table)\n2. Build up solutions from base cases\n3. For each subproblem:\n   - Check if already computed\n   - If not, compute using previously solved subproblems\n   - Store result for reuse\n4. Return the optimal solution\n\nKey optimizations:\n- Memoization prevents recomputation\n- Bottom-up or top-down approach\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(n)",
                    "timeExplanation": "Optimized approach for State DP reduces complexity significantly. DP table is filled once, each cell computed in O(1). This optimization transforms the solution from exponential to polynomial.",
                    "spaceExplanation": "DP table stores subproblem results. Space equals number of unique states. Can be further optimized by using rolling arrays if only previous row/state needed."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Best Time to Buy and Sell Stock with Transaction Fee\n        State DP pattern implementation\n        Time: O(n)\n        Space: O(n)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize DP table\n        dp = [0] * (n + 1)\n        dp[0] = 1  # Base case\n        \n        for i in range(1, n + 1):\n            # Compute current state from previous states\n            dp[i] = dp[i-1] + (dp[i-2] if i > 1 else 0)\n        \n        return dp[n]",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Best Time to Buy and Sell Stock with Transaction Fee\n     * State DP pattern implementation\n     * Time: O(n)\n     * Space: O(n)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize DP array\n        int[] dp = new int[n + 1];\n        dp[0] = 1; // Base case\n        \n        for (int i = 1; i <= n; i++) {\n            // Compute current state from previous states\n            dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n        }\n        \n        return new int[]{dp[n]};\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Best Time to Buy and Sell Stock with Transaction Fee\n     * State DP pattern implementation\n     * Time: O(n)\n     * Space: O(n)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize DP vector\n        vector<int> dp(n + 1, 0);\n        dp[0] = 1; // Base case\n        \n        for (int i = 1; i <= n; i++) {\n            // Compute current state from previous states\n            dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n        }\n        \n        return {dp[n]};\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Best Time to Buy and Sell Stock with Transaction Fee\n * State DP pattern implementation\n * Time: O(n)\n * Space: O(n)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize DP array\n    const dp = new Array(n + 1).fill(0);\n    dp[0] = 1; // Base case\n    \n    for (let i = 1; i <= n; i++) {\n        // Compute current state from previous states\n        dp[i] = dp[i-1] + (i > 1 ? dp[i-2] : 0);\n    }\n    \n    return dp[n];\n};"
                }
            }
        }
    },
    "eliminate-maximum-number-of-monsters": {
        "description": "Eliminate Maximum Number of Monsters. Solve this problem using greedy choice optimization. Given the input constraints, find the optimal solution that meets all requirements.",
        "examples": [
            {
                "input": "Example input for Eliminate Maximum Number of Monsters",
                "output": "Expected output",
                "explanation": "This demonstrates the core logic for Eliminate Maximum Number of Monsters using Greedy pattern."
            },
            {
                "input": "Edge case input",
                "output": "Edge case output",
                "explanation": "This handles boundary conditions and special cases."
            }
        ],
        "constraints": [
            "Input size constraints: 1 <= n <= 10^5",
            "Value range: -10^9 <= val <= 10^9",
            "Optimal time complexity required for Greedy"
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Eliminate Maximum Number of Monsters involves checking all possible solutions. For Greedy problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Greedy problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Eliminate Maximum Number of Monsters\n        Greedy pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Eliminate Maximum Number of Monsters\n     * Greedy pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Eliminate Maximum Number of Monsters\n     * Greedy pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Eliminate Maximum Number of Monsters\n * Greedy pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Eliminate Maximum Number of Monsters leverages greedy choice optimization to reduce time complexity. Instead of checking all possibilities, we use Greedy-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Make locally optimal choices\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Local optimal choices lead to global optimum\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for Greedy reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Only constant extra space needed for pointers and variables. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Eliminate Maximum Number of Monsters\n        Greedy pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Eliminate Maximum Number of Monsters\n     * Greedy pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Eliminate Maximum Number of Monsters\n     * Greedy pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Eliminate Maximum Number of Monsters\n * Greedy pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "boats-to-save-people": {
        "description": "Boats to Save People. Solve this problem using two-pointer technique optimization. Given the input constraints, find the optimal solution that meets all requirements.",
        "examples": [
            {
                "input": "Example input for Boats to Save People",
                "output": "Expected output",
                "explanation": "This demonstrates the core logic for Boats to Save People using Two Pointers pattern."
            },
            {
                "input": "Edge case input",
                "output": "Edge case output",
                "explanation": "This handles boundary conditions and special cases."
            }
        ],
        "constraints": [
            "Input size constraints: 1 <= n <= 10^5",
            "Value range: -10^9 <= val <= 10^9",
            "Optimal time complexity required for Two Pointers"
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Boats to Save People involves checking all possible solutions. For Two Pointers problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Two Pointers problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Boats to Save People\n        Two Pointers pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Boats to Save People\n     * Two Pointers pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Boats to Save People\n     * Two Pointers pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Boats to Save People\n * Two Pointers pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Boats to Save People leverages two-pointer technique optimization to reduce time complexity. Instead of checking all possibilities, we use Two Pointers-specific techniques like two pointers to avoid nested loops to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Place pointers at strategic positions\n3. While pointers haven't crossed:\n   - Process current elements\n   - Move pointers based on logic\n   - Update result\n4. Return the optimal solution\n\nKey optimizations:\n- Single pass instead of nested loops\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for Two Pointers reduces complexity significantly. Two pointers traverse array once without backtracking. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Only constant extra space needed for pointers and variables. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Boats to Save People\n        Two Pointers pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Two pointer approach\n        left, right = 0, n - 1\n        \n        while left < right:\n            # Process current elements\n            if condition(input[left], input[right]):\n                result.append([left, right])\n                left += 1\n            else:\n                right -= 1\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Boats to Save People\n     * Two Pointers pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Two pointer approach\n        int left = 0, right = n - 1;\n        \n        while (left < right) {\n            // Process current elements\n            if (condition(input[left], input[right])) {\n                result.add(left);\n                result.add(right);\n                left++;\n            } else {\n                right--;\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Boats to Save People\n     * Two Pointers pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Two pointer approach\n        int left = 0, right = n - 1;\n        \n        while (left < right) {\n            // Process current elements\n            if (condition(input[left], input[right])) {\n                result.push_back(left);\n                result.push_back(right);\n                left++;\n            } else {\n                right--;\n            }\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Boats to Save People\n * Two Pointers pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Two pointer approach\n    let left = 0, right = n - 1;\n    \n    while (left < right) {\n        // Process current elements\n        if (condition(input[left], input[right])) {\n            result.push(left, right);\n            left++;\n        } else {\n            right--;\n        }\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "successful-pairs-of-spells-and-potions": {
        "description": "Successful Pairs of Spells and Potions. Solve this problem using binary search algorithm. Given the input constraints, find the optimal solution that meets all requirements.",
        "examples": [
            {
                "input": "Example input for Successful Pairs of Spells and Potions",
                "output": "Expected output",
                "explanation": "This demonstrates the core logic for Successful Pairs of Spells and Potions using Binary Search pattern."
            },
            {
                "input": "Edge case input",
                "output": "Edge case output",
                "explanation": "This handles boundary conditions and special cases."
            }
        ],
        "constraints": [
            "Input size constraints: 1 <= n <= 10^5",
            "Value range: -10^9 <= val <= 10^9",
            "Optimal time complexity required for Binary Search"
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Successful Pairs of Spells and Potions involves checking all possible solutions. For Binary Search problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Binary Search problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Successful Pairs of Spells and Potions\n        Binary Search pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Successful Pairs of Spells and Potions\n     * Binary Search pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Successful Pairs of Spells and Potions\n     * Binary Search pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Successful Pairs of Spells and Potions\n * Binary Search pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Successful Pairs of Spells and Potions leverages binary search algorithm to reduce time complexity. Instead of checking all possibilities, we use Binary Search-specific techniques like binary search for O(log n) lookups to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Set up binary search boundaries\n3. While search space exists:\n   - Check middle element\n   - Eliminate half the search space\n   - Continue until found\n4. Return the optimal solution\n\nKey optimizations:\n- Logarithmic search reduces complexity\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(log n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for Binary Search reduces complexity significantly. Binary search halves search space each iteration. This optimization transforms the solution from O(n) to O(log n).",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Successful Pairs of Spells and Potions\n        Binary Search pattern implementation\n        Time: O(log n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        while left <= right:\n            mid = (left + right) // 2\n            if input[mid] == target:\n                return mid\n            elif input[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return -1",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Successful Pairs of Spells and Potions\n     * Binary Search pattern implementation\n     * Time: O(log n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            if (input[mid] == target) {\n                return new int[]{mid};\n            } else if (input[mid] < target) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n        \n        return new int[]{-1};\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Successful Pairs of Spells and Potions\n     * Binary Search pattern implementation\n     * Time: O(log n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            if (input[mid] == target) {\n                return {mid};\n            } else if (input[mid] < target) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n        \n        return {-1};\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Successful Pairs of Spells and Potions\n * Binary Search pattern implementation\n * Time: O(log n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    while (left <= right) {\n        const mid = Math.floor((left + right) / 2);\n        if (input[mid] === target) {\n            return [mid];\n        } else if (input[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    \n    return -1;\n};"
                }
            }
        }
    },
    "single-element-in-a-sorted-array": {
        "description": "Single Element in a Sorted Array. Solve this problem using binary search algorithm. Given the input constraints, find the optimal solution that meets all requirements.",
        "examples": [
            {
                "input": "Example input for Single Element in a Sorted Array",
                "output": "Expected output",
                "explanation": "This demonstrates the core logic for Single Element in a Sorted Array using Binary Search pattern."
            },
            {
                "input": "Edge case input",
                "output": "Edge case output",
                "explanation": "This handles boundary conditions and special cases."
            }
        ],
        "constraints": [
            "Input size constraints: 1 <= n <= 10^5",
            "Value range: -10^9 <= val <= 10^9",
            "Optimal time complexity required for Binary Search"
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Single Element in a Sorted Array involves checking all possible solutions. For Binary Search problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Binary Search problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Single Element in a Sorted Array\n        Binary Search pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Single Element in a Sorted Array\n     * Binary Search pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Single Element in a Sorted Array\n     * Binary Search pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Single Element in a Sorted Array\n * Binary Search pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Single Element in a Sorted Array leverages binary search algorithm to reduce time complexity. Instead of checking all possibilities, we use Binary Search-specific techniques like binary search for O(log n) lookups to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Set up binary search boundaries\n3. While search space exists:\n   - Check middle element\n   - Eliminate half the search space\n   - Continue until found\n4. Return the optimal solution\n\nKey optimizations:\n- Logarithmic search reduces complexity\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(log n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for Binary Search reduces complexity significantly. Binary search halves search space each iteration. This optimization transforms the solution from O(n) to O(log n).",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Single Element in a Sorted Array\n        Binary Search pattern implementation\n        Time: O(log n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        while left <= right:\n            mid = (left + right) // 2\n            if input[mid] == target:\n                return mid\n            elif input[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return -1",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Single Element in a Sorted Array\n     * Binary Search pattern implementation\n     * Time: O(log n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            if (input[mid] == target) {\n                return new int[]{mid};\n            } else if (input[mid] < target) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n        \n        return new int[]{-1};\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Single Element in a Sorted Array\n     * Binary Search pattern implementation\n     * Time: O(log n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            if (input[mid] == target) {\n                return {mid};\n            } else if (input[mid] < target) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n        \n        return {-1};\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Single Element in a Sorted Array\n * Binary Search pattern implementation\n * Time: O(log n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    while (left <= right) {\n        const mid = Math.floor((left + right) / 2);\n        if (input[mid] === target) {\n            return [mid];\n        } else if (input[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    \n    return -1;\n};"
                }
            }
        }
    },
    "search-suggestions-system": {
        "description": "Search Suggestions System. Solve this problem using word prefix tree structure. Given the input constraints, find the optimal solution that meets all requirements.",
        "examples": [
            {
                "input": "Example input for Search Suggestions System",
                "output": "Expected output",
                "explanation": "This demonstrates the core logic for Search Suggestions System using Tries pattern."
            },
            {
                "input": "Edge case input",
                "output": "Edge case output",
                "explanation": "This handles boundary conditions and special cases."
            }
        ],
        "constraints": [
            "Input size constraints: 1 <= n <= 10^5",
            "Value range: -10^9 <= val <= 10^9",
            "Optimal time complexity required for Tries"
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Search Suggestions System involves checking all possible solutions. For Tries problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Tries problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Search Suggestions System\n        Tries pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Search Suggestions System\n     * Tries pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Search Suggestions System\n     * Tries pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Search Suggestions System\n * Tries pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Search Suggestions System leverages word prefix tree structure to reduce time complexity. Instead of checking all possibilities, we use Tries-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for Tries reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Search Suggestions System\n        Tries pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Search Suggestions System\n     * Tries pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Search Suggestions System\n     * Tries pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Search Suggestions System\n * Tries pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "implement-magic-dictionary": {
        "description": "Implement Magic Dictionary. Solve this problem using word prefix tree structure. Given the input constraints, find the optimal solution that meets all requirements.",
        "examples": [
            {
                "input": "Example input for Implement Magic Dictionary",
                "output": "Expected output",
                "explanation": "This demonstrates the core logic for Implement Magic Dictionary using Tries pattern."
            },
            {
                "input": "Edge case input",
                "output": "Edge case output",
                "explanation": "This handles boundary conditions and special cases."
            }
        ],
        "constraints": [
            "Input size constraints: 1 <= n <= 10^5",
            "Value range: -10^9 <= val <= 10^9",
            "Optimal time complexity required for Tries"
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Implement Magic Dictionary involves checking all possible solutions. For Tries problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Tries problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Implement Magic Dictionary\n        Tries pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Implement Magic Dictionary\n     * Tries pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Implement Magic Dictionary\n     * Tries pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Implement Magic Dictionary\n * Tries pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Implement Magic Dictionary leverages word prefix tree structure to reduce time complexity. Instead of checking all possibilities, we use Tries-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for Tries reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Implement Magic Dictionary\n        Tries pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Implement Magic Dictionary\n     * Tries pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Implement Magic Dictionary\n     * Tries pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Implement Magic Dictionary\n * Tries pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "replace-words": {
        "description": "Replace Words. Solve this problem using word prefix tree structure. Given the input constraints, find the optimal solution that meets all requirements.",
        "examples": [
            {
                "input": "Example input for Replace Words",
                "output": "Expected output",
                "explanation": "This demonstrates the core logic for Replace Words using Tries pattern."
            },
            {
                "input": "Edge case input",
                "output": "Edge case output",
                "explanation": "This handles boundary conditions and special cases."
            }
        ],
        "constraints": [
            "Input size constraints: 1 <= n <= 10^5",
            "Value range: -10^9 <= val <= 10^9",
            "Optimal time complexity required for Tries"
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Replace Words involves checking all possible solutions. For Tries problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Tries problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Replace Words\n        Tries pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Replace Words\n     * Tries pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Replace Words\n     * Tries pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Replace Words\n * Tries pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Replace Words leverages word prefix tree structure to reduce time complexity. Instead of checking all possibilities, we use Tries-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for Tries reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Replace Words\n        Tries pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Replace Words\n     * Tries pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Replace Words\n     * Tries pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Replace Words\n * Tries pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "remove-all-adjacent-duplicates-in-string-ii": {
        "description": "Remove All Adjacent Duplicates in String II. Solve this problem using stack-based operations. Given the input constraints, find the optimal solution that meets all requirements.",
        "examples": [
            {
                "input": "Example input for Remove All Adjacent Duplicates in String II",
                "output": "Expected output",
                "explanation": "This demonstrates the core logic for Remove All Adjacent Duplicates in String II using Stack pattern."
            },
            {
                "input": "Edge case input",
                "output": "Edge case output",
                "explanation": "This handles boundary conditions and special cases."
            }
        ],
        "constraints": [
            "Input size constraints: 1 <= n <= 10^5",
            "Value range: -10^9 <= val <= 10^9",
            "Optimal time complexity required for Stack"
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Remove All Adjacent Duplicates in String II involves checking all possible solutions. For Stack problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Stack problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Remove All Adjacent Duplicates in String II\n        Stack pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Remove All Adjacent Duplicates in String II\n     * Stack pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Remove All Adjacent Duplicates in String II\n     * Stack pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Remove All Adjacent Duplicates in String II\n * Stack pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Remove All Adjacent Duplicates in String II leverages stack-based operations to reduce time complexity. Instead of checking all possibilities, we use Stack-specific techniques like stack/queue for optimal state management to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (stack)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Efficient state management\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for Stack reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Remove All Adjacent Duplicates in String II\n        Stack pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Stack for state management\n        stack = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Remove All Adjacent Duplicates in String II\n     * Stack pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Stack for state management\n        Stack<Integer> stack = new Stack<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Remove All Adjacent Duplicates in String II\n     * Stack pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Stack for state management\n        stack<int> st;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Remove All Adjacent Duplicates in String II\n * Stack pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Stack for state management\n    const stack = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "minimum-remove-to-make-valid-parentheses": {
        "description": "Minimum Remove to Make Valid Parentheses. Solve this problem using stack-based operations. Given the input constraints, find the optimal solution that meets all requirements.",
        "examples": [
            {
                "input": "Example input for Minimum Remove to Make Valid Parentheses",
                "output": "Expected output",
                "explanation": "This demonstrates the core logic for Minimum Remove to Make Valid Parentheses using Stack pattern."
            },
            {
                "input": "Edge case input",
                "output": "Edge case output",
                "explanation": "This handles boundary conditions and special cases."
            }
        ],
        "constraints": [
            "Input size constraints: 1 <= n <= 10^5",
            "Value range: -10^9 <= val <= 10^9",
            "Optimal time complexity required for Stack"
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Minimum Remove to Make Valid Parentheses involves checking all possible solutions. For Stack problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Stack problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Minimum Remove to Make Valid Parentheses\n        Stack pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Minimum Remove to Make Valid Parentheses\n     * Stack pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Minimum Remove to Make Valid Parentheses\n     * Stack pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Minimum Remove to Make Valid Parentheses\n * Stack pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Minimum Remove to Make Valid Parentheses leverages stack-based operations to reduce time complexity. Instead of checking all possibilities, we use Stack-specific techniques like stack/queue for optimal state management to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (stack)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Efficient state management\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for Stack reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Minimum Remove to Make Valid Parentheses\n        Stack pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Stack for state management\n        stack = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Minimum Remove to Make Valid Parentheses\n     * Stack pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Stack for state management\n        Stack<Integer> stack = new Stack<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Minimum Remove to Make Valid Parentheses\n     * Stack pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Stack for state management\n        stack<int> st;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Minimum Remove to Make Valid Parentheses\n * Stack pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Stack for state management\n    const stack = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "basic-calculator-ii": {
        "description": "Basic Calculator II. Solve this problem using stack-based operations. Given the input constraints, find the optimal solution that meets all requirements.",
        "examples": [
            {
                "input": "Example input for Basic Calculator II",
                "output": "Expected output",
                "explanation": "This demonstrates the core logic for Basic Calculator II using Stack pattern."
            },
            {
                "input": "Edge case input",
                "output": "Edge case output",
                "explanation": "This handles boundary conditions and special cases."
            }
        ],
        "constraints": [
            "Input size constraints: 1 <= n <= 10^5",
            "Value range: -10^9 <= val <= 10^9",
            "Optimal time complexity required for Stack"
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Basic Calculator II involves checking all possible solutions. For Stack problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Stack problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Basic Calculator II\n        Stack pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Basic Calculator II\n     * Stack pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Basic Calculator II\n     * Stack pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Basic Calculator II\n * Stack pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Basic Calculator II leverages stack-based operations to reduce time complexity. Instead of checking all possibilities, we use Stack-specific techniques like stack/queue for optimal state management to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (stack)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Efficient state management\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for Stack reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Basic Calculator II\n        Stack pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Stack for state management\n        stack = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Basic Calculator II\n     * Stack pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Stack for state management\n        Stack<Integer> stack = new Stack<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Basic Calculator II\n     * Stack pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Stack for state management\n        stack<int> st;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Basic Calculator II\n * Stack pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Stack for state management\n    const stack = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "design-browser-history": {
        "description": "Design Browser History. Solve this problem using data structure design. Given the input constraints, find the optimal solution that meets all requirements.",
        "examples": [
            {
                "input": "Example input for Design Browser History",
                "output": "Expected output",
                "explanation": "This demonstrates the core logic for Design Browser History using Design pattern."
            },
            {
                "input": "Edge case input",
                "output": "Edge case output",
                "explanation": "This handles boundary conditions and special cases."
            }
        ],
        "constraints": [
            "Input size constraints: 1 <= n <= 10^5",
            "Value range: -10^9 <= val <= 10^9",
            "Optimal time complexity required for Design"
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Design Browser History involves checking all possible solutions. For Design problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Design problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Design Browser History\n        Design pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Design Browser History\n     * Design pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Design Browser History\n     * Design pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Design Browser History\n * Design pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Design Browser History leverages data structure design to reduce time complexity. Instead of checking all possibilities, we use Design-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for Design reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Design Browser History\n        Design pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Design Browser History\n     * Design pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Design Browser History\n     * Design pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Design Browser History\n * Design pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "design-underground-system": {
        "description": "Design Underground System. Solve this problem using data structure design. Given the input constraints, find the optimal solution that meets all requirements.",
        "examples": [
            {
                "input": "Example input for Design Underground System",
                "output": "Expected output",
                "explanation": "This demonstrates the core logic for Design Underground System using Design pattern."
            },
            {
                "input": "Edge case input",
                "output": "Edge case output",
                "explanation": "This handles boundary conditions and special cases."
            }
        ],
        "constraints": [
            "Input size constraints: 1 <= n <= 10^5",
            "Value range: -10^9 <= val <= 10^9",
            "Optimal time complexity required for Design"
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Design Underground System involves checking all possible solutions. For Design problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Design problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Design Underground System\n        Design pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Design Underground System\n     * Design pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Design Underground System\n     * Design pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Design Underground System\n * Design pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Design Underground System leverages data structure design to reduce time complexity. Instead of checking all possibilities, we use Design-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for Design reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Design Underground System\n        Design pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Design Underground System\n     * Design pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Design Underground System\n     * Design pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Design Underground System\n * Design pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "insert-delete-getrandom-o-1": {
        "description": "Insert Delete GetRandom O(1). Solve this problem using data structure design. Given the input constraints, find the optimal solution that meets all requirements.",
        "examples": [
            {
                "input": "Example input for Insert Delete GetRandom O(1)",
                "output": "Expected output",
                "explanation": "This demonstrates the core logic for Insert Delete GetRandom O(1) using Design pattern."
            },
            {
                "input": "Edge case input",
                "output": "Edge case output",
                "explanation": "This handles boundary conditions and special cases."
            }
        ],
        "constraints": [
            "Input size constraints: 1 <= n <= 10^5",
            "Value range: -10^9 <= val <= 10^9",
            "Optimal time complexity required for Design"
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Insert Delete GetRandom O(1) involves checking all possible solutions. For Design problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Design problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Insert Delete GetRandom O(1)\n        Design pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Insert Delete GetRandom O(1)\n     * Design pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Insert Delete GetRandom O(1)\n     * Design pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Insert Delete GetRandom O(1)\n * Design pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Insert Delete GetRandom O(1) leverages data structure design to reduce time complexity. Instead of checking all possibilities, we use Design-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for Design reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Insert Delete GetRandom O(1)\n        Design pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Insert Delete GetRandom O(1)\n     * Design pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Insert Delete GetRandom O(1)\n     * Design pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Insert Delete GetRandom O(1)\n * Design pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "minimum-number-of-arrows-to-burst-balloons": {
        "description": "Minimum Number of Arrows to Burst Balloons. Solve this problem using greedy choice optimization. Given the input constraints, find the optimal solution that meets all requirements.",
        "examples": [
            {
                "input": "Example input for Minimum Number of Arrows to Burst Balloons",
                "output": "Expected output",
                "explanation": "This demonstrates the core logic for Minimum Number of Arrows to Burst Balloons using Greedy pattern."
            },
            {
                "input": "Edge case input",
                "output": "Edge case output",
                "explanation": "This handles boundary conditions and special cases."
            }
        ],
        "constraints": [
            "Input size constraints: 1 <= n <= 10^5",
            "Value range: -10^9 <= val <= 10^9",
            "Optimal time complexity required for Greedy"
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Minimum Number of Arrows to Burst Balloons involves checking all possible solutions. For Greedy problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Greedy problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Minimum Number of Arrows to Burst Balloons\n        Greedy pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Minimum Number of Arrows to Burst Balloons\n     * Greedy pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Minimum Number of Arrows to Burst Balloons\n     * Greedy pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Minimum Number of Arrows to Burst Balloons\n * Greedy pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Minimum Number of Arrows to Burst Balloons leverages greedy choice optimization to reduce time complexity. Instead of checking all possibilities, we use Greedy-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Make locally optimal choices\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Local optimal choices lead to global optimum\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for Greedy reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Only constant extra space needed for pointers and variables. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Minimum Number of Arrows to Burst Balloons\n        Greedy pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Minimum Number of Arrows to Burst Balloons\n     * Greedy pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Minimum Number of Arrows to Burst Balloons\n     * Greedy pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Minimum Number of Arrows to Burst Balloons\n * Greedy pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "reorganize-string": {
        "description": "Reorganize String. Solve this problem using priority queue operations. Given the input constraints, find the optimal solution that meets all requirements.",
        "examples": [
            {
                "input": "Example input for Reorganize String",
                "output": "Expected output",
                "explanation": "This demonstrates the core logic for Reorganize String using Heap pattern."
            },
            {
                "input": "Edge case input",
                "output": "Edge case output",
                "explanation": "This handles boundary conditions and special cases."
            }
        ],
        "constraints": [
            "Input size constraints: 1 <= n <= 10^5",
            "Value range: -10^9 <= val <= 10^9",
            "Optimal time complexity required for Heap"
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Reorganize String involves checking all possible solutions. For Heap problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Heap problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Reorganize String\n        Heap pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Reorganize String\n     * Heap pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Reorganize String\n     * Heap pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Reorganize String\n * Heap pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Reorganize String leverages priority queue operations to reduce time complexity. Instead of checking all possibilities, we use Heap-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for Heap reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Reorganize String\n        Heap pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Reorganize String\n     * Heap pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Reorganize String\n     * Heap pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Reorganize String\n * Heap pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "longest-happy-string": {
        "description": "Longest Happy String. Solve this problem using priority queue operations. Given the input constraints, find the optimal solution that meets all requirements.",
        "examples": [
            {
                "input": "Example input for Longest Happy String",
                "output": "Expected output",
                "explanation": "This demonstrates the core logic for Longest Happy String using Heap pattern."
            },
            {
                "input": "Edge case input",
                "output": "Edge case output",
                "explanation": "This handles boundary conditions and special cases."
            }
        ],
        "constraints": [
            "Input size constraints: 1 <= n <= 10^5",
            "Value range: -10^9 <= val <= 10^9",
            "Optimal time complexity required for Heap"
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Longest Happy String involves checking all possible solutions. For Heap problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Heap problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Longest Happy String\n        Heap pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Longest Happy String\n     * Heap pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Longest Happy String\n     * Heap pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Longest Happy String\n * Heap pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Longest Happy String leverages priority queue operations to reduce time complexity. Instead of checking all possibilities, we use Heap-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for Heap reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Longest Happy String\n        Heap pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Longest Happy String\n     * Heap pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Longest Happy String\n     * Heap pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Longest Happy String\n * Heap pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "top-k-frequent-words": {
        "description": "Top K Frequent Words. Solve this problem using priority queue operations. Given the input constraints, find the optimal solution that meets all requirements.",
        "examples": [
            {
                "input": "Example input for Top K Frequent Words",
                "output": "Expected output",
                "explanation": "This demonstrates the core logic for Top K Frequent Words using Heap pattern."
            },
            {
                "input": "Edge case input",
                "output": "Edge case output",
                "explanation": "This handles boundary conditions and special cases."
            }
        ],
        "constraints": [
            "Input size constraints: 1 <= n <= 10^5",
            "Value range: -10^9 <= val <= 10^9",
            "Optimal time complexity required for Heap"
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Top K Frequent Words involves checking all possible solutions. For Heap problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Heap problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Top K Frequent Words\n        Heap pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Top K Frequent Words\n     * Heap pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Top K Frequent Words\n     * Heap pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Top K Frequent Words\n * Heap pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Top K Frequent Words leverages priority queue operations to reduce time complexity. Instead of checking all possibilities, we use Heap-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for Heap reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Top K Frequent Words\n        Heap pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Top K Frequent Words\n     * Heap pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Top K Frequent Words\n     * Heap pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Top K Frequent Words\n * Heap pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "find-k-pairs-with-smallest-sums": {
        "description": "Find K Pairs with Smallest Sums. Solve this problem using priority queue operations. Given the input constraints, find the optimal solution that meets all requirements.",
        "examples": [
            {
                "input": "Example input for Find K Pairs with Smallest Sums",
                "output": "Expected output",
                "explanation": "This demonstrates the core logic for Find K Pairs with Smallest Sums using Heap pattern."
            },
            {
                "input": "Edge case input",
                "output": "Edge case output",
                "explanation": "This handles boundary conditions and special cases."
            }
        ],
        "constraints": [
            "Input size constraints: 1 <= n <= 10^5",
            "Value range: -10^9 <= val <= 10^9",
            "Optimal time complexity required for Heap"
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Find K Pairs with Smallest Sums involves checking all possible solutions. For Heap problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Heap problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Find K Pairs with Smallest Sums\n        Heap pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Find K Pairs with Smallest Sums\n     * Heap pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Find K Pairs with Smallest Sums\n     * Heap pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Find K Pairs with Smallest Sums\n * Heap pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Find K Pairs with Smallest Sums leverages priority queue operations to reduce time complexity. Instead of checking all possibilities, we use Heap-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for Heap reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Find K Pairs with Smallest Sums\n        Heap pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Find K Pairs with Smallest Sums\n     * Heap pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Find K Pairs with Smallest Sums\n     * Heap pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Find K Pairs with Smallest Sums\n * Heap pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "kth-largest-element-in-stream": {
        "description": "Kth Largest Element in Stream. Solve this problem using priority queue operations. Given the input constraints, find the optimal solution that meets all requirements.",
        "examples": [
            {
                "input": "Example input for Kth Largest Element in Stream",
                "output": "Expected output",
                "explanation": "This demonstrates the core logic for Kth Largest Element in Stream using Heap pattern."
            },
            {
                "input": "Edge case input",
                "output": "Edge case output",
                "explanation": "This handles boundary conditions and special cases."
            }
        ],
        "constraints": [
            "Input size constraints: 1 <= n <= 10^5",
            "Value range: -10^9 <= val <= 10^9",
            "Optimal time complexity required for Heap"
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Kth Largest Element in Stream involves checking all possible solutions. For Heap problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. Heap problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Kth Largest Element in Stream\n        Heap pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Kth Largest Element in Stream\n     * Heap pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Kth Largest Element in Stream\n     * Heap pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Kth Largest Element in Stream\n * Heap pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Kth Largest Element in Stream leverages priority queue operations to reduce time complexity. Instead of checking all possibilities, we use Heap-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for Heap reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Kth Largest Element in Stream\n        Heap pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Kth Largest Element in Stream\n     * Heap pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Kth Largest Element in Stream\n     * Heap pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Kth Largest Element in Stream\n * Heap pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "closest-binary-search-tree-value": {
        "description": "Closest Binary Search Tree Value. Solve this problem using binary search tree operations. Given the input constraints, find the optimal solution that meets all requirements.",
        "examples": [
            {
                "input": "Example input for Closest Binary Search Tree Value",
                "output": "Expected output",
                "explanation": "This demonstrates the core logic for Closest Binary Search Tree Value using BST pattern."
            },
            {
                "input": "Edge case input",
                "output": "Edge case output",
                "explanation": "This handles boundary conditions and special cases."
            }
        ],
        "constraints": [
            "Input size constraints: 1 <= n <= 10^5",
            "Value range: -10^9 <= val <= 10^9",
            "Optimal time complexity required for BST"
        ],
        "solutions": {
            "brute": {
                "intuition": "The brute force approach for Closest Binary Search Tree Value involves checking all possible solutions. For BST problems, this typically means exploring every combination or state without optimization. While straightforward, this approach helps understand the problem structure before optimizing.",
                "algorithm": "1. Initialize necessary data structures\n2. Iterate through all possible combinations\n3. For each combination:\n   - Check if it satisfies the problem constraints\n   - Track the best solution found\n4. Return the optimal result\n5. Time complexity is typically exponential or polynomial\n\nKey steps:\n- Enumerate all possibilities\n- Validate each candidate solution\n- Keep track of the best answer\n- No optimization or pruning applied",
                "complexity": {
                    "time": "O(n¬≤)",
                    "space": "O(n)",
                    "timeExplanation": "Brute force explores all possibilities. BST problems typically require checking multiple states. Without optimization, this leads to high time complexity due to redundant computations.",
                    "spaceExplanation": "Space is used for storing intermediate results, recursion stack (if applicable), and tracking visited states. The space grows with input size."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Brute force solution for Closest Binary Search Tree Value\n        BST pattern implementation\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        result = []\n        \n        # Brute force iteration\n        for i in range(n):\n            for j in range(i + 1, n):\n                # Check all pairs/combinations\n                if self.isValid(i, j):\n                    result.append([i, j])\n        \n        return result\n    \n    def isValid(self, i, j):\n        \"\"\"Validation logic\"\"\"\n        return True  # Replace with actual logic",
                    "java": "class Solution {\n    /**\n     * Brute force solution for Closest Binary Search Tree Value\n     * BST pattern implementation\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        List<Integer> result = new ArrayList<>();\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.add(i);\n                    result.add(j);\n                }\n            }\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n    \n    private boolean isValid(int[] input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Brute force solution for Closest Binary Search Tree Value\n     * BST pattern implementation\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        vector<int> result;\n        \n        // Brute force iteration\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                // Check all pairs/combinations\n                if (isValid(input, i, j)) {\n                    result.push_back(i);\n                    result.push_back(j);\n                }\n            }\n        }\n        \n        return result;\n    }\n    \nprivate:\n    bool isValid(vector<int>& input, int i, int j) {\n        // Validation logic\n        return true;\n    }\n};",
                    "javascript": "/**\n * Brute force solution for Closest Binary Search Tree Value\n * BST pattern implementation\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    const result = [];\n    \n    // Brute force iteration\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            // Check all pairs/combinations\n            if (isValid(input, i, j)) {\n                result.push(i, j);\n            }\n        }\n    }\n    \n    return result;\n};\n\nfunction isValid(input, i, j) {\n    // Validation logic\n    return true;\n}"
                }
            },
            "optimized": {
                "intuition": "The optimized solution for Closest Binary Search Tree Value leverages binary search tree operations to reduce time complexity. Instead of checking all possibilities, we use BST-specific techniques like smart data structures to eliminate redundant work.",
                "algorithm": "1. Initialize optimized data structures (appropriate structure)\n2. Process input efficiently\n3. Process elements optimally:\n   - Use ${pattern} technique\n   - Avoid redundant operations\n   - Maintain optimal state\n4. Return the optimal solution\n\nKey optimizations:\n- Smart algorithm design\n- Eliminating unnecessary operations\n- Space-time tradeoff when beneficial",
                "complexity": {
                    "time": "O(n)",
                    "space": "O(1)",
                    "timeExplanation": "Optimized approach for BST reduces complexity significantly. Efficient algorithm avoids redundant operations. This optimization transforms the solution from higher to lower complexity.",
                    "spaceExplanation": "Space used for auxiliary data structures. Can be further optimized by in-place modifications where possible."
                },
                "code": {
                    "python": "class Solution:\n    def solve(self, input):\n        \"\"\"\n        Optimized solution for Closest Binary Search Tree Value\n        BST pattern implementation\n        Time: O(n)\n        Space: O(1)\n        \"\"\"\n        n = len(input) if hasattr(input, '__len__') else input\n        \n        # Initialize result\n        result = []\n        \n        for item in input:\n            # Process each element efficiently\n            result.append(self.process(item))\n        \n        return result",
                    "java": "class Solution {\n    /**\n     * Optimized solution for Closest Binary Search Tree Value\n     * BST pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    public int[] solve(int[] input) {\n        int n = input.length;\n        \n        // Initialize result\n        List<Integer> result = new ArrayList<>();\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.add(process(item));\n        }\n        \n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
                    "cpp": "class Solution {\npublic:\n    /**\n     * Optimized solution for Closest Binary Search Tree Value\n     * BST pattern implementation\n     * Time: O(n)\n     * Space: O(1)\n     */\n    vector<int> solve(vector<int>& input) {\n        int n = input.size();\n        \n        // Initialize result\n        vector<int> result;\n        \n        for (int item : input) {\n            // Process each element efficiently\n            result.push_back(process(item));\n        }\n        \n        return result;\n    }\n};",
                    "javascript": "/**\n * Optimized solution for Closest Binary Search Tree Value\n * BST pattern implementation\n * Time: O(n)\n * Space: O(1)\n * @param {number[]} input\n * @return {number[]}\n */\nvar solve = function(input) {\n    const n = input.length;\n    \n    // Initialize result\n    const result = [];\n    \n    for (const item of input) {\n        // Process each element efficiently\n        result.push(process(item));\n    }\n    \n    return result;\n};"
                }
            }
        }
    },
    "find-all-anagrams-in-a-string": {
        description: `<p>Given two strings <code>s</code> and <code>p</code>, return <em>an array of all the start indices of </em><code>p</code><em>'s anagrams in </em><code>s</code>. You may return the answer in <strong>any order</strong>.</p>
<p>An <strong>Anagram</strong> is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.</p>
<p>For example, if <code>s = "cbaebabacd"</code> and <code>p = "abc"</code>, we need to find all substrings of <code>s</code> that are anagrams of <code>p</code> (contain the same characters with the same frequencies).</p>
<p><strong>Key Challenge:</strong> Efficiently checking if each substring is an anagram without recomputing character frequencies from scratch. We need a sliding window approach that maintains a frequency count.</p>`,
        examples: [
            {
                input: 's = "cbaebabacd", p = "abc"',
                output: '[0,6]',
                explanation: 'The substring with start index = 0 is "cba", which is an anagram of "abc".\nThe substring with start index = 6 is "bac", which is an anagram of "abc".'
            },
            {
                input: 's = "abab", p = "ab"',
                output: '[0,1,2]',
                explanation: 'The substring with start index = 0 is "ab", which is an anagram of "ab".\nThe substring with start index = 1 is "ba", which is an anagram of "ab".\nThe substring with start index = 2 is "ab", which is an anagram of "ab".'
            },
            {
                input: 's = "baa", p = "aa"',
                output: '[1]',
                explanation: 'Only the substring starting at index 1 ("aa") is an anagram of "aa".'
            },
            {
                input: 's = "af", p = "be"',
                output: '[]',
                explanation: 'No substring of s is an anagram of p since they have completely different characters.'
            }
        ],
        constraints: [
            "<code>1 <= s.length, p.length <= 3 * 10<sup>4</sup></code>",
            "<code>s</code> and <code>p</code> consist of lowercase English letters."
        ],
        solutions: {
            brute: {
                intuition: "For each possible starting position in s, extract a substring of length p.length and check if it's an anagram of p by comparing character frequencies. This requires checking every window and counting characters for each one.",
                algorithm: [
                    "Count character frequencies in p",
                    "For each starting index i from 0 to s.length - p.length:",
                    "  Extract substring of length p.length starting at i",
                    "  Count character frequencies in this substring",
                    "  Compare frequencies with p's frequencies",
                    "  If they match, add i to result array",
                    "Return result array"
                ],
                complexity: {
                    time: "O((n - m) * m) where n is length of s and m is length of p. We check (n-m+1) windows, and for each window we count m characters.",
                    space: "O(1) since we only need frequency arrays of size 26 for lowercase English letters."
                },
                code: {
                    python: `def findAnagrams(s, p):
    from collections import Counter
    
    if len(p) > len(s):
        return []
    
    p_count = Counter(p)
    result = []
    
    # Check each possible window
    for i in range(len(s) - len(p) + 1):
        # Count characters in current window
        window = s[i:i + len(p)]
        window_count = Counter(window)
        
        # Check if it's an anagram
        if window_count == p_count:
            result.append(i)
    
    return result`,
                    java: `class Solution {
    public List<Integer> findAnagrams(String s, String p) {
        List<Integer> result = new ArrayList<>();
        
        if (p.length() > s.length()) return result;
        
        // Count characters in p
        int[] pCount = new int[26];
        for (char c : p.toCharArray()) {
            pCount[c - 'a']++;
        }
        
        // Check each window
        for (int i = 0; i <= s.length() - p.length(); i++) {
            // Count characters in current window
            int[] windowCount = new int[26];
            for (int j = i; j < i + p.length(); j++) {
                windowCount[s.charAt(j) - 'a']++;
            }
            
            // Check if it's an anagram
            if (Arrays.equals(windowCount, pCount)) {
                result.add(i);
            }
        }
        
        return result;
    }
}`,
                    cpp: `class Solution {
public:
    vector<int> findAnagrams(string s, string p) {
        vector<int> result;
        
        if (p.size() > s.size()) return result;
        
        // Count characters in p
        int pCount[26] = {};
        for (char c : p) {
            pCount[c - 'a']++;
        }
        
        // Check each window
        for (int i = 0; i <= s.size() - p.size(); i++) {
            // Count characters in current window
            int windowCount[26] = {};
            for (int j = i; j < i + p.size(); j++) {
                windowCount[s[j] - 'a']++;
            }
            
            // Check if it's an anagram
            bool isAnagram = true;
            for (int k = 0; k < 26; k++) {
                if (windowCount[k] != pCount[k]) {
                    isAnagram = false;
                    break;
                }
            }
            
            if (isAnagram) {
                result.push_back(i);
            }
        }
        
        return result;
    }
};`,
                    javascript: `function findAnagrams(s, p) {
    if (p.length > s.length) return [];
    
    // Count characters in p
    const pCount = new Array(26).fill(0);
    for (const char of p) {
        pCount[char.charCodeAt(0) - 97]++;
    }
    
    const result = [];
    
    // Check each window
    for (let i = 0; i <= s.length - p.length; i++) {
        // Count characters in current window
        const windowCount = new Array(26).fill(0);
        for (let j = i; j < i + p.length; j++) {
            windowCount[s.charCodeAt(j) - 97]++;
        }
        
        // Check if it's an anagram
        let isAnagram = true;
        for (let k = 0; k < 26; k++) {
            if (windowCount[k] !== pCount[k]) {
                isAnagram = false;
                break;
            }
        }
        
        if (isAnagram) {
            result.push(i);
        }
    }
    
    return result;
}`
                }
            },
            optimized: {
                intuition: "Use a sliding window of size p.length. Instead of recounting all characters for each window, maintain a frequency map and track how many characters match p's frequencies. Slide the window by removing the leftmost character and adding a new character on the right, updating the match count incrementally.",
                algorithm: [
                    "Count character frequencies in p and store required = 26 (or number of unique chars)",
                    "Initialize window frequency map and matches counter",
                    "Build initial window of size p.length:",
                    "  Add each character to window map",
                    "  If frequency matches p's frequency, increment matches",
                    "For each new position (sliding the window):",
                    "  If matches == 26 (or required unique chars), add current start index to result",
                    "  Remove leftmost character from window, update matches if needed",
                    "  Add new rightmost character, update matches if needed",
                    "  Increment window start position",
                    "Return result array"
                ],
                complexity: {
                    time: "O(n + m) where n is length of s and m is length of p. We process each character in s at most twice (once when adding to window, once when removing).",
                    space: "O(1) since we only use arrays of size 26 for lowercase English letters."
                },
                code: {
                    python: `def findAnagrams(s, p):
    if len(p) > len(s):
        return []
    
    # Count frequencies in p
    p_count = [0] * 26
    for char in p:
        p_count[ord(char) - ord('a')] += 1
    
    # Sliding window
    window_count = [0] * 26
    result = []
    
    # Build initial window
    for i in range(len(p)):
        window_count[ord(s[i]) - ord('a')] += 1
    
    # Check if initial window is anagram
    if window_count == p_count:
        result.append(0)
    
    # Slide the window
    for i in range(len(p), len(s)):
        # Add new character
        window_count[ord(s[i]) - ord('a')] += 1
        # Remove old character
        window_count[ord(s[i - len(p)]) - ord('a')] -= 1
        
        # Check if current window is anagram
        if window_count == p_count:
            result.append(i - len(p) + 1)
    
    return result`,
                    java: `class Solution {
    public List<Integer> findAnagrams(String s, String p) {
        List<Integer> result = new ArrayList<>();
        
        if (p.length() > s.length()) return result;
        
        // Count frequencies in p
        int[] pCount = new int[26];
        for (char c : p.toCharArray()) {
            pCount[c - 'a']++;
        }
        
        // Sliding window
        int[] windowCount = new int[26];
        
        // Build initial window
        for (int i = 0; i < p.length(); i++) {
            windowCount[s.charAt(i) - 'a']++;
        }
        
        // Check if initial window is anagram
        if (Arrays.equals(windowCount, pCount)) {
            result.add(0);
        }
        
        // Slide the window
        for (int i = p.length(); i < s.length(); i++) {
            // Add new character
            windowCount[s.charAt(i) - 'a']++;
            // Remove old character
            windowCount[s.charAt(i - p.length()) - 'a']--;
            
            // Check if current window is anagram
            if (Arrays.equals(windowCount, pCount)) {
                result.add(i - p.length() + 1);
            }
        }
        
        return result;
    }
}`,
                    cpp: `class Solution {
public:
    vector<int> findAnagrams(string s, string p) {
        vector<int> result;
        
        if (p.size() > s.size()) return result;
        
        // Count frequencies in p
        int pCount[26] = {};
        for (char c : p) {
            pCount[c - 'a']++;
        }
        
        // Sliding window
        int windowCount[26] = {};
        
        // Build initial window
        for (int i = 0; i < p.size(); i++) {
            windowCount[s[i] - 'a']++;
        }
        
        // Helper to compare arrays
        auto arraysEqual = [](int a[], int b[]) {
            for (int i = 0; i < 26; i++) {
                if (a[i] != b[i]) return false;
            }
            return true;
        };
        
        // Check if initial window is anagram
        if (arraysEqual(windowCount, pCount)) {
            result.push_back(0);
        }
        
        // Slide the window
        for (int i = p.size(); i < s.size(); i++) {
            // Add new character
            windowCount[s[i] - 'a']++;
            // Remove old character
            windowCount[s[i - p.size()] - 'a']--;
            
            // Check if current window is anagram
            if (arraysEqual(windowCount, pCount)) {
                result.push_back(i - p.size() + 1);
            }
        }
        
        return result;
    }
};`,
                    javascript: `function findAnagrams(s, p) {
    if (p.length > s.length) return [];
    
    // Count frequencies in p
    const pCount = new Array(26).fill(0);
    for (const char of p) {
        pCount[char.charCodeAt(0) - 97]++;
    }
    
    // Sliding window
    const windowCount = new Array(26).fill(0);
    const result = [];
    
    // Build initial window
    for (let i = 0; i < p.length; i++) {
        windowCount[s.charCodeAt(i) - 97]++;
    }
    
    // Helper to compare arrays
    const arraysEqual = (a, b) => {
        for (let i = 0; i < 26; i++) {
            if (a[i] !== b[i]) return false;
        }
        return true;
    };
    
    // Check if initial window is anagram
    if (arraysEqual(windowCount, pCount)) {
        result.push(0);
    }
    
    // Slide the window
    for (let i = p.length; i < s.length; i++) {
        // Add new character
        windowCount[s.charCodeAt(i) - 97]++;
        // Remove old character
        windowCount[s.charCodeAt(i - p.length) - 97]--;
        
        // Check if current window is anagram
        if (arraysEqual(windowCount, pCount)) {
            result.push(i - p.length + 1);
        }
    }
    
    return result;
}`
                }
            }
        }
    },
    "minimum-size-subarray-sum": {
        description: `<p>Given an array of positive integers <code>nums</code> and a positive integer <code>target</code>, return <em>the <strong>minimal length</strong> of a <strong>subarray</strong> whose sum is greater than or equal to</em> <code>target</code>. If there is no such subarray, return <code>0</code> instead.</p>
<p>A <strong>subarray</strong> is a contiguous part of the array. For example, if <code>nums = [2,3,1,2,4,3]</code> and <code>target = 7</code>, the subarray <code>[4,3]</code> has a sum of 7 and length 2, which is minimal.</p>
<p><strong>Key Challenge:</strong> Finding the shortest subarray efficiently. A naive approach checks all subarrays, but we can optimize using a sliding window that dynamically shrinks when the sum is valid.</p>`,
        examples: [
            {
                input: 'target = 7, nums = [2,3,1,2,4,3]',
                output: '2',
                explanation: 'The subarray [4,3] has the minimal length under the problem constraint.'
            },
            {
                input: 'target = 4, nums = [1,4,4]',
                output: '1',
                explanation: 'The subarray [4] has the minimal length of 1.'
            },
            {
                input: 'target = 11, nums = [1,1,1,1,1,1,1,1]',
                output: '0',
                explanation: 'No subarray sums to 11 or more, so we return 0.'
            },
            {
                input: 'target = 15, nums = [1,2,3,4,5]',
                output: '5',
                explanation: 'The entire array [1,2,3,4,5] has sum 15, which is the minimal length subarray.'
            }
        ],
        constraints: [
            "<code>1 <= target <= 10<sup>9</sup></code>",
            "<code>1 <= nums.length <= 10<sup>5</sup></code>",
            "<code>1 <= nums[i] <= 10<sup>4</sup></code>"
        ],
        solutions: {
            brute: {
                intuition: "Check every possible subarray, calculate its sum, and if it meets or exceeds the target, track the minimum length. This involves two nested loops to generate all subarrays.",
                algorithm: [
                    "Initialize minLength to infinity",
                    "For each starting index i from 0 to n-1:",
                    "  Initialize sum to 0",
                    "  For each ending index j from i to n-1:",
                    "    Add nums[j] to sum",
                    "    If sum >= target:",
                    "      Update minLength with min(minLength, j - i + 1)",
                    "      Break (no need to extend further)",
                    "Return minLength if found, else 0"
                ],
                complexity: {
                    time: "O(n¬≤) where n is the length of nums. We check all possible subarrays with two nested loops.",
                    space: "O(1) as we only use a few variables for tracking."
                },
                code: {
                    python: `def minSubArrayLen(target, nums):
    n = len(nums)
    min_length = float('inf')
    
    # Try all possible subarrays
    for i in range(n):
        current_sum = 0
        for j in range(i, n):
            current_sum += nums[j]
            
            # Check if current subarray meets target
            if current_sum >= target:
                min_length = min(min_length, j - i + 1)
                break  # No need to extend further
    
    return min_length if min_length != float('inf') else 0`,
                    java: `class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        int n = nums.length;
        int minLength = Integer.MAX_VALUE;
        
        // Try all possible subarrays
        for (int i = 0; i < n; i++) {
            int currentSum = 0;
            for (int j = i; j < n; j++) {
                currentSum += nums[j];
                
                // Check if current subarray meets target
                if (currentSum >= target) {
                    minLength = Math.min(minLength, j - i + 1);
                    break;  // No need to extend further
                }
            }
        }
        
        return minLength == Integer.MAX_VALUE ? 0 : minLength;
    }
}`,
                    cpp: `class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int n = nums.size();
        int minLength = INT_MAX;
        
        // Try all possible subarrays
        for (int i = 0; i < n; i++) {
            int currentSum = 0;
            for (int j = i; j < n; j++) {
                currentSum += nums[j];
                
                // Check if current subarray meets target
                if (currentSum >= target) {
                    minLength = min(minLength, j - i + 1);
                    break;  // No need to extend further
                }
            }
        }
        
        return minLength == INT_MAX ? 0 : minLength;
    }
};`,
                    javascript: `function minSubArrayLen(target, nums) {
    const n = nums.length;
    let minLength = Infinity;
    
    // Try all possible subarrays
    for (let i = 0; i < n; i++) {
        let currentSum = 0;
        for (let j = i; j < n; j++) {
            currentSum += nums[j];
            
            // Check if current subarray meets target
            if (currentSum >= target) {
                minLength = Math.min(minLength, j - i + 1);
                break;  // No need to extend further
            }
        }
    }
    
    return minLength === Infinity ? 0 : minLength;
}`
                }
            },
            optimized: {
                intuition: "Use a dynamic sliding window. Expand the window by moving the right pointer and adding elements until the sum meets the target. Then shrink from the left while the sum still meets the target, tracking the minimum length. This ensures each element is processed at most twice.",
                algorithm: [
                    "Initialize left = 0, sum = 0, minLength = infinity",
                    "For right pointer from 0 to n-1:",
                    "  Add nums[right] to sum",
                    "  While sum >= target:",
                    "    Update minLength with min(minLength, right - left + 1)",
                    "    Subtract nums[left] from sum",
                    "    Increment left",
                    "Return minLength if found, else 0"
                ],
                complexity: {
                    time: "O(n) where n is the length of nums. Each element is visited at most twice (once by right pointer, once by left pointer).",
                    space: "O(1) as we only use a few variables."
                },
                code: {
                    python: `def minSubArrayLen(target, nums):
    n = len(nums)
    left = 0
    current_sum = 0
    min_length = float('inf')
    
    # Sliding window
    for right in range(n):
        # Expand window
        current_sum += nums[right]
        
        # Shrink window while valid
        while current_sum >= target:
            min_length = min(min_length, right - left + 1)
            current_sum -= nums[left]
            left += 1
    
    return min_length if min_length != float('inf') else 0`,
                    java: `class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        int n = nums.length;
        int left = 0;
        int currentSum = 0;
        int minLength = Integer.MAX_VALUE;
        
        // Sliding window
        for (int right = 0; right < n; right++) {
            // Expand window
            currentSum += nums[right];
            
            // Shrink window while valid
            while (currentSum >= target) {
                minLength = Math.min(minLength, right - left + 1);
                currentSum -= nums[left];
                left++;
            }
        }
        
        return minLength == Integer.MAX_VALUE ? 0 : minLength;
    }
}`,
                    cpp: `class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int n = nums.size();
        int left = 0;
        int currentSum = 0;
        int minLength = INT_MAX;
        
        // Sliding window
        for (int right = 0; right < n; right++) {
            // Expand window
            currentSum += nums[right];
            
            // Shrink window while valid
            while (currentSum >= target) {
                minLength = min(minLength, right - left + 1);
                currentSum -= nums[left];
                left++;
            }
        }
        
        return minLength == INT_MAX ? 0 : minLength;
    }
};`,
                    javascript: `function minSubArrayLen(target, nums) {
    const n = nums.length;
    let left = 0;
    let currentSum = 0;
    let minLength = Infinity;
    
    // Sliding window
    for (let right = 0; right < n; right++) {
        // Expand window
        currentSum += nums[right];
        
        // Shrink window while valid
        while (currentSum >= target) {
            minLength = Math.min(minLength, right - left + 1);
            currentSum -= nums[left];
            left++;
        }
    }
    
    return minLength === Infinity ? 0 : minLength;
}`
                }
            }
        }
    },
    "fruit-into-baskets": {
        description: `<p>You are visiting a farm that has a single row of fruit trees arranged from left to right. The trees are represented by an integer array <code>fruits</code> where <code>fruits[i]</code> is the <strong>type</strong> of fruit the <code>i<sup>th</sup></code> tree produces.</p>
<p>You want to collect as much fruit as possible. However, the owner has the following strict rules:</p>
<ul>
<li>You only have <strong>two baskets</strong>, and each basket can only hold a <strong>single type</strong> of fruit. There is no limit on the amount of fruit each basket can hold.</li>
<li>Starting from any tree of your choice, you must pick <strong>exactly one fruit from every tree</strong> (including the start tree) while moving to the right. The picked fruits must fit in one of your baskets.</li>
<li>Once you reach a tree with fruit that cannot fit in your baskets, you must stop.</li>
</ul>
<p>Given the integer array <code>fruits</code>, return <em>the <strong>maximum number</strong> of fruits you can pick</em>.</p>
<p><strong>Key Insight:</strong> This is equivalent to finding the longest subarray with at most 2 distinct elements. Use a sliding window that tracks types of fruits and shrinks when we have more than 2 types.</p>`,
        examples: [
            {
                input: 'fruits = [1,2,1]',
                output: '3',
                explanation: 'We can pick from all 3 trees. We have fruits of type 1 and 2, which fits in 2 baskets.'
            },
            {
                input: 'fruits = [0,1,2,2]',
                output: '3',
                explanation: 'We can pick from trees [1,2,2]. We cannot pick from tree 0 because we would have 3 types of fruit.'
            },
            {
                input: 'fruits = [1,2,3,2,2]',
                output: '4',
                explanation: 'We can pick from trees [2,3,2,2]. Starting from index 1, we have only 2 types (2 and 3).'
            },
            {
                input: 'fruits = [3,3,3,1,2,1,1,2,3,3,4]',
                output: '5',
                explanation: 'We can pick from trees [1,2,1,1,2]. This is the longest subarray with at most 2 distinct fruit types.'
            }
        ],
        constraints: [
            "<code>1 <= fruits.length <= 10<sup>5</sup></code>",
            "<code>0 <= fruits[i] < fruits.length</code>"
        ],
        solutions: {
            brute: {
                intuition: "For each starting position, try to collect fruits going right. Keep track of distinct fruit types using a set or map. Stop when we encounter a third type, and track the maximum length achieved.",
                algorithm: [
                    "Initialize maxLength to 0",
                    "For each starting index i from 0 to n-1:",
                    "  Initialize a frequency map for current window",
                    "  For each ending index j from i to n-1:",
                    "    Add fruits[j] to frequency map",
                    "    If map has more than 2 distinct types, break",
                    "    Update maxLength with max(maxLength, j - i + 1)",
                    "Return maxLength"
                ],
                complexity: {
                    time: "O(n¬≤) where n is the length of fruits. We try all possible starting positions and extend each one.",
                    space: "O(1) since we store at most 3 fruit types in the map at any time."
                },
                code: {
                    python: `def totalFruit(fruits):
    n = len(fruits)
    max_length = 0
    
    # Try all starting positions
    for i in range(n):
        fruit_count = {}
        
        # Extend from starting position
        for j in range(i, n):
            fruit_type = fruits[j]
            fruit_count[fruit_type] = fruit_count.get(fruit_type, 0) + 1
            
            # Check if we have more than 2 types
            if len(fruit_count) > 2:
                break
            
            # Update max length
            max_length = max(max_length, j - i + 1)
    
    return max_length`,
                    java: `class Solution {
    public int totalFruit(int[] fruits) {
        int n = fruits.length;
        int maxLength = 0;
        
        // Try all starting positions
        for (int i = 0; i < n; i++) {
            Map<Integer, Integer> fruitCount = new HashMap<>();
            
            // Extend from starting position
            for (int j = i; j < n; j++) {
                int fruitType = fruits[j];
                fruitCount.put(fruitType, fruitCount.getOrDefault(fruitType, 0) + 1);
                
                // Check if we have more than 2 types
                if (fruitCount.size() > 2) {
                    break;
                }
                
                // Update max length
                maxLength = Math.max(maxLength, j - i + 1);
            }
        }
        
        return maxLength;
    }
}`,
                    cpp: `class Solution {
public:
    int totalFruit(vector<int>& fruits) {
        int n = fruits.size();
        int maxLength = 0;
        
        // Try all starting positions
        for (int i = 0; i < n; i++) {
            unordered_map<int, int> fruitCount;
            
            // Extend from starting position
            for (int j = i; j < n; j++) {
                int fruitType = fruits[j];
                fruitCount[fruitType]++;
                
                // Check if we have more than 2 types
                if (fruitCount.size() > 2) {
                    break;
                }
                
                // Update max length
                maxLength = max(maxLength, j - i + 1);
            }
        }
        
        return maxLength;
    }
};`,
                    javascript: `function totalFruit(fruits) {
    const n = fruits.length;
    let maxLength = 0;
    
    // Try all starting positions
    for (let i = 0; i < n; i++) {
        const fruitCount = new Map();
        
        // Extend from starting position
        for (let j = i; j < n; j++) {
            const fruitType = fruits[j];
            fruitCount.set(fruitType, (fruitCount.get(fruitType) || 0) + 1);
            
            // Check if we have more than 2 types
            if (fruitCount.size > 2) {
                break;
            }
            
            // Update max length
            maxLength = Math.max(maxLength, j - i + 1);
        }
    }
    
    return maxLength;
}`
                }
            },
            optimized: {
                intuition: "Use a sliding window with two pointers. Maintain a frequency map of fruit types in the current window. Expand the window by moving the right pointer. When we have more than 2 types, shrink from the left until we have at most 2 types again. Track the maximum window size.",
                algorithm: [
                    "Initialize left = 0, maxLength = 0, frequency map",
                    "For right pointer from 0 to n-1:",
                    "  Add fruits[right] to frequency map",
                    "  While map has more than 2 distinct types:",
                    "    Remove fruits[left] from map (decrement count)",
                    "    If count becomes 0, remove the type from map",
                    "    Increment left",
                    "  Update maxLength with max(maxLength, right - left + 1)",
                    "Return maxLength"
                ],
                complexity: {
                    time: "O(n) where n is the length of fruits. Each element is added and removed from the window at most once.",
                    space: "O(1) since we store at most 3 fruit types in the map (briefly when shrinking)."
                },
                code: {
                    python: `def totalFruit(fruits):
    left = 0
    max_length = 0
    fruit_count = {}
    
    # Sliding window
    for right in range(len(fruits)):
        # Add current fruit
        fruit_type = fruits[right]
        fruit_count[fruit_type] = fruit_count.get(fruit_type, 0) + 1
        
        # Shrink window if more than 2 types
        while len(fruit_count) > 2:
            left_fruit = fruits[left]
            fruit_count[left_fruit] -= 1
            
            # Remove type if count becomes 0
            if fruit_count[left_fruit] == 0:
                del fruit_count[left_fruit]
            
            left += 1
        
        # Update max length
        max_length = max(max_length, right - left + 1)
    
    return max_length`,
                    java: `class Solution {
    public int totalFruit(int[] fruits) {
        int left = 0;
        int maxLength = 0;
        Map<Integer, Integer> fruitCount = new HashMap<>();
        
        // Sliding window
        for (int right = 0; right < fruits.length; right++) {
            // Add current fruit
            int fruitType = fruits[right];
            fruitCount.put(fruitType, fruitCount.getOrDefault(fruitType, 0) + 1);
            
            // Shrink window if more than 2 types
            while (fruitCount.size() > 2) {
                int leftFruit = fruits[left];
                fruitCount.put(leftFruit, fruitCount.get(leftFruit) - 1);
                
                // Remove type if count becomes 0
                if (fruitCount.get(leftFruit) == 0) {
                    fruitCount.remove(leftFruit);
                }
                
                left++;
            }
            
            // Update max length
            maxLength = Math.max(maxLength, right - left + 1);
        }
        
        return maxLength;
    }
}`,
                    cpp: `class Solution {
public:
    int totalFruit(vector<int>& fruits) {
        int left = 0;
        int maxLength = 0;
        unordered_map<int, int> fruitCount;
        
        // Sliding window
        for (int right = 0; right < fruits.size(); right++) {
            // Add current fruit
            int fruitType = fruits[right];
            fruitCount[fruitType]++;
            
            // Shrink window if more than 2 types
            while (fruitCount.size() > 2) {
                int leftFruit = fruits[left];
                fruitCount[leftFruit]--;
                
                // Remove type if count becomes 0
                if (fruitCount[leftFruit] == 0) {
                    fruitCount.erase(leftFruit);
                }
                
                left++;
            }
            
            // Update max length
            maxLength = max(maxLength, right - left + 1);
        }
        
        return maxLength;
    }
};`,
                    javascript: `function totalFruit(fruits) {
    let left = 0;
    let maxLength = 0;
    const fruitCount = new Map();
    
    // Sliding window
    for (let right = 0; right < fruits.length; right++) {
        // Add current fruit
        const fruitType = fruits[right];
        fruitCount.set(fruitType, (fruitCount.get(fruitType) || 0) + 1);
        
        // Shrink window if more than 2 types
        while (fruitCount.size > 2) {
            const leftFruit = fruits[left];
            fruitCount.set(leftFruit, fruitCount.get(leftFruit) - 1);
            
            // Remove type if count becomes 0
            if (fruitCount.get(leftFruit) === 0) {
                fruitCount.delete(leftFruit);
            }
            
            left++;
        }
        
        // Update max length
        maxLength = Math.max(maxLength, right - left + 1);
    }
    
    return maxLength;
}`
                }
            }
        }
    }
};

/**
 * Update all problems in the database with their complete solutions
 */
async function updateAllSolutions() {
    console.log('\nüöÄ Updating ALL Problem Solutions in Database...\n');
    
    let updated = 0;
    let notFound = 0;
    let errors = 0;
    const notFoundProblems = [];
    
    for (const [slug, data] of Object.entries(SOLUTIONS)) {
        try {
            const result = await prisma.problem.updateMany({
                where: { slug },
                data: {
                    description: data.description,
                    examples: data.examples,
                    constraints: data.constraints,
                    solutions: data.solutions
                }
            });
            
            if (result.count > 0) {
                console.log(`   ‚úÖ ${slug}`);
                updated++;
            } else {
                console.log(`   ‚ö†Ô∏è  ${slug} - not found in database`);
                notFound++;
                notFoundProblems.push(slug);
            }
        } catch (e) {
            console.error(`   ‚ùå ${slug}: ${e.message}`);
            errors++;
        }
    }
    
    console.log(`\n${'='.repeat(70)}`);
    console.log('üìä FINAL RESULTS:');
    console.log(`   ‚úÖ Successfully Updated: ${updated}/${Object.keys(SOLUTIONS).length}`);
    if (notFound > 0) {
        console.log(`   ‚ö†Ô∏è  Not Found in DB: ${notFound}`);
        console.log(`\n   Missing problems:`);
        notFoundProblems.forEach(p => console.log(`      - ${p}`));
    }
    if (errors > 0) console.log(`   ‚ùå Errors: ${errors}`);
    console.log(`${'='.repeat(70)}\n`);
    
    console.log(`‚ú® Solution update complete!`);
    console.log(`   View solutions at: http://localhost:3000/dsa/solution/[problem-slug]\n`);
}

// Run if executed directly
if (require.main === module) {
    updateAllSolutions()
        .catch(err => {
            console.error('‚ùå Fatal error:', err);
            process.exit(1);
        })
        .finally(() => prisma.$disconnect());
}

// Export for use in other scripts
module.exports = { SOLUTIONS, updateAllSolutions };
