
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model DSATopic
 * 
 */
export type DSATopic = $Result.DefaultSelection<Prisma.$DSATopicPayload>
/**
 * Model DSALesson
 * 
 */
export type DSALesson = $Result.DefaultSelection<Prisma.$DSALessonPayload>
/**
 * Model Problem
 * 
 */
export type Problem = $Result.DefaultSelection<Prisma.$ProblemPayload>
/**
 * Model UserProgress
 * 
 */
export type UserProgress = $Result.DefaultSelection<Prisma.$UserProgressPayload>
/**
 * Model Submission
 * 
 */
export type Submission = $Result.DefaultSelection<Prisma.$SubmissionPayload>
/**
 * Model LearnDomain
 * 
 */
export type LearnDomain = $Result.DefaultSelection<Prisma.$LearnDomainPayload>
/**
 * Model LearnCategory
 * 
 */
export type LearnCategory = $Result.DefaultSelection<Prisma.$LearnCategoryPayload>
/**
 * Model LearnTopic
 * 
 */
export type LearnTopic = $Result.DefaultSelection<Prisma.$LearnTopicPayload>
/**
 * Model InterviewSession
 * 
 */
export type InterviewSession = $Result.DefaultSelection<Prisma.$InterviewSessionPayload>
/**
 * Model InterviewFeedback
 * 
 */
export type InterviewFeedback = $Result.DefaultSelection<Prisma.$InterviewFeedbackPayload>
/**
 * Model QuestionBank
 * 
 */
export type QuestionBank = $Result.DefaultSelection<Prisma.$QuestionBankPayload>
/**
 * Model SharedInterviewResult
 * 
 */
export type SharedInterviewResult = $Result.DefaultSelection<Prisma.$SharedInterviewResultPayload>
/**
 * Model InterviewAnalytics
 * 
 */
export type InterviewAnalytics = $Result.DefaultSelection<Prisma.$InterviewAnalyticsPayload>
/**
 * Model Roadmap
 * 
 */
export type Roadmap = $Result.DefaultSelection<Prisma.$RoadmapPayload>
/**
 * Model RoadmapPhase
 * 
 */
export type RoadmapPhase = $Result.DefaultSelection<Prisma.$RoadmapPhasePayload>
/**
 * Model RoadmapStep
 * 
 */
export type RoadmapStep = $Result.DefaultSelection<Prisma.$RoadmapStepPayload>
/**
 * Model RoadmapProgress
 * 
 */
export type RoadmapProgress = $Result.DefaultSelection<Prisma.$RoadmapProgressPayload>
/**
 * Model CheatsheetCategory
 * 
 */
export type CheatsheetCategory = $Result.DefaultSelection<Prisma.$CheatsheetCategoryPayload>
/**
 * Model Cheatsheet
 * 
 */
export type Cheatsheet = $Result.DefaultSelection<Prisma.$CheatsheetPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.dSATopic`: Exposes CRUD operations for the **DSATopic** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DSATopics
    * const dSATopics = await prisma.dSATopic.findMany()
    * ```
    */
  get dSATopic(): Prisma.DSATopicDelegate<ExtArgs>;

  /**
   * `prisma.dSALesson`: Exposes CRUD operations for the **DSALesson** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DSALessons
    * const dSALessons = await prisma.dSALesson.findMany()
    * ```
    */
  get dSALesson(): Prisma.DSALessonDelegate<ExtArgs>;

  /**
   * `prisma.problem`: Exposes CRUD operations for the **Problem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Problems
    * const problems = await prisma.problem.findMany()
    * ```
    */
  get problem(): Prisma.ProblemDelegate<ExtArgs>;

  /**
   * `prisma.userProgress`: Exposes CRUD operations for the **UserProgress** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserProgresses
    * const userProgresses = await prisma.userProgress.findMany()
    * ```
    */
  get userProgress(): Prisma.UserProgressDelegate<ExtArgs>;

  /**
   * `prisma.submission`: Exposes CRUD operations for the **Submission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Submissions
    * const submissions = await prisma.submission.findMany()
    * ```
    */
  get submission(): Prisma.SubmissionDelegate<ExtArgs>;

  /**
   * `prisma.learnDomain`: Exposes CRUD operations for the **LearnDomain** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LearnDomains
    * const learnDomains = await prisma.learnDomain.findMany()
    * ```
    */
  get learnDomain(): Prisma.LearnDomainDelegate<ExtArgs>;

  /**
   * `prisma.learnCategory`: Exposes CRUD operations for the **LearnCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LearnCategories
    * const learnCategories = await prisma.learnCategory.findMany()
    * ```
    */
  get learnCategory(): Prisma.LearnCategoryDelegate<ExtArgs>;

  /**
   * `prisma.learnTopic`: Exposes CRUD operations for the **LearnTopic** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LearnTopics
    * const learnTopics = await prisma.learnTopic.findMany()
    * ```
    */
  get learnTopic(): Prisma.LearnTopicDelegate<ExtArgs>;

  /**
   * `prisma.interviewSession`: Exposes CRUD operations for the **InterviewSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InterviewSessions
    * const interviewSessions = await prisma.interviewSession.findMany()
    * ```
    */
  get interviewSession(): Prisma.InterviewSessionDelegate<ExtArgs>;

  /**
   * `prisma.interviewFeedback`: Exposes CRUD operations for the **InterviewFeedback** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InterviewFeedbacks
    * const interviewFeedbacks = await prisma.interviewFeedback.findMany()
    * ```
    */
  get interviewFeedback(): Prisma.InterviewFeedbackDelegate<ExtArgs>;

  /**
   * `prisma.questionBank`: Exposes CRUD operations for the **QuestionBank** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuestionBanks
    * const questionBanks = await prisma.questionBank.findMany()
    * ```
    */
  get questionBank(): Prisma.QuestionBankDelegate<ExtArgs>;

  /**
   * `prisma.sharedInterviewResult`: Exposes CRUD operations for the **SharedInterviewResult** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SharedInterviewResults
    * const sharedInterviewResults = await prisma.sharedInterviewResult.findMany()
    * ```
    */
  get sharedInterviewResult(): Prisma.SharedInterviewResultDelegate<ExtArgs>;

  /**
   * `prisma.interviewAnalytics`: Exposes CRUD operations for the **InterviewAnalytics** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InterviewAnalytics
    * const interviewAnalytics = await prisma.interviewAnalytics.findMany()
    * ```
    */
  get interviewAnalytics(): Prisma.InterviewAnalyticsDelegate<ExtArgs>;

  /**
   * `prisma.roadmap`: Exposes CRUD operations for the **Roadmap** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roadmaps
    * const roadmaps = await prisma.roadmap.findMany()
    * ```
    */
  get roadmap(): Prisma.RoadmapDelegate<ExtArgs>;

  /**
   * `prisma.roadmapPhase`: Exposes CRUD operations for the **RoadmapPhase** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RoadmapPhases
    * const roadmapPhases = await prisma.roadmapPhase.findMany()
    * ```
    */
  get roadmapPhase(): Prisma.RoadmapPhaseDelegate<ExtArgs>;

  /**
   * `prisma.roadmapStep`: Exposes CRUD operations for the **RoadmapStep** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RoadmapSteps
    * const roadmapSteps = await prisma.roadmapStep.findMany()
    * ```
    */
  get roadmapStep(): Prisma.RoadmapStepDelegate<ExtArgs>;

  /**
   * `prisma.roadmapProgress`: Exposes CRUD operations for the **RoadmapProgress** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RoadmapProgresses
    * const roadmapProgresses = await prisma.roadmapProgress.findMany()
    * ```
    */
  get roadmapProgress(): Prisma.RoadmapProgressDelegate<ExtArgs>;

  /**
   * `prisma.cheatsheetCategory`: Exposes CRUD operations for the **CheatsheetCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CheatsheetCategories
    * const cheatsheetCategories = await prisma.cheatsheetCategory.findMany()
    * ```
    */
  get cheatsheetCategory(): Prisma.CheatsheetCategoryDelegate<ExtArgs>;

  /**
   * `prisma.cheatsheet`: Exposes CRUD operations for the **Cheatsheet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cheatsheets
    * const cheatsheets = await prisma.cheatsheet.findMany()
    * ```
    */
  get cheatsheet(): Prisma.CheatsheetDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    DSATopic: 'DSATopic',
    DSALesson: 'DSALesson',
    Problem: 'Problem',
    UserProgress: 'UserProgress',
    Submission: 'Submission',
    LearnDomain: 'LearnDomain',
    LearnCategory: 'LearnCategory',
    LearnTopic: 'LearnTopic',
    InterviewSession: 'InterviewSession',
    InterviewFeedback: 'InterviewFeedback',
    QuestionBank: 'QuestionBank',
    SharedInterviewResult: 'SharedInterviewResult',
    InterviewAnalytics: 'InterviewAnalytics',
    Roadmap: 'Roadmap',
    RoadmapPhase: 'RoadmapPhase',
    RoadmapStep: 'RoadmapStep',
    RoadmapProgress: 'RoadmapProgress',
    CheatsheetCategory: 'CheatsheetCategory',
    Cheatsheet: 'Cheatsheet'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "dSATopic" | "dSALesson" | "problem" | "userProgress" | "submission" | "learnDomain" | "learnCategory" | "learnTopic" | "interviewSession" | "interviewFeedback" | "questionBank" | "sharedInterviewResult" | "interviewAnalytics" | "roadmap" | "roadmapPhase" | "roadmapStep" | "roadmapProgress" | "cheatsheetCategory" | "cheatsheet"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      DSATopic: {
        payload: Prisma.$DSATopicPayload<ExtArgs>
        fields: Prisma.DSATopicFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DSATopicFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DSATopicPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DSATopicFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DSATopicPayload>
          }
          findFirst: {
            args: Prisma.DSATopicFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DSATopicPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DSATopicFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DSATopicPayload>
          }
          findMany: {
            args: Prisma.DSATopicFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DSATopicPayload>[]
          }
          create: {
            args: Prisma.DSATopicCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DSATopicPayload>
          }
          createMany: {
            args: Prisma.DSATopicCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DSATopicCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DSATopicPayload>[]
          }
          delete: {
            args: Prisma.DSATopicDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DSATopicPayload>
          }
          update: {
            args: Prisma.DSATopicUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DSATopicPayload>
          }
          deleteMany: {
            args: Prisma.DSATopicDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DSATopicUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DSATopicUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DSATopicPayload>
          }
          aggregate: {
            args: Prisma.DSATopicAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDSATopic>
          }
          groupBy: {
            args: Prisma.DSATopicGroupByArgs<ExtArgs>
            result: $Utils.Optional<DSATopicGroupByOutputType>[]
          }
          count: {
            args: Prisma.DSATopicCountArgs<ExtArgs>
            result: $Utils.Optional<DSATopicCountAggregateOutputType> | number
          }
        }
      }
      DSALesson: {
        payload: Prisma.$DSALessonPayload<ExtArgs>
        fields: Prisma.DSALessonFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DSALessonFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DSALessonPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DSALessonFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DSALessonPayload>
          }
          findFirst: {
            args: Prisma.DSALessonFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DSALessonPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DSALessonFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DSALessonPayload>
          }
          findMany: {
            args: Prisma.DSALessonFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DSALessonPayload>[]
          }
          create: {
            args: Prisma.DSALessonCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DSALessonPayload>
          }
          createMany: {
            args: Prisma.DSALessonCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DSALessonCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DSALessonPayload>[]
          }
          delete: {
            args: Prisma.DSALessonDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DSALessonPayload>
          }
          update: {
            args: Prisma.DSALessonUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DSALessonPayload>
          }
          deleteMany: {
            args: Prisma.DSALessonDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DSALessonUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DSALessonUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DSALessonPayload>
          }
          aggregate: {
            args: Prisma.DSALessonAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDSALesson>
          }
          groupBy: {
            args: Prisma.DSALessonGroupByArgs<ExtArgs>
            result: $Utils.Optional<DSALessonGroupByOutputType>[]
          }
          count: {
            args: Prisma.DSALessonCountArgs<ExtArgs>
            result: $Utils.Optional<DSALessonCountAggregateOutputType> | number
          }
        }
      }
      Problem: {
        payload: Prisma.$ProblemPayload<ExtArgs>
        fields: Prisma.ProblemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProblemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProblemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProblemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProblemPayload>
          }
          findFirst: {
            args: Prisma.ProblemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProblemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProblemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProblemPayload>
          }
          findMany: {
            args: Prisma.ProblemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProblemPayload>[]
          }
          create: {
            args: Prisma.ProblemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProblemPayload>
          }
          createMany: {
            args: Prisma.ProblemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProblemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProblemPayload>[]
          }
          delete: {
            args: Prisma.ProblemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProblemPayload>
          }
          update: {
            args: Prisma.ProblemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProblemPayload>
          }
          deleteMany: {
            args: Prisma.ProblemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProblemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProblemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProblemPayload>
          }
          aggregate: {
            args: Prisma.ProblemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProblem>
          }
          groupBy: {
            args: Prisma.ProblemGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProblemGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProblemCountArgs<ExtArgs>
            result: $Utils.Optional<ProblemCountAggregateOutputType> | number
          }
        }
      }
      UserProgress: {
        payload: Prisma.$UserProgressPayload<ExtArgs>
        fields: Prisma.UserProgressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserProgressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProgressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserProgressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProgressPayload>
          }
          findFirst: {
            args: Prisma.UserProgressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProgressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserProgressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProgressPayload>
          }
          findMany: {
            args: Prisma.UserProgressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProgressPayload>[]
          }
          create: {
            args: Prisma.UserProgressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProgressPayload>
          }
          createMany: {
            args: Prisma.UserProgressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserProgressCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProgressPayload>[]
          }
          delete: {
            args: Prisma.UserProgressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProgressPayload>
          }
          update: {
            args: Prisma.UserProgressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProgressPayload>
          }
          deleteMany: {
            args: Prisma.UserProgressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserProgressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserProgressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProgressPayload>
          }
          aggregate: {
            args: Prisma.UserProgressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserProgress>
          }
          groupBy: {
            args: Prisma.UserProgressGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserProgressGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserProgressCountArgs<ExtArgs>
            result: $Utils.Optional<UserProgressCountAggregateOutputType> | number
          }
        }
      }
      Submission: {
        payload: Prisma.$SubmissionPayload<ExtArgs>
        fields: Prisma.SubmissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubmissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubmissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubmissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubmissionPayload>
          }
          findFirst: {
            args: Prisma.SubmissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubmissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubmissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubmissionPayload>
          }
          findMany: {
            args: Prisma.SubmissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubmissionPayload>[]
          }
          create: {
            args: Prisma.SubmissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubmissionPayload>
          }
          createMany: {
            args: Prisma.SubmissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubmissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubmissionPayload>[]
          }
          delete: {
            args: Prisma.SubmissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubmissionPayload>
          }
          update: {
            args: Prisma.SubmissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubmissionPayload>
          }
          deleteMany: {
            args: Prisma.SubmissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubmissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SubmissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubmissionPayload>
          }
          aggregate: {
            args: Prisma.SubmissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubmission>
          }
          groupBy: {
            args: Prisma.SubmissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubmissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubmissionCountArgs<ExtArgs>
            result: $Utils.Optional<SubmissionCountAggregateOutputType> | number
          }
        }
      }
      LearnDomain: {
        payload: Prisma.$LearnDomainPayload<ExtArgs>
        fields: Prisma.LearnDomainFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LearnDomainFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearnDomainPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LearnDomainFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearnDomainPayload>
          }
          findFirst: {
            args: Prisma.LearnDomainFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearnDomainPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LearnDomainFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearnDomainPayload>
          }
          findMany: {
            args: Prisma.LearnDomainFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearnDomainPayload>[]
          }
          create: {
            args: Prisma.LearnDomainCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearnDomainPayload>
          }
          createMany: {
            args: Prisma.LearnDomainCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LearnDomainCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearnDomainPayload>[]
          }
          delete: {
            args: Prisma.LearnDomainDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearnDomainPayload>
          }
          update: {
            args: Prisma.LearnDomainUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearnDomainPayload>
          }
          deleteMany: {
            args: Prisma.LearnDomainDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LearnDomainUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LearnDomainUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearnDomainPayload>
          }
          aggregate: {
            args: Prisma.LearnDomainAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLearnDomain>
          }
          groupBy: {
            args: Prisma.LearnDomainGroupByArgs<ExtArgs>
            result: $Utils.Optional<LearnDomainGroupByOutputType>[]
          }
          count: {
            args: Prisma.LearnDomainCountArgs<ExtArgs>
            result: $Utils.Optional<LearnDomainCountAggregateOutputType> | number
          }
        }
      }
      LearnCategory: {
        payload: Prisma.$LearnCategoryPayload<ExtArgs>
        fields: Prisma.LearnCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LearnCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearnCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LearnCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearnCategoryPayload>
          }
          findFirst: {
            args: Prisma.LearnCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearnCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LearnCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearnCategoryPayload>
          }
          findMany: {
            args: Prisma.LearnCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearnCategoryPayload>[]
          }
          create: {
            args: Prisma.LearnCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearnCategoryPayload>
          }
          createMany: {
            args: Prisma.LearnCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LearnCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearnCategoryPayload>[]
          }
          delete: {
            args: Prisma.LearnCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearnCategoryPayload>
          }
          update: {
            args: Prisma.LearnCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearnCategoryPayload>
          }
          deleteMany: {
            args: Prisma.LearnCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LearnCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LearnCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearnCategoryPayload>
          }
          aggregate: {
            args: Prisma.LearnCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLearnCategory>
          }
          groupBy: {
            args: Prisma.LearnCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<LearnCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.LearnCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<LearnCategoryCountAggregateOutputType> | number
          }
        }
      }
      LearnTopic: {
        payload: Prisma.$LearnTopicPayload<ExtArgs>
        fields: Prisma.LearnTopicFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LearnTopicFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearnTopicPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LearnTopicFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearnTopicPayload>
          }
          findFirst: {
            args: Prisma.LearnTopicFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearnTopicPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LearnTopicFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearnTopicPayload>
          }
          findMany: {
            args: Prisma.LearnTopicFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearnTopicPayload>[]
          }
          create: {
            args: Prisma.LearnTopicCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearnTopicPayload>
          }
          createMany: {
            args: Prisma.LearnTopicCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LearnTopicCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearnTopicPayload>[]
          }
          delete: {
            args: Prisma.LearnTopicDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearnTopicPayload>
          }
          update: {
            args: Prisma.LearnTopicUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearnTopicPayload>
          }
          deleteMany: {
            args: Prisma.LearnTopicDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LearnTopicUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LearnTopicUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LearnTopicPayload>
          }
          aggregate: {
            args: Prisma.LearnTopicAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLearnTopic>
          }
          groupBy: {
            args: Prisma.LearnTopicGroupByArgs<ExtArgs>
            result: $Utils.Optional<LearnTopicGroupByOutputType>[]
          }
          count: {
            args: Prisma.LearnTopicCountArgs<ExtArgs>
            result: $Utils.Optional<LearnTopicCountAggregateOutputType> | number
          }
        }
      }
      InterviewSession: {
        payload: Prisma.$InterviewSessionPayload<ExtArgs>
        fields: Prisma.InterviewSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InterviewSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InterviewSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewSessionPayload>
          }
          findFirst: {
            args: Prisma.InterviewSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InterviewSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewSessionPayload>
          }
          findMany: {
            args: Prisma.InterviewSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewSessionPayload>[]
          }
          create: {
            args: Prisma.InterviewSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewSessionPayload>
          }
          createMany: {
            args: Prisma.InterviewSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InterviewSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewSessionPayload>[]
          }
          delete: {
            args: Prisma.InterviewSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewSessionPayload>
          }
          update: {
            args: Prisma.InterviewSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewSessionPayload>
          }
          deleteMany: {
            args: Prisma.InterviewSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InterviewSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InterviewSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewSessionPayload>
          }
          aggregate: {
            args: Prisma.InterviewSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInterviewSession>
          }
          groupBy: {
            args: Prisma.InterviewSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<InterviewSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.InterviewSessionCountArgs<ExtArgs>
            result: $Utils.Optional<InterviewSessionCountAggregateOutputType> | number
          }
        }
      }
      InterviewFeedback: {
        payload: Prisma.$InterviewFeedbackPayload<ExtArgs>
        fields: Prisma.InterviewFeedbackFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InterviewFeedbackFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewFeedbackPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InterviewFeedbackFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewFeedbackPayload>
          }
          findFirst: {
            args: Prisma.InterviewFeedbackFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewFeedbackPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InterviewFeedbackFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewFeedbackPayload>
          }
          findMany: {
            args: Prisma.InterviewFeedbackFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewFeedbackPayload>[]
          }
          create: {
            args: Prisma.InterviewFeedbackCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewFeedbackPayload>
          }
          createMany: {
            args: Prisma.InterviewFeedbackCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InterviewFeedbackCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewFeedbackPayload>[]
          }
          delete: {
            args: Prisma.InterviewFeedbackDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewFeedbackPayload>
          }
          update: {
            args: Prisma.InterviewFeedbackUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewFeedbackPayload>
          }
          deleteMany: {
            args: Prisma.InterviewFeedbackDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InterviewFeedbackUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InterviewFeedbackUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewFeedbackPayload>
          }
          aggregate: {
            args: Prisma.InterviewFeedbackAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInterviewFeedback>
          }
          groupBy: {
            args: Prisma.InterviewFeedbackGroupByArgs<ExtArgs>
            result: $Utils.Optional<InterviewFeedbackGroupByOutputType>[]
          }
          count: {
            args: Prisma.InterviewFeedbackCountArgs<ExtArgs>
            result: $Utils.Optional<InterviewFeedbackCountAggregateOutputType> | number
          }
        }
      }
      QuestionBank: {
        payload: Prisma.$QuestionBankPayload<ExtArgs>
        fields: Prisma.QuestionBankFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuestionBankFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionBankPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuestionBankFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionBankPayload>
          }
          findFirst: {
            args: Prisma.QuestionBankFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionBankPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuestionBankFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionBankPayload>
          }
          findMany: {
            args: Prisma.QuestionBankFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionBankPayload>[]
          }
          create: {
            args: Prisma.QuestionBankCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionBankPayload>
          }
          createMany: {
            args: Prisma.QuestionBankCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuestionBankCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionBankPayload>[]
          }
          delete: {
            args: Prisma.QuestionBankDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionBankPayload>
          }
          update: {
            args: Prisma.QuestionBankUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionBankPayload>
          }
          deleteMany: {
            args: Prisma.QuestionBankDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuestionBankUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.QuestionBankUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionBankPayload>
          }
          aggregate: {
            args: Prisma.QuestionBankAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuestionBank>
          }
          groupBy: {
            args: Prisma.QuestionBankGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuestionBankGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuestionBankCountArgs<ExtArgs>
            result: $Utils.Optional<QuestionBankCountAggregateOutputType> | number
          }
        }
      }
      SharedInterviewResult: {
        payload: Prisma.$SharedInterviewResultPayload<ExtArgs>
        fields: Prisma.SharedInterviewResultFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SharedInterviewResultFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharedInterviewResultPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SharedInterviewResultFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharedInterviewResultPayload>
          }
          findFirst: {
            args: Prisma.SharedInterviewResultFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharedInterviewResultPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SharedInterviewResultFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharedInterviewResultPayload>
          }
          findMany: {
            args: Prisma.SharedInterviewResultFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharedInterviewResultPayload>[]
          }
          create: {
            args: Prisma.SharedInterviewResultCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharedInterviewResultPayload>
          }
          createMany: {
            args: Prisma.SharedInterviewResultCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SharedInterviewResultCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharedInterviewResultPayload>[]
          }
          delete: {
            args: Prisma.SharedInterviewResultDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharedInterviewResultPayload>
          }
          update: {
            args: Prisma.SharedInterviewResultUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharedInterviewResultPayload>
          }
          deleteMany: {
            args: Prisma.SharedInterviewResultDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SharedInterviewResultUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SharedInterviewResultUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SharedInterviewResultPayload>
          }
          aggregate: {
            args: Prisma.SharedInterviewResultAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSharedInterviewResult>
          }
          groupBy: {
            args: Prisma.SharedInterviewResultGroupByArgs<ExtArgs>
            result: $Utils.Optional<SharedInterviewResultGroupByOutputType>[]
          }
          count: {
            args: Prisma.SharedInterviewResultCountArgs<ExtArgs>
            result: $Utils.Optional<SharedInterviewResultCountAggregateOutputType> | number
          }
        }
      }
      InterviewAnalytics: {
        payload: Prisma.$InterviewAnalyticsPayload<ExtArgs>
        fields: Prisma.InterviewAnalyticsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InterviewAnalyticsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewAnalyticsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InterviewAnalyticsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewAnalyticsPayload>
          }
          findFirst: {
            args: Prisma.InterviewAnalyticsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewAnalyticsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InterviewAnalyticsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewAnalyticsPayload>
          }
          findMany: {
            args: Prisma.InterviewAnalyticsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewAnalyticsPayload>[]
          }
          create: {
            args: Prisma.InterviewAnalyticsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewAnalyticsPayload>
          }
          createMany: {
            args: Prisma.InterviewAnalyticsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InterviewAnalyticsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewAnalyticsPayload>[]
          }
          delete: {
            args: Prisma.InterviewAnalyticsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewAnalyticsPayload>
          }
          update: {
            args: Prisma.InterviewAnalyticsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewAnalyticsPayload>
          }
          deleteMany: {
            args: Prisma.InterviewAnalyticsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InterviewAnalyticsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InterviewAnalyticsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterviewAnalyticsPayload>
          }
          aggregate: {
            args: Prisma.InterviewAnalyticsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInterviewAnalytics>
          }
          groupBy: {
            args: Prisma.InterviewAnalyticsGroupByArgs<ExtArgs>
            result: $Utils.Optional<InterviewAnalyticsGroupByOutputType>[]
          }
          count: {
            args: Prisma.InterviewAnalyticsCountArgs<ExtArgs>
            result: $Utils.Optional<InterviewAnalyticsCountAggregateOutputType> | number
          }
        }
      }
      Roadmap: {
        payload: Prisma.$RoadmapPayload<ExtArgs>
        fields: Prisma.RoadmapFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoadmapFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoadmapFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapPayload>
          }
          findFirst: {
            args: Prisma.RoadmapFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoadmapFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapPayload>
          }
          findMany: {
            args: Prisma.RoadmapFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapPayload>[]
          }
          create: {
            args: Prisma.RoadmapCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapPayload>
          }
          createMany: {
            args: Prisma.RoadmapCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoadmapCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapPayload>[]
          }
          delete: {
            args: Prisma.RoadmapDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapPayload>
          }
          update: {
            args: Prisma.RoadmapUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapPayload>
          }
          deleteMany: {
            args: Prisma.RoadmapDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoadmapUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RoadmapUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapPayload>
          }
          aggregate: {
            args: Prisma.RoadmapAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoadmap>
          }
          groupBy: {
            args: Prisma.RoadmapGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoadmapGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoadmapCountArgs<ExtArgs>
            result: $Utils.Optional<RoadmapCountAggregateOutputType> | number
          }
        }
      }
      RoadmapPhase: {
        payload: Prisma.$RoadmapPhasePayload<ExtArgs>
        fields: Prisma.RoadmapPhaseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoadmapPhaseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapPhasePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoadmapPhaseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapPhasePayload>
          }
          findFirst: {
            args: Prisma.RoadmapPhaseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapPhasePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoadmapPhaseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapPhasePayload>
          }
          findMany: {
            args: Prisma.RoadmapPhaseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapPhasePayload>[]
          }
          create: {
            args: Prisma.RoadmapPhaseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapPhasePayload>
          }
          createMany: {
            args: Prisma.RoadmapPhaseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoadmapPhaseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapPhasePayload>[]
          }
          delete: {
            args: Prisma.RoadmapPhaseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapPhasePayload>
          }
          update: {
            args: Prisma.RoadmapPhaseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapPhasePayload>
          }
          deleteMany: {
            args: Prisma.RoadmapPhaseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoadmapPhaseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RoadmapPhaseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapPhasePayload>
          }
          aggregate: {
            args: Prisma.RoadmapPhaseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoadmapPhase>
          }
          groupBy: {
            args: Prisma.RoadmapPhaseGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoadmapPhaseGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoadmapPhaseCountArgs<ExtArgs>
            result: $Utils.Optional<RoadmapPhaseCountAggregateOutputType> | number
          }
        }
      }
      RoadmapStep: {
        payload: Prisma.$RoadmapStepPayload<ExtArgs>
        fields: Prisma.RoadmapStepFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoadmapStepFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapStepPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoadmapStepFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapStepPayload>
          }
          findFirst: {
            args: Prisma.RoadmapStepFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapStepPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoadmapStepFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapStepPayload>
          }
          findMany: {
            args: Prisma.RoadmapStepFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapStepPayload>[]
          }
          create: {
            args: Prisma.RoadmapStepCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapStepPayload>
          }
          createMany: {
            args: Prisma.RoadmapStepCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoadmapStepCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapStepPayload>[]
          }
          delete: {
            args: Prisma.RoadmapStepDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapStepPayload>
          }
          update: {
            args: Prisma.RoadmapStepUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapStepPayload>
          }
          deleteMany: {
            args: Prisma.RoadmapStepDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoadmapStepUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RoadmapStepUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapStepPayload>
          }
          aggregate: {
            args: Prisma.RoadmapStepAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoadmapStep>
          }
          groupBy: {
            args: Prisma.RoadmapStepGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoadmapStepGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoadmapStepCountArgs<ExtArgs>
            result: $Utils.Optional<RoadmapStepCountAggregateOutputType> | number
          }
        }
      }
      RoadmapProgress: {
        payload: Prisma.$RoadmapProgressPayload<ExtArgs>
        fields: Prisma.RoadmapProgressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoadmapProgressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapProgressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoadmapProgressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapProgressPayload>
          }
          findFirst: {
            args: Prisma.RoadmapProgressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapProgressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoadmapProgressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapProgressPayload>
          }
          findMany: {
            args: Prisma.RoadmapProgressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapProgressPayload>[]
          }
          create: {
            args: Prisma.RoadmapProgressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapProgressPayload>
          }
          createMany: {
            args: Prisma.RoadmapProgressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoadmapProgressCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapProgressPayload>[]
          }
          delete: {
            args: Prisma.RoadmapProgressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapProgressPayload>
          }
          update: {
            args: Prisma.RoadmapProgressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapProgressPayload>
          }
          deleteMany: {
            args: Prisma.RoadmapProgressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoadmapProgressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RoadmapProgressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapProgressPayload>
          }
          aggregate: {
            args: Prisma.RoadmapProgressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoadmapProgress>
          }
          groupBy: {
            args: Prisma.RoadmapProgressGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoadmapProgressGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoadmapProgressCountArgs<ExtArgs>
            result: $Utils.Optional<RoadmapProgressCountAggregateOutputType> | number
          }
        }
      }
      CheatsheetCategory: {
        payload: Prisma.$CheatsheetCategoryPayload<ExtArgs>
        fields: Prisma.CheatsheetCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CheatsheetCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheatsheetCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CheatsheetCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheatsheetCategoryPayload>
          }
          findFirst: {
            args: Prisma.CheatsheetCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheatsheetCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CheatsheetCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheatsheetCategoryPayload>
          }
          findMany: {
            args: Prisma.CheatsheetCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheatsheetCategoryPayload>[]
          }
          create: {
            args: Prisma.CheatsheetCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheatsheetCategoryPayload>
          }
          createMany: {
            args: Prisma.CheatsheetCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CheatsheetCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheatsheetCategoryPayload>[]
          }
          delete: {
            args: Prisma.CheatsheetCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheatsheetCategoryPayload>
          }
          update: {
            args: Prisma.CheatsheetCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheatsheetCategoryPayload>
          }
          deleteMany: {
            args: Prisma.CheatsheetCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CheatsheetCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CheatsheetCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheatsheetCategoryPayload>
          }
          aggregate: {
            args: Prisma.CheatsheetCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCheatsheetCategory>
          }
          groupBy: {
            args: Prisma.CheatsheetCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CheatsheetCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CheatsheetCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<CheatsheetCategoryCountAggregateOutputType> | number
          }
        }
      }
      Cheatsheet: {
        payload: Prisma.$CheatsheetPayload<ExtArgs>
        fields: Prisma.CheatsheetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CheatsheetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheatsheetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CheatsheetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheatsheetPayload>
          }
          findFirst: {
            args: Prisma.CheatsheetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheatsheetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CheatsheetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheatsheetPayload>
          }
          findMany: {
            args: Prisma.CheatsheetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheatsheetPayload>[]
          }
          create: {
            args: Prisma.CheatsheetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheatsheetPayload>
          }
          createMany: {
            args: Prisma.CheatsheetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CheatsheetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheatsheetPayload>[]
          }
          delete: {
            args: Prisma.CheatsheetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheatsheetPayload>
          }
          update: {
            args: Prisma.CheatsheetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheatsheetPayload>
          }
          deleteMany: {
            args: Prisma.CheatsheetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CheatsheetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CheatsheetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheatsheetPayload>
          }
          aggregate: {
            args: Prisma.CheatsheetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCheatsheet>
          }
          groupBy: {
            args: Prisma.CheatsheetGroupByArgs<ExtArgs>
            result: $Utils.Optional<CheatsheetGroupByOutputType>[]
          }
          count: {
            args: Prisma.CheatsheetCountArgs<ExtArgs>
            result: $Utils.Optional<CheatsheetCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    progress: number
    submissions: number
    interviewSessions: number
    sharedResults: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    progress?: boolean | UserCountOutputTypeCountProgressArgs
    submissions?: boolean | UserCountOutputTypeCountSubmissionsArgs
    interviewSessions?: boolean | UserCountOutputTypeCountInterviewSessionsArgs
    sharedResults?: boolean | UserCountOutputTypeCountSharedResultsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserProgressWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSubmissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubmissionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInterviewSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InterviewSessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSharedResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SharedInterviewResultWhereInput
  }


  /**
   * Count Type DSATopicCountOutputType
   */

  export type DSATopicCountOutputType = {
    lessons: number
  }

  export type DSATopicCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lessons?: boolean | DSATopicCountOutputTypeCountLessonsArgs
  }

  // Custom InputTypes
  /**
   * DSATopicCountOutputType without action
   */
  export type DSATopicCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DSATopicCountOutputType
     */
    select?: DSATopicCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DSATopicCountOutputType without action
   */
  export type DSATopicCountOutputTypeCountLessonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DSALessonWhereInput
  }


  /**
   * Count Type ProblemCountOutputType
   */

  export type ProblemCountOutputType = {
    progress: number
    submissions: number
  }

  export type ProblemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    progress?: boolean | ProblemCountOutputTypeCountProgressArgs
    submissions?: boolean | ProblemCountOutputTypeCountSubmissionsArgs
  }

  // Custom InputTypes
  /**
   * ProblemCountOutputType without action
   */
  export type ProblemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProblemCountOutputType
     */
    select?: ProblemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProblemCountOutputType without action
   */
  export type ProblemCountOutputTypeCountProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserProgressWhereInput
  }

  /**
   * ProblemCountOutputType without action
   */
  export type ProblemCountOutputTypeCountSubmissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubmissionWhereInput
  }


  /**
   * Count Type LearnDomainCountOutputType
   */

  export type LearnDomainCountOutputType = {
    categories: number
  }

  export type LearnDomainCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    categories?: boolean | LearnDomainCountOutputTypeCountCategoriesArgs
  }

  // Custom InputTypes
  /**
   * LearnDomainCountOutputType without action
   */
  export type LearnDomainCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearnDomainCountOutputType
     */
    select?: LearnDomainCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LearnDomainCountOutputType without action
   */
  export type LearnDomainCountOutputTypeCountCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LearnCategoryWhereInput
  }


  /**
   * Count Type LearnCategoryCountOutputType
   */

  export type LearnCategoryCountOutputType = {
    topics: number
  }

  export type LearnCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    topics?: boolean | LearnCategoryCountOutputTypeCountTopicsArgs
  }

  // Custom InputTypes
  /**
   * LearnCategoryCountOutputType without action
   */
  export type LearnCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearnCategoryCountOutputType
     */
    select?: LearnCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LearnCategoryCountOutputType without action
   */
  export type LearnCategoryCountOutputTypeCountTopicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LearnTopicWhereInput
  }


  /**
   * Count Type RoadmapCountOutputType
   */

  export type RoadmapCountOutputType = {
    phases: number
    progress: number
  }

  export type RoadmapCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    phases?: boolean | RoadmapCountOutputTypeCountPhasesArgs
    progress?: boolean | RoadmapCountOutputTypeCountProgressArgs
  }

  // Custom InputTypes
  /**
   * RoadmapCountOutputType without action
   */
  export type RoadmapCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapCountOutputType
     */
    select?: RoadmapCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoadmapCountOutputType without action
   */
  export type RoadmapCountOutputTypeCountPhasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoadmapPhaseWhereInput
  }

  /**
   * RoadmapCountOutputType without action
   */
  export type RoadmapCountOutputTypeCountProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoadmapProgressWhereInput
  }


  /**
   * Count Type RoadmapPhaseCountOutputType
   */

  export type RoadmapPhaseCountOutputType = {
    steps: number
  }

  export type RoadmapPhaseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    steps?: boolean | RoadmapPhaseCountOutputTypeCountStepsArgs
  }

  // Custom InputTypes
  /**
   * RoadmapPhaseCountOutputType without action
   */
  export type RoadmapPhaseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapPhaseCountOutputType
     */
    select?: RoadmapPhaseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoadmapPhaseCountOutputType without action
   */
  export type RoadmapPhaseCountOutputTypeCountStepsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoadmapStepWhereInput
  }


  /**
   * Count Type RoadmapStepCountOutputType
   */

  export type RoadmapStepCountOutputType = {
    progress: number
  }

  export type RoadmapStepCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    progress?: boolean | RoadmapStepCountOutputTypeCountProgressArgs
  }

  // Custom InputTypes
  /**
   * RoadmapStepCountOutputType without action
   */
  export type RoadmapStepCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapStepCountOutputType
     */
    select?: RoadmapStepCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoadmapStepCountOutputType without action
   */
  export type RoadmapStepCountOutputTypeCountProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoadmapProgressWhereInput
  }


  /**
   * Count Type CheatsheetCategoryCountOutputType
   */

  export type CheatsheetCategoryCountOutputType = {
    cheatsheets: number
  }

  export type CheatsheetCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cheatsheets?: boolean | CheatsheetCategoryCountOutputTypeCountCheatsheetsArgs
  }

  // Custom InputTypes
  /**
   * CheatsheetCategoryCountOutputType without action
   */
  export type CheatsheetCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheatsheetCategoryCountOutputType
     */
    select?: CheatsheetCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CheatsheetCategoryCountOutputType without action
   */
  export type CheatsheetCategoryCountOutputTypeCountCheatsheetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CheatsheetWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    name: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    progress?: boolean | User$progressArgs<ExtArgs>
    submissions?: boolean | User$submissionsArgs<ExtArgs>
    interviewSessions?: boolean | User$interviewSessionsArgs<ExtArgs>
    sharedResults?: boolean | User$sharedResultsArgs<ExtArgs>
    analytics?: boolean | User$analyticsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    progress?: boolean | User$progressArgs<ExtArgs>
    submissions?: boolean | User$submissionsArgs<ExtArgs>
    interviewSessions?: boolean | User$interviewSessionsArgs<ExtArgs>
    sharedResults?: boolean | User$sharedResultsArgs<ExtArgs>
    analytics?: boolean | User$analyticsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      progress: Prisma.$UserProgressPayload<ExtArgs>[]
      submissions: Prisma.$SubmissionPayload<ExtArgs>[]
      interviewSessions: Prisma.$InterviewSessionPayload<ExtArgs>[]
      sharedResults: Prisma.$SharedInterviewResultPayload<ExtArgs>[]
      analytics: Prisma.$InterviewAnalyticsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      name: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    progress<T extends User$progressArgs<ExtArgs> = {}>(args?: Subset<T, User$progressArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProgressPayload<ExtArgs>, T, "findMany"> | Null>
    submissions<T extends User$submissionsArgs<ExtArgs> = {}>(args?: Subset<T, User$submissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubmissionPayload<ExtArgs>, T, "findMany"> | Null>
    interviewSessions<T extends User$interviewSessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$interviewSessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterviewSessionPayload<ExtArgs>, T, "findMany"> | Null>
    sharedResults<T extends User$sharedResultsArgs<ExtArgs> = {}>(args?: Subset<T, User$sharedResultsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SharedInterviewResultPayload<ExtArgs>, T, "findMany"> | Null>
    analytics<T extends User$analyticsArgs<ExtArgs> = {}>(args?: Subset<T, User$analyticsArgs<ExtArgs>>): Prisma__InterviewAnalyticsClient<$Result.GetResult<Prisma.$InterviewAnalyticsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.progress
   */
  export type User$progressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProgressInclude<ExtArgs> | null
    where?: UserProgressWhereInput
    orderBy?: UserProgressOrderByWithRelationInput | UserProgressOrderByWithRelationInput[]
    cursor?: UserProgressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserProgressScalarFieldEnum | UserProgressScalarFieldEnum[]
  }

  /**
   * User.submissions
   */
  export type User$submissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Submission
     */
    select?: SubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionInclude<ExtArgs> | null
    where?: SubmissionWhereInput
    orderBy?: SubmissionOrderByWithRelationInput | SubmissionOrderByWithRelationInput[]
    cursor?: SubmissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubmissionScalarFieldEnum | SubmissionScalarFieldEnum[]
  }

  /**
   * User.interviewSessions
   */
  export type User$interviewSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewSession
     */
    select?: InterviewSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewSessionInclude<ExtArgs> | null
    where?: InterviewSessionWhereInput
    orderBy?: InterviewSessionOrderByWithRelationInput | InterviewSessionOrderByWithRelationInput[]
    cursor?: InterviewSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InterviewSessionScalarFieldEnum | InterviewSessionScalarFieldEnum[]
  }

  /**
   * User.sharedResults
   */
  export type User$sharedResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedInterviewResult
     */
    select?: SharedInterviewResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharedInterviewResultInclude<ExtArgs> | null
    where?: SharedInterviewResultWhereInput
    orderBy?: SharedInterviewResultOrderByWithRelationInput | SharedInterviewResultOrderByWithRelationInput[]
    cursor?: SharedInterviewResultWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SharedInterviewResultScalarFieldEnum | SharedInterviewResultScalarFieldEnum[]
  }

  /**
   * User.analytics
   */
  export type User$analyticsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewAnalytics
     */
    select?: InterviewAnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewAnalyticsInclude<ExtArgs> | null
    where?: InterviewAnalyticsWhereInput
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model DSATopic
   */

  export type AggregateDSATopic = {
    _count: DSATopicCountAggregateOutputType | null
    _avg: DSATopicAvgAggregateOutputType | null
    _sum: DSATopicSumAggregateOutputType | null
    _min: DSATopicMinAggregateOutputType | null
    _max: DSATopicMaxAggregateOutputType | null
  }

  export type DSATopicAvgAggregateOutputType = {
    order: number | null
    targetCount: number | null
  }

  export type DSATopicSumAggregateOutputType = {
    order: number | null
    targetCount: number | null
  }

  export type DSATopicMinAggregateOutputType = {
    id: string | null
    slug: string | null
    title: string | null
    category: string | null
    order: number | null
    targetCount: number | null
    createdAt: Date | null
  }

  export type DSATopicMaxAggregateOutputType = {
    id: string | null
    slug: string | null
    title: string | null
    category: string | null
    order: number | null
    targetCount: number | null
    createdAt: Date | null
  }

  export type DSATopicCountAggregateOutputType = {
    id: number
    slug: number
    title: number
    category: number
    order: number
    targetCount: number
    createdAt: number
    _all: number
  }


  export type DSATopicAvgAggregateInputType = {
    order?: true
    targetCount?: true
  }

  export type DSATopicSumAggregateInputType = {
    order?: true
    targetCount?: true
  }

  export type DSATopicMinAggregateInputType = {
    id?: true
    slug?: true
    title?: true
    category?: true
    order?: true
    targetCount?: true
    createdAt?: true
  }

  export type DSATopicMaxAggregateInputType = {
    id?: true
    slug?: true
    title?: true
    category?: true
    order?: true
    targetCount?: true
    createdAt?: true
  }

  export type DSATopicCountAggregateInputType = {
    id?: true
    slug?: true
    title?: true
    category?: true
    order?: true
    targetCount?: true
    createdAt?: true
    _all?: true
  }

  export type DSATopicAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DSATopic to aggregate.
     */
    where?: DSATopicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DSATopics to fetch.
     */
    orderBy?: DSATopicOrderByWithRelationInput | DSATopicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DSATopicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DSATopics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DSATopics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DSATopics
    **/
    _count?: true | DSATopicCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DSATopicAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DSATopicSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DSATopicMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DSATopicMaxAggregateInputType
  }

  export type GetDSATopicAggregateType<T extends DSATopicAggregateArgs> = {
        [P in keyof T & keyof AggregateDSATopic]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDSATopic[P]>
      : GetScalarType<T[P], AggregateDSATopic[P]>
  }




  export type DSATopicGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DSATopicWhereInput
    orderBy?: DSATopicOrderByWithAggregationInput | DSATopicOrderByWithAggregationInput[]
    by: DSATopicScalarFieldEnum[] | DSATopicScalarFieldEnum
    having?: DSATopicScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DSATopicCountAggregateInputType | true
    _avg?: DSATopicAvgAggregateInputType
    _sum?: DSATopicSumAggregateInputType
    _min?: DSATopicMinAggregateInputType
    _max?: DSATopicMaxAggregateInputType
  }

  export type DSATopicGroupByOutputType = {
    id: string
    slug: string
    title: string
    category: string | null
    order: number
    targetCount: number
    createdAt: Date
    _count: DSATopicCountAggregateOutputType | null
    _avg: DSATopicAvgAggregateOutputType | null
    _sum: DSATopicSumAggregateOutputType | null
    _min: DSATopicMinAggregateOutputType | null
    _max: DSATopicMaxAggregateOutputType | null
  }

  type GetDSATopicGroupByPayload<T extends DSATopicGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DSATopicGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DSATopicGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DSATopicGroupByOutputType[P]>
            : GetScalarType<T[P], DSATopicGroupByOutputType[P]>
        }
      >
    >


  export type DSATopicSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    title?: boolean
    category?: boolean
    order?: boolean
    targetCount?: boolean
    createdAt?: boolean
    lessons?: boolean | DSATopic$lessonsArgs<ExtArgs>
    _count?: boolean | DSATopicCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dSATopic"]>

  export type DSATopicSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    title?: boolean
    category?: boolean
    order?: boolean
    targetCount?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["dSATopic"]>

  export type DSATopicSelectScalar = {
    id?: boolean
    slug?: boolean
    title?: boolean
    category?: boolean
    order?: boolean
    targetCount?: boolean
    createdAt?: boolean
  }

  export type DSATopicInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lessons?: boolean | DSATopic$lessonsArgs<ExtArgs>
    _count?: boolean | DSATopicCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DSATopicIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DSATopicPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DSATopic"
    objects: {
      lessons: Prisma.$DSALessonPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      slug: string
      title: string
      category: string | null
      order: number
      targetCount: number
      createdAt: Date
    }, ExtArgs["result"]["dSATopic"]>
    composites: {}
  }

  type DSATopicGetPayload<S extends boolean | null | undefined | DSATopicDefaultArgs> = $Result.GetResult<Prisma.$DSATopicPayload, S>

  type DSATopicCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DSATopicFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DSATopicCountAggregateInputType | true
    }

  export interface DSATopicDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DSATopic'], meta: { name: 'DSATopic' } }
    /**
     * Find zero or one DSATopic that matches the filter.
     * @param {DSATopicFindUniqueArgs} args - Arguments to find a DSATopic
     * @example
     * // Get one DSATopic
     * const dSATopic = await prisma.dSATopic.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DSATopicFindUniqueArgs>(args: SelectSubset<T, DSATopicFindUniqueArgs<ExtArgs>>): Prisma__DSATopicClient<$Result.GetResult<Prisma.$DSATopicPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DSATopic that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DSATopicFindUniqueOrThrowArgs} args - Arguments to find a DSATopic
     * @example
     * // Get one DSATopic
     * const dSATopic = await prisma.dSATopic.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DSATopicFindUniqueOrThrowArgs>(args: SelectSubset<T, DSATopicFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DSATopicClient<$Result.GetResult<Prisma.$DSATopicPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DSATopic that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DSATopicFindFirstArgs} args - Arguments to find a DSATopic
     * @example
     * // Get one DSATopic
     * const dSATopic = await prisma.dSATopic.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DSATopicFindFirstArgs>(args?: SelectSubset<T, DSATopicFindFirstArgs<ExtArgs>>): Prisma__DSATopicClient<$Result.GetResult<Prisma.$DSATopicPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DSATopic that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DSATopicFindFirstOrThrowArgs} args - Arguments to find a DSATopic
     * @example
     * // Get one DSATopic
     * const dSATopic = await prisma.dSATopic.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DSATopicFindFirstOrThrowArgs>(args?: SelectSubset<T, DSATopicFindFirstOrThrowArgs<ExtArgs>>): Prisma__DSATopicClient<$Result.GetResult<Prisma.$DSATopicPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DSATopics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DSATopicFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DSATopics
     * const dSATopics = await prisma.dSATopic.findMany()
     * 
     * // Get first 10 DSATopics
     * const dSATopics = await prisma.dSATopic.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dSATopicWithIdOnly = await prisma.dSATopic.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DSATopicFindManyArgs>(args?: SelectSubset<T, DSATopicFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DSATopicPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DSATopic.
     * @param {DSATopicCreateArgs} args - Arguments to create a DSATopic.
     * @example
     * // Create one DSATopic
     * const DSATopic = await prisma.dSATopic.create({
     *   data: {
     *     // ... data to create a DSATopic
     *   }
     * })
     * 
     */
    create<T extends DSATopicCreateArgs>(args: SelectSubset<T, DSATopicCreateArgs<ExtArgs>>): Prisma__DSATopicClient<$Result.GetResult<Prisma.$DSATopicPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DSATopics.
     * @param {DSATopicCreateManyArgs} args - Arguments to create many DSATopics.
     * @example
     * // Create many DSATopics
     * const dSATopic = await prisma.dSATopic.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DSATopicCreateManyArgs>(args?: SelectSubset<T, DSATopicCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DSATopics and returns the data saved in the database.
     * @param {DSATopicCreateManyAndReturnArgs} args - Arguments to create many DSATopics.
     * @example
     * // Create many DSATopics
     * const dSATopic = await prisma.dSATopic.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DSATopics and only return the `id`
     * const dSATopicWithIdOnly = await prisma.dSATopic.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DSATopicCreateManyAndReturnArgs>(args?: SelectSubset<T, DSATopicCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DSATopicPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DSATopic.
     * @param {DSATopicDeleteArgs} args - Arguments to delete one DSATopic.
     * @example
     * // Delete one DSATopic
     * const DSATopic = await prisma.dSATopic.delete({
     *   where: {
     *     // ... filter to delete one DSATopic
     *   }
     * })
     * 
     */
    delete<T extends DSATopicDeleteArgs>(args: SelectSubset<T, DSATopicDeleteArgs<ExtArgs>>): Prisma__DSATopicClient<$Result.GetResult<Prisma.$DSATopicPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DSATopic.
     * @param {DSATopicUpdateArgs} args - Arguments to update one DSATopic.
     * @example
     * // Update one DSATopic
     * const dSATopic = await prisma.dSATopic.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DSATopicUpdateArgs>(args: SelectSubset<T, DSATopicUpdateArgs<ExtArgs>>): Prisma__DSATopicClient<$Result.GetResult<Prisma.$DSATopicPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DSATopics.
     * @param {DSATopicDeleteManyArgs} args - Arguments to filter DSATopics to delete.
     * @example
     * // Delete a few DSATopics
     * const { count } = await prisma.dSATopic.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DSATopicDeleteManyArgs>(args?: SelectSubset<T, DSATopicDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DSATopics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DSATopicUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DSATopics
     * const dSATopic = await prisma.dSATopic.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DSATopicUpdateManyArgs>(args: SelectSubset<T, DSATopicUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DSATopic.
     * @param {DSATopicUpsertArgs} args - Arguments to update or create a DSATopic.
     * @example
     * // Update or create a DSATopic
     * const dSATopic = await prisma.dSATopic.upsert({
     *   create: {
     *     // ... data to create a DSATopic
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DSATopic we want to update
     *   }
     * })
     */
    upsert<T extends DSATopicUpsertArgs>(args: SelectSubset<T, DSATopicUpsertArgs<ExtArgs>>): Prisma__DSATopicClient<$Result.GetResult<Prisma.$DSATopicPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DSATopics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DSATopicCountArgs} args - Arguments to filter DSATopics to count.
     * @example
     * // Count the number of DSATopics
     * const count = await prisma.dSATopic.count({
     *   where: {
     *     // ... the filter for the DSATopics we want to count
     *   }
     * })
    **/
    count<T extends DSATopicCountArgs>(
      args?: Subset<T, DSATopicCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DSATopicCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DSATopic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DSATopicAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DSATopicAggregateArgs>(args: Subset<T, DSATopicAggregateArgs>): Prisma.PrismaPromise<GetDSATopicAggregateType<T>>

    /**
     * Group by DSATopic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DSATopicGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DSATopicGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DSATopicGroupByArgs['orderBy'] }
        : { orderBy?: DSATopicGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DSATopicGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDSATopicGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DSATopic model
   */
  readonly fields: DSATopicFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DSATopic.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DSATopicClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lessons<T extends DSATopic$lessonsArgs<ExtArgs> = {}>(args?: Subset<T, DSATopic$lessonsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DSALessonPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DSATopic model
   */ 
  interface DSATopicFieldRefs {
    readonly id: FieldRef<"DSATopic", 'String'>
    readonly slug: FieldRef<"DSATopic", 'String'>
    readonly title: FieldRef<"DSATopic", 'String'>
    readonly category: FieldRef<"DSATopic", 'String'>
    readonly order: FieldRef<"DSATopic", 'Int'>
    readonly targetCount: FieldRef<"DSATopic", 'Int'>
    readonly createdAt: FieldRef<"DSATopic", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DSATopic findUnique
   */
  export type DSATopicFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DSATopic
     */
    select?: DSATopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DSATopicInclude<ExtArgs> | null
    /**
     * Filter, which DSATopic to fetch.
     */
    where: DSATopicWhereUniqueInput
  }

  /**
   * DSATopic findUniqueOrThrow
   */
  export type DSATopicFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DSATopic
     */
    select?: DSATopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DSATopicInclude<ExtArgs> | null
    /**
     * Filter, which DSATopic to fetch.
     */
    where: DSATopicWhereUniqueInput
  }

  /**
   * DSATopic findFirst
   */
  export type DSATopicFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DSATopic
     */
    select?: DSATopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DSATopicInclude<ExtArgs> | null
    /**
     * Filter, which DSATopic to fetch.
     */
    where?: DSATopicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DSATopics to fetch.
     */
    orderBy?: DSATopicOrderByWithRelationInput | DSATopicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DSATopics.
     */
    cursor?: DSATopicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DSATopics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DSATopics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DSATopics.
     */
    distinct?: DSATopicScalarFieldEnum | DSATopicScalarFieldEnum[]
  }

  /**
   * DSATopic findFirstOrThrow
   */
  export type DSATopicFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DSATopic
     */
    select?: DSATopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DSATopicInclude<ExtArgs> | null
    /**
     * Filter, which DSATopic to fetch.
     */
    where?: DSATopicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DSATopics to fetch.
     */
    orderBy?: DSATopicOrderByWithRelationInput | DSATopicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DSATopics.
     */
    cursor?: DSATopicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DSATopics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DSATopics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DSATopics.
     */
    distinct?: DSATopicScalarFieldEnum | DSATopicScalarFieldEnum[]
  }

  /**
   * DSATopic findMany
   */
  export type DSATopicFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DSATopic
     */
    select?: DSATopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DSATopicInclude<ExtArgs> | null
    /**
     * Filter, which DSATopics to fetch.
     */
    where?: DSATopicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DSATopics to fetch.
     */
    orderBy?: DSATopicOrderByWithRelationInput | DSATopicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DSATopics.
     */
    cursor?: DSATopicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DSATopics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DSATopics.
     */
    skip?: number
    distinct?: DSATopicScalarFieldEnum | DSATopicScalarFieldEnum[]
  }

  /**
   * DSATopic create
   */
  export type DSATopicCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DSATopic
     */
    select?: DSATopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DSATopicInclude<ExtArgs> | null
    /**
     * The data needed to create a DSATopic.
     */
    data: XOR<DSATopicCreateInput, DSATopicUncheckedCreateInput>
  }

  /**
   * DSATopic createMany
   */
  export type DSATopicCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DSATopics.
     */
    data: DSATopicCreateManyInput | DSATopicCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DSATopic createManyAndReturn
   */
  export type DSATopicCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DSATopic
     */
    select?: DSATopicSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DSATopics.
     */
    data: DSATopicCreateManyInput | DSATopicCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DSATopic update
   */
  export type DSATopicUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DSATopic
     */
    select?: DSATopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DSATopicInclude<ExtArgs> | null
    /**
     * The data needed to update a DSATopic.
     */
    data: XOR<DSATopicUpdateInput, DSATopicUncheckedUpdateInput>
    /**
     * Choose, which DSATopic to update.
     */
    where: DSATopicWhereUniqueInput
  }

  /**
   * DSATopic updateMany
   */
  export type DSATopicUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DSATopics.
     */
    data: XOR<DSATopicUpdateManyMutationInput, DSATopicUncheckedUpdateManyInput>
    /**
     * Filter which DSATopics to update
     */
    where?: DSATopicWhereInput
  }

  /**
   * DSATopic upsert
   */
  export type DSATopicUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DSATopic
     */
    select?: DSATopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DSATopicInclude<ExtArgs> | null
    /**
     * The filter to search for the DSATopic to update in case it exists.
     */
    where: DSATopicWhereUniqueInput
    /**
     * In case the DSATopic found by the `where` argument doesn't exist, create a new DSATopic with this data.
     */
    create: XOR<DSATopicCreateInput, DSATopicUncheckedCreateInput>
    /**
     * In case the DSATopic was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DSATopicUpdateInput, DSATopicUncheckedUpdateInput>
  }

  /**
   * DSATopic delete
   */
  export type DSATopicDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DSATopic
     */
    select?: DSATopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DSATopicInclude<ExtArgs> | null
    /**
     * Filter which DSATopic to delete.
     */
    where: DSATopicWhereUniqueInput
  }

  /**
   * DSATopic deleteMany
   */
  export type DSATopicDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DSATopics to delete
     */
    where?: DSATopicWhereInput
  }

  /**
   * DSATopic.lessons
   */
  export type DSATopic$lessonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DSALesson
     */
    select?: DSALessonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DSALessonInclude<ExtArgs> | null
    where?: DSALessonWhereInput
    orderBy?: DSALessonOrderByWithRelationInput | DSALessonOrderByWithRelationInput[]
    cursor?: DSALessonWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DSALessonScalarFieldEnum | DSALessonScalarFieldEnum[]
  }

  /**
   * DSATopic without action
   */
  export type DSATopicDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DSATopic
     */
    select?: DSATopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DSATopicInclude<ExtArgs> | null
  }


  /**
   * Model DSALesson
   */

  export type AggregateDSALesson = {
    _count: DSALessonCountAggregateOutputType | null
    _avg: DSALessonAvgAggregateOutputType | null
    _sum: DSALessonSumAggregateOutputType | null
    _min: DSALessonMinAggregateOutputType | null
    _max: DSALessonMaxAggregateOutputType | null
  }

  export type DSALessonAvgAggregateOutputType = {
    order: number | null
  }

  export type DSALessonSumAggregateOutputType = {
    order: number | null
  }

  export type DSALessonMinAggregateOutputType = {
    id: string | null
    topicId: string | null
    slug: string | null
    title: string | null
    content: string | null
    difficulty: string | null
    order: number | null
    createdAt: Date | null
  }

  export type DSALessonMaxAggregateOutputType = {
    id: string | null
    topicId: string | null
    slug: string | null
    title: string | null
    content: string | null
    difficulty: string | null
    order: number | null
    createdAt: Date | null
  }

  export type DSALessonCountAggregateOutputType = {
    id: number
    topicId: number
    slug: number
    title: number
    content: number
    codeExamples: number
    difficulty: number
    order: number
    createdAt: number
    _all: number
  }


  export type DSALessonAvgAggregateInputType = {
    order?: true
  }

  export type DSALessonSumAggregateInputType = {
    order?: true
  }

  export type DSALessonMinAggregateInputType = {
    id?: true
    topicId?: true
    slug?: true
    title?: true
    content?: true
    difficulty?: true
    order?: true
    createdAt?: true
  }

  export type DSALessonMaxAggregateInputType = {
    id?: true
    topicId?: true
    slug?: true
    title?: true
    content?: true
    difficulty?: true
    order?: true
    createdAt?: true
  }

  export type DSALessonCountAggregateInputType = {
    id?: true
    topicId?: true
    slug?: true
    title?: true
    content?: true
    codeExamples?: true
    difficulty?: true
    order?: true
    createdAt?: true
    _all?: true
  }

  export type DSALessonAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DSALesson to aggregate.
     */
    where?: DSALessonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DSALessons to fetch.
     */
    orderBy?: DSALessonOrderByWithRelationInput | DSALessonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DSALessonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DSALessons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DSALessons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DSALessons
    **/
    _count?: true | DSALessonCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DSALessonAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DSALessonSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DSALessonMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DSALessonMaxAggregateInputType
  }

  export type GetDSALessonAggregateType<T extends DSALessonAggregateArgs> = {
        [P in keyof T & keyof AggregateDSALesson]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDSALesson[P]>
      : GetScalarType<T[P], AggregateDSALesson[P]>
  }




  export type DSALessonGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DSALessonWhereInput
    orderBy?: DSALessonOrderByWithAggregationInput | DSALessonOrderByWithAggregationInput[]
    by: DSALessonScalarFieldEnum[] | DSALessonScalarFieldEnum
    having?: DSALessonScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DSALessonCountAggregateInputType | true
    _avg?: DSALessonAvgAggregateInputType
    _sum?: DSALessonSumAggregateInputType
    _min?: DSALessonMinAggregateInputType
    _max?: DSALessonMaxAggregateInputType
  }

  export type DSALessonGroupByOutputType = {
    id: string
    topicId: string
    slug: string
    title: string
    content: string
    codeExamples: JsonValue | null
    difficulty: string | null
    order: number
    createdAt: Date
    _count: DSALessonCountAggregateOutputType | null
    _avg: DSALessonAvgAggregateOutputType | null
    _sum: DSALessonSumAggregateOutputType | null
    _min: DSALessonMinAggregateOutputType | null
    _max: DSALessonMaxAggregateOutputType | null
  }

  type GetDSALessonGroupByPayload<T extends DSALessonGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DSALessonGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DSALessonGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DSALessonGroupByOutputType[P]>
            : GetScalarType<T[P], DSALessonGroupByOutputType[P]>
        }
      >
    >


  export type DSALessonSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    topicId?: boolean
    slug?: boolean
    title?: boolean
    content?: boolean
    codeExamples?: boolean
    difficulty?: boolean
    order?: boolean
    createdAt?: boolean
    topic?: boolean | DSATopicDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dSALesson"]>

  export type DSALessonSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    topicId?: boolean
    slug?: boolean
    title?: boolean
    content?: boolean
    codeExamples?: boolean
    difficulty?: boolean
    order?: boolean
    createdAt?: boolean
    topic?: boolean | DSATopicDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dSALesson"]>

  export type DSALessonSelectScalar = {
    id?: boolean
    topicId?: boolean
    slug?: boolean
    title?: boolean
    content?: boolean
    codeExamples?: boolean
    difficulty?: boolean
    order?: boolean
    createdAt?: boolean
  }

  export type DSALessonInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    topic?: boolean | DSATopicDefaultArgs<ExtArgs>
  }
  export type DSALessonIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    topic?: boolean | DSATopicDefaultArgs<ExtArgs>
  }

  export type $DSALessonPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DSALesson"
    objects: {
      topic: Prisma.$DSATopicPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      topicId: string
      slug: string
      title: string
      content: string
      codeExamples: Prisma.JsonValue | null
      difficulty: string | null
      order: number
      createdAt: Date
    }, ExtArgs["result"]["dSALesson"]>
    composites: {}
  }

  type DSALessonGetPayload<S extends boolean | null | undefined | DSALessonDefaultArgs> = $Result.GetResult<Prisma.$DSALessonPayload, S>

  type DSALessonCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DSALessonFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DSALessonCountAggregateInputType | true
    }

  export interface DSALessonDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DSALesson'], meta: { name: 'DSALesson' } }
    /**
     * Find zero or one DSALesson that matches the filter.
     * @param {DSALessonFindUniqueArgs} args - Arguments to find a DSALesson
     * @example
     * // Get one DSALesson
     * const dSALesson = await prisma.dSALesson.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DSALessonFindUniqueArgs>(args: SelectSubset<T, DSALessonFindUniqueArgs<ExtArgs>>): Prisma__DSALessonClient<$Result.GetResult<Prisma.$DSALessonPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DSALesson that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DSALessonFindUniqueOrThrowArgs} args - Arguments to find a DSALesson
     * @example
     * // Get one DSALesson
     * const dSALesson = await prisma.dSALesson.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DSALessonFindUniqueOrThrowArgs>(args: SelectSubset<T, DSALessonFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DSALessonClient<$Result.GetResult<Prisma.$DSALessonPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DSALesson that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DSALessonFindFirstArgs} args - Arguments to find a DSALesson
     * @example
     * // Get one DSALesson
     * const dSALesson = await prisma.dSALesson.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DSALessonFindFirstArgs>(args?: SelectSubset<T, DSALessonFindFirstArgs<ExtArgs>>): Prisma__DSALessonClient<$Result.GetResult<Prisma.$DSALessonPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DSALesson that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DSALessonFindFirstOrThrowArgs} args - Arguments to find a DSALesson
     * @example
     * // Get one DSALesson
     * const dSALesson = await prisma.dSALesson.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DSALessonFindFirstOrThrowArgs>(args?: SelectSubset<T, DSALessonFindFirstOrThrowArgs<ExtArgs>>): Prisma__DSALessonClient<$Result.GetResult<Prisma.$DSALessonPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DSALessons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DSALessonFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DSALessons
     * const dSALessons = await prisma.dSALesson.findMany()
     * 
     * // Get first 10 DSALessons
     * const dSALessons = await prisma.dSALesson.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dSALessonWithIdOnly = await prisma.dSALesson.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DSALessonFindManyArgs>(args?: SelectSubset<T, DSALessonFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DSALessonPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DSALesson.
     * @param {DSALessonCreateArgs} args - Arguments to create a DSALesson.
     * @example
     * // Create one DSALesson
     * const DSALesson = await prisma.dSALesson.create({
     *   data: {
     *     // ... data to create a DSALesson
     *   }
     * })
     * 
     */
    create<T extends DSALessonCreateArgs>(args: SelectSubset<T, DSALessonCreateArgs<ExtArgs>>): Prisma__DSALessonClient<$Result.GetResult<Prisma.$DSALessonPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DSALessons.
     * @param {DSALessonCreateManyArgs} args - Arguments to create many DSALessons.
     * @example
     * // Create many DSALessons
     * const dSALesson = await prisma.dSALesson.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DSALessonCreateManyArgs>(args?: SelectSubset<T, DSALessonCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DSALessons and returns the data saved in the database.
     * @param {DSALessonCreateManyAndReturnArgs} args - Arguments to create many DSALessons.
     * @example
     * // Create many DSALessons
     * const dSALesson = await prisma.dSALesson.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DSALessons and only return the `id`
     * const dSALessonWithIdOnly = await prisma.dSALesson.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DSALessonCreateManyAndReturnArgs>(args?: SelectSubset<T, DSALessonCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DSALessonPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DSALesson.
     * @param {DSALessonDeleteArgs} args - Arguments to delete one DSALesson.
     * @example
     * // Delete one DSALesson
     * const DSALesson = await prisma.dSALesson.delete({
     *   where: {
     *     // ... filter to delete one DSALesson
     *   }
     * })
     * 
     */
    delete<T extends DSALessonDeleteArgs>(args: SelectSubset<T, DSALessonDeleteArgs<ExtArgs>>): Prisma__DSALessonClient<$Result.GetResult<Prisma.$DSALessonPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DSALesson.
     * @param {DSALessonUpdateArgs} args - Arguments to update one DSALesson.
     * @example
     * // Update one DSALesson
     * const dSALesson = await prisma.dSALesson.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DSALessonUpdateArgs>(args: SelectSubset<T, DSALessonUpdateArgs<ExtArgs>>): Prisma__DSALessonClient<$Result.GetResult<Prisma.$DSALessonPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DSALessons.
     * @param {DSALessonDeleteManyArgs} args - Arguments to filter DSALessons to delete.
     * @example
     * // Delete a few DSALessons
     * const { count } = await prisma.dSALesson.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DSALessonDeleteManyArgs>(args?: SelectSubset<T, DSALessonDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DSALessons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DSALessonUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DSALessons
     * const dSALesson = await prisma.dSALesson.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DSALessonUpdateManyArgs>(args: SelectSubset<T, DSALessonUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DSALesson.
     * @param {DSALessonUpsertArgs} args - Arguments to update or create a DSALesson.
     * @example
     * // Update or create a DSALesson
     * const dSALesson = await prisma.dSALesson.upsert({
     *   create: {
     *     // ... data to create a DSALesson
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DSALesson we want to update
     *   }
     * })
     */
    upsert<T extends DSALessonUpsertArgs>(args: SelectSubset<T, DSALessonUpsertArgs<ExtArgs>>): Prisma__DSALessonClient<$Result.GetResult<Prisma.$DSALessonPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DSALessons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DSALessonCountArgs} args - Arguments to filter DSALessons to count.
     * @example
     * // Count the number of DSALessons
     * const count = await prisma.dSALesson.count({
     *   where: {
     *     // ... the filter for the DSALessons we want to count
     *   }
     * })
    **/
    count<T extends DSALessonCountArgs>(
      args?: Subset<T, DSALessonCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DSALessonCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DSALesson.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DSALessonAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DSALessonAggregateArgs>(args: Subset<T, DSALessonAggregateArgs>): Prisma.PrismaPromise<GetDSALessonAggregateType<T>>

    /**
     * Group by DSALesson.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DSALessonGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DSALessonGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DSALessonGroupByArgs['orderBy'] }
        : { orderBy?: DSALessonGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DSALessonGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDSALessonGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DSALesson model
   */
  readonly fields: DSALessonFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DSALesson.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DSALessonClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    topic<T extends DSATopicDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DSATopicDefaultArgs<ExtArgs>>): Prisma__DSATopicClient<$Result.GetResult<Prisma.$DSATopicPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DSALesson model
   */ 
  interface DSALessonFieldRefs {
    readonly id: FieldRef<"DSALesson", 'String'>
    readonly topicId: FieldRef<"DSALesson", 'String'>
    readonly slug: FieldRef<"DSALesson", 'String'>
    readonly title: FieldRef<"DSALesson", 'String'>
    readonly content: FieldRef<"DSALesson", 'String'>
    readonly codeExamples: FieldRef<"DSALesson", 'Json'>
    readonly difficulty: FieldRef<"DSALesson", 'String'>
    readonly order: FieldRef<"DSALesson", 'Int'>
    readonly createdAt: FieldRef<"DSALesson", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DSALesson findUnique
   */
  export type DSALessonFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DSALesson
     */
    select?: DSALessonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DSALessonInclude<ExtArgs> | null
    /**
     * Filter, which DSALesson to fetch.
     */
    where: DSALessonWhereUniqueInput
  }

  /**
   * DSALesson findUniqueOrThrow
   */
  export type DSALessonFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DSALesson
     */
    select?: DSALessonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DSALessonInclude<ExtArgs> | null
    /**
     * Filter, which DSALesson to fetch.
     */
    where: DSALessonWhereUniqueInput
  }

  /**
   * DSALesson findFirst
   */
  export type DSALessonFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DSALesson
     */
    select?: DSALessonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DSALessonInclude<ExtArgs> | null
    /**
     * Filter, which DSALesson to fetch.
     */
    where?: DSALessonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DSALessons to fetch.
     */
    orderBy?: DSALessonOrderByWithRelationInput | DSALessonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DSALessons.
     */
    cursor?: DSALessonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DSALessons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DSALessons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DSALessons.
     */
    distinct?: DSALessonScalarFieldEnum | DSALessonScalarFieldEnum[]
  }

  /**
   * DSALesson findFirstOrThrow
   */
  export type DSALessonFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DSALesson
     */
    select?: DSALessonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DSALessonInclude<ExtArgs> | null
    /**
     * Filter, which DSALesson to fetch.
     */
    where?: DSALessonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DSALessons to fetch.
     */
    orderBy?: DSALessonOrderByWithRelationInput | DSALessonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DSALessons.
     */
    cursor?: DSALessonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DSALessons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DSALessons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DSALessons.
     */
    distinct?: DSALessonScalarFieldEnum | DSALessonScalarFieldEnum[]
  }

  /**
   * DSALesson findMany
   */
  export type DSALessonFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DSALesson
     */
    select?: DSALessonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DSALessonInclude<ExtArgs> | null
    /**
     * Filter, which DSALessons to fetch.
     */
    where?: DSALessonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DSALessons to fetch.
     */
    orderBy?: DSALessonOrderByWithRelationInput | DSALessonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DSALessons.
     */
    cursor?: DSALessonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DSALessons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DSALessons.
     */
    skip?: number
    distinct?: DSALessonScalarFieldEnum | DSALessonScalarFieldEnum[]
  }

  /**
   * DSALesson create
   */
  export type DSALessonCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DSALesson
     */
    select?: DSALessonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DSALessonInclude<ExtArgs> | null
    /**
     * The data needed to create a DSALesson.
     */
    data: XOR<DSALessonCreateInput, DSALessonUncheckedCreateInput>
  }

  /**
   * DSALesson createMany
   */
  export type DSALessonCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DSALessons.
     */
    data: DSALessonCreateManyInput | DSALessonCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DSALesson createManyAndReturn
   */
  export type DSALessonCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DSALesson
     */
    select?: DSALessonSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DSALessons.
     */
    data: DSALessonCreateManyInput | DSALessonCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DSALessonIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DSALesson update
   */
  export type DSALessonUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DSALesson
     */
    select?: DSALessonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DSALessonInclude<ExtArgs> | null
    /**
     * The data needed to update a DSALesson.
     */
    data: XOR<DSALessonUpdateInput, DSALessonUncheckedUpdateInput>
    /**
     * Choose, which DSALesson to update.
     */
    where: DSALessonWhereUniqueInput
  }

  /**
   * DSALesson updateMany
   */
  export type DSALessonUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DSALessons.
     */
    data: XOR<DSALessonUpdateManyMutationInput, DSALessonUncheckedUpdateManyInput>
    /**
     * Filter which DSALessons to update
     */
    where?: DSALessonWhereInput
  }

  /**
   * DSALesson upsert
   */
  export type DSALessonUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DSALesson
     */
    select?: DSALessonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DSALessonInclude<ExtArgs> | null
    /**
     * The filter to search for the DSALesson to update in case it exists.
     */
    where: DSALessonWhereUniqueInput
    /**
     * In case the DSALesson found by the `where` argument doesn't exist, create a new DSALesson with this data.
     */
    create: XOR<DSALessonCreateInput, DSALessonUncheckedCreateInput>
    /**
     * In case the DSALesson was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DSALessonUpdateInput, DSALessonUncheckedUpdateInput>
  }

  /**
   * DSALesson delete
   */
  export type DSALessonDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DSALesson
     */
    select?: DSALessonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DSALessonInclude<ExtArgs> | null
    /**
     * Filter which DSALesson to delete.
     */
    where: DSALessonWhereUniqueInput
  }

  /**
   * DSALesson deleteMany
   */
  export type DSALessonDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DSALessons to delete
     */
    where?: DSALessonWhereInput
  }

  /**
   * DSALesson without action
   */
  export type DSALessonDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DSALesson
     */
    select?: DSALessonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DSALessonInclude<ExtArgs> | null
  }


  /**
   * Model Problem
   */

  export type AggregateProblem = {
    _count: ProblemCountAggregateOutputType | null
    _avg: ProblemAvgAggregateOutputType | null
    _sum: ProblemSumAggregateOutputType | null
    _min: ProblemMinAggregateOutputType | null
    _max: ProblemMaxAggregateOutputType | null
  }

  export type ProblemAvgAggregateOutputType = {
    order: number | null
  }

  export type ProblemSumAggregateOutputType = {
    order: number | null
  }

  export type ProblemMinAggregateOutputType = {
    id: string | null
    title: string | null
    slug: string | null
    difficulty: string | null
    description: string | null
    pattern: string | null
    order: number | null
    createdAt: Date | null
  }

  export type ProblemMaxAggregateOutputType = {
    id: string | null
    title: string | null
    slug: string | null
    difficulty: string | null
    description: string | null
    pattern: string | null
    order: number | null
    createdAt: Date | null
  }

  export type ProblemCountAggregateOutputType = {
    id: number
    title: number
    slug: number
    difficulty: number
    description: number
    examples: number
    constraints: number
    starterCode: number
    solutions: number
    testCases: number
    pattern: number
    sheets: number
    order: number
    createdAt: number
    _all: number
  }


  export type ProblemAvgAggregateInputType = {
    order?: true
  }

  export type ProblemSumAggregateInputType = {
    order?: true
  }

  export type ProblemMinAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    difficulty?: true
    description?: true
    pattern?: true
    order?: true
    createdAt?: true
  }

  export type ProblemMaxAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    difficulty?: true
    description?: true
    pattern?: true
    order?: true
    createdAt?: true
  }

  export type ProblemCountAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    difficulty?: true
    description?: true
    examples?: true
    constraints?: true
    starterCode?: true
    solutions?: true
    testCases?: true
    pattern?: true
    sheets?: true
    order?: true
    createdAt?: true
    _all?: true
  }

  export type ProblemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Problem to aggregate.
     */
    where?: ProblemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Problems to fetch.
     */
    orderBy?: ProblemOrderByWithRelationInput | ProblemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProblemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Problems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Problems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Problems
    **/
    _count?: true | ProblemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProblemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProblemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProblemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProblemMaxAggregateInputType
  }

  export type GetProblemAggregateType<T extends ProblemAggregateArgs> = {
        [P in keyof T & keyof AggregateProblem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProblem[P]>
      : GetScalarType<T[P], AggregateProblem[P]>
  }




  export type ProblemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProblemWhereInput
    orderBy?: ProblemOrderByWithAggregationInput | ProblemOrderByWithAggregationInput[]
    by: ProblemScalarFieldEnum[] | ProblemScalarFieldEnum
    having?: ProblemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProblemCountAggregateInputType | true
    _avg?: ProblemAvgAggregateInputType
    _sum?: ProblemSumAggregateInputType
    _min?: ProblemMinAggregateInputType
    _max?: ProblemMaxAggregateInputType
  }

  export type ProblemGroupByOutputType = {
    id: string
    title: string
    slug: string
    difficulty: string
    description: string
    examples: JsonValue
    constraints: string[]
    starterCode: JsonValue
    solutions: JsonValue | null
    testCases: JsonValue | null
    pattern: string
    sheets: string[]
    order: number
    createdAt: Date
    _count: ProblemCountAggregateOutputType | null
    _avg: ProblemAvgAggregateOutputType | null
    _sum: ProblemSumAggregateOutputType | null
    _min: ProblemMinAggregateOutputType | null
    _max: ProblemMaxAggregateOutputType | null
  }

  type GetProblemGroupByPayload<T extends ProblemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProblemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProblemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProblemGroupByOutputType[P]>
            : GetScalarType<T[P], ProblemGroupByOutputType[P]>
        }
      >
    >


  export type ProblemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    difficulty?: boolean
    description?: boolean
    examples?: boolean
    constraints?: boolean
    starterCode?: boolean
    solutions?: boolean
    testCases?: boolean
    pattern?: boolean
    sheets?: boolean
    order?: boolean
    createdAt?: boolean
    progress?: boolean | Problem$progressArgs<ExtArgs>
    submissions?: boolean | Problem$submissionsArgs<ExtArgs>
    _count?: boolean | ProblemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["problem"]>

  export type ProblemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    difficulty?: boolean
    description?: boolean
    examples?: boolean
    constraints?: boolean
    starterCode?: boolean
    solutions?: boolean
    testCases?: boolean
    pattern?: boolean
    sheets?: boolean
    order?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["problem"]>

  export type ProblemSelectScalar = {
    id?: boolean
    title?: boolean
    slug?: boolean
    difficulty?: boolean
    description?: boolean
    examples?: boolean
    constraints?: boolean
    starterCode?: boolean
    solutions?: boolean
    testCases?: boolean
    pattern?: boolean
    sheets?: boolean
    order?: boolean
    createdAt?: boolean
  }

  export type ProblemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    progress?: boolean | Problem$progressArgs<ExtArgs>
    submissions?: boolean | Problem$submissionsArgs<ExtArgs>
    _count?: boolean | ProblemCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProblemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ProblemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Problem"
    objects: {
      progress: Prisma.$UserProgressPayload<ExtArgs>[]
      submissions: Prisma.$SubmissionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      slug: string
      difficulty: string
      description: string
      examples: Prisma.JsonValue
      constraints: string[]
      starterCode: Prisma.JsonValue
      solutions: Prisma.JsonValue | null
      testCases: Prisma.JsonValue | null
      pattern: string
      sheets: string[]
      order: number
      createdAt: Date
    }, ExtArgs["result"]["problem"]>
    composites: {}
  }

  type ProblemGetPayload<S extends boolean | null | undefined | ProblemDefaultArgs> = $Result.GetResult<Prisma.$ProblemPayload, S>

  type ProblemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProblemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProblemCountAggregateInputType | true
    }

  export interface ProblemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Problem'], meta: { name: 'Problem' } }
    /**
     * Find zero or one Problem that matches the filter.
     * @param {ProblemFindUniqueArgs} args - Arguments to find a Problem
     * @example
     * // Get one Problem
     * const problem = await prisma.problem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProblemFindUniqueArgs>(args: SelectSubset<T, ProblemFindUniqueArgs<ExtArgs>>): Prisma__ProblemClient<$Result.GetResult<Prisma.$ProblemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Problem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProblemFindUniqueOrThrowArgs} args - Arguments to find a Problem
     * @example
     * // Get one Problem
     * const problem = await prisma.problem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProblemFindUniqueOrThrowArgs>(args: SelectSubset<T, ProblemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProblemClient<$Result.GetResult<Prisma.$ProblemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Problem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProblemFindFirstArgs} args - Arguments to find a Problem
     * @example
     * // Get one Problem
     * const problem = await prisma.problem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProblemFindFirstArgs>(args?: SelectSubset<T, ProblemFindFirstArgs<ExtArgs>>): Prisma__ProblemClient<$Result.GetResult<Prisma.$ProblemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Problem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProblemFindFirstOrThrowArgs} args - Arguments to find a Problem
     * @example
     * // Get one Problem
     * const problem = await prisma.problem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProblemFindFirstOrThrowArgs>(args?: SelectSubset<T, ProblemFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProblemClient<$Result.GetResult<Prisma.$ProblemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Problems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProblemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Problems
     * const problems = await prisma.problem.findMany()
     * 
     * // Get first 10 Problems
     * const problems = await prisma.problem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const problemWithIdOnly = await prisma.problem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProblemFindManyArgs>(args?: SelectSubset<T, ProblemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProblemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Problem.
     * @param {ProblemCreateArgs} args - Arguments to create a Problem.
     * @example
     * // Create one Problem
     * const Problem = await prisma.problem.create({
     *   data: {
     *     // ... data to create a Problem
     *   }
     * })
     * 
     */
    create<T extends ProblemCreateArgs>(args: SelectSubset<T, ProblemCreateArgs<ExtArgs>>): Prisma__ProblemClient<$Result.GetResult<Prisma.$ProblemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Problems.
     * @param {ProblemCreateManyArgs} args - Arguments to create many Problems.
     * @example
     * // Create many Problems
     * const problem = await prisma.problem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProblemCreateManyArgs>(args?: SelectSubset<T, ProblemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Problems and returns the data saved in the database.
     * @param {ProblemCreateManyAndReturnArgs} args - Arguments to create many Problems.
     * @example
     * // Create many Problems
     * const problem = await prisma.problem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Problems and only return the `id`
     * const problemWithIdOnly = await prisma.problem.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProblemCreateManyAndReturnArgs>(args?: SelectSubset<T, ProblemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProblemPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Problem.
     * @param {ProblemDeleteArgs} args - Arguments to delete one Problem.
     * @example
     * // Delete one Problem
     * const Problem = await prisma.problem.delete({
     *   where: {
     *     // ... filter to delete one Problem
     *   }
     * })
     * 
     */
    delete<T extends ProblemDeleteArgs>(args: SelectSubset<T, ProblemDeleteArgs<ExtArgs>>): Prisma__ProblemClient<$Result.GetResult<Prisma.$ProblemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Problem.
     * @param {ProblemUpdateArgs} args - Arguments to update one Problem.
     * @example
     * // Update one Problem
     * const problem = await prisma.problem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProblemUpdateArgs>(args: SelectSubset<T, ProblemUpdateArgs<ExtArgs>>): Prisma__ProblemClient<$Result.GetResult<Prisma.$ProblemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Problems.
     * @param {ProblemDeleteManyArgs} args - Arguments to filter Problems to delete.
     * @example
     * // Delete a few Problems
     * const { count } = await prisma.problem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProblemDeleteManyArgs>(args?: SelectSubset<T, ProblemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Problems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProblemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Problems
     * const problem = await prisma.problem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProblemUpdateManyArgs>(args: SelectSubset<T, ProblemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Problem.
     * @param {ProblemUpsertArgs} args - Arguments to update or create a Problem.
     * @example
     * // Update or create a Problem
     * const problem = await prisma.problem.upsert({
     *   create: {
     *     // ... data to create a Problem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Problem we want to update
     *   }
     * })
     */
    upsert<T extends ProblemUpsertArgs>(args: SelectSubset<T, ProblemUpsertArgs<ExtArgs>>): Prisma__ProblemClient<$Result.GetResult<Prisma.$ProblemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Problems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProblemCountArgs} args - Arguments to filter Problems to count.
     * @example
     * // Count the number of Problems
     * const count = await prisma.problem.count({
     *   where: {
     *     // ... the filter for the Problems we want to count
     *   }
     * })
    **/
    count<T extends ProblemCountArgs>(
      args?: Subset<T, ProblemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProblemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Problem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProblemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProblemAggregateArgs>(args: Subset<T, ProblemAggregateArgs>): Prisma.PrismaPromise<GetProblemAggregateType<T>>

    /**
     * Group by Problem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProblemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProblemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProblemGroupByArgs['orderBy'] }
        : { orderBy?: ProblemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProblemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProblemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Problem model
   */
  readonly fields: ProblemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Problem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProblemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    progress<T extends Problem$progressArgs<ExtArgs> = {}>(args?: Subset<T, Problem$progressArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProgressPayload<ExtArgs>, T, "findMany"> | Null>
    submissions<T extends Problem$submissionsArgs<ExtArgs> = {}>(args?: Subset<T, Problem$submissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubmissionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Problem model
   */ 
  interface ProblemFieldRefs {
    readonly id: FieldRef<"Problem", 'String'>
    readonly title: FieldRef<"Problem", 'String'>
    readonly slug: FieldRef<"Problem", 'String'>
    readonly difficulty: FieldRef<"Problem", 'String'>
    readonly description: FieldRef<"Problem", 'String'>
    readonly examples: FieldRef<"Problem", 'Json'>
    readonly constraints: FieldRef<"Problem", 'String[]'>
    readonly starterCode: FieldRef<"Problem", 'Json'>
    readonly solutions: FieldRef<"Problem", 'Json'>
    readonly testCases: FieldRef<"Problem", 'Json'>
    readonly pattern: FieldRef<"Problem", 'String'>
    readonly sheets: FieldRef<"Problem", 'String[]'>
    readonly order: FieldRef<"Problem", 'Int'>
    readonly createdAt: FieldRef<"Problem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Problem findUnique
   */
  export type ProblemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Problem
     */
    select?: ProblemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProblemInclude<ExtArgs> | null
    /**
     * Filter, which Problem to fetch.
     */
    where: ProblemWhereUniqueInput
  }

  /**
   * Problem findUniqueOrThrow
   */
  export type ProblemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Problem
     */
    select?: ProblemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProblemInclude<ExtArgs> | null
    /**
     * Filter, which Problem to fetch.
     */
    where: ProblemWhereUniqueInput
  }

  /**
   * Problem findFirst
   */
  export type ProblemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Problem
     */
    select?: ProblemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProblemInclude<ExtArgs> | null
    /**
     * Filter, which Problem to fetch.
     */
    where?: ProblemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Problems to fetch.
     */
    orderBy?: ProblemOrderByWithRelationInput | ProblemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Problems.
     */
    cursor?: ProblemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Problems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Problems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Problems.
     */
    distinct?: ProblemScalarFieldEnum | ProblemScalarFieldEnum[]
  }

  /**
   * Problem findFirstOrThrow
   */
  export type ProblemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Problem
     */
    select?: ProblemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProblemInclude<ExtArgs> | null
    /**
     * Filter, which Problem to fetch.
     */
    where?: ProblemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Problems to fetch.
     */
    orderBy?: ProblemOrderByWithRelationInput | ProblemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Problems.
     */
    cursor?: ProblemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Problems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Problems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Problems.
     */
    distinct?: ProblemScalarFieldEnum | ProblemScalarFieldEnum[]
  }

  /**
   * Problem findMany
   */
  export type ProblemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Problem
     */
    select?: ProblemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProblemInclude<ExtArgs> | null
    /**
     * Filter, which Problems to fetch.
     */
    where?: ProblemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Problems to fetch.
     */
    orderBy?: ProblemOrderByWithRelationInput | ProblemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Problems.
     */
    cursor?: ProblemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Problems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Problems.
     */
    skip?: number
    distinct?: ProblemScalarFieldEnum | ProblemScalarFieldEnum[]
  }

  /**
   * Problem create
   */
  export type ProblemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Problem
     */
    select?: ProblemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProblemInclude<ExtArgs> | null
    /**
     * The data needed to create a Problem.
     */
    data: XOR<ProblemCreateInput, ProblemUncheckedCreateInput>
  }

  /**
   * Problem createMany
   */
  export type ProblemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Problems.
     */
    data: ProblemCreateManyInput | ProblemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Problem createManyAndReturn
   */
  export type ProblemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Problem
     */
    select?: ProblemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Problems.
     */
    data: ProblemCreateManyInput | ProblemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Problem update
   */
  export type ProblemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Problem
     */
    select?: ProblemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProblemInclude<ExtArgs> | null
    /**
     * The data needed to update a Problem.
     */
    data: XOR<ProblemUpdateInput, ProblemUncheckedUpdateInput>
    /**
     * Choose, which Problem to update.
     */
    where: ProblemWhereUniqueInput
  }

  /**
   * Problem updateMany
   */
  export type ProblemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Problems.
     */
    data: XOR<ProblemUpdateManyMutationInput, ProblemUncheckedUpdateManyInput>
    /**
     * Filter which Problems to update
     */
    where?: ProblemWhereInput
  }

  /**
   * Problem upsert
   */
  export type ProblemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Problem
     */
    select?: ProblemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProblemInclude<ExtArgs> | null
    /**
     * The filter to search for the Problem to update in case it exists.
     */
    where: ProblemWhereUniqueInput
    /**
     * In case the Problem found by the `where` argument doesn't exist, create a new Problem with this data.
     */
    create: XOR<ProblemCreateInput, ProblemUncheckedCreateInput>
    /**
     * In case the Problem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProblemUpdateInput, ProblemUncheckedUpdateInput>
  }

  /**
   * Problem delete
   */
  export type ProblemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Problem
     */
    select?: ProblemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProblemInclude<ExtArgs> | null
    /**
     * Filter which Problem to delete.
     */
    where: ProblemWhereUniqueInput
  }

  /**
   * Problem deleteMany
   */
  export type ProblemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Problems to delete
     */
    where?: ProblemWhereInput
  }

  /**
   * Problem.progress
   */
  export type Problem$progressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProgressInclude<ExtArgs> | null
    where?: UserProgressWhereInput
    orderBy?: UserProgressOrderByWithRelationInput | UserProgressOrderByWithRelationInput[]
    cursor?: UserProgressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserProgressScalarFieldEnum | UserProgressScalarFieldEnum[]
  }

  /**
   * Problem.submissions
   */
  export type Problem$submissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Submission
     */
    select?: SubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionInclude<ExtArgs> | null
    where?: SubmissionWhereInput
    orderBy?: SubmissionOrderByWithRelationInput | SubmissionOrderByWithRelationInput[]
    cursor?: SubmissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubmissionScalarFieldEnum | SubmissionScalarFieldEnum[]
  }

  /**
   * Problem without action
   */
  export type ProblemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Problem
     */
    select?: ProblemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProblemInclude<ExtArgs> | null
  }


  /**
   * Model UserProgress
   */

  export type AggregateUserProgress = {
    _count: UserProgressCountAggregateOutputType | null
    _min: UserProgressMinAggregateOutputType | null
    _max: UserProgressMaxAggregateOutputType | null
  }

  export type UserProgressMinAggregateOutputType = {
    id: string | null
    userId: string | null
    problemId: string | null
    status: string | null
    starred: boolean | null
    lastAttempt: Date | null
    createdAt: Date | null
  }

  export type UserProgressMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    problemId: string | null
    status: string | null
    starred: boolean | null
    lastAttempt: Date | null
    createdAt: Date | null
  }

  export type UserProgressCountAggregateOutputType = {
    id: number
    userId: number
    problemId: number
    status: number
    starred: number
    lastAttempt: number
    createdAt: number
    _all: number
  }


  export type UserProgressMinAggregateInputType = {
    id?: true
    userId?: true
    problemId?: true
    status?: true
    starred?: true
    lastAttempt?: true
    createdAt?: true
  }

  export type UserProgressMaxAggregateInputType = {
    id?: true
    userId?: true
    problemId?: true
    status?: true
    starred?: true
    lastAttempt?: true
    createdAt?: true
  }

  export type UserProgressCountAggregateInputType = {
    id?: true
    userId?: true
    problemId?: true
    status?: true
    starred?: true
    lastAttempt?: true
    createdAt?: true
    _all?: true
  }

  export type UserProgressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserProgress to aggregate.
     */
    where?: UserProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProgresses to fetch.
     */
    orderBy?: UserProgressOrderByWithRelationInput | UserProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserProgresses
    **/
    _count?: true | UserProgressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserProgressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserProgressMaxAggregateInputType
  }

  export type GetUserProgressAggregateType<T extends UserProgressAggregateArgs> = {
        [P in keyof T & keyof AggregateUserProgress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserProgress[P]>
      : GetScalarType<T[P], AggregateUserProgress[P]>
  }




  export type UserProgressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserProgressWhereInput
    orderBy?: UserProgressOrderByWithAggregationInput | UserProgressOrderByWithAggregationInput[]
    by: UserProgressScalarFieldEnum[] | UserProgressScalarFieldEnum
    having?: UserProgressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserProgressCountAggregateInputType | true
    _min?: UserProgressMinAggregateInputType
    _max?: UserProgressMaxAggregateInputType
  }

  export type UserProgressGroupByOutputType = {
    id: string
    userId: string
    problemId: string
    status: string
    starred: boolean
    lastAttempt: Date
    createdAt: Date
    _count: UserProgressCountAggregateOutputType | null
    _min: UserProgressMinAggregateOutputType | null
    _max: UserProgressMaxAggregateOutputType | null
  }

  type GetUserProgressGroupByPayload<T extends UserProgressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserProgressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserProgressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserProgressGroupByOutputType[P]>
            : GetScalarType<T[P], UserProgressGroupByOutputType[P]>
        }
      >
    >


  export type UserProgressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    problemId?: boolean
    status?: boolean
    starred?: boolean
    lastAttempt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    problem?: boolean | ProblemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userProgress"]>

  export type UserProgressSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    problemId?: boolean
    status?: boolean
    starred?: boolean
    lastAttempt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    problem?: boolean | ProblemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userProgress"]>

  export type UserProgressSelectScalar = {
    id?: boolean
    userId?: boolean
    problemId?: boolean
    status?: boolean
    starred?: boolean
    lastAttempt?: boolean
    createdAt?: boolean
  }

  export type UserProgressInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    problem?: boolean | ProblemDefaultArgs<ExtArgs>
  }
  export type UserProgressIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    problem?: boolean | ProblemDefaultArgs<ExtArgs>
  }

  export type $UserProgressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserProgress"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      problem: Prisma.$ProblemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      problemId: string
      status: string
      starred: boolean
      lastAttempt: Date
      createdAt: Date
    }, ExtArgs["result"]["userProgress"]>
    composites: {}
  }

  type UserProgressGetPayload<S extends boolean | null | undefined | UserProgressDefaultArgs> = $Result.GetResult<Prisma.$UserProgressPayload, S>

  type UserProgressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserProgressFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserProgressCountAggregateInputType | true
    }

  export interface UserProgressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserProgress'], meta: { name: 'UserProgress' } }
    /**
     * Find zero or one UserProgress that matches the filter.
     * @param {UserProgressFindUniqueArgs} args - Arguments to find a UserProgress
     * @example
     * // Get one UserProgress
     * const userProgress = await prisma.userProgress.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserProgressFindUniqueArgs>(args: SelectSubset<T, UserProgressFindUniqueArgs<ExtArgs>>): Prisma__UserProgressClient<$Result.GetResult<Prisma.$UserProgressPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserProgress that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserProgressFindUniqueOrThrowArgs} args - Arguments to find a UserProgress
     * @example
     * // Get one UserProgress
     * const userProgress = await prisma.userProgress.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserProgressFindUniqueOrThrowArgs>(args: SelectSubset<T, UserProgressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserProgressClient<$Result.GetResult<Prisma.$UserProgressPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserProgress that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProgressFindFirstArgs} args - Arguments to find a UserProgress
     * @example
     * // Get one UserProgress
     * const userProgress = await prisma.userProgress.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserProgressFindFirstArgs>(args?: SelectSubset<T, UserProgressFindFirstArgs<ExtArgs>>): Prisma__UserProgressClient<$Result.GetResult<Prisma.$UserProgressPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserProgress that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProgressFindFirstOrThrowArgs} args - Arguments to find a UserProgress
     * @example
     * // Get one UserProgress
     * const userProgress = await prisma.userProgress.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserProgressFindFirstOrThrowArgs>(args?: SelectSubset<T, UserProgressFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserProgressClient<$Result.GetResult<Prisma.$UserProgressPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserProgresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProgressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserProgresses
     * const userProgresses = await prisma.userProgress.findMany()
     * 
     * // Get first 10 UserProgresses
     * const userProgresses = await prisma.userProgress.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userProgressWithIdOnly = await prisma.userProgress.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserProgressFindManyArgs>(args?: SelectSubset<T, UserProgressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProgressPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserProgress.
     * @param {UserProgressCreateArgs} args - Arguments to create a UserProgress.
     * @example
     * // Create one UserProgress
     * const UserProgress = await prisma.userProgress.create({
     *   data: {
     *     // ... data to create a UserProgress
     *   }
     * })
     * 
     */
    create<T extends UserProgressCreateArgs>(args: SelectSubset<T, UserProgressCreateArgs<ExtArgs>>): Prisma__UserProgressClient<$Result.GetResult<Prisma.$UserProgressPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserProgresses.
     * @param {UserProgressCreateManyArgs} args - Arguments to create many UserProgresses.
     * @example
     * // Create many UserProgresses
     * const userProgress = await prisma.userProgress.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserProgressCreateManyArgs>(args?: SelectSubset<T, UserProgressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserProgresses and returns the data saved in the database.
     * @param {UserProgressCreateManyAndReturnArgs} args - Arguments to create many UserProgresses.
     * @example
     * // Create many UserProgresses
     * const userProgress = await prisma.userProgress.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserProgresses and only return the `id`
     * const userProgressWithIdOnly = await prisma.userProgress.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserProgressCreateManyAndReturnArgs>(args?: SelectSubset<T, UserProgressCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProgressPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserProgress.
     * @param {UserProgressDeleteArgs} args - Arguments to delete one UserProgress.
     * @example
     * // Delete one UserProgress
     * const UserProgress = await prisma.userProgress.delete({
     *   where: {
     *     // ... filter to delete one UserProgress
     *   }
     * })
     * 
     */
    delete<T extends UserProgressDeleteArgs>(args: SelectSubset<T, UserProgressDeleteArgs<ExtArgs>>): Prisma__UserProgressClient<$Result.GetResult<Prisma.$UserProgressPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserProgress.
     * @param {UserProgressUpdateArgs} args - Arguments to update one UserProgress.
     * @example
     * // Update one UserProgress
     * const userProgress = await prisma.userProgress.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserProgressUpdateArgs>(args: SelectSubset<T, UserProgressUpdateArgs<ExtArgs>>): Prisma__UserProgressClient<$Result.GetResult<Prisma.$UserProgressPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserProgresses.
     * @param {UserProgressDeleteManyArgs} args - Arguments to filter UserProgresses to delete.
     * @example
     * // Delete a few UserProgresses
     * const { count } = await prisma.userProgress.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserProgressDeleteManyArgs>(args?: SelectSubset<T, UserProgressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserProgresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProgressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserProgresses
     * const userProgress = await prisma.userProgress.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserProgressUpdateManyArgs>(args: SelectSubset<T, UserProgressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserProgress.
     * @param {UserProgressUpsertArgs} args - Arguments to update or create a UserProgress.
     * @example
     * // Update or create a UserProgress
     * const userProgress = await prisma.userProgress.upsert({
     *   create: {
     *     // ... data to create a UserProgress
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserProgress we want to update
     *   }
     * })
     */
    upsert<T extends UserProgressUpsertArgs>(args: SelectSubset<T, UserProgressUpsertArgs<ExtArgs>>): Prisma__UserProgressClient<$Result.GetResult<Prisma.$UserProgressPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserProgresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProgressCountArgs} args - Arguments to filter UserProgresses to count.
     * @example
     * // Count the number of UserProgresses
     * const count = await prisma.userProgress.count({
     *   where: {
     *     // ... the filter for the UserProgresses we want to count
     *   }
     * })
    **/
    count<T extends UserProgressCountArgs>(
      args?: Subset<T, UserProgressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserProgressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserProgress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProgressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserProgressAggregateArgs>(args: Subset<T, UserProgressAggregateArgs>): Prisma.PrismaPromise<GetUserProgressAggregateType<T>>

    /**
     * Group by UserProgress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProgressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserProgressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserProgressGroupByArgs['orderBy'] }
        : { orderBy?: UserProgressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserProgressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserProgressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserProgress model
   */
  readonly fields: UserProgressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserProgress.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserProgressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    problem<T extends ProblemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProblemDefaultArgs<ExtArgs>>): Prisma__ProblemClient<$Result.GetResult<Prisma.$ProblemPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserProgress model
   */ 
  interface UserProgressFieldRefs {
    readonly id: FieldRef<"UserProgress", 'String'>
    readonly userId: FieldRef<"UserProgress", 'String'>
    readonly problemId: FieldRef<"UserProgress", 'String'>
    readonly status: FieldRef<"UserProgress", 'String'>
    readonly starred: FieldRef<"UserProgress", 'Boolean'>
    readonly lastAttempt: FieldRef<"UserProgress", 'DateTime'>
    readonly createdAt: FieldRef<"UserProgress", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserProgress findUnique
   */
  export type UserProgressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProgressInclude<ExtArgs> | null
    /**
     * Filter, which UserProgress to fetch.
     */
    where: UserProgressWhereUniqueInput
  }

  /**
   * UserProgress findUniqueOrThrow
   */
  export type UserProgressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProgressInclude<ExtArgs> | null
    /**
     * Filter, which UserProgress to fetch.
     */
    where: UserProgressWhereUniqueInput
  }

  /**
   * UserProgress findFirst
   */
  export type UserProgressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProgressInclude<ExtArgs> | null
    /**
     * Filter, which UserProgress to fetch.
     */
    where?: UserProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProgresses to fetch.
     */
    orderBy?: UserProgressOrderByWithRelationInput | UserProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserProgresses.
     */
    cursor?: UserProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserProgresses.
     */
    distinct?: UserProgressScalarFieldEnum | UserProgressScalarFieldEnum[]
  }

  /**
   * UserProgress findFirstOrThrow
   */
  export type UserProgressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProgressInclude<ExtArgs> | null
    /**
     * Filter, which UserProgress to fetch.
     */
    where?: UserProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProgresses to fetch.
     */
    orderBy?: UserProgressOrderByWithRelationInput | UserProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserProgresses.
     */
    cursor?: UserProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserProgresses.
     */
    distinct?: UserProgressScalarFieldEnum | UserProgressScalarFieldEnum[]
  }

  /**
   * UserProgress findMany
   */
  export type UserProgressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProgressInclude<ExtArgs> | null
    /**
     * Filter, which UserProgresses to fetch.
     */
    where?: UserProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProgresses to fetch.
     */
    orderBy?: UserProgressOrderByWithRelationInput | UserProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserProgresses.
     */
    cursor?: UserProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProgresses.
     */
    skip?: number
    distinct?: UserProgressScalarFieldEnum | UserProgressScalarFieldEnum[]
  }

  /**
   * UserProgress create
   */
  export type UserProgressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProgressInclude<ExtArgs> | null
    /**
     * The data needed to create a UserProgress.
     */
    data: XOR<UserProgressCreateInput, UserProgressUncheckedCreateInput>
  }

  /**
   * UserProgress createMany
   */
  export type UserProgressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserProgresses.
     */
    data: UserProgressCreateManyInput | UserProgressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserProgress createManyAndReturn
   */
  export type UserProgressCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserProgresses.
     */
    data: UserProgressCreateManyInput | UserProgressCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProgressIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserProgress update
   */
  export type UserProgressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProgressInclude<ExtArgs> | null
    /**
     * The data needed to update a UserProgress.
     */
    data: XOR<UserProgressUpdateInput, UserProgressUncheckedUpdateInput>
    /**
     * Choose, which UserProgress to update.
     */
    where: UserProgressWhereUniqueInput
  }

  /**
   * UserProgress updateMany
   */
  export type UserProgressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserProgresses.
     */
    data: XOR<UserProgressUpdateManyMutationInput, UserProgressUncheckedUpdateManyInput>
    /**
     * Filter which UserProgresses to update
     */
    where?: UserProgressWhereInput
  }

  /**
   * UserProgress upsert
   */
  export type UserProgressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProgressInclude<ExtArgs> | null
    /**
     * The filter to search for the UserProgress to update in case it exists.
     */
    where: UserProgressWhereUniqueInput
    /**
     * In case the UserProgress found by the `where` argument doesn't exist, create a new UserProgress with this data.
     */
    create: XOR<UserProgressCreateInput, UserProgressUncheckedCreateInput>
    /**
     * In case the UserProgress was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserProgressUpdateInput, UserProgressUncheckedUpdateInput>
  }

  /**
   * UserProgress delete
   */
  export type UserProgressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProgressInclude<ExtArgs> | null
    /**
     * Filter which UserProgress to delete.
     */
    where: UserProgressWhereUniqueInput
  }

  /**
   * UserProgress deleteMany
   */
  export type UserProgressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserProgresses to delete
     */
    where?: UserProgressWhereInput
  }

  /**
   * UserProgress without action
   */
  export type UserProgressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProgress
     */
    select?: UserProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProgressInclude<ExtArgs> | null
  }


  /**
   * Model Submission
   */

  export type AggregateSubmission = {
    _count: SubmissionCountAggregateOutputType | null
    _avg: SubmissionAvgAggregateOutputType | null
    _sum: SubmissionSumAggregateOutputType | null
    _min: SubmissionMinAggregateOutputType | null
    _max: SubmissionMaxAggregateOutputType | null
  }

  export type SubmissionAvgAggregateOutputType = {
    runtime: number | null
    memory: number | null
  }

  export type SubmissionSumAggregateOutputType = {
    runtime: number | null
    memory: number | null
  }

  export type SubmissionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    problemId: string | null
    code: string | null
    language: string | null
    status: string | null
    runtime: number | null
    memory: number | null
    createdAt: Date | null
  }

  export type SubmissionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    problemId: string | null
    code: string | null
    language: string | null
    status: string | null
    runtime: number | null
    memory: number | null
    createdAt: Date | null
  }

  export type SubmissionCountAggregateOutputType = {
    id: number
    userId: number
    problemId: number
    code: number
    language: number
    status: number
    runtime: number
    memory: number
    createdAt: number
    _all: number
  }


  export type SubmissionAvgAggregateInputType = {
    runtime?: true
    memory?: true
  }

  export type SubmissionSumAggregateInputType = {
    runtime?: true
    memory?: true
  }

  export type SubmissionMinAggregateInputType = {
    id?: true
    userId?: true
    problemId?: true
    code?: true
    language?: true
    status?: true
    runtime?: true
    memory?: true
    createdAt?: true
  }

  export type SubmissionMaxAggregateInputType = {
    id?: true
    userId?: true
    problemId?: true
    code?: true
    language?: true
    status?: true
    runtime?: true
    memory?: true
    createdAt?: true
  }

  export type SubmissionCountAggregateInputType = {
    id?: true
    userId?: true
    problemId?: true
    code?: true
    language?: true
    status?: true
    runtime?: true
    memory?: true
    createdAt?: true
    _all?: true
  }

  export type SubmissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Submission to aggregate.
     */
    where?: SubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Submissions to fetch.
     */
    orderBy?: SubmissionOrderByWithRelationInput | SubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Submissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Submissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Submissions
    **/
    _count?: true | SubmissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubmissionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubmissionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubmissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubmissionMaxAggregateInputType
  }

  export type GetSubmissionAggregateType<T extends SubmissionAggregateArgs> = {
        [P in keyof T & keyof AggregateSubmission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubmission[P]>
      : GetScalarType<T[P], AggregateSubmission[P]>
  }




  export type SubmissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubmissionWhereInput
    orderBy?: SubmissionOrderByWithAggregationInput | SubmissionOrderByWithAggregationInput[]
    by: SubmissionScalarFieldEnum[] | SubmissionScalarFieldEnum
    having?: SubmissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubmissionCountAggregateInputType | true
    _avg?: SubmissionAvgAggregateInputType
    _sum?: SubmissionSumAggregateInputType
    _min?: SubmissionMinAggregateInputType
    _max?: SubmissionMaxAggregateInputType
  }

  export type SubmissionGroupByOutputType = {
    id: string
    userId: string
    problemId: string
    code: string
    language: string
    status: string
    runtime: number | null
    memory: number | null
    createdAt: Date
    _count: SubmissionCountAggregateOutputType | null
    _avg: SubmissionAvgAggregateOutputType | null
    _sum: SubmissionSumAggregateOutputType | null
    _min: SubmissionMinAggregateOutputType | null
    _max: SubmissionMaxAggregateOutputType | null
  }

  type GetSubmissionGroupByPayload<T extends SubmissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubmissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubmissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubmissionGroupByOutputType[P]>
            : GetScalarType<T[P], SubmissionGroupByOutputType[P]>
        }
      >
    >


  export type SubmissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    problemId?: boolean
    code?: boolean
    language?: boolean
    status?: boolean
    runtime?: boolean
    memory?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    problem?: boolean | ProblemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["submission"]>

  export type SubmissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    problemId?: boolean
    code?: boolean
    language?: boolean
    status?: boolean
    runtime?: boolean
    memory?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    problem?: boolean | ProblemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["submission"]>

  export type SubmissionSelectScalar = {
    id?: boolean
    userId?: boolean
    problemId?: boolean
    code?: boolean
    language?: boolean
    status?: boolean
    runtime?: boolean
    memory?: boolean
    createdAt?: boolean
  }

  export type SubmissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    problem?: boolean | ProblemDefaultArgs<ExtArgs>
  }
  export type SubmissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    problem?: boolean | ProblemDefaultArgs<ExtArgs>
  }

  export type $SubmissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Submission"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      problem: Prisma.$ProblemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      problemId: string
      code: string
      language: string
      status: string
      runtime: number | null
      memory: number | null
      createdAt: Date
    }, ExtArgs["result"]["submission"]>
    composites: {}
  }

  type SubmissionGetPayload<S extends boolean | null | undefined | SubmissionDefaultArgs> = $Result.GetResult<Prisma.$SubmissionPayload, S>

  type SubmissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SubmissionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SubmissionCountAggregateInputType | true
    }

  export interface SubmissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Submission'], meta: { name: 'Submission' } }
    /**
     * Find zero or one Submission that matches the filter.
     * @param {SubmissionFindUniqueArgs} args - Arguments to find a Submission
     * @example
     * // Get one Submission
     * const submission = await prisma.submission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubmissionFindUniqueArgs>(args: SelectSubset<T, SubmissionFindUniqueArgs<ExtArgs>>): Prisma__SubmissionClient<$Result.GetResult<Prisma.$SubmissionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Submission that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SubmissionFindUniqueOrThrowArgs} args - Arguments to find a Submission
     * @example
     * // Get one Submission
     * const submission = await prisma.submission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubmissionFindUniqueOrThrowArgs>(args: SelectSubset<T, SubmissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubmissionClient<$Result.GetResult<Prisma.$SubmissionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Submission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmissionFindFirstArgs} args - Arguments to find a Submission
     * @example
     * // Get one Submission
     * const submission = await prisma.submission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubmissionFindFirstArgs>(args?: SelectSubset<T, SubmissionFindFirstArgs<ExtArgs>>): Prisma__SubmissionClient<$Result.GetResult<Prisma.$SubmissionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Submission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmissionFindFirstOrThrowArgs} args - Arguments to find a Submission
     * @example
     * // Get one Submission
     * const submission = await prisma.submission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubmissionFindFirstOrThrowArgs>(args?: SelectSubset<T, SubmissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubmissionClient<$Result.GetResult<Prisma.$SubmissionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Submissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Submissions
     * const submissions = await prisma.submission.findMany()
     * 
     * // Get first 10 Submissions
     * const submissions = await prisma.submission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const submissionWithIdOnly = await prisma.submission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubmissionFindManyArgs>(args?: SelectSubset<T, SubmissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubmissionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Submission.
     * @param {SubmissionCreateArgs} args - Arguments to create a Submission.
     * @example
     * // Create one Submission
     * const Submission = await prisma.submission.create({
     *   data: {
     *     // ... data to create a Submission
     *   }
     * })
     * 
     */
    create<T extends SubmissionCreateArgs>(args: SelectSubset<T, SubmissionCreateArgs<ExtArgs>>): Prisma__SubmissionClient<$Result.GetResult<Prisma.$SubmissionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Submissions.
     * @param {SubmissionCreateManyArgs} args - Arguments to create many Submissions.
     * @example
     * // Create many Submissions
     * const submission = await prisma.submission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubmissionCreateManyArgs>(args?: SelectSubset<T, SubmissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Submissions and returns the data saved in the database.
     * @param {SubmissionCreateManyAndReturnArgs} args - Arguments to create many Submissions.
     * @example
     * // Create many Submissions
     * const submission = await prisma.submission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Submissions and only return the `id`
     * const submissionWithIdOnly = await prisma.submission.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubmissionCreateManyAndReturnArgs>(args?: SelectSubset<T, SubmissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubmissionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Submission.
     * @param {SubmissionDeleteArgs} args - Arguments to delete one Submission.
     * @example
     * // Delete one Submission
     * const Submission = await prisma.submission.delete({
     *   where: {
     *     // ... filter to delete one Submission
     *   }
     * })
     * 
     */
    delete<T extends SubmissionDeleteArgs>(args: SelectSubset<T, SubmissionDeleteArgs<ExtArgs>>): Prisma__SubmissionClient<$Result.GetResult<Prisma.$SubmissionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Submission.
     * @param {SubmissionUpdateArgs} args - Arguments to update one Submission.
     * @example
     * // Update one Submission
     * const submission = await prisma.submission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubmissionUpdateArgs>(args: SelectSubset<T, SubmissionUpdateArgs<ExtArgs>>): Prisma__SubmissionClient<$Result.GetResult<Prisma.$SubmissionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Submissions.
     * @param {SubmissionDeleteManyArgs} args - Arguments to filter Submissions to delete.
     * @example
     * // Delete a few Submissions
     * const { count } = await prisma.submission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubmissionDeleteManyArgs>(args?: SelectSubset<T, SubmissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Submissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Submissions
     * const submission = await prisma.submission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubmissionUpdateManyArgs>(args: SelectSubset<T, SubmissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Submission.
     * @param {SubmissionUpsertArgs} args - Arguments to update or create a Submission.
     * @example
     * // Update or create a Submission
     * const submission = await prisma.submission.upsert({
     *   create: {
     *     // ... data to create a Submission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Submission we want to update
     *   }
     * })
     */
    upsert<T extends SubmissionUpsertArgs>(args: SelectSubset<T, SubmissionUpsertArgs<ExtArgs>>): Prisma__SubmissionClient<$Result.GetResult<Prisma.$SubmissionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Submissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmissionCountArgs} args - Arguments to filter Submissions to count.
     * @example
     * // Count the number of Submissions
     * const count = await prisma.submission.count({
     *   where: {
     *     // ... the filter for the Submissions we want to count
     *   }
     * })
    **/
    count<T extends SubmissionCountArgs>(
      args?: Subset<T, SubmissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubmissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Submission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubmissionAggregateArgs>(args: Subset<T, SubmissionAggregateArgs>): Prisma.PrismaPromise<GetSubmissionAggregateType<T>>

    /**
     * Group by Submission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubmissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubmissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubmissionGroupByArgs['orderBy'] }
        : { orderBy?: SubmissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubmissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubmissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Submission model
   */
  readonly fields: SubmissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Submission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubmissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    problem<T extends ProblemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProblemDefaultArgs<ExtArgs>>): Prisma__ProblemClient<$Result.GetResult<Prisma.$ProblemPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Submission model
   */ 
  interface SubmissionFieldRefs {
    readonly id: FieldRef<"Submission", 'String'>
    readonly userId: FieldRef<"Submission", 'String'>
    readonly problemId: FieldRef<"Submission", 'String'>
    readonly code: FieldRef<"Submission", 'String'>
    readonly language: FieldRef<"Submission", 'String'>
    readonly status: FieldRef<"Submission", 'String'>
    readonly runtime: FieldRef<"Submission", 'Int'>
    readonly memory: FieldRef<"Submission", 'Int'>
    readonly createdAt: FieldRef<"Submission", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Submission findUnique
   */
  export type SubmissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Submission
     */
    select?: SubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionInclude<ExtArgs> | null
    /**
     * Filter, which Submission to fetch.
     */
    where: SubmissionWhereUniqueInput
  }

  /**
   * Submission findUniqueOrThrow
   */
  export type SubmissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Submission
     */
    select?: SubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionInclude<ExtArgs> | null
    /**
     * Filter, which Submission to fetch.
     */
    where: SubmissionWhereUniqueInput
  }

  /**
   * Submission findFirst
   */
  export type SubmissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Submission
     */
    select?: SubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionInclude<ExtArgs> | null
    /**
     * Filter, which Submission to fetch.
     */
    where?: SubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Submissions to fetch.
     */
    orderBy?: SubmissionOrderByWithRelationInput | SubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Submissions.
     */
    cursor?: SubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Submissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Submissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Submissions.
     */
    distinct?: SubmissionScalarFieldEnum | SubmissionScalarFieldEnum[]
  }

  /**
   * Submission findFirstOrThrow
   */
  export type SubmissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Submission
     */
    select?: SubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionInclude<ExtArgs> | null
    /**
     * Filter, which Submission to fetch.
     */
    where?: SubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Submissions to fetch.
     */
    orderBy?: SubmissionOrderByWithRelationInput | SubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Submissions.
     */
    cursor?: SubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Submissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Submissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Submissions.
     */
    distinct?: SubmissionScalarFieldEnum | SubmissionScalarFieldEnum[]
  }

  /**
   * Submission findMany
   */
  export type SubmissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Submission
     */
    select?: SubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionInclude<ExtArgs> | null
    /**
     * Filter, which Submissions to fetch.
     */
    where?: SubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Submissions to fetch.
     */
    orderBy?: SubmissionOrderByWithRelationInput | SubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Submissions.
     */
    cursor?: SubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Submissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Submissions.
     */
    skip?: number
    distinct?: SubmissionScalarFieldEnum | SubmissionScalarFieldEnum[]
  }

  /**
   * Submission create
   */
  export type SubmissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Submission
     */
    select?: SubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionInclude<ExtArgs> | null
    /**
     * The data needed to create a Submission.
     */
    data: XOR<SubmissionCreateInput, SubmissionUncheckedCreateInput>
  }

  /**
   * Submission createMany
   */
  export type SubmissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Submissions.
     */
    data: SubmissionCreateManyInput | SubmissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Submission createManyAndReturn
   */
  export type SubmissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Submission
     */
    select?: SubmissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Submissions.
     */
    data: SubmissionCreateManyInput | SubmissionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Submission update
   */
  export type SubmissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Submission
     */
    select?: SubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionInclude<ExtArgs> | null
    /**
     * The data needed to update a Submission.
     */
    data: XOR<SubmissionUpdateInput, SubmissionUncheckedUpdateInput>
    /**
     * Choose, which Submission to update.
     */
    where: SubmissionWhereUniqueInput
  }

  /**
   * Submission updateMany
   */
  export type SubmissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Submissions.
     */
    data: XOR<SubmissionUpdateManyMutationInput, SubmissionUncheckedUpdateManyInput>
    /**
     * Filter which Submissions to update
     */
    where?: SubmissionWhereInput
  }

  /**
   * Submission upsert
   */
  export type SubmissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Submission
     */
    select?: SubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionInclude<ExtArgs> | null
    /**
     * The filter to search for the Submission to update in case it exists.
     */
    where: SubmissionWhereUniqueInput
    /**
     * In case the Submission found by the `where` argument doesn't exist, create a new Submission with this data.
     */
    create: XOR<SubmissionCreateInput, SubmissionUncheckedCreateInput>
    /**
     * In case the Submission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubmissionUpdateInput, SubmissionUncheckedUpdateInput>
  }

  /**
   * Submission delete
   */
  export type SubmissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Submission
     */
    select?: SubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionInclude<ExtArgs> | null
    /**
     * Filter which Submission to delete.
     */
    where: SubmissionWhereUniqueInput
  }

  /**
   * Submission deleteMany
   */
  export type SubmissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Submissions to delete
     */
    where?: SubmissionWhereInput
  }

  /**
   * Submission without action
   */
  export type SubmissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Submission
     */
    select?: SubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubmissionInclude<ExtArgs> | null
  }


  /**
   * Model LearnDomain
   */

  export type AggregateLearnDomain = {
    _count: LearnDomainCountAggregateOutputType | null
    _min: LearnDomainMinAggregateOutputType | null
    _max: LearnDomainMaxAggregateOutputType | null
  }

  export type LearnDomainMinAggregateOutputType = {
    id: string | null
    slug: string | null
    title: string | null
    createdAt: Date | null
  }

  export type LearnDomainMaxAggregateOutputType = {
    id: string | null
    slug: string | null
    title: string | null
    createdAt: Date | null
  }

  export type LearnDomainCountAggregateOutputType = {
    id: number
    slug: number
    title: number
    createdAt: number
    _all: number
  }


  export type LearnDomainMinAggregateInputType = {
    id?: true
    slug?: true
    title?: true
    createdAt?: true
  }

  export type LearnDomainMaxAggregateInputType = {
    id?: true
    slug?: true
    title?: true
    createdAt?: true
  }

  export type LearnDomainCountAggregateInputType = {
    id?: true
    slug?: true
    title?: true
    createdAt?: true
    _all?: true
  }

  export type LearnDomainAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LearnDomain to aggregate.
     */
    where?: LearnDomainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearnDomains to fetch.
     */
    orderBy?: LearnDomainOrderByWithRelationInput | LearnDomainOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LearnDomainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearnDomains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearnDomains.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LearnDomains
    **/
    _count?: true | LearnDomainCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LearnDomainMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LearnDomainMaxAggregateInputType
  }

  export type GetLearnDomainAggregateType<T extends LearnDomainAggregateArgs> = {
        [P in keyof T & keyof AggregateLearnDomain]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLearnDomain[P]>
      : GetScalarType<T[P], AggregateLearnDomain[P]>
  }




  export type LearnDomainGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LearnDomainWhereInput
    orderBy?: LearnDomainOrderByWithAggregationInput | LearnDomainOrderByWithAggregationInput[]
    by: LearnDomainScalarFieldEnum[] | LearnDomainScalarFieldEnum
    having?: LearnDomainScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LearnDomainCountAggregateInputType | true
    _min?: LearnDomainMinAggregateInputType
    _max?: LearnDomainMaxAggregateInputType
  }

  export type LearnDomainGroupByOutputType = {
    id: string
    slug: string
    title: string
    createdAt: Date
    _count: LearnDomainCountAggregateOutputType | null
    _min: LearnDomainMinAggregateOutputType | null
    _max: LearnDomainMaxAggregateOutputType | null
  }

  type GetLearnDomainGroupByPayload<T extends LearnDomainGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LearnDomainGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LearnDomainGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LearnDomainGroupByOutputType[P]>
            : GetScalarType<T[P], LearnDomainGroupByOutputType[P]>
        }
      >
    >


  export type LearnDomainSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    title?: boolean
    createdAt?: boolean
    categories?: boolean | LearnDomain$categoriesArgs<ExtArgs>
    _count?: boolean | LearnDomainCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["learnDomain"]>

  export type LearnDomainSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    title?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["learnDomain"]>

  export type LearnDomainSelectScalar = {
    id?: boolean
    slug?: boolean
    title?: boolean
    createdAt?: boolean
  }

  export type LearnDomainInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    categories?: boolean | LearnDomain$categoriesArgs<ExtArgs>
    _count?: boolean | LearnDomainCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LearnDomainIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $LearnDomainPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LearnDomain"
    objects: {
      categories: Prisma.$LearnCategoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      slug: string
      title: string
      createdAt: Date
    }, ExtArgs["result"]["learnDomain"]>
    composites: {}
  }

  type LearnDomainGetPayload<S extends boolean | null | undefined | LearnDomainDefaultArgs> = $Result.GetResult<Prisma.$LearnDomainPayload, S>

  type LearnDomainCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LearnDomainFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LearnDomainCountAggregateInputType | true
    }

  export interface LearnDomainDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LearnDomain'], meta: { name: 'LearnDomain' } }
    /**
     * Find zero or one LearnDomain that matches the filter.
     * @param {LearnDomainFindUniqueArgs} args - Arguments to find a LearnDomain
     * @example
     * // Get one LearnDomain
     * const learnDomain = await prisma.learnDomain.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LearnDomainFindUniqueArgs>(args: SelectSubset<T, LearnDomainFindUniqueArgs<ExtArgs>>): Prisma__LearnDomainClient<$Result.GetResult<Prisma.$LearnDomainPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one LearnDomain that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LearnDomainFindUniqueOrThrowArgs} args - Arguments to find a LearnDomain
     * @example
     * // Get one LearnDomain
     * const learnDomain = await prisma.learnDomain.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LearnDomainFindUniqueOrThrowArgs>(args: SelectSubset<T, LearnDomainFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LearnDomainClient<$Result.GetResult<Prisma.$LearnDomainPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first LearnDomain that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearnDomainFindFirstArgs} args - Arguments to find a LearnDomain
     * @example
     * // Get one LearnDomain
     * const learnDomain = await prisma.learnDomain.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LearnDomainFindFirstArgs>(args?: SelectSubset<T, LearnDomainFindFirstArgs<ExtArgs>>): Prisma__LearnDomainClient<$Result.GetResult<Prisma.$LearnDomainPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first LearnDomain that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearnDomainFindFirstOrThrowArgs} args - Arguments to find a LearnDomain
     * @example
     * // Get one LearnDomain
     * const learnDomain = await prisma.learnDomain.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LearnDomainFindFirstOrThrowArgs>(args?: SelectSubset<T, LearnDomainFindFirstOrThrowArgs<ExtArgs>>): Prisma__LearnDomainClient<$Result.GetResult<Prisma.$LearnDomainPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more LearnDomains that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearnDomainFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LearnDomains
     * const learnDomains = await prisma.learnDomain.findMany()
     * 
     * // Get first 10 LearnDomains
     * const learnDomains = await prisma.learnDomain.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const learnDomainWithIdOnly = await prisma.learnDomain.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LearnDomainFindManyArgs>(args?: SelectSubset<T, LearnDomainFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LearnDomainPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a LearnDomain.
     * @param {LearnDomainCreateArgs} args - Arguments to create a LearnDomain.
     * @example
     * // Create one LearnDomain
     * const LearnDomain = await prisma.learnDomain.create({
     *   data: {
     *     // ... data to create a LearnDomain
     *   }
     * })
     * 
     */
    create<T extends LearnDomainCreateArgs>(args: SelectSubset<T, LearnDomainCreateArgs<ExtArgs>>): Prisma__LearnDomainClient<$Result.GetResult<Prisma.$LearnDomainPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many LearnDomains.
     * @param {LearnDomainCreateManyArgs} args - Arguments to create many LearnDomains.
     * @example
     * // Create many LearnDomains
     * const learnDomain = await prisma.learnDomain.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LearnDomainCreateManyArgs>(args?: SelectSubset<T, LearnDomainCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LearnDomains and returns the data saved in the database.
     * @param {LearnDomainCreateManyAndReturnArgs} args - Arguments to create many LearnDomains.
     * @example
     * // Create many LearnDomains
     * const learnDomain = await prisma.learnDomain.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LearnDomains and only return the `id`
     * const learnDomainWithIdOnly = await prisma.learnDomain.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LearnDomainCreateManyAndReturnArgs>(args?: SelectSubset<T, LearnDomainCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LearnDomainPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a LearnDomain.
     * @param {LearnDomainDeleteArgs} args - Arguments to delete one LearnDomain.
     * @example
     * // Delete one LearnDomain
     * const LearnDomain = await prisma.learnDomain.delete({
     *   where: {
     *     // ... filter to delete one LearnDomain
     *   }
     * })
     * 
     */
    delete<T extends LearnDomainDeleteArgs>(args: SelectSubset<T, LearnDomainDeleteArgs<ExtArgs>>): Prisma__LearnDomainClient<$Result.GetResult<Prisma.$LearnDomainPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one LearnDomain.
     * @param {LearnDomainUpdateArgs} args - Arguments to update one LearnDomain.
     * @example
     * // Update one LearnDomain
     * const learnDomain = await prisma.learnDomain.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LearnDomainUpdateArgs>(args: SelectSubset<T, LearnDomainUpdateArgs<ExtArgs>>): Prisma__LearnDomainClient<$Result.GetResult<Prisma.$LearnDomainPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more LearnDomains.
     * @param {LearnDomainDeleteManyArgs} args - Arguments to filter LearnDomains to delete.
     * @example
     * // Delete a few LearnDomains
     * const { count } = await prisma.learnDomain.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LearnDomainDeleteManyArgs>(args?: SelectSubset<T, LearnDomainDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LearnDomains.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearnDomainUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LearnDomains
     * const learnDomain = await prisma.learnDomain.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LearnDomainUpdateManyArgs>(args: SelectSubset<T, LearnDomainUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LearnDomain.
     * @param {LearnDomainUpsertArgs} args - Arguments to update or create a LearnDomain.
     * @example
     * // Update or create a LearnDomain
     * const learnDomain = await prisma.learnDomain.upsert({
     *   create: {
     *     // ... data to create a LearnDomain
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LearnDomain we want to update
     *   }
     * })
     */
    upsert<T extends LearnDomainUpsertArgs>(args: SelectSubset<T, LearnDomainUpsertArgs<ExtArgs>>): Prisma__LearnDomainClient<$Result.GetResult<Prisma.$LearnDomainPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of LearnDomains.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearnDomainCountArgs} args - Arguments to filter LearnDomains to count.
     * @example
     * // Count the number of LearnDomains
     * const count = await prisma.learnDomain.count({
     *   where: {
     *     // ... the filter for the LearnDomains we want to count
     *   }
     * })
    **/
    count<T extends LearnDomainCountArgs>(
      args?: Subset<T, LearnDomainCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LearnDomainCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LearnDomain.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearnDomainAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LearnDomainAggregateArgs>(args: Subset<T, LearnDomainAggregateArgs>): Prisma.PrismaPromise<GetLearnDomainAggregateType<T>>

    /**
     * Group by LearnDomain.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearnDomainGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LearnDomainGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LearnDomainGroupByArgs['orderBy'] }
        : { orderBy?: LearnDomainGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LearnDomainGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLearnDomainGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LearnDomain model
   */
  readonly fields: LearnDomainFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LearnDomain.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LearnDomainClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    categories<T extends LearnDomain$categoriesArgs<ExtArgs> = {}>(args?: Subset<T, LearnDomain$categoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LearnCategoryPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LearnDomain model
   */ 
  interface LearnDomainFieldRefs {
    readonly id: FieldRef<"LearnDomain", 'String'>
    readonly slug: FieldRef<"LearnDomain", 'String'>
    readonly title: FieldRef<"LearnDomain", 'String'>
    readonly createdAt: FieldRef<"LearnDomain", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LearnDomain findUnique
   */
  export type LearnDomainFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearnDomain
     */
    select?: LearnDomainSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearnDomainInclude<ExtArgs> | null
    /**
     * Filter, which LearnDomain to fetch.
     */
    where: LearnDomainWhereUniqueInput
  }

  /**
   * LearnDomain findUniqueOrThrow
   */
  export type LearnDomainFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearnDomain
     */
    select?: LearnDomainSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearnDomainInclude<ExtArgs> | null
    /**
     * Filter, which LearnDomain to fetch.
     */
    where: LearnDomainWhereUniqueInput
  }

  /**
   * LearnDomain findFirst
   */
  export type LearnDomainFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearnDomain
     */
    select?: LearnDomainSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearnDomainInclude<ExtArgs> | null
    /**
     * Filter, which LearnDomain to fetch.
     */
    where?: LearnDomainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearnDomains to fetch.
     */
    orderBy?: LearnDomainOrderByWithRelationInput | LearnDomainOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LearnDomains.
     */
    cursor?: LearnDomainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearnDomains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearnDomains.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LearnDomains.
     */
    distinct?: LearnDomainScalarFieldEnum | LearnDomainScalarFieldEnum[]
  }

  /**
   * LearnDomain findFirstOrThrow
   */
  export type LearnDomainFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearnDomain
     */
    select?: LearnDomainSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearnDomainInclude<ExtArgs> | null
    /**
     * Filter, which LearnDomain to fetch.
     */
    where?: LearnDomainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearnDomains to fetch.
     */
    orderBy?: LearnDomainOrderByWithRelationInput | LearnDomainOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LearnDomains.
     */
    cursor?: LearnDomainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearnDomains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearnDomains.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LearnDomains.
     */
    distinct?: LearnDomainScalarFieldEnum | LearnDomainScalarFieldEnum[]
  }

  /**
   * LearnDomain findMany
   */
  export type LearnDomainFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearnDomain
     */
    select?: LearnDomainSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearnDomainInclude<ExtArgs> | null
    /**
     * Filter, which LearnDomains to fetch.
     */
    where?: LearnDomainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearnDomains to fetch.
     */
    orderBy?: LearnDomainOrderByWithRelationInput | LearnDomainOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LearnDomains.
     */
    cursor?: LearnDomainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearnDomains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearnDomains.
     */
    skip?: number
    distinct?: LearnDomainScalarFieldEnum | LearnDomainScalarFieldEnum[]
  }

  /**
   * LearnDomain create
   */
  export type LearnDomainCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearnDomain
     */
    select?: LearnDomainSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearnDomainInclude<ExtArgs> | null
    /**
     * The data needed to create a LearnDomain.
     */
    data: XOR<LearnDomainCreateInput, LearnDomainUncheckedCreateInput>
  }

  /**
   * LearnDomain createMany
   */
  export type LearnDomainCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LearnDomains.
     */
    data: LearnDomainCreateManyInput | LearnDomainCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LearnDomain createManyAndReturn
   */
  export type LearnDomainCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearnDomain
     */
    select?: LearnDomainSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many LearnDomains.
     */
    data: LearnDomainCreateManyInput | LearnDomainCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LearnDomain update
   */
  export type LearnDomainUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearnDomain
     */
    select?: LearnDomainSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearnDomainInclude<ExtArgs> | null
    /**
     * The data needed to update a LearnDomain.
     */
    data: XOR<LearnDomainUpdateInput, LearnDomainUncheckedUpdateInput>
    /**
     * Choose, which LearnDomain to update.
     */
    where: LearnDomainWhereUniqueInput
  }

  /**
   * LearnDomain updateMany
   */
  export type LearnDomainUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LearnDomains.
     */
    data: XOR<LearnDomainUpdateManyMutationInput, LearnDomainUncheckedUpdateManyInput>
    /**
     * Filter which LearnDomains to update
     */
    where?: LearnDomainWhereInput
  }

  /**
   * LearnDomain upsert
   */
  export type LearnDomainUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearnDomain
     */
    select?: LearnDomainSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearnDomainInclude<ExtArgs> | null
    /**
     * The filter to search for the LearnDomain to update in case it exists.
     */
    where: LearnDomainWhereUniqueInput
    /**
     * In case the LearnDomain found by the `where` argument doesn't exist, create a new LearnDomain with this data.
     */
    create: XOR<LearnDomainCreateInput, LearnDomainUncheckedCreateInput>
    /**
     * In case the LearnDomain was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LearnDomainUpdateInput, LearnDomainUncheckedUpdateInput>
  }

  /**
   * LearnDomain delete
   */
  export type LearnDomainDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearnDomain
     */
    select?: LearnDomainSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearnDomainInclude<ExtArgs> | null
    /**
     * Filter which LearnDomain to delete.
     */
    where: LearnDomainWhereUniqueInput
  }

  /**
   * LearnDomain deleteMany
   */
  export type LearnDomainDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LearnDomains to delete
     */
    where?: LearnDomainWhereInput
  }

  /**
   * LearnDomain.categories
   */
  export type LearnDomain$categoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearnCategory
     */
    select?: LearnCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearnCategoryInclude<ExtArgs> | null
    where?: LearnCategoryWhereInput
    orderBy?: LearnCategoryOrderByWithRelationInput | LearnCategoryOrderByWithRelationInput[]
    cursor?: LearnCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LearnCategoryScalarFieldEnum | LearnCategoryScalarFieldEnum[]
  }

  /**
   * LearnDomain without action
   */
  export type LearnDomainDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearnDomain
     */
    select?: LearnDomainSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearnDomainInclude<ExtArgs> | null
  }


  /**
   * Model LearnCategory
   */

  export type AggregateLearnCategory = {
    _count: LearnCategoryCountAggregateOutputType | null
    _avg: LearnCategoryAvgAggregateOutputType | null
    _sum: LearnCategorySumAggregateOutputType | null
    _min: LearnCategoryMinAggregateOutputType | null
    _max: LearnCategoryMaxAggregateOutputType | null
  }

  export type LearnCategoryAvgAggregateOutputType = {
    order: number | null
  }

  export type LearnCategorySumAggregateOutputType = {
    order: number | null
  }

  export type LearnCategoryMinAggregateOutputType = {
    id: string | null
    title: string | null
    order: number | null
    domainId: string | null
  }

  export type LearnCategoryMaxAggregateOutputType = {
    id: string | null
    title: string | null
    order: number | null
    domainId: string | null
  }

  export type LearnCategoryCountAggregateOutputType = {
    id: number
    title: number
    order: number
    domainId: number
    _all: number
  }


  export type LearnCategoryAvgAggregateInputType = {
    order?: true
  }

  export type LearnCategorySumAggregateInputType = {
    order?: true
  }

  export type LearnCategoryMinAggregateInputType = {
    id?: true
    title?: true
    order?: true
    domainId?: true
  }

  export type LearnCategoryMaxAggregateInputType = {
    id?: true
    title?: true
    order?: true
    domainId?: true
  }

  export type LearnCategoryCountAggregateInputType = {
    id?: true
    title?: true
    order?: true
    domainId?: true
    _all?: true
  }

  export type LearnCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LearnCategory to aggregate.
     */
    where?: LearnCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearnCategories to fetch.
     */
    orderBy?: LearnCategoryOrderByWithRelationInput | LearnCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LearnCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearnCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearnCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LearnCategories
    **/
    _count?: true | LearnCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LearnCategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LearnCategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LearnCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LearnCategoryMaxAggregateInputType
  }

  export type GetLearnCategoryAggregateType<T extends LearnCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateLearnCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLearnCategory[P]>
      : GetScalarType<T[P], AggregateLearnCategory[P]>
  }




  export type LearnCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LearnCategoryWhereInput
    orderBy?: LearnCategoryOrderByWithAggregationInput | LearnCategoryOrderByWithAggregationInput[]
    by: LearnCategoryScalarFieldEnum[] | LearnCategoryScalarFieldEnum
    having?: LearnCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LearnCategoryCountAggregateInputType | true
    _avg?: LearnCategoryAvgAggregateInputType
    _sum?: LearnCategorySumAggregateInputType
    _min?: LearnCategoryMinAggregateInputType
    _max?: LearnCategoryMaxAggregateInputType
  }

  export type LearnCategoryGroupByOutputType = {
    id: string
    title: string
    order: number
    domainId: string
    _count: LearnCategoryCountAggregateOutputType | null
    _avg: LearnCategoryAvgAggregateOutputType | null
    _sum: LearnCategorySumAggregateOutputType | null
    _min: LearnCategoryMinAggregateOutputType | null
    _max: LearnCategoryMaxAggregateOutputType | null
  }

  type GetLearnCategoryGroupByPayload<T extends LearnCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LearnCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LearnCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LearnCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], LearnCategoryGroupByOutputType[P]>
        }
      >
    >


  export type LearnCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    order?: boolean
    domainId?: boolean
    domain?: boolean | LearnDomainDefaultArgs<ExtArgs>
    topics?: boolean | LearnCategory$topicsArgs<ExtArgs>
    _count?: boolean | LearnCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["learnCategory"]>

  export type LearnCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    order?: boolean
    domainId?: boolean
    domain?: boolean | LearnDomainDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["learnCategory"]>

  export type LearnCategorySelectScalar = {
    id?: boolean
    title?: boolean
    order?: boolean
    domainId?: boolean
  }

  export type LearnCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    domain?: boolean | LearnDomainDefaultArgs<ExtArgs>
    topics?: boolean | LearnCategory$topicsArgs<ExtArgs>
    _count?: boolean | LearnCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LearnCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    domain?: boolean | LearnDomainDefaultArgs<ExtArgs>
  }

  export type $LearnCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LearnCategory"
    objects: {
      domain: Prisma.$LearnDomainPayload<ExtArgs>
      topics: Prisma.$LearnTopicPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      order: number
      domainId: string
    }, ExtArgs["result"]["learnCategory"]>
    composites: {}
  }

  type LearnCategoryGetPayload<S extends boolean | null | undefined | LearnCategoryDefaultArgs> = $Result.GetResult<Prisma.$LearnCategoryPayload, S>

  type LearnCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LearnCategoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LearnCategoryCountAggregateInputType | true
    }

  export interface LearnCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LearnCategory'], meta: { name: 'LearnCategory' } }
    /**
     * Find zero or one LearnCategory that matches the filter.
     * @param {LearnCategoryFindUniqueArgs} args - Arguments to find a LearnCategory
     * @example
     * // Get one LearnCategory
     * const learnCategory = await prisma.learnCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LearnCategoryFindUniqueArgs>(args: SelectSubset<T, LearnCategoryFindUniqueArgs<ExtArgs>>): Prisma__LearnCategoryClient<$Result.GetResult<Prisma.$LearnCategoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one LearnCategory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LearnCategoryFindUniqueOrThrowArgs} args - Arguments to find a LearnCategory
     * @example
     * // Get one LearnCategory
     * const learnCategory = await prisma.learnCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LearnCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, LearnCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LearnCategoryClient<$Result.GetResult<Prisma.$LearnCategoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first LearnCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearnCategoryFindFirstArgs} args - Arguments to find a LearnCategory
     * @example
     * // Get one LearnCategory
     * const learnCategory = await prisma.learnCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LearnCategoryFindFirstArgs>(args?: SelectSubset<T, LearnCategoryFindFirstArgs<ExtArgs>>): Prisma__LearnCategoryClient<$Result.GetResult<Prisma.$LearnCategoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first LearnCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearnCategoryFindFirstOrThrowArgs} args - Arguments to find a LearnCategory
     * @example
     * // Get one LearnCategory
     * const learnCategory = await prisma.learnCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LearnCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, LearnCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__LearnCategoryClient<$Result.GetResult<Prisma.$LearnCategoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more LearnCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearnCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LearnCategories
     * const learnCategories = await prisma.learnCategory.findMany()
     * 
     * // Get first 10 LearnCategories
     * const learnCategories = await prisma.learnCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const learnCategoryWithIdOnly = await prisma.learnCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LearnCategoryFindManyArgs>(args?: SelectSubset<T, LearnCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LearnCategoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a LearnCategory.
     * @param {LearnCategoryCreateArgs} args - Arguments to create a LearnCategory.
     * @example
     * // Create one LearnCategory
     * const LearnCategory = await prisma.learnCategory.create({
     *   data: {
     *     // ... data to create a LearnCategory
     *   }
     * })
     * 
     */
    create<T extends LearnCategoryCreateArgs>(args: SelectSubset<T, LearnCategoryCreateArgs<ExtArgs>>): Prisma__LearnCategoryClient<$Result.GetResult<Prisma.$LearnCategoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many LearnCategories.
     * @param {LearnCategoryCreateManyArgs} args - Arguments to create many LearnCategories.
     * @example
     * // Create many LearnCategories
     * const learnCategory = await prisma.learnCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LearnCategoryCreateManyArgs>(args?: SelectSubset<T, LearnCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LearnCategories and returns the data saved in the database.
     * @param {LearnCategoryCreateManyAndReturnArgs} args - Arguments to create many LearnCategories.
     * @example
     * // Create many LearnCategories
     * const learnCategory = await prisma.learnCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LearnCategories and only return the `id`
     * const learnCategoryWithIdOnly = await prisma.learnCategory.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LearnCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, LearnCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LearnCategoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a LearnCategory.
     * @param {LearnCategoryDeleteArgs} args - Arguments to delete one LearnCategory.
     * @example
     * // Delete one LearnCategory
     * const LearnCategory = await prisma.learnCategory.delete({
     *   where: {
     *     // ... filter to delete one LearnCategory
     *   }
     * })
     * 
     */
    delete<T extends LearnCategoryDeleteArgs>(args: SelectSubset<T, LearnCategoryDeleteArgs<ExtArgs>>): Prisma__LearnCategoryClient<$Result.GetResult<Prisma.$LearnCategoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one LearnCategory.
     * @param {LearnCategoryUpdateArgs} args - Arguments to update one LearnCategory.
     * @example
     * // Update one LearnCategory
     * const learnCategory = await prisma.learnCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LearnCategoryUpdateArgs>(args: SelectSubset<T, LearnCategoryUpdateArgs<ExtArgs>>): Prisma__LearnCategoryClient<$Result.GetResult<Prisma.$LearnCategoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more LearnCategories.
     * @param {LearnCategoryDeleteManyArgs} args - Arguments to filter LearnCategories to delete.
     * @example
     * // Delete a few LearnCategories
     * const { count } = await prisma.learnCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LearnCategoryDeleteManyArgs>(args?: SelectSubset<T, LearnCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LearnCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearnCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LearnCategories
     * const learnCategory = await prisma.learnCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LearnCategoryUpdateManyArgs>(args: SelectSubset<T, LearnCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LearnCategory.
     * @param {LearnCategoryUpsertArgs} args - Arguments to update or create a LearnCategory.
     * @example
     * // Update or create a LearnCategory
     * const learnCategory = await prisma.learnCategory.upsert({
     *   create: {
     *     // ... data to create a LearnCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LearnCategory we want to update
     *   }
     * })
     */
    upsert<T extends LearnCategoryUpsertArgs>(args: SelectSubset<T, LearnCategoryUpsertArgs<ExtArgs>>): Prisma__LearnCategoryClient<$Result.GetResult<Prisma.$LearnCategoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of LearnCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearnCategoryCountArgs} args - Arguments to filter LearnCategories to count.
     * @example
     * // Count the number of LearnCategories
     * const count = await prisma.learnCategory.count({
     *   where: {
     *     // ... the filter for the LearnCategories we want to count
     *   }
     * })
    **/
    count<T extends LearnCategoryCountArgs>(
      args?: Subset<T, LearnCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LearnCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LearnCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearnCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LearnCategoryAggregateArgs>(args: Subset<T, LearnCategoryAggregateArgs>): Prisma.PrismaPromise<GetLearnCategoryAggregateType<T>>

    /**
     * Group by LearnCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearnCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LearnCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LearnCategoryGroupByArgs['orderBy'] }
        : { orderBy?: LearnCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LearnCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLearnCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LearnCategory model
   */
  readonly fields: LearnCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LearnCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LearnCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    domain<T extends LearnDomainDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LearnDomainDefaultArgs<ExtArgs>>): Prisma__LearnDomainClient<$Result.GetResult<Prisma.$LearnDomainPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    topics<T extends LearnCategory$topicsArgs<ExtArgs> = {}>(args?: Subset<T, LearnCategory$topicsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LearnTopicPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LearnCategory model
   */ 
  interface LearnCategoryFieldRefs {
    readonly id: FieldRef<"LearnCategory", 'String'>
    readonly title: FieldRef<"LearnCategory", 'String'>
    readonly order: FieldRef<"LearnCategory", 'Int'>
    readonly domainId: FieldRef<"LearnCategory", 'String'>
  }
    

  // Custom InputTypes
  /**
   * LearnCategory findUnique
   */
  export type LearnCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearnCategory
     */
    select?: LearnCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearnCategoryInclude<ExtArgs> | null
    /**
     * Filter, which LearnCategory to fetch.
     */
    where: LearnCategoryWhereUniqueInput
  }

  /**
   * LearnCategory findUniqueOrThrow
   */
  export type LearnCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearnCategory
     */
    select?: LearnCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearnCategoryInclude<ExtArgs> | null
    /**
     * Filter, which LearnCategory to fetch.
     */
    where: LearnCategoryWhereUniqueInput
  }

  /**
   * LearnCategory findFirst
   */
  export type LearnCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearnCategory
     */
    select?: LearnCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearnCategoryInclude<ExtArgs> | null
    /**
     * Filter, which LearnCategory to fetch.
     */
    where?: LearnCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearnCategories to fetch.
     */
    orderBy?: LearnCategoryOrderByWithRelationInput | LearnCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LearnCategories.
     */
    cursor?: LearnCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearnCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearnCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LearnCategories.
     */
    distinct?: LearnCategoryScalarFieldEnum | LearnCategoryScalarFieldEnum[]
  }

  /**
   * LearnCategory findFirstOrThrow
   */
  export type LearnCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearnCategory
     */
    select?: LearnCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearnCategoryInclude<ExtArgs> | null
    /**
     * Filter, which LearnCategory to fetch.
     */
    where?: LearnCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearnCategories to fetch.
     */
    orderBy?: LearnCategoryOrderByWithRelationInput | LearnCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LearnCategories.
     */
    cursor?: LearnCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearnCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearnCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LearnCategories.
     */
    distinct?: LearnCategoryScalarFieldEnum | LearnCategoryScalarFieldEnum[]
  }

  /**
   * LearnCategory findMany
   */
  export type LearnCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearnCategory
     */
    select?: LearnCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearnCategoryInclude<ExtArgs> | null
    /**
     * Filter, which LearnCategories to fetch.
     */
    where?: LearnCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearnCategories to fetch.
     */
    orderBy?: LearnCategoryOrderByWithRelationInput | LearnCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LearnCategories.
     */
    cursor?: LearnCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearnCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearnCategories.
     */
    skip?: number
    distinct?: LearnCategoryScalarFieldEnum | LearnCategoryScalarFieldEnum[]
  }

  /**
   * LearnCategory create
   */
  export type LearnCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearnCategory
     */
    select?: LearnCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearnCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a LearnCategory.
     */
    data: XOR<LearnCategoryCreateInput, LearnCategoryUncheckedCreateInput>
  }

  /**
   * LearnCategory createMany
   */
  export type LearnCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LearnCategories.
     */
    data: LearnCategoryCreateManyInput | LearnCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LearnCategory createManyAndReturn
   */
  export type LearnCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearnCategory
     */
    select?: LearnCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many LearnCategories.
     */
    data: LearnCategoryCreateManyInput | LearnCategoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearnCategoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LearnCategory update
   */
  export type LearnCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearnCategory
     */
    select?: LearnCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearnCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a LearnCategory.
     */
    data: XOR<LearnCategoryUpdateInput, LearnCategoryUncheckedUpdateInput>
    /**
     * Choose, which LearnCategory to update.
     */
    where: LearnCategoryWhereUniqueInput
  }

  /**
   * LearnCategory updateMany
   */
  export type LearnCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LearnCategories.
     */
    data: XOR<LearnCategoryUpdateManyMutationInput, LearnCategoryUncheckedUpdateManyInput>
    /**
     * Filter which LearnCategories to update
     */
    where?: LearnCategoryWhereInput
  }

  /**
   * LearnCategory upsert
   */
  export type LearnCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearnCategory
     */
    select?: LearnCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearnCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the LearnCategory to update in case it exists.
     */
    where: LearnCategoryWhereUniqueInput
    /**
     * In case the LearnCategory found by the `where` argument doesn't exist, create a new LearnCategory with this data.
     */
    create: XOR<LearnCategoryCreateInput, LearnCategoryUncheckedCreateInput>
    /**
     * In case the LearnCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LearnCategoryUpdateInput, LearnCategoryUncheckedUpdateInput>
  }

  /**
   * LearnCategory delete
   */
  export type LearnCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearnCategory
     */
    select?: LearnCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearnCategoryInclude<ExtArgs> | null
    /**
     * Filter which LearnCategory to delete.
     */
    where: LearnCategoryWhereUniqueInput
  }

  /**
   * LearnCategory deleteMany
   */
  export type LearnCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LearnCategories to delete
     */
    where?: LearnCategoryWhereInput
  }

  /**
   * LearnCategory.topics
   */
  export type LearnCategory$topicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearnTopic
     */
    select?: LearnTopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearnTopicInclude<ExtArgs> | null
    where?: LearnTopicWhereInput
    orderBy?: LearnTopicOrderByWithRelationInput | LearnTopicOrderByWithRelationInput[]
    cursor?: LearnTopicWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LearnTopicScalarFieldEnum | LearnTopicScalarFieldEnum[]
  }

  /**
   * LearnCategory without action
   */
  export type LearnCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearnCategory
     */
    select?: LearnCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearnCategoryInclude<ExtArgs> | null
  }


  /**
   * Model LearnTopic
   */

  export type AggregateLearnTopic = {
    _count: LearnTopicCountAggregateOutputType | null
    _avg: LearnTopicAvgAggregateOutputType | null
    _sum: LearnTopicSumAggregateOutputType | null
    _min: LearnTopicMinAggregateOutputType | null
    _max: LearnTopicMaxAggregateOutputType | null
  }

  export type LearnTopicAvgAggregateOutputType = {
    order: number | null
  }

  export type LearnTopicSumAggregateOutputType = {
    order: number | null
  }

  export type LearnTopicMinAggregateOutputType = {
    id: string | null
    title: string | null
    slug: string | null
    order: number | null
    content: string | null
    categoryId: string | null
    createdAt: Date | null
  }

  export type LearnTopicMaxAggregateOutputType = {
    id: string | null
    title: string | null
    slug: string | null
    order: number | null
    content: string | null
    categoryId: string | null
    createdAt: Date | null
  }

  export type LearnTopicCountAggregateOutputType = {
    id: number
    title: number
    slug: number
    order: number
    content: number
    categoryId: number
    createdAt: number
    _all: number
  }


  export type LearnTopicAvgAggregateInputType = {
    order?: true
  }

  export type LearnTopicSumAggregateInputType = {
    order?: true
  }

  export type LearnTopicMinAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    order?: true
    content?: true
    categoryId?: true
    createdAt?: true
  }

  export type LearnTopicMaxAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    order?: true
    content?: true
    categoryId?: true
    createdAt?: true
  }

  export type LearnTopicCountAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    order?: true
    content?: true
    categoryId?: true
    createdAt?: true
    _all?: true
  }

  export type LearnTopicAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LearnTopic to aggregate.
     */
    where?: LearnTopicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearnTopics to fetch.
     */
    orderBy?: LearnTopicOrderByWithRelationInput | LearnTopicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LearnTopicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearnTopics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearnTopics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LearnTopics
    **/
    _count?: true | LearnTopicCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LearnTopicAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LearnTopicSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LearnTopicMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LearnTopicMaxAggregateInputType
  }

  export type GetLearnTopicAggregateType<T extends LearnTopicAggregateArgs> = {
        [P in keyof T & keyof AggregateLearnTopic]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLearnTopic[P]>
      : GetScalarType<T[P], AggregateLearnTopic[P]>
  }




  export type LearnTopicGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LearnTopicWhereInput
    orderBy?: LearnTopicOrderByWithAggregationInput | LearnTopicOrderByWithAggregationInput[]
    by: LearnTopicScalarFieldEnum[] | LearnTopicScalarFieldEnum
    having?: LearnTopicScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LearnTopicCountAggregateInputType | true
    _avg?: LearnTopicAvgAggregateInputType
    _sum?: LearnTopicSumAggregateInputType
    _min?: LearnTopicMinAggregateInputType
    _max?: LearnTopicMaxAggregateInputType
  }

  export type LearnTopicGroupByOutputType = {
    id: string
    title: string
    slug: string
    order: number
    content: string
    categoryId: string
    createdAt: Date
    _count: LearnTopicCountAggregateOutputType | null
    _avg: LearnTopicAvgAggregateOutputType | null
    _sum: LearnTopicSumAggregateOutputType | null
    _min: LearnTopicMinAggregateOutputType | null
    _max: LearnTopicMaxAggregateOutputType | null
  }

  type GetLearnTopicGroupByPayload<T extends LearnTopicGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LearnTopicGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LearnTopicGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LearnTopicGroupByOutputType[P]>
            : GetScalarType<T[P], LearnTopicGroupByOutputType[P]>
        }
      >
    >


  export type LearnTopicSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    order?: boolean
    content?: boolean
    categoryId?: boolean
    createdAt?: boolean
    category?: boolean | LearnCategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["learnTopic"]>

  export type LearnTopicSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    order?: boolean
    content?: boolean
    categoryId?: boolean
    createdAt?: boolean
    category?: boolean | LearnCategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["learnTopic"]>

  export type LearnTopicSelectScalar = {
    id?: boolean
    title?: boolean
    slug?: boolean
    order?: boolean
    content?: boolean
    categoryId?: boolean
    createdAt?: boolean
  }

  export type LearnTopicInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | LearnCategoryDefaultArgs<ExtArgs>
  }
  export type LearnTopicIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | LearnCategoryDefaultArgs<ExtArgs>
  }

  export type $LearnTopicPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LearnTopic"
    objects: {
      category: Prisma.$LearnCategoryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      slug: string
      order: number
      content: string
      categoryId: string
      createdAt: Date
    }, ExtArgs["result"]["learnTopic"]>
    composites: {}
  }

  type LearnTopicGetPayload<S extends boolean | null | undefined | LearnTopicDefaultArgs> = $Result.GetResult<Prisma.$LearnTopicPayload, S>

  type LearnTopicCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LearnTopicFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LearnTopicCountAggregateInputType | true
    }

  export interface LearnTopicDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LearnTopic'], meta: { name: 'LearnTopic' } }
    /**
     * Find zero or one LearnTopic that matches the filter.
     * @param {LearnTopicFindUniqueArgs} args - Arguments to find a LearnTopic
     * @example
     * // Get one LearnTopic
     * const learnTopic = await prisma.learnTopic.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LearnTopicFindUniqueArgs>(args: SelectSubset<T, LearnTopicFindUniqueArgs<ExtArgs>>): Prisma__LearnTopicClient<$Result.GetResult<Prisma.$LearnTopicPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one LearnTopic that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LearnTopicFindUniqueOrThrowArgs} args - Arguments to find a LearnTopic
     * @example
     * // Get one LearnTopic
     * const learnTopic = await prisma.learnTopic.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LearnTopicFindUniqueOrThrowArgs>(args: SelectSubset<T, LearnTopicFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LearnTopicClient<$Result.GetResult<Prisma.$LearnTopicPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first LearnTopic that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearnTopicFindFirstArgs} args - Arguments to find a LearnTopic
     * @example
     * // Get one LearnTopic
     * const learnTopic = await prisma.learnTopic.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LearnTopicFindFirstArgs>(args?: SelectSubset<T, LearnTopicFindFirstArgs<ExtArgs>>): Prisma__LearnTopicClient<$Result.GetResult<Prisma.$LearnTopicPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first LearnTopic that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearnTopicFindFirstOrThrowArgs} args - Arguments to find a LearnTopic
     * @example
     * // Get one LearnTopic
     * const learnTopic = await prisma.learnTopic.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LearnTopicFindFirstOrThrowArgs>(args?: SelectSubset<T, LearnTopicFindFirstOrThrowArgs<ExtArgs>>): Prisma__LearnTopicClient<$Result.GetResult<Prisma.$LearnTopicPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more LearnTopics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearnTopicFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LearnTopics
     * const learnTopics = await prisma.learnTopic.findMany()
     * 
     * // Get first 10 LearnTopics
     * const learnTopics = await prisma.learnTopic.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const learnTopicWithIdOnly = await prisma.learnTopic.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LearnTopicFindManyArgs>(args?: SelectSubset<T, LearnTopicFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LearnTopicPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a LearnTopic.
     * @param {LearnTopicCreateArgs} args - Arguments to create a LearnTopic.
     * @example
     * // Create one LearnTopic
     * const LearnTopic = await prisma.learnTopic.create({
     *   data: {
     *     // ... data to create a LearnTopic
     *   }
     * })
     * 
     */
    create<T extends LearnTopicCreateArgs>(args: SelectSubset<T, LearnTopicCreateArgs<ExtArgs>>): Prisma__LearnTopicClient<$Result.GetResult<Prisma.$LearnTopicPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many LearnTopics.
     * @param {LearnTopicCreateManyArgs} args - Arguments to create many LearnTopics.
     * @example
     * // Create many LearnTopics
     * const learnTopic = await prisma.learnTopic.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LearnTopicCreateManyArgs>(args?: SelectSubset<T, LearnTopicCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LearnTopics and returns the data saved in the database.
     * @param {LearnTopicCreateManyAndReturnArgs} args - Arguments to create many LearnTopics.
     * @example
     * // Create many LearnTopics
     * const learnTopic = await prisma.learnTopic.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LearnTopics and only return the `id`
     * const learnTopicWithIdOnly = await prisma.learnTopic.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LearnTopicCreateManyAndReturnArgs>(args?: SelectSubset<T, LearnTopicCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LearnTopicPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a LearnTopic.
     * @param {LearnTopicDeleteArgs} args - Arguments to delete one LearnTopic.
     * @example
     * // Delete one LearnTopic
     * const LearnTopic = await prisma.learnTopic.delete({
     *   where: {
     *     // ... filter to delete one LearnTopic
     *   }
     * })
     * 
     */
    delete<T extends LearnTopicDeleteArgs>(args: SelectSubset<T, LearnTopicDeleteArgs<ExtArgs>>): Prisma__LearnTopicClient<$Result.GetResult<Prisma.$LearnTopicPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one LearnTopic.
     * @param {LearnTopicUpdateArgs} args - Arguments to update one LearnTopic.
     * @example
     * // Update one LearnTopic
     * const learnTopic = await prisma.learnTopic.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LearnTopicUpdateArgs>(args: SelectSubset<T, LearnTopicUpdateArgs<ExtArgs>>): Prisma__LearnTopicClient<$Result.GetResult<Prisma.$LearnTopicPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more LearnTopics.
     * @param {LearnTopicDeleteManyArgs} args - Arguments to filter LearnTopics to delete.
     * @example
     * // Delete a few LearnTopics
     * const { count } = await prisma.learnTopic.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LearnTopicDeleteManyArgs>(args?: SelectSubset<T, LearnTopicDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LearnTopics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearnTopicUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LearnTopics
     * const learnTopic = await prisma.learnTopic.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LearnTopicUpdateManyArgs>(args: SelectSubset<T, LearnTopicUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LearnTopic.
     * @param {LearnTopicUpsertArgs} args - Arguments to update or create a LearnTopic.
     * @example
     * // Update or create a LearnTopic
     * const learnTopic = await prisma.learnTopic.upsert({
     *   create: {
     *     // ... data to create a LearnTopic
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LearnTopic we want to update
     *   }
     * })
     */
    upsert<T extends LearnTopicUpsertArgs>(args: SelectSubset<T, LearnTopicUpsertArgs<ExtArgs>>): Prisma__LearnTopicClient<$Result.GetResult<Prisma.$LearnTopicPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of LearnTopics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearnTopicCountArgs} args - Arguments to filter LearnTopics to count.
     * @example
     * // Count the number of LearnTopics
     * const count = await prisma.learnTopic.count({
     *   where: {
     *     // ... the filter for the LearnTopics we want to count
     *   }
     * })
    **/
    count<T extends LearnTopicCountArgs>(
      args?: Subset<T, LearnTopicCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LearnTopicCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LearnTopic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearnTopicAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LearnTopicAggregateArgs>(args: Subset<T, LearnTopicAggregateArgs>): Prisma.PrismaPromise<GetLearnTopicAggregateType<T>>

    /**
     * Group by LearnTopic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LearnTopicGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LearnTopicGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LearnTopicGroupByArgs['orderBy'] }
        : { orderBy?: LearnTopicGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LearnTopicGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLearnTopicGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LearnTopic model
   */
  readonly fields: LearnTopicFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LearnTopic.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LearnTopicClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    category<T extends LearnCategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LearnCategoryDefaultArgs<ExtArgs>>): Prisma__LearnCategoryClient<$Result.GetResult<Prisma.$LearnCategoryPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LearnTopic model
   */ 
  interface LearnTopicFieldRefs {
    readonly id: FieldRef<"LearnTopic", 'String'>
    readonly title: FieldRef<"LearnTopic", 'String'>
    readonly slug: FieldRef<"LearnTopic", 'String'>
    readonly order: FieldRef<"LearnTopic", 'Int'>
    readonly content: FieldRef<"LearnTopic", 'String'>
    readonly categoryId: FieldRef<"LearnTopic", 'String'>
    readonly createdAt: FieldRef<"LearnTopic", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LearnTopic findUnique
   */
  export type LearnTopicFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearnTopic
     */
    select?: LearnTopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearnTopicInclude<ExtArgs> | null
    /**
     * Filter, which LearnTopic to fetch.
     */
    where: LearnTopicWhereUniqueInput
  }

  /**
   * LearnTopic findUniqueOrThrow
   */
  export type LearnTopicFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearnTopic
     */
    select?: LearnTopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearnTopicInclude<ExtArgs> | null
    /**
     * Filter, which LearnTopic to fetch.
     */
    where: LearnTopicWhereUniqueInput
  }

  /**
   * LearnTopic findFirst
   */
  export type LearnTopicFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearnTopic
     */
    select?: LearnTopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearnTopicInclude<ExtArgs> | null
    /**
     * Filter, which LearnTopic to fetch.
     */
    where?: LearnTopicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearnTopics to fetch.
     */
    orderBy?: LearnTopicOrderByWithRelationInput | LearnTopicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LearnTopics.
     */
    cursor?: LearnTopicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearnTopics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearnTopics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LearnTopics.
     */
    distinct?: LearnTopicScalarFieldEnum | LearnTopicScalarFieldEnum[]
  }

  /**
   * LearnTopic findFirstOrThrow
   */
  export type LearnTopicFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearnTopic
     */
    select?: LearnTopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearnTopicInclude<ExtArgs> | null
    /**
     * Filter, which LearnTopic to fetch.
     */
    where?: LearnTopicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearnTopics to fetch.
     */
    orderBy?: LearnTopicOrderByWithRelationInput | LearnTopicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LearnTopics.
     */
    cursor?: LearnTopicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearnTopics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearnTopics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LearnTopics.
     */
    distinct?: LearnTopicScalarFieldEnum | LearnTopicScalarFieldEnum[]
  }

  /**
   * LearnTopic findMany
   */
  export type LearnTopicFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearnTopic
     */
    select?: LearnTopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearnTopicInclude<ExtArgs> | null
    /**
     * Filter, which LearnTopics to fetch.
     */
    where?: LearnTopicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LearnTopics to fetch.
     */
    orderBy?: LearnTopicOrderByWithRelationInput | LearnTopicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LearnTopics.
     */
    cursor?: LearnTopicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LearnTopics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LearnTopics.
     */
    skip?: number
    distinct?: LearnTopicScalarFieldEnum | LearnTopicScalarFieldEnum[]
  }

  /**
   * LearnTopic create
   */
  export type LearnTopicCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearnTopic
     */
    select?: LearnTopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearnTopicInclude<ExtArgs> | null
    /**
     * The data needed to create a LearnTopic.
     */
    data: XOR<LearnTopicCreateInput, LearnTopicUncheckedCreateInput>
  }

  /**
   * LearnTopic createMany
   */
  export type LearnTopicCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LearnTopics.
     */
    data: LearnTopicCreateManyInput | LearnTopicCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LearnTopic createManyAndReturn
   */
  export type LearnTopicCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearnTopic
     */
    select?: LearnTopicSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many LearnTopics.
     */
    data: LearnTopicCreateManyInput | LearnTopicCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearnTopicIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LearnTopic update
   */
  export type LearnTopicUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearnTopic
     */
    select?: LearnTopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearnTopicInclude<ExtArgs> | null
    /**
     * The data needed to update a LearnTopic.
     */
    data: XOR<LearnTopicUpdateInput, LearnTopicUncheckedUpdateInput>
    /**
     * Choose, which LearnTopic to update.
     */
    where: LearnTopicWhereUniqueInput
  }

  /**
   * LearnTopic updateMany
   */
  export type LearnTopicUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LearnTopics.
     */
    data: XOR<LearnTopicUpdateManyMutationInput, LearnTopicUncheckedUpdateManyInput>
    /**
     * Filter which LearnTopics to update
     */
    where?: LearnTopicWhereInput
  }

  /**
   * LearnTopic upsert
   */
  export type LearnTopicUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearnTopic
     */
    select?: LearnTopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearnTopicInclude<ExtArgs> | null
    /**
     * The filter to search for the LearnTopic to update in case it exists.
     */
    where: LearnTopicWhereUniqueInput
    /**
     * In case the LearnTopic found by the `where` argument doesn't exist, create a new LearnTopic with this data.
     */
    create: XOR<LearnTopicCreateInput, LearnTopicUncheckedCreateInput>
    /**
     * In case the LearnTopic was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LearnTopicUpdateInput, LearnTopicUncheckedUpdateInput>
  }

  /**
   * LearnTopic delete
   */
  export type LearnTopicDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearnTopic
     */
    select?: LearnTopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearnTopicInclude<ExtArgs> | null
    /**
     * Filter which LearnTopic to delete.
     */
    where: LearnTopicWhereUniqueInput
  }

  /**
   * LearnTopic deleteMany
   */
  export type LearnTopicDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LearnTopics to delete
     */
    where?: LearnTopicWhereInput
  }

  /**
   * LearnTopic without action
   */
  export type LearnTopicDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LearnTopic
     */
    select?: LearnTopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LearnTopicInclude<ExtArgs> | null
  }


  /**
   * Model InterviewSession
   */

  export type AggregateInterviewSession = {
    _count: InterviewSessionCountAggregateOutputType | null
    _avg: InterviewSessionAvgAggregateOutputType | null
    _sum: InterviewSessionSumAggregateOutputType | null
    _min: InterviewSessionMinAggregateOutputType | null
    _max: InterviewSessionMaxAggregateOutputType | null
  }

  export type InterviewSessionAvgAggregateOutputType = {
    duration: number | null
  }

  export type InterviewSessionSumAggregateOutputType = {
    duration: number | null
  }

  export type InterviewSessionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    role: string | null
    duration: number | null
    status: string | null
    resumeSnapshot: string | null
    jobDescription: string | null
    resumeSummary: string | null
    jdSummary: string | null
    vapiCallId: string | null
    vapiAssistantId: string | null
    videoUrl: string | null
    videoRecorded: boolean | null
    createdAt: Date | null
    startedAt: Date | null
    endedAt: Date | null
  }

  export type InterviewSessionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    role: string | null
    duration: number | null
    status: string | null
    resumeSnapshot: string | null
    jobDescription: string | null
    resumeSummary: string | null
    jdSummary: string | null
    vapiCallId: string | null
    vapiAssistantId: string | null
    videoUrl: string | null
    videoRecorded: boolean | null
    createdAt: Date | null
    startedAt: Date | null
    endedAt: Date | null
  }

  export type InterviewSessionCountAggregateOutputType = {
    id: number
    userId: number
    role: number
    duration: number
    status: number
    resumeSnapshot: number
    jobDescription: number
    resumeSummary: number
    jdSummary: number
    vapiCallId: number
    vapiAssistantId: number
    transcript: number
    videoUrl: number
    videoRecorded: number
    createdAt: number
    startedAt: number
    endedAt: number
    _all: number
  }


  export type InterviewSessionAvgAggregateInputType = {
    duration?: true
  }

  export type InterviewSessionSumAggregateInputType = {
    duration?: true
  }

  export type InterviewSessionMinAggregateInputType = {
    id?: true
    userId?: true
    role?: true
    duration?: true
    status?: true
    resumeSnapshot?: true
    jobDescription?: true
    resumeSummary?: true
    jdSummary?: true
    vapiCallId?: true
    vapiAssistantId?: true
    videoUrl?: true
    videoRecorded?: true
    createdAt?: true
    startedAt?: true
    endedAt?: true
  }

  export type InterviewSessionMaxAggregateInputType = {
    id?: true
    userId?: true
    role?: true
    duration?: true
    status?: true
    resumeSnapshot?: true
    jobDescription?: true
    resumeSummary?: true
    jdSummary?: true
    vapiCallId?: true
    vapiAssistantId?: true
    videoUrl?: true
    videoRecorded?: true
    createdAt?: true
    startedAt?: true
    endedAt?: true
  }

  export type InterviewSessionCountAggregateInputType = {
    id?: true
    userId?: true
    role?: true
    duration?: true
    status?: true
    resumeSnapshot?: true
    jobDescription?: true
    resumeSummary?: true
    jdSummary?: true
    vapiCallId?: true
    vapiAssistantId?: true
    transcript?: true
    videoUrl?: true
    videoRecorded?: true
    createdAt?: true
    startedAt?: true
    endedAt?: true
    _all?: true
  }

  export type InterviewSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InterviewSession to aggregate.
     */
    where?: InterviewSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InterviewSessions to fetch.
     */
    orderBy?: InterviewSessionOrderByWithRelationInput | InterviewSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InterviewSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InterviewSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InterviewSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InterviewSessions
    **/
    _count?: true | InterviewSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InterviewSessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InterviewSessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InterviewSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InterviewSessionMaxAggregateInputType
  }

  export type GetInterviewSessionAggregateType<T extends InterviewSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateInterviewSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInterviewSession[P]>
      : GetScalarType<T[P], AggregateInterviewSession[P]>
  }




  export type InterviewSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InterviewSessionWhereInput
    orderBy?: InterviewSessionOrderByWithAggregationInput | InterviewSessionOrderByWithAggregationInput[]
    by: InterviewSessionScalarFieldEnum[] | InterviewSessionScalarFieldEnum
    having?: InterviewSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InterviewSessionCountAggregateInputType | true
    _avg?: InterviewSessionAvgAggregateInputType
    _sum?: InterviewSessionSumAggregateInputType
    _min?: InterviewSessionMinAggregateInputType
    _max?: InterviewSessionMaxAggregateInputType
  }

  export type InterviewSessionGroupByOutputType = {
    id: string
    userId: string
    role: string
    duration: number
    status: string
    resumeSnapshot: string
    jobDescription: string | null
    resumeSummary: string | null
    jdSummary: string | null
    vapiCallId: string | null
    vapiAssistantId: string | null
    transcript: JsonValue | null
    videoUrl: string | null
    videoRecorded: boolean
    createdAt: Date
    startedAt: Date | null
    endedAt: Date | null
    _count: InterviewSessionCountAggregateOutputType | null
    _avg: InterviewSessionAvgAggregateOutputType | null
    _sum: InterviewSessionSumAggregateOutputType | null
    _min: InterviewSessionMinAggregateOutputType | null
    _max: InterviewSessionMaxAggregateOutputType | null
  }

  type GetInterviewSessionGroupByPayload<T extends InterviewSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InterviewSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InterviewSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InterviewSessionGroupByOutputType[P]>
            : GetScalarType<T[P], InterviewSessionGroupByOutputType[P]>
        }
      >
    >


  export type InterviewSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    role?: boolean
    duration?: boolean
    status?: boolean
    resumeSnapshot?: boolean
    jobDescription?: boolean
    resumeSummary?: boolean
    jdSummary?: boolean
    vapiCallId?: boolean
    vapiAssistantId?: boolean
    transcript?: boolean
    videoUrl?: boolean
    videoRecorded?: boolean
    createdAt?: boolean
    startedAt?: boolean
    endedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    feedback?: boolean | InterviewSession$feedbackArgs<ExtArgs>
    sharedResult?: boolean | InterviewSession$sharedResultArgs<ExtArgs>
  }, ExtArgs["result"]["interviewSession"]>

  export type InterviewSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    role?: boolean
    duration?: boolean
    status?: boolean
    resumeSnapshot?: boolean
    jobDescription?: boolean
    resumeSummary?: boolean
    jdSummary?: boolean
    vapiCallId?: boolean
    vapiAssistantId?: boolean
    transcript?: boolean
    videoUrl?: boolean
    videoRecorded?: boolean
    createdAt?: boolean
    startedAt?: boolean
    endedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["interviewSession"]>

  export type InterviewSessionSelectScalar = {
    id?: boolean
    userId?: boolean
    role?: boolean
    duration?: boolean
    status?: boolean
    resumeSnapshot?: boolean
    jobDescription?: boolean
    resumeSummary?: boolean
    jdSummary?: boolean
    vapiCallId?: boolean
    vapiAssistantId?: boolean
    transcript?: boolean
    videoUrl?: boolean
    videoRecorded?: boolean
    createdAt?: boolean
    startedAt?: boolean
    endedAt?: boolean
  }

  export type InterviewSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    feedback?: boolean | InterviewSession$feedbackArgs<ExtArgs>
    sharedResult?: boolean | InterviewSession$sharedResultArgs<ExtArgs>
  }
  export type InterviewSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $InterviewSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InterviewSession"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      feedback: Prisma.$InterviewFeedbackPayload<ExtArgs> | null
      sharedResult: Prisma.$SharedInterviewResultPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      role: string
      duration: number
      status: string
      resumeSnapshot: string
      jobDescription: string | null
      resumeSummary: string | null
      jdSummary: string | null
      vapiCallId: string | null
      vapiAssistantId: string | null
      transcript: Prisma.JsonValue | null
      videoUrl: string | null
      videoRecorded: boolean
      createdAt: Date
      startedAt: Date | null
      endedAt: Date | null
    }, ExtArgs["result"]["interviewSession"]>
    composites: {}
  }

  type InterviewSessionGetPayload<S extends boolean | null | undefined | InterviewSessionDefaultArgs> = $Result.GetResult<Prisma.$InterviewSessionPayload, S>

  type InterviewSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InterviewSessionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InterviewSessionCountAggregateInputType | true
    }

  export interface InterviewSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InterviewSession'], meta: { name: 'InterviewSession' } }
    /**
     * Find zero or one InterviewSession that matches the filter.
     * @param {InterviewSessionFindUniqueArgs} args - Arguments to find a InterviewSession
     * @example
     * // Get one InterviewSession
     * const interviewSession = await prisma.interviewSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InterviewSessionFindUniqueArgs>(args: SelectSubset<T, InterviewSessionFindUniqueArgs<ExtArgs>>): Prisma__InterviewSessionClient<$Result.GetResult<Prisma.$InterviewSessionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one InterviewSession that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InterviewSessionFindUniqueOrThrowArgs} args - Arguments to find a InterviewSession
     * @example
     * // Get one InterviewSession
     * const interviewSession = await prisma.interviewSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InterviewSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, InterviewSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InterviewSessionClient<$Result.GetResult<Prisma.$InterviewSessionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first InterviewSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewSessionFindFirstArgs} args - Arguments to find a InterviewSession
     * @example
     * // Get one InterviewSession
     * const interviewSession = await prisma.interviewSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InterviewSessionFindFirstArgs>(args?: SelectSubset<T, InterviewSessionFindFirstArgs<ExtArgs>>): Prisma__InterviewSessionClient<$Result.GetResult<Prisma.$InterviewSessionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first InterviewSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewSessionFindFirstOrThrowArgs} args - Arguments to find a InterviewSession
     * @example
     * // Get one InterviewSession
     * const interviewSession = await prisma.interviewSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InterviewSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, InterviewSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__InterviewSessionClient<$Result.GetResult<Prisma.$InterviewSessionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more InterviewSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InterviewSessions
     * const interviewSessions = await prisma.interviewSession.findMany()
     * 
     * // Get first 10 InterviewSessions
     * const interviewSessions = await prisma.interviewSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const interviewSessionWithIdOnly = await prisma.interviewSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InterviewSessionFindManyArgs>(args?: SelectSubset<T, InterviewSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterviewSessionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a InterviewSession.
     * @param {InterviewSessionCreateArgs} args - Arguments to create a InterviewSession.
     * @example
     * // Create one InterviewSession
     * const InterviewSession = await prisma.interviewSession.create({
     *   data: {
     *     // ... data to create a InterviewSession
     *   }
     * })
     * 
     */
    create<T extends InterviewSessionCreateArgs>(args: SelectSubset<T, InterviewSessionCreateArgs<ExtArgs>>): Prisma__InterviewSessionClient<$Result.GetResult<Prisma.$InterviewSessionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many InterviewSessions.
     * @param {InterviewSessionCreateManyArgs} args - Arguments to create many InterviewSessions.
     * @example
     * // Create many InterviewSessions
     * const interviewSession = await prisma.interviewSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InterviewSessionCreateManyArgs>(args?: SelectSubset<T, InterviewSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InterviewSessions and returns the data saved in the database.
     * @param {InterviewSessionCreateManyAndReturnArgs} args - Arguments to create many InterviewSessions.
     * @example
     * // Create many InterviewSessions
     * const interviewSession = await prisma.interviewSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InterviewSessions and only return the `id`
     * const interviewSessionWithIdOnly = await prisma.interviewSession.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InterviewSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, InterviewSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterviewSessionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a InterviewSession.
     * @param {InterviewSessionDeleteArgs} args - Arguments to delete one InterviewSession.
     * @example
     * // Delete one InterviewSession
     * const InterviewSession = await prisma.interviewSession.delete({
     *   where: {
     *     // ... filter to delete one InterviewSession
     *   }
     * })
     * 
     */
    delete<T extends InterviewSessionDeleteArgs>(args: SelectSubset<T, InterviewSessionDeleteArgs<ExtArgs>>): Prisma__InterviewSessionClient<$Result.GetResult<Prisma.$InterviewSessionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one InterviewSession.
     * @param {InterviewSessionUpdateArgs} args - Arguments to update one InterviewSession.
     * @example
     * // Update one InterviewSession
     * const interviewSession = await prisma.interviewSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InterviewSessionUpdateArgs>(args: SelectSubset<T, InterviewSessionUpdateArgs<ExtArgs>>): Prisma__InterviewSessionClient<$Result.GetResult<Prisma.$InterviewSessionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more InterviewSessions.
     * @param {InterviewSessionDeleteManyArgs} args - Arguments to filter InterviewSessions to delete.
     * @example
     * // Delete a few InterviewSessions
     * const { count } = await prisma.interviewSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InterviewSessionDeleteManyArgs>(args?: SelectSubset<T, InterviewSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InterviewSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InterviewSessions
     * const interviewSession = await prisma.interviewSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InterviewSessionUpdateManyArgs>(args: SelectSubset<T, InterviewSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InterviewSession.
     * @param {InterviewSessionUpsertArgs} args - Arguments to update or create a InterviewSession.
     * @example
     * // Update or create a InterviewSession
     * const interviewSession = await prisma.interviewSession.upsert({
     *   create: {
     *     // ... data to create a InterviewSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InterviewSession we want to update
     *   }
     * })
     */
    upsert<T extends InterviewSessionUpsertArgs>(args: SelectSubset<T, InterviewSessionUpsertArgs<ExtArgs>>): Prisma__InterviewSessionClient<$Result.GetResult<Prisma.$InterviewSessionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of InterviewSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewSessionCountArgs} args - Arguments to filter InterviewSessions to count.
     * @example
     * // Count the number of InterviewSessions
     * const count = await prisma.interviewSession.count({
     *   where: {
     *     // ... the filter for the InterviewSessions we want to count
     *   }
     * })
    **/
    count<T extends InterviewSessionCountArgs>(
      args?: Subset<T, InterviewSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InterviewSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InterviewSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InterviewSessionAggregateArgs>(args: Subset<T, InterviewSessionAggregateArgs>): Prisma.PrismaPromise<GetInterviewSessionAggregateType<T>>

    /**
     * Group by InterviewSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InterviewSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InterviewSessionGroupByArgs['orderBy'] }
        : { orderBy?: InterviewSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InterviewSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInterviewSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InterviewSession model
   */
  readonly fields: InterviewSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InterviewSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InterviewSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    feedback<T extends InterviewSession$feedbackArgs<ExtArgs> = {}>(args?: Subset<T, InterviewSession$feedbackArgs<ExtArgs>>): Prisma__InterviewFeedbackClient<$Result.GetResult<Prisma.$InterviewFeedbackPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    sharedResult<T extends InterviewSession$sharedResultArgs<ExtArgs> = {}>(args?: Subset<T, InterviewSession$sharedResultArgs<ExtArgs>>): Prisma__SharedInterviewResultClient<$Result.GetResult<Prisma.$SharedInterviewResultPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InterviewSession model
   */ 
  interface InterviewSessionFieldRefs {
    readonly id: FieldRef<"InterviewSession", 'String'>
    readonly userId: FieldRef<"InterviewSession", 'String'>
    readonly role: FieldRef<"InterviewSession", 'String'>
    readonly duration: FieldRef<"InterviewSession", 'Int'>
    readonly status: FieldRef<"InterviewSession", 'String'>
    readonly resumeSnapshot: FieldRef<"InterviewSession", 'String'>
    readonly jobDescription: FieldRef<"InterviewSession", 'String'>
    readonly resumeSummary: FieldRef<"InterviewSession", 'String'>
    readonly jdSummary: FieldRef<"InterviewSession", 'String'>
    readonly vapiCallId: FieldRef<"InterviewSession", 'String'>
    readonly vapiAssistantId: FieldRef<"InterviewSession", 'String'>
    readonly transcript: FieldRef<"InterviewSession", 'Json'>
    readonly videoUrl: FieldRef<"InterviewSession", 'String'>
    readonly videoRecorded: FieldRef<"InterviewSession", 'Boolean'>
    readonly createdAt: FieldRef<"InterviewSession", 'DateTime'>
    readonly startedAt: FieldRef<"InterviewSession", 'DateTime'>
    readonly endedAt: FieldRef<"InterviewSession", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InterviewSession findUnique
   */
  export type InterviewSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewSession
     */
    select?: InterviewSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewSessionInclude<ExtArgs> | null
    /**
     * Filter, which InterviewSession to fetch.
     */
    where: InterviewSessionWhereUniqueInput
  }

  /**
   * InterviewSession findUniqueOrThrow
   */
  export type InterviewSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewSession
     */
    select?: InterviewSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewSessionInclude<ExtArgs> | null
    /**
     * Filter, which InterviewSession to fetch.
     */
    where: InterviewSessionWhereUniqueInput
  }

  /**
   * InterviewSession findFirst
   */
  export type InterviewSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewSession
     */
    select?: InterviewSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewSessionInclude<ExtArgs> | null
    /**
     * Filter, which InterviewSession to fetch.
     */
    where?: InterviewSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InterviewSessions to fetch.
     */
    orderBy?: InterviewSessionOrderByWithRelationInput | InterviewSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InterviewSessions.
     */
    cursor?: InterviewSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InterviewSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InterviewSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InterviewSessions.
     */
    distinct?: InterviewSessionScalarFieldEnum | InterviewSessionScalarFieldEnum[]
  }

  /**
   * InterviewSession findFirstOrThrow
   */
  export type InterviewSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewSession
     */
    select?: InterviewSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewSessionInclude<ExtArgs> | null
    /**
     * Filter, which InterviewSession to fetch.
     */
    where?: InterviewSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InterviewSessions to fetch.
     */
    orderBy?: InterviewSessionOrderByWithRelationInput | InterviewSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InterviewSessions.
     */
    cursor?: InterviewSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InterviewSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InterviewSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InterviewSessions.
     */
    distinct?: InterviewSessionScalarFieldEnum | InterviewSessionScalarFieldEnum[]
  }

  /**
   * InterviewSession findMany
   */
  export type InterviewSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewSession
     */
    select?: InterviewSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewSessionInclude<ExtArgs> | null
    /**
     * Filter, which InterviewSessions to fetch.
     */
    where?: InterviewSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InterviewSessions to fetch.
     */
    orderBy?: InterviewSessionOrderByWithRelationInput | InterviewSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InterviewSessions.
     */
    cursor?: InterviewSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InterviewSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InterviewSessions.
     */
    skip?: number
    distinct?: InterviewSessionScalarFieldEnum | InterviewSessionScalarFieldEnum[]
  }

  /**
   * InterviewSession create
   */
  export type InterviewSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewSession
     */
    select?: InterviewSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a InterviewSession.
     */
    data: XOR<InterviewSessionCreateInput, InterviewSessionUncheckedCreateInput>
  }

  /**
   * InterviewSession createMany
   */
  export type InterviewSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InterviewSessions.
     */
    data: InterviewSessionCreateManyInput | InterviewSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InterviewSession createManyAndReturn
   */
  export type InterviewSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewSession
     */
    select?: InterviewSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many InterviewSessions.
     */
    data: InterviewSessionCreateManyInput | InterviewSessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InterviewSession update
   */
  export type InterviewSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewSession
     */
    select?: InterviewSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a InterviewSession.
     */
    data: XOR<InterviewSessionUpdateInput, InterviewSessionUncheckedUpdateInput>
    /**
     * Choose, which InterviewSession to update.
     */
    where: InterviewSessionWhereUniqueInput
  }

  /**
   * InterviewSession updateMany
   */
  export type InterviewSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InterviewSessions.
     */
    data: XOR<InterviewSessionUpdateManyMutationInput, InterviewSessionUncheckedUpdateManyInput>
    /**
     * Filter which InterviewSessions to update
     */
    where?: InterviewSessionWhereInput
  }

  /**
   * InterviewSession upsert
   */
  export type InterviewSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewSession
     */
    select?: InterviewSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the InterviewSession to update in case it exists.
     */
    where: InterviewSessionWhereUniqueInput
    /**
     * In case the InterviewSession found by the `where` argument doesn't exist, create a new InterviewSession with this data.
     */
    create: XOR<InterviewSessionCreateInput, InterviewSessionUncheckedCreateInput>
    /**
     * In case the InterviewSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InterviewSessionUpdateInput, InterviewSessionUncheckedUpdateInput>
  }

  /**
   * InterviewSession delete
   */
  export type InterviewSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewSession
     */
    select?: InterviewSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewSessionInclude<ExtArgs> | null
    /**
     * Filter which InterviewSession to delete.
     */
    where: InterviewSessionWhereUniqueInput
  }

  /**
   * InterviewSession deleteMany
   */
  export type InterviewSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InterviewSessions to delete
     */
    where?: InterviewSessionWhereInput
  }

  /**
   * InterviewSession.feedback
   */
  export type InterviewSession$feedbackArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewFeedback
     */
    select?: InterviewFeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewFeedbackInclude<ExtArgs> | null
    where?: InterviewFeedbackWhereInput
  }

  /**
   * InterviewSession.sharedResult
   */
  export type InterviewSession$sharedResultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedInterviewResult
     */
    select?: SharedInterviewResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharedInterviewResultInclude<ExtArgs> | null
    where?: SharedInterviewResultWhereInput
  }

  /**
   * InterviewSession without action
   */
  export type InterviewSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewSession
     */
    select?: InterviewSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewSessionInclude<ExtArgs> | null
  }


  /**
   * Model InterviewFeedback
   */

  export type AggregateInterviewFeedback = {
    _count: InterviewFeedbackCountAggregateOutputType | null
    _avg: InterviewFeedbackAvgAggregateOutputType | null
    _sum: InterviewFeedbackSumAggregateOutputType | null
    _min: InterviewFeedbackMinAggregateOutputType | null
    _max: InterviewFeedbackMaxAggregateOutputType | null
  }

  export type InterviewFeedbackAvgAggregateOutputType = {
    overallScore: number | null
    communicationClarity: number | null
    technicalDepth: number | null
    confidence: number | null
    roleAlignment: number | null
  }

  export type InterviewFeedbackSumAggregateOutputType = {
    overallScore: number | null
    communicationClarity: number | null
    technicalDepth: number | null
    confidence: number | null
    roleAlignment: number | null
  }

  export type InterviewFeedbackMinAggregateOutputType = {
    id: string | null
    sessionId: string | null
    overallScore: number | null
    communicationClarity: number | null
    technicalDepth: number | null
    confidence: number | null
    roleAlignment: number | null
    learningRoadmap: string | null
    aiSummary: string | null
    createdAt: Date | null
  }

  export type InterviewFeedbackMaxAggregateOutputType = {
    id: string | null
    sessionId: string | null
    overallScore: number | null
    communicationClarity: number | null
    technicalDepth: number | null
    confidence: number | null
    roleAlignment: number | null
    learningRoadmap: string | null
    aiSummary: string | null
    createdAt: Date | null
  }

  export type InterviewFeedbackCountAggregateOutputType = {
    id: number
    sessionId: number
    overallScore: number
    communicationClarity: number
    technicalDepth: number
    confidence: number
    roleAlignment: number
    skillRatings: number
    strengths: number
    weaknesses: number
    improvements: number
    suggestedTopics: number
    learningRoadmap: number
    aiSummary: number
    createdAt: number
    _all: number
  }


  export type InterviewFeedbackAvgAggregateInputType = {
    overallScore?: true
    communicationClarity?: true
    technicalDepth?: true
    confidence?: true
    roleAlignment?: true
  }

  export type InterviewFeedbackSumAggregateInputType = {
    overallScore?: true
    communicationClarity?: true
    technicalDepth?: true
    confidence?: true
    roleAlignment?: true
  }

  export type InterviewFeedbackMinAggregateInputType = {
    id?: true
    sessionId?: true
    overallScore?: true
    communicationClarity?: true
    technicalDepth?: true
    confidence?: true
    roleAlignment?: true
    learningRoadmap?: true
    aiSummary?: true
    createdAt?: true
  }

  export type InterviewFeedbackMaxAggregateInputType = {
    id?: true
    sessionId?: true
    overallScore?: true
    communicationClarity?: true
    technicalDepth?: true
    confidence?: true
    roleAlignment?: true
    learningRoadmap?: true
    aiSummary?: true
    createdAt?: true
  }

  export type InterviewFeedbackCountAggregateInputType = {
    id?: true
    sessionId?: true
    overallScore?: true
    communicationClarity?: true
    technicalDepth?: true
    confidence?: true
    roleAlignment?: true
    skillRatings?: true
    strengths?: true
    weaknesses?: true
    improvements?: true
    suggestedTopics?: true
    learningRoadmap?: true
    aiSummary?: true
    createdAt?: true
    _all?: true
  }

  export type InterviewFeedbackAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InterviewFeedback to aggregate.
     */
    where?: InterviewFeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InterviewFeedbacks to fetch.
     */
    orderBy?: InterviewFeedbackOrderByWithRelationInput | InterviewFeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InterviewFeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InterviewFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InterviewFeedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InterviewFeedbacks
    **/
    _count?: true | InterviewFeedbackCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InterviewFeedbackAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InterviewFeedbackSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InterviewFeedbackMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InterviewFeedbackMaxAggregateInputType
  }

  export type GetInterviewFeedbackAggregateType<T extends InterviewFeedbackAggregateArgs> = {
        [P in keyof T & keyof AggregateInterviewFeedback]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInterviewFeedback[P]>
      : GetScalarType<T[P], AggregateInterviewFeedback[P]>
  }




  export type InterviewFeedbackGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InterviewFeedbackWhereInput
    orderBy?: InterviewFeedbackOrderByWithAggregationInput | InterviewFeedbackOrderByWithAggregationInput[]
    by: InterviewFeedbackScalarFieldEnum[] | InterviewFeedbackScalarFieldEnum
    having?: InterviewFeedbackScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InterviewFeedbackCountAggregateInputType | true
    _avg?: InterviewFeedbackAvgAggregateInputType
    _sum?: InterviewFeedbackSumAggregateInputType
    _min?: InterviewFeedbackMinAggregateInputType
    _max?: InterviewFeedbackMaxAggregateInputType
  }

  export type InterviewFeedbackGroupByOutputType = {
    id: string
    sessionId: string
    overallScore: number
    communicationClarity: number
    technicalDepth: number
    confidence: number
    roleAlignment: number
    skillRatings: JsonValue
    strengths: string[]
    weaknesses: string[]
    improvements: string[]
    suggestedTopics: string[]
    learningRoadmap: string
    aiSummary: string
    createdAt: Date
    _count: InterviewFeedbackCountAggregateOutputType | null
    _avg: InterviewFeedbackAvgAggregateOutputType | null
    _sum: InterviewFeedbackSumAggregateOutputType | null
    _min: InterviewFeedbackMinAggregateOutputType | null
    _max: InterviewFeedbackMaxAggregateOutputType | null
  }

  type GetInterviewFeedbackGroupByPayload<T extends InterviewFeedbackGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InterviewFeedbackGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InterviewFeedbackGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InterviewFeedbackGroupByOutputType[P]>
            : GetScalarType<T[P], InterviewFeedbackGroupByOutputType[P]>
        }
      >
    >


  export type InterviewFeedbackSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    overallScore?: boolean
    communicationClarity?: boolean
    technicalDepth?: boolean
    confidence?: boolean
    roleAlignment?: boolean
    skillRatings?: boolean
    strengths?: boolean
    weaknesses?: boolean
    improvements?: boolean
    suggestedTopics?: boolean
    learningRoadmap?: boolean
    aiSummary?: boolean
    createdAt?: boolean
    session?: boolean | InterviewSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["interviewFeedback"]>

  export type InterviewFeedbackSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    overallScore?: boolean
    communicationClarity?: boolean
    technicalDepth?: boolean
    confidence?: boolean
    roleAlignment?: boolean
    skillRatings?: boolean
    strengths?: boolean
    weaknesses?: boolean
    improvements?: boolean
    suggestedTopics?: boolean
    learningRoadmap?: boolean
    aiSummary?: boolean
    createdAt?: boolean
    session?: boolean | InterviewSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["interviewFeedback"]>

  export type InterviewFeedbackSelectScalar = {
    id?: boolean
    sessionId?: boolean
    overallScore?: boolean
    communicationClarity?: boolean
    technicalDepth?: boolean
    confidence?: boolean
    roleAlignment?: boolean
    skillRatings?: boolean
    strengths?: boolean
    weaknesses?: boolean
    improvements?: boolean
    suggestedTopics?: boolean
    learningRoadmap?: boolean
    aiSummary?: boolean
    createdAt?: boolean
  }

  export type InterviewFeedbackInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | InterviewSessionDefaultArgs<ExtArgs>
  }
  export type InterviewFeedbackIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | InterviewSessionDefaultArgs<ExtArgs>
  }

  export type $InterviewFeedbackPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InterviewFeedback"
    objects: {
      session: Prisma.$InterviewSessionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionId: string
      overallScore: number
      communicationClarity: number
      technicalDepth: number
      confidence: number
      roleAlignment: number
      skillRatings: Prisma.JsonValue
      strengths: string[]
      weaknesses: string[]
      improvements: string[]
      suggestedTopics: string[]
      learningRoadmap: string
      aiSummary: string
      createdAt: Date
    }, ExtArgs["result"]["interviewFeedback"]>
    composites: {}
  }

  type InterviewFeedbackGetPayload<S extends boolean | null | undefined | InterviewFeedbackDefaultArgs> = $Result.GetResult<Prisma.$InterviewFeedbackPayload, S>

  type InterviewFeedbackCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InterviewFeedbackFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InterviewFeedbackCountAggregateInputType | true
    }

  export interface InterviewFeedbackDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InterviewFeedback'], meta: { name: 'InterviewFeedback' } }
    /**
     * Find zero or one InterviewFeedback that matches the filter.
     * @param {InterviewFeedbackFindUniqueArgs} args - Arguments to find a InterviewFeedback
     * @example
     * // Get one InterviewFeedback
     * const interviewFeedback = await prisma.interviewFeedback.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InterviewFeedbackFindUniqueArgs>(args: SelectSubset<T, InterviewFeedbackFindUniqueArgs<ExtArgs>>): Prisma__InterviewFeedbackClient<$Result.GetResult<Prisma.$InterviewFeedbackPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one InterviewFeedback that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InterviewFeedbackFindUniqueOrThrowArgs} args - Arguments to find a InterviewFeedback
     * @example
     * // Get one InterviewFeedback
     * const interviewFeedback = await prisma.interviewFeedback.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InterviewFeedbackFindUniqueOrThrowArgs>(args: SelectSubset<T, InterviewFeedbackFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InterviewFeedbackClient<$Result.GetResult<Prisma.$InterviewFeedbackPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first InterviewFeedback that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewFeedbackFindFirstArgs} args - Arguments to find a InterviewFeedback
     * @example
     * // Get one InterviewFeedback
     * const interviewFeedback = await prisma.interviewFeedback.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InterviewFeedbackFindFirstArgs>(args?: SelectSubset<T, InterviewFeedbackFindFirstArgs<ExtArgs>>): Prisma__InterviewFeedbackClient<$Result.GetResult<Prisma.$InterviewFeedbackPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first InterviewFeedback that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewFeedbackFindFirstOrThrowArgs} args - Arguments to find a InterviewFeedback
     * @example
     * // Get one InterviewFeedback
     * const interviewFeedback = await prisma.interviewFeedback.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InterviewFeedbackFindFirstOrThrowArgs>(args?: SelectSubset<T, InterviewFeedbackFindFirstOrThrowArgs<ExtArgs>>): Prisma__InterviewFeedbackClient<$Result.GetResult<Prisma.$InterviewFeedbackPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more InterviewFeedbacks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewFeedbackFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InterviewFeedbacks
     * const interviewFeedbacks = await prisma.interviewFeedback.findMany()
     * 
     * // Get first 10 InterviewFeedbacks
     * const interviewFeedbacks = await prisma.interviewFeedback.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const interviewFeedbackWithIdOnly = await prisma.interviewFeedback.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InterviewFeedbackFindManyArgs>(args?: SelectSubset<T, InterviewFeedbackFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterviewFeedbackPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a InterviewFeedback.
     * @param {InterviewFeedbackCreateArgs} args - Arguments to create a InterviewFeedback.
     * @example
     * // Create one InterviewFeedback
     * const InterviewFeedback = await prisma.interviewFeedback.create({
     *   data: {
     *     // ... data to create a InterviewFeedback
     *   }
     * })
     * 
     */
    create<T extends InterviewFeedbackCreateArgs>(args: SelectSubset<T, InterviewFeedbackCreateArgs<ExtArgs>>): Prisma__InterviewFeedbackClient<$Result.GetResult<Prisma.$InterviewFeedbackPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many InterviewFeedbacks.
     * @param {InterviewFeedbackCreateManyArgs} args - Arguments to create many InterviewFeedbacks.
     * @example
     * // Create many InterviewFeedbacks
     * const interviewFeedback = await prisma.interviewFeedback.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InterviewFeedbackCreateManyArgs>(args?: SelectSubset<T, InterviewFeedbackCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InterviewFeedbacks and returns the data saved in the database.
     * @param {InterviewFeedbackCreateManyAndReturnArgs} args - Arguments to create many InterviewFeedbacks.
     * @example
     * // Create many InterviewFeedbacks
     * const interviewFeedback = await prisma.interviewFeedback.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InterviewFeedbacks and only return the `id`
     * const interviewFeedbackWithIdOnly = await prisma.interviewFeedback.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InterviewFeedbackCreateManyAndReturnArgs>(args?: SelectSubset<T, InterviewFeedbackCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterviewFeedbackPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a InterviewFeedback.
     * @param {InterviewFeedbackDeleteArgs} args - Arguments to delete one InterviewFeedback.
     * @example
     * // Delete one InterviewFeedback
     * const InterviewFeedback = await prisma.interviewFeedback.delete({
     *   where: {
     *     // ... filter to delete one InterviewFeedback
     *   }
     * })
     * 
     */
    delete<T extends InterviewFeedbackDeleteArgs>(args: SelectSubset<T, InterviewFeedbackDeleteArgs<ExtArgs>>): Prisma__InterviewFeedbackClient<$Result.GetResult<Prisma.$InterviewFeedbackPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one InterviewFeedback.
     * @param {InterviewFeedbackUpdateArgs} args - Arguments to update one InterviewFeedback.
     * @example
     * // Update one InterviewFeedback
     * const interviewFeedback = await prisma.interviewFeedback.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InterviewFeedbackUpdateArgs>(args: SelectSubset<T, InterviewFeedbackUpdateArgs<ExtArgs>>): Prisma__InterviewFeedbackClient<$Result.GetResult<Prisma.$InterviewFeedbackPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more InterviewFeedbacks.
     * @param {InterviewFeedbackDeleteManyArgs} args - Arguments to filter InterviewFeedbacks to delete.
     * @example
     * // Delete a few InterviewFeedbacks
     * const { count } = await prisma.interviewFeedback.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InterviewFeedbackDeleteManyArgs>(args?: SelectSubset<T, InterviewFeedbackDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InterviewFeedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewFeedbackUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InterviewFeedbacks
     * const interviewFeedback = await prisma.interviewFeedback.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InterviewFeedbackUpdateManyArgs>(args: SelectSubset<T, InterviewFeedbackUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InterviewFeedback.
     * @param {InterviewFeedbackUpsertArgs} args - Arguments to update or create a InterviewFeedback.
     * @example
     * // Update or create a InterviewFeedback
     * const interviewFeedback = await prisma.interviewFeedback.upsert({
     *   create: {
     *     // ... data to create a InterviewFeedback
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InterviewFeedback we want to update
     *   }
     * })
     */
    upsert<T extends InterviewFeedbackUpsertArgs>(args: SelectSubset<T, InterviewFeedbackUpsertArgs<ExtArgs>>): Prisma__InterviewFeedbackClient<$Result.GetResult<Prisma.$InterviewFeedbackPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of InterviewFeedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewFeedbackCountArgs} args - Arguments to filter InterviewFeedbacks to count.
     * @example
     * // Count the number of InterviewFeedbacks
     * const count = await prisma.interviewFeedback.count({
     *   where: {
     *     // ... the filter for the InterviewFeedbacks we want to count
     *   }
     * })
    **/
    count<T extends InterviewFeedbackCountArgs>(
      args?: Subset<T, InterviewFeedbackCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InterviewFeedbackCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InterviewFeedback.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewFeedbackAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InterviewFeedbackAggregateArgs>(args: Subset<T, InterviewFeedbackAggregateArgs>): Prisma.PrismaPromise<GetInterviewFeedbackAggregateType<T>>

    /**
     * Group by InterviewFeedback.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewFeedbackGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InterviewFeedbackGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InterviewFeedbackGroupByArgs['orderBy'] }
        : { orderBy?: InterviewFeedbackGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InterviewFeedbackGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInterviewFeedbackGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InterviewFeedback model
   */
  readonly fields: InterviewFeedbackFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InterviewFeedback.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InterviewFeedbackClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    session<T extends InterviewSessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InterviewSessionDefaultArgs<ExtArgs>>): Prisma__InterviewSessionClient<$Result.GetResult<Prisma.$InterviewSessionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InterviewFeedback model
   */ 
  interface InterviewFeedbackFieldRefs {
    readonly id: FieldRef<"InterviewFeedback", 'String'>
    readonly sessionId: FieldRef<"InterviewFeedback", 'String'>
    readonly overallScore: FieldRef<"InterviewFeedback", 'Int'>
    readonly communicationClarity: FieldRef<"InterviewFeedback", 'Int'>
    readonly technicalDepth: FieldRef<"InterviewFeedback", 'Int'>
    readonly confidence: FieldRef<"InterviewFeedback", 'Int'>
    readonly roleAlignment: FieldRef<"InterviewFeedback", 'Int'>
    readonly skillRatings: FieldRef<"InterviewFeedback", 'Json'>
    readonly strengths: FieldRef<"InterviewFeedback", 'String[]'>
    readonly weaknesses: FieldRef<"InterviewFeedback", 'String[]'>
    readonly improvements: FieldRef<"InterviewFeedback", 'String[]'>
    readonly suggestedTopics: FieldRef<"InterviewFeedback", 'String[]'>
    readonly learningRoadmap: FieldRef<"InterviewFeedback", 'String'>
    readonly aiSummary: FieldRef<"InterviewFeedback", 'String'>
    readonly createdAt: FieldRef<"InterviewFeedback", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InterviewFeedback findUnique
   */
  export type InterviewFeedbackFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewFeedback
     */
    select?: InterviewFeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which InterviewFeedback to fetch.
     */
    where: InterviewFeedbackWhereUniqueInput
  }

  /**
   * InterviewFeedback findUniqueOrThrow
   */
  export type InterviewFeedbackFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewFeedback
     */
    select?: InterviewFeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which InterviewFeedback to fetch.
     */
    where: InterviewFeedbackWhereUniqueInput
  }

  /**
   * InterviewFeedback findFirst
   */
  export type InterviewFeedbackFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewFeedback
     */
    select?: InterviewFeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which InterviewFeedback to fetch.
     */
    where?: InterviewFeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InterviewFeedbacks to fetch.
     */
    orderBy?: InterviewFeedbackOrderByWithRelationInput | InterviewFeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InterviewFeedbacks.
     */
    cursor?: InterviewFeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InterviewFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InterviewFeedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InterviewFeedbacks.
     */
    distinct?: InterviewFeedbackScalarFieldEnum | InterviewFeedbackScalarFieldEnum[]
  }

  /**
   * InterviewFeedback findFirstOrThrow
   */
  export type InterviewFeedbackFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewFeedback
     */
    select?: InterviewFeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which InterviewFeedback to fetch.
     */
    where?: InterviewFeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InterviewFeedbacks to fetch.
     */
    orderBy?: InterviewFeedbackOrderByWithRelationInput | InterviewFeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InterviewFeedbacks.
     */
    cursor?: InterviewFeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InterviewFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InterviewFeedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InterviewFeedbacks.
     */
    distinct?: InterviewFeedbackScalarFieldEnum | InterviewFeedbackScalarFieldEnum[]
  }

  /**
   * InterviewFeedback findMany
   */
  export type InterviewFeedbackFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewFeedback
     */
    select?: InterviewFeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewFeedbackInclude<ExtArgs> | null
    /**
     * Filter, which InterviewFeedbacks to fetch.
     */
    where?: InterviewFeedbackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InterviewFeedbacks to fetch.
     */
    orderBy?: InterviewFeedbackOrderByWithRelationInput | InterviewFeedbackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InterviewFeedbacks.
     */
    cursor?: InterviewFeedbackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InterviewFeedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InterviewFeedbacks.
     */
    skip?: number
    distinct?: InterviewFeedbackScalarFieldEnum | InterviewFeedbackScalarFieldEnum[]
  }

  /**
   * InterviewFeedback create
   */
  export type InterviewFeedbackCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewFeedback
     */
    select?: InterviewFeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewFeedbackInclude<ExtArgs> | null
    /**
     * The data needed to create a InterviewFeedback.
     */
    data: XOR<InterviewFeedbackCreateInput, InterviewFeedbackUncheckedCreateInput>
  }

  /**
   * InterviewFeedback createMany
   */
  export type InterviewFeedbackCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InterviewFeedbacks.
     */
    data: InterviewFeedbackCreateManyInput | InterviewFeedbackCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InterviewFeedback createManyAndReturn
   */
  export type InterviewFeedbackCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewFeedback
     */
    select?: InterviewFeedbackSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many InterviewFeedbacks.
     */
    data: InterviewFeedbackCreateManyInput | InterviewFeedbackCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewFeedbackIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InterviewFeedback update
   */
  export type InterviewFeedbackUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewFeedback
     */
    select?: InterviewFeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewFeedbackInclude<ExtArgs> | null
    /**
     * The data needed to update a InterviewFeedback.
     */
    data: XOR<InterviewFeedbackUpdateInput, InterviewFeedbackUncheckedUpdateInput>
    /**
     * Choose, which InterviewFeedback to update.
     */
    where: InterviewFeedbackWhereUniqueInput
  }

  /**
   * InterviewFeedback updateMany
   */
  export type InterviewFeedbackUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InterviewFeedbacks.
     */
    data: XOR<InterviewFeedbackUpdateManyMutationInput, InterviewFeedbackUncheckedUpdateManyInput>
    /**
     * Filter which InterviewFeedbacks to update
     */
    where?: InterviewFeedbackWhereInput
  }

  /**
   * InterviewFeedback upsert
   */
  export type InterviewFeedbackUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewFeedback
     */
    select?: InterviewFeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewFeedbackInclude<ExtArgs> | null
    /**
     * The filter to search for the InterviewFeedback to update in case it exists.
     */
    where: InterviewFeedbackWhereUniqueInput
    /**
     * In case the InterviewFeedback found by the `where` argument doesn't exist, create a new InterviewFeedback with this data.
     */
    create: XOR<InterviewFeedbackCreateInput, InterviewFeedbackUncheckedCreateInput>
    /**
     * In case the InterviewFeedback was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InterviewFeedbackUpdateInput, InterviewFeedbackUncheckedUpdateInput>
  }

  /**
   * InterviewFeedback delete
   */
  export type InterviewFeedbackDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewFeedback
     */
    select?: InterviewFeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewFeedbackInclude<ExtArgs> | null
    /**
     * Filter which InterviewFeedback to delete.
     */
    where: InterviewFeedbackWhereUniqueInput
  }

  /**
   * InterviewFeedback deleteMany
   */
  export type InterviewFeedbackDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InterviewFeedbacks to delete
     */
    where?: InterviewFeedbackWhereInput
  }

  /**
   * InterviewFeedback without action
   */
  export type InterviewFeedbackDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewFeedback
     */
    select?: InterviewFeedbackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewFeedbackInclude<ExtArgs> | null
  }


  /**
   * Model QuestionBank
   */

  export type AggregateQuestionBank = {
    _count: QuestionBankCountAggregateOutputType | null
    _avg: QuestionBankAvgAggregateOutputType | null
    _sum: QuestionBankSumAggregateOutputType | null
    _min: QuestionBankMinAggregateOutputType | null
    _max: QuestionBankMaxAggregateOutputType | null
  }

  export type QuestionBankAvgAggregateOutputType = {
    usageCount: number | null
  }

  export type QuestionBankSumAggregateOutputType = {
    usageCount: number | null
  }

  export type QuestionBankMinAggregateOutputType = {
    id: string | null
    role: string | null
    difficulty: string | null
    category: string | null
    question: string | null
    active: boolean | null
    usageCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuestionBankMaxAggregateOutputType = {
    id: string | null
    role: string | null
    difficulty: string | null
    category: string | null
    question: string | null
    active: boolean | null
    usageCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuestionBankCountAggregateOutputType = {
    id: number
    role: number
    difficulty: number
    category: number
    question: number
    followUps: number
    keyPoints: number
    tags: number
    active: number
    usageCount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type QuestionBankAvgAggregateInputType = {
    usageCount?: true
  }

  export type QuestionBankSumAggregateInputType = {
    usageCount?: true
  }

  export type QuestionBankMinAggregateInputType = {
    id?: true
    role?: true
    difficulty?: true
    category?: true
    question?: true
    active?: true
    usageCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuestionBankMaxAggregateInputType = {
    id?: true
    role?: true
    difficulty?: true
    category?: true
    question?: true
    active?: true
    usageCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuestionBankCountAggregateInputType = {
    id?: true
    role?: true
    difficulty?: true
    category?: true
    question?: true
    followUps?: true
    keyPoints?: true
    tags?: true
    active?: true
    usageCount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type QuestionBankAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuestionBank to aggregate.
     */
    where?: QuestionBankWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionBanks to fetch.
     */
    orderBy?: QuestionBankOrderByWithRelationInput | QuestionBankOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuestionBankWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionBanks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionBanks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuestionBanks
    **/
    _count?: true | QuestionBankCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuestionBankAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuestionBankSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuestionBankMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuestionBankMaxAggregateInputType
  }

  export type GetQuestionBankAggregateType<T extends QuestionBankAggregateArgs> = {
        [P in keyof T & keyof AggregateQuestionBank]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuestionBank[P]>
      : GetScalarType<T[P], AggregateQuestionBank[P]>
  }




  export type QuestionBankGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestionBankWhereInput
    orderBy?: QuestionBankOrderByWithAggregationInput | QuestionBankOrderByWithAggregationInput[]
    by: QuestionBankScalarFieldEnum[] | QuestionBankScalarFieldEnum
    having?: QuestionBankScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuestionBankCountAggregateInputType | true
    _avg?: QuestionBankAvgAggregateInputType
    _sum?: QuestionBankSumAggregateInputType
    _min?: QuestionBankMinAggregateInputType
    _max?: QuestionBankMaxAggregateInputType
  }

  export type QuestionBankGroupByOutputType = {
    id: string
    role: string
    difficulty: string
    category: string
    question: string
    followUps: string[]
    keyPoints: string[]
    tags: string[]
    active: boolean
    usageCount: number
    createdAt: Date
    updatedAt: Date
    _count: QuestionBankCountAggregateOutputType | null
    _avg: QuestionBankAvgAggregateOutputType | null
    _sum: QuestionBankSumAggregateOutputType | null
    _min: QuestionBankMinAggregateOutputType | null
    _max: QuestionBankMaxAggregateOutputType | null
  }

  type GetQuestionBankGroupByPayload<T extends QuestionBankGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuestionBankGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuestionBankGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuestionBankGroupByOutputType[P]>
            : GetScalarType<T[P], QuestionBankGroupByOutputType[P]>
        }
      >
    >


  export type QuestionBankSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    role?: boolean
    difficulty?: boolean
    category?: boolean
    question?: boolean
    followUps?: boolean
    keyPoints?: boolean
    tags?: boolean
    active?: boolean
    usageCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["questionBank"]>

  export type QuestionBankSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    role?: boolean
    difficulty?: boolean
    category?: boolean
    question?: boolean
    followUps?: boolean
    keyPoints?: boolean
    tags?: boolean
    active?: boolean
    usageCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["questionBank"]>

  export type QuestionBankSelectScalar = {
    id?: boolean
    role?: boolean
    difficulty?: boolean
    category?: boolean
    question?: boolean
    followUps?: boolean
    keyPoints?: boolean
    tags?: boolean
    active?: boolean
    usageCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $QuestionBankPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QuestionBank"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      role: string
      difficulty: string
      category: string
      question: string
      followUps: string[]
      keyPoints: string[]
      tags: string[]
      active: boolean
      usageCount: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["questionBank"]>
    composites: {}
  }

  type QuestionBankGetPayload<S extends boolean | null | undefined | QuestionBankDefaultArgs> = $Result.GetResult<Prisma.$QuestionBankPayload, S>

  type QuestionBankCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<QuestionBankFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: QuestionBankCountAggregateInputType | true
    }

  export interface QuestionBankDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QuestionBank'], meta: { name: 'QuestionBank' } }
    /**
     * Find zero or one QuestionBank that matches the filter.
     * @param {QuestionBankFindUniqueArgs} args - Arguments to find a QuestionBank
     * @example
     * // Get one QuestionBank
     * const questionBank = await prisma.questionBank.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuestionBankFindUniqueArgs>(args: SelectSubset<T, QuestionBankFindUniqueArgs<ExtArgs>>): Prisma__QuestionBankClient<$Result.GetResult<Prisma.$QuestionBankPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one QuestionBank that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {QuestionBankFindUniqueOrThrowArgs} args - Arguments to find a QuestionBank
     * @example
     * // Get one QuestionBank
     * const questionBank = await prisma.questionBank.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuestionBankFindUniqueOrThrowArgs>(args: SelectSubset<T, QuestionBankFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuestionBankClient<$Result.GetResult<Prisma.$QuestionBankPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first QuestionBank that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionBankFindFirstArgs} args - Arguments to find a QuestionBank
     * @example
     * // Get one QuestionBank
     * const questionBank = await prisma.questionBank.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuestionBankFindFirstArgs>(args?: SelectSubset<T, QuestionBankFindFirstArgs<ExtArgs>>): Prisma__QuestionBankClient<$Result.GetResult<Prisma.$QuestionBankPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first QuestionBank that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionBankFindFirstOrThrowArgs} args - Arguments to find a QuestionBank
     * @example
     * // Get one QuestionBank
     * const questionBank = await prisma.questionBank.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuestionBankFindFirstOrThrowArgs>(args?: SelectSubset<T, QuestionBankFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuestionBankClient<$Result.GetResult<Prisma.$QuestionBankPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more QuestionBanks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionBankFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuestionBanks
     * const questionBanks = await prisma.questionBank.findMany()
     * 
     * // Get first 10 QuestionBanks
     * const questionBanks = await prisma.questionBank.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const questionBankWithIdOnly = await prisma.questionBank.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuestionBankFindManyArgs>(args?: SelectSubset<T, QuestionBankFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionBankPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a QuestionBank.
     * @param {QuestionBankCreateArgs} args - Arguments to create a QuestionBank.
     * @example
     * // Create one QuestionBank
     * const QuestionBank = await prisma.questionBank.create({
     *   data: {
     *     // ... data to create a QuestionBank
     *   }
     * })
     * 
     */
    create<T extends QuestionBankCreateArgs>(args: SelectSubset<T, QuestionBankCreateArgs<ExtArgs>>): Prisma__QuestionBankClient<$Result.GetResult<Prisma.$QuestionBankPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many QuestionBanks.
     * @param {QuestionBankCreateManyArgs} args - Arguments to create many QuestionBanks.
     * @example
     * // Create many QuestionBanks
     * const questionBank = await prisma.questionBank.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuestionBankCreateManyArgs>(args?: SelectSubset<T, QuestionBankCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QuestionBanks and returns the data saved in the database.
     * @param {QuestionBankCreateManyAndReturnArgs} args - Arguments to create many QuestionBanks.
     * @example
     * // Create many QuestionBanks
     * const questionBank = await prisma.questionBank.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QuestionBanks and only return the `id`
     * const questionBankWithIdOnly = await prisma.questionBank.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuestionBankCreateManyAndReturnArgs>(args?: SelectSubset<T, QuestionBankCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionBankPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a QuestionBank.
     * @param {QuestionBankDeleteArgs} args - Arguments to delete one QuestionBank.
     * @example
     * // Delete one QuestionBank
     * const QuestionBank = await prisma.questionBank.delete({
     *   where: {
     *     // ... filter to delete one QuestionBank
     *   }
     * })
     * 
     */
    delete<T extends QuestionBankDeleteArgs>(args: SelectSubset<T, QuestionBankDeleteArgs<ExtArgs>>): Prisma__QuestionBankClient<$Result.GetResult<Prisma.$QuestionBankPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one QuestionBank.
     * @param {QuestionBankUpdateArgs} args - Arguments to update one QuestionBank.
     * @example
     * // Update one QuestionBank
     * const questionBank = await prisma.questionBank.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuestionBankUpdateArgs>(args: SelectSubset<T, QuestionBankUpdateArgs<ExtArgs>>): Prisma__QuestionBankClient<$Result.GetResult<Prisma.$QuestionBankPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more QuestionBanks.
     * @param {QuestionBankDeleteManyArgs} args - Arguments to filter QuestionBanks to delete.
     * @example
     * // Delete a few QuestionBanks
     * const { count } = await prisma.questionBank.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuestionBankDeleteManyArgs>(args?: SelectSubset<T, QuestionBankDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuestionBanks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionBankUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuestionBanks
     * const questionBank = await prisma.questionBank.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuestionBankUpdateManyArgs>(args: SelectSubset<T, QuestionBankUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one QuestionBank.
     * @param {QuestionBankUpsertArgs} args - Arguments to update or create a QuestionBank.
     * @example
     * // Update or create a QuestionBank
     * const questionBank = await prisma.questionBank.upsert({
     *   create: {
     *     // ... data to create a QuestionBank
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuestionBank we want to update
     *   }
     * })
     */
    upsert<T extends QuestionBankUpsertArgs>(args: SelectSubset<T, QuestionBankUpsertArgs<ExtArgs>>): Prisma__QuestionBankClient<$Result.GetResult<Prisma.$QuestionBankPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of QuestionBanks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionBankCountArgs} args - Arguments to filter QuestionBanks to count.
     * @example
     * // Count the number of QuestionBanks
     * const count = await prisma.questionBank.count({
     *   where: {
     *     // ... the filter for the QuestionBanks we want to count
     *   }
     * })
    **/
    count<T extends QuestionBankCountArgs>(
      args?: Subset<T, QuestionBankCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuestionBankCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuestionBank.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionBankAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuestionBankAggregateArgs>(args: Subset<T, QuestionBankAggregateArgs>): Prisma.PrismaPromise<GetQuestionBankAggregateType<T>>

    /**
     * Group by QuestionBank.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionBankGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuestionBankGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuestionBankGroupByArgs['orderBy'] }
        : { orderBy?: QuestionBankGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuestionBankGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuestionBankGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QuestionBank model
   */
  readonly fields: QuestionBankFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QuestionBank.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuestionBankClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QuestionBank model
   */ 
  interface QuestionBankFieldRefs {
    readonly id: FieldRef<"QuestionBank", 'String'>
    readonly role: FieldRef<"QuestionBank", 'String'>
    readonly difficulty: FieldRef<"QuestionBank", 'String'>
    readonly category: FieldRef<"QuestionBank", 'String'>
    readonly question: FieldRef<"QuestionBank", 'String'>
    readonly followUps: FieldRef<"QuestionBank", 'String[]'>
    readonly keyPoints: FieldRef<"QuestionBank", 'String[]'>
    readonly tags: FieldRef<"QuestionBank", 'String[]'>
    readonly active: FieldRef<"QuestionBank", 'Boolean'>
    readonly usageCount: FieldRef<"QuestionBank", 'Int'>
    readonly createdAt: FieldRef<"QuestionBank", 'DateTime'>
    readonly updatedAt: FieldRef<"QuestionBank", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * QuestionBank findUnique
   */
  export type QuestionBankFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionBank
     */
    select?: QuestionBankSelect<ExtArgs> | null
    /**
     * Filter, which QuestionBank to fetch.
     */
    where: QuestionBankWhereUniqueInput
  }

  /**
   * QuestionBank findUniqueOrThrow
   */
  export type QuestionBankFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionBank
     */
    select?: QuestionBankSelect<ExtArgs> | null
    /**
     * Filter, which QuestionBank to fetch.
     */
    where: QuestionBankWhereUniqueInput
  }

  /**
   * QuestionBank findFirst
   */
  export type QuestionBankFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionBank
     */
    select?: QuestionBankSelect<ExtArgs> | null
    /**
     * Filter, which QuestionBank to fetch.
     */
    where?: QuestionBankWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionBanks to fetch.
     */
    orderBy?: QuestionBankOrderByWithRelationInput | QuestionBankOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuestionBanks.
     */
    cursor?: QuestionBankWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionBanks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionBanks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuestionBanks.
     */
    distinct?: QuestionBankScalarFieldEnum | QuestionBankScalarFieldEnum[]
  }

  /**
   * QuestionBank findFirstOrThrow
   */
  export type QuestionBankFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionBank
     */
    select?: QuestionBankSelect<ExtArgs> | null
    /**
     * Filter, which QuestionBank to fetch.
     */
    where?: QuestionBankWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionBanks to fetch.
     */
    orderBy?: QuestionBankOrderByWithRelationInput | QuestionBankOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuestionBanks.
     */
    cursor?: QuestionBankWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionBanks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionBanks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuestionBanks.
     */
    distinct?: QuestionBankScalarFieldEnum | QuestionBankScalarFieldEnum[]
  }

  /**
   * QuestionBank findMany
   */
  export type QuestionBankFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionBank
     */
    select?: QuestionBankSelect<ExtArgs> | null
    /**
     * Filter, which QuestionBanks to fetch.
     */
    where?: QuestionBankWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionBanks to fetch.
     */
    orderBy?: QuestionBankOrderByWithRelationInput | QuestionBankOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuestionBanks.
     */
    cursor?: QuestionBankWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionBanks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionBanks.
     */
    skip?: number
    distinct?: QuestionBankScalarFieldEnum | QuestionBankScalarFieldEnum[]
  }

  /**
   * QuestionBank create
   */
  export type QuestionBankCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionBank
     */
    select?: QuestionBankSelect<ExtArgs> | null
    /**
     * The data needed to create a QuestionBank.
     */
    data: XOR<QuestionBankCreateInput, QuestionBankUncheckedCreateInput>
  }

  /**
   * QuestionBank createMany
   */
  export type QuestionBankCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QuestionBanks.
     */
    data: QuestionBankCreateManyInput | QuestionBankCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QuestionBank createManyAndReturn
   */
  export type QuestionBankCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionBank
     */
    select?: QuestionBankSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many QuestionBanks.
     */
    data: QuestionBankCreateManyInput | QuestionBankCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QuestionBank update
   */
  export type QuestionBankUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionBank
     */
    select?: QuestionBankSelect<ExtArgs> | null
    /**
     * The data needed to update a QuestionBank.
     */
    data: XOR<QuestionBankUpdateInput, QuestionBankUncheckedUpdateInput>
    /**
     * Choose, which QuestionBank to update.
     */
    where: QuestionBankWhereUniqueInput
  }

  /**
   * QuestionBank updateMany
   */
  export type QuestionBankUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QuestionBanks.
     */
    data: XOR<QuestionBankUpdateManyMutationInput, QuestionBankUncheckedUpdateManyInput>
    /**
     * Filter which QuestionBanks to update
     */
    where?: QuestionBankWhereInput
  }

  /**
   * QuestionBank upsert
   */
  export type QuestionBankUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionBank
     */
    select?: QuestionBankSelect<ExtArgs> | null
    /**
     * The filter to search for the QuestionBank to update in case it exists.
     */
    where: QuestionBankWhereUniqueInput
    /**
     * In case the QuestionBank found by the `where` argument doesn't exist, create a new QuestionBank with this data.
     */
    create: XOR<QuestionBankCreateInput, QuestionBankUncheckedCreateInput>
    /**
     * In case the QuestionBank was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuestionBankUpdateInput, QuestionBankUncheckedUpdateInput>
  }

  /**
   * QuestionBank delete
   */
  export type QuestionBankDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionBank
     */
    select?: QuestionBankSelect<ExtArgs> | null
    /**
     * Filter which QuestionBank to delete.
     */
    where: QuestionBankWhereUniqueInput
  }

  /**
   * QuestionBank deleteMany
   */
  export type QuestionBankDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuestionBanks to delete
     */
    where?: QuestionBankWhereInput
  }

  /**
   * QuestionBank without action
   */
  export type QuestionBankDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionBank
     */
    select?: QuestionBankSelect<ExtArgs> | null
  }


  /**
   * Model SharedInterviewResult
   */

  export type AggregateSharedInterviewResult = {
    _count: SharedInterviewResultCountAggregateOutputType | null
    _avg: SharedInterviewResultAvgAggregateOutputType | null
    _sum: SharedInterviewResultSumAggregateOutputType | null
    _min: SharedInterviewResultMinAggregateOutputType | null
    _max: SharedInterviewResultMaxAggregateOutputType | null
  }

  export type SharedInterviewResultAvgAggregateOutputType = {
    viewCount: number | null
  }

  export type SharedInterviewResultSumAggregateOutputType = {
    viewCount: number | null
  }

  export type SharedInterviewResultMinAggregateOutputType = {
    id: string | null
    sessionId: string | null
    userId: string | null
    shareToken: string | null
    isPublic: boolean | null
    expiresAt: Date | null
    viewCount: number | null
    lastViewedAt: Date | null
    createdAt: Date | null
  }

  export type SharedInterviewResultMaxAggregateOutputType = {
    id: string | null
    sessionId: string | null
    userId: string | null
    shareToken: string | null
    isPublic: boolean | null
    expiresAt: Date | null
    viewCount: number | null
    lastViewedAt: Date | null
    createdAt: Date | null
  }

  export type SharedInterviewResultCountAggregateOutputType = {
    id: number
    sessionId: number
    userId: number
    shareToken: number
    isPublic: number
    expiresAt: number
    viewCount: number
    lastViewedAt: number
    createdAt: number
    _all: number
  }


  export type SharedInterviewResultAvgAggregateInputType = {
    viewCount?: true
  }

  export type SharedInterviewResultSumAggregateInputType = {
    viewCount?: true
  }

  export type SharedInterviewResultMinAggregateInputType = {
    id?: true
    sessionId?: true
    userId?: true
    shareToken?: true
    isPublic?: true
    expiresAt?: true
    viewCount?: true
    lastViewedAt?: true
    createdAt?: true
  }

  export type SharedInterviewResultMaxAggregateInputType = {
    id?: true
    sessionId?: true
    userId?: true
    shareToken?: true
    isPublic?: true
    expiresAt?: true
    viewCount?: true
    lastViewedAt?: true
    createdAt?: true
  }

  export type SharedInterviewResultCountAggregateInputType = {
    id?: true
    sessionId?: true
    userId?: true
    shareToken?: true
    isPublic?: true
    expiresAt?: true
    viewCount?: true
    lastViewedAt?: true
    createdAt?: true
    _all?: true
  }

  export type SharedInterviewResultAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SharedInterviewResult to aggregate.
     */
    where?: SharedInterviewResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SharedInterviewResults to fetch.
     */
    orderBy?: SharedInterviewResultOrderByWithRelationInput | SharedInterviewResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SharedInterviewResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SharedInterviewResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SharedInterviewResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SharedInterviewResults
    **/
    _count?: true | SharedInterviewResultCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SharedInterviewResultAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SharedInterviewResultSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SharedInterviewResultMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SharedInterviewResultMaxAggregateInputType
  }

  export type GetSharedInterviewResultAggregateType<T extends SharedInterviewResultAggregateArgs> = {
        [P in keyof T & keyof AggregateSharedInterviewResult]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSharedInterviewResult[P]>
      : GetScalarType<T[P], AggregateSharedInterviewResult[P]>
  }




  export type SharedInterviewResultGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SharedInterviewResultWhereInput
    orderBy?: SharedInterviewResultOrderByWithAggregationInput | SharedInterviewResultOrderByWithAggregationInput[]
    by: SharedInterviewResultScalarFieldEnum[] | SharedInterviewResultScalarFieldEnum
    having?: SharedInterviewResultScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SharedInterviewResultCountAggregateInputType | true
    _avg?: SharedInterviewResultAvgAggregateInputType
    _sum?: SharedInterviewResultSumAggregateInputType
    _min?: SharedInterviewResultMinAggregateInputType
    _max?: SharedInterviewResultMaxAggregateInputType
  }

  export type SharedInterviewResultGroupByOutputType = {
    id: string
    sessionId: string
    userId: string
    shareToken: string
    isPublic: boolean
    expiresAt: Date | null
    viewCount: number
    lastViewedAt: Date | null
    createdAt: Date
    _count: SharedInterviewResultCountAggregateOutputType | null
    _avg: SharedInterviewResultAvgAggregateOutputType | null
    _sum: SharedInterviewResultSumAggregateOutputType | null
    _min: SharedInterviewResultMinAggregateOutputType | null
    _max: SharedInterviewResultMaxAggregateOutputType | null
  }

  type GetSharedInterviewResultGroupByPayload<T extends SharedInterviewResultGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SharedInterviewResultGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SharedInterviewResultGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SharedInterviewResultGroupByOutputType[P]>
            : GetScalarType<T[P], SharedInterviewResultGroupByOutputType[P]>
        }
      >
    >


  export type SharedInterviewResultSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    userId?: boolean
    shareToken?: boolean
    isPublic?: boolean
    expiresAt?: boolean
    viewCount?: boolean
    lastViewedAt?: boolean
    createdAt?: boolean
    session?: boolean | InterviewSessionDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sharedInterviewResult"]>

  export type SharedInterviewResultSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    userId?: boolean
    shareToken?: boolean
    isPublic?: boolean
    expiresAt?: boolean
    viewCount?: boolean
    lastViewedAt?: boolean
    createdAt?: boolean
    session?: boolean | InterviewSessionDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sharedInterviewResult"]>

  export type SharedInterviewResultSelectScalar = {
    id?: boolean
    sessionId?: boolean
    userId?: boolean
    shareToken?: boolean
    isPublic?: boolean
    expiresAt?: boolean
    viewCount?: boolean
    lastViewedAt?: boolean
    createdAt?: boolean
  }

  export type SharedInterviewResultInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | InterviewSessionDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SharedInterviewResultIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | InterviewSessionDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SharedInterviewResultPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SharedInterviewResult"
    objects: {
      session: Prisma.$InterviewSessionPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionId: string
      userId: string
      shareToken: string
      isPublic: boolean
      expiresAt: Date | null
      viewCount: number
      lastViewedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["sharedInterviewResult"]>
    composites: {}
  }

  type SharedInterviewResultGetPayload<S extends boolean | null | undefined | SharedInterviewResultDefaultArgs> = $Result.GetResult<Prisma.$SharedInterviewResultPayload, S>

  type SharedInterviewResultCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SharedInterviewResultFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SharedInterviewResultCountAggregateInputType | true
    }

  export interface SharedInterviewResultDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SharedInterviewResult'], meta: { name: 'SharedInterviewResult' } }
    /**
     * Find zero or one SharedInterviewResult that matches the filter.
     * @param {SharedInterviewResultFindUniqueArgs} args - Arguments to find a SharedInterviewResult
     * @example
     * // Get one SharedInterviewResult
     * const sharedInterviewResult = await prisma.sharedInterviewResult.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SharedInterviewResultFindUniqueArgs>(args: SelectSubset<T, SharedInterviewResultFindUniqueArgs<ExtArgs>>): Prisma__SharedInterviewResultClient<$Result.GetResult<Prisma.$SharedInterviewResultPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SharedInterviewResult that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SharedInterviewResultFindUniqueOrThrowArgs} args - Arguments to find a SharedInterviewResult
     * @example
     * // Get one SharedInterviewResult
     * const sharedInterviewResult = await prisma.sharedInterviewResult.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SharedInterviewResultFindUniqueOrThrowArgs>(args: SelectSubset<T, SharedInterviewResultFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SharedInterviewResultClient<$Result.GetResult<Prisma.$SharedInterviewResultPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SharedInterviewResult that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharedInterviewResultFindFirstArgs} args - Arguments to find a SharedInterviewResult
     * @example
     * // Get one SharedInterviewResult
     * const sharedInterviewResult = await prisma.sharedInterviewResult.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SharedInterviewResultFindFirstArgs>(args?: SelectSubset<T, SharedInterviewResultFindFirstArgs<ExtArgs>>): Prisma__SharedInterviewResultClient<$Result.GetResult<Prisma.$SharedInterviewResultPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SharedInterviewResult that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharedInterviewResultFindFirstOrThrowArgs} args - Arguments to find a SharedInterviewResult
     * @example
     * // Get one SharedInterviewResult
     * const sharedInterviewResult = await prisma.sharedInterviewResult.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SharedInterviewResultFindFirstOrThrowArgs>(args?: SelectSubset<T, SharedInterviewResultFindFirstOrThrowArgs<ExtArgs>>): Prisma__SharedInterviewResultClient<$Result.GetResult<Prisma.$SharedInterviewResultPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SharedInterviewResults that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharedInterviewResultFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SharedInterviewResults
     * const sharedInterviewResults = await prisma.sharedInterviewResult.findMany()
     * 
     * // Get first 10 SharedInterviewResults
     * const sharedInterviewResults = await prisma.sharedInterviewResult.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sharedInterviewResultWithIdOnly = await prisma.sharedInterviewResult.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SharedInterviewResultFindManyArgs>(args?: SelectSubset<T, SharedInterviewResultFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SharedInterviewResultPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SharedInterviewResult.
     * @param {SharedInterviewResultCreateArgs} args - Arguments to create a SharedInterviewResult.
     * @example
     * // Create one SharedInterviewResult
     * const SharedInterviewResult = await prisma.sharedInterviewResult.create({
     *   data: {
     *     // ... data to create a SharedInterviewResult
     *   }
     * })
     * 
     */
    create<T extends SharedInterviewResultCreateArgs>(args: SelectSubset<T, SharedInterviewResultCreateArgs<ExtArgs>>): Prisma__SharedInterviewResultClient<$Result.GetResult<Prisma.$SharedInterviewResultPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SharedInterviewResults.
     * @param {SharedInterviewResultCreateManyArgs} args - Arguments to create many SharedInterviewResults.
     * @example
     * // Create many SharedInterviewResults
     * const sharedInterviewResult = await prisma.sharedInterviewResult.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SharedInterviewResultCreateManyArgs>(args?: SelectSubset<T, SharedInterviewResultCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SharedInterviewResults and returns the data saved in the database.
     * @param {SharedInterviewResultCreateManyAndReturnArgs} args - Arguments to create many SharedInterviewResults.
     * @example
     * // Create many SharedInterviewResults
     * const sharedInterviewResult = await prisma.sharedInterviewResult.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SharedInterviewResults and only return the `id`
     * const sharedInterviewResultWithIdOnly = await prisma.sharedInterviewResult.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SharedInterviewResultCreateManyAndReturnArgs>(args?: SelectSubset<T, SharedInterviewResultCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SharedInterviewResultPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SharedInterviewResult.
     * @param {SharedInterviewResultDeleteArgs} args - Arguments to delete one SharedInterviewResult.
     * @example
     * // Delete one SharedInterviewResult
     * const SharedInterviewResult = await prisma.sharedInterviewResult.delete({
     *   where: {
     *     // ... filter to delete one SharedInterviewResult
     *   }
     * })
     * 
     */
    delete<T extends SharedInterviewResultDeleteArgs>(args: SelectSubset<T, SharedInterviewResultDeleteArgs<ExtArgs>>): Prisma__SharedInterviewResultClient<$Result.GetResult<Prisma.$SharedInterviewResultPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SharedInterviewResult.
     * @param {SharedInterviewResultUpdateArgs} args - Arguments to update one SharedInterviewResult.
     * @example
     * // Update one SharedInterviewResult
     * const sharedInterviewResult = await prisma.sharedInterviewResult.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SharedInterviewResultUpdateArgs>(args: SelectSubset<T, SharedInterviewResultUpdateArgs<ExtArgs>>): Prisma__SharedInterviewResultClient<$Result.GetResult<Prisma.$SharedInterviewResultPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SharedInterviewResults.
     * @param {SharedInterviewResultDeleteManyArgs} args - Arguments to filter SharedInterviewResults to delete.
     * @example
     * // Delete a few SharedInterviewResults
     * const { count } = await prisma.sharedInterviewResult.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SharedInterviewResultDeleteManyArgs>(args?: SelectSubset<T, SharedInterviewResultDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SharedInterviewResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharedInterviewResultUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SharedInterviewResults
     * const sharedInterviewResult = await prisma.sharedInterviewResult.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SharedInterviewResultUpdateManyArgs>(args: SelectSubset<T, SharedInterviewResultUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SharedInterviewResult.
     * @param {SharedInterviewResultUpsertArgs} args - Arguments to update or create a SharedInterviewResult.
     * @example
     * // Update or create a SharedInterviewResult
     * const sharedInterviewResult = await prisma.sharedInterviewResult.upsert({
     *   create: {
     *     // ... data to create a SharedInterviewResult
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SharedInterviewResult we want to update
     *   }
     * })
     */
    upsert<T extends SharedInterviewResultUpsertArgs>(args: SelectSubset<T, SharedInterviewResultUpsertArgs<ExtArgs>>): Prisma__SharedInterviewResultClient<$Result.GetResult<Prisma.$SharedInterviewResultPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SharedInterviewResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharedInterviewResultCountArgs} args - Arguments to filter SharedInterviewResults to count.
     * @example
     * // Count the number of SharedInterviewResults
     * const count = await prisma.sharedInterviewResult.count({
     *   where: {
     *     // ... the filter for the SharedInterviewResults we want to count
     *   }
     * })
    **/
    count<T extends SharedInterviewResultCountArgs>(
      args?: Subset<T, SharedInterviewResultCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SharedInterviewResultCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SharedInterviewResult.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharedInterviewResultAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SharedInterviewResultAggregateArgs>(args: Subset<T, SharedInterviewResultAggregateArgs>): Prisma.PrismaPromise<GetSharedInterviewResultAggregateType<T>>

    /**
     * Group by SharedInterviewResult.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SharedInterviewResultGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SharedInterviewResultGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SharedInterviewResultGroupByArgs['orderBy'] }
        : { orderBy?: SharedInterviewResultGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SharedInterviewResultGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSharedInterviewResultGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SharedInterviewResult model
   */
  readonly fields: SharedInterviewResultFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SharedInterviewResult.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SharedInterviewResultClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    session<T extends InterviewSessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InterviewSessionDefaultArgs<ExtArgs>>): Prisma__InterviewSessionClient<$Result.GetResult<Prisma.$InterviewSessionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SharedInterviewResult model
   */ 
  interface SharedInterviewResultFieldRefs {
    readonly id: FieldRef<"SharedInterviewResult", 'String'>
    readonly sessionId: FieldRef<"SharedInterviewResult", 'String'>
    readonly userId: FieldRef<"SharedInterviewResult", 'String'>
    readonly shareToken: FieldRef<"SharedInterviewResult", 'String'>
    readonly isPublic: FieldRef<"SharedInterviewResult", 'Boolean'>
    readonly expiresAt: FieldRef<"SharedInterviewResult", 'DateTime'>
    readonly viewCount: FieldRef<"SharedInterviewResult", 'Int'>
    readonly lastViewedAt: FieldRef<"SharedInterviewResult", 'DateTime'>
    readonly createdAt: FieldRef<"SharedInterviewResult", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SharedInterviewResult findUnique
   */
  export type SharedInterviewResultFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedInterviewResult
     */
    select?: SharedInterviewResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharedInterviewResultInclude<ExtArgs> | null
    /**
     * Filter, which SharedInterviewResult to fetch.
     */
    where: SharedInterviewResultWhereUniqueInput
  }

  /**
   * SharedInterviewResult findUniqueOrThrow
   */
  export type SharedInterviewResultFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedInterviewResult
     */
    select?: SharedInterviewResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharedInterviewResultInclude<ExtArgs> | null
    /**
     * Filter, which SharedInterviewResult to fetch.
     */
    where: SharedInterviewResultWhereUniqueInput
  }

  /**
   * SharedInterviewResult findFirst
   */
  export type SharedInterviewResultFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedInterviewResult
     */
    select?: SharedInterviewResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharedInterviewResultInclude<ExtArgs> | null
    /**
     * Filter, which SharedInterviewResult to fetch.
     */
    where?: SharedInterviewResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SharedInterviewResults to fetch.
     */
    orderBy?: SharedInterviewResultOrderByWithRelationInput | SharedInterviewResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SharedInterviewResults.
     */
    cursor?: SharedInterviewResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SharedInterviewResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SharedInterviewResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SharedInterviewResults.
     */
    distinct?: SharedInterviewResultScalarFieldEnum | SharedInterviewResultScalarFieldEnum[]
  }

  /**
   * SharedInterviewResult findFirstOrThrow
   */
  export type SharedInterviewResultFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedInterviewResult
     */
    select?: SharedInterviewResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharedInterviewResultInclude<ExtArgs> | null
    /**
     * Filter, which SharedInterviewResult to fetch.
     */
    where?: SharedInterviewResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SharedInterviewResults to fetch.
     */
    orderBy?: SharedInterviewResultOrderByWithRelationInput | SharedInterviewResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SharedInterviewResults.
     */
    cursor?: SharedInterviewResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SharedInterviewResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SharedInterviewResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SharedInterviewResults.
     */
    distinct?: SharedInterviewResultScalarFieldEnum | SharedInterviewResultScalarFieldEnum[]
  }

  /**
   * SharedInterviewResult findMany
   */
  export type SharedInterviewResultFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedInterviewResult
     */
    select?: SharedInterviewResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharedInterviewResultInclude<ExtArgs> | null
    /**
     * Filter, which SharedInterviewResults to fetch.
     */
    where?: SharedInterviewResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SharedInterviewResults to fetch.
     */
    orderBy?: SharedInterviewResultOrderByWithRelationInput | SharedInterviewResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SharedInterviewResults.
     */
    cursor?: SharedInterviewResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SharedInterviewResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SharedInterviewResults.
     */
    skip?: number
    distinct?: SharedInterviewResultScalarFieldEnum | SharedInterviewResultScalarFieldEnum[]
  }

  /**
   * SharedInterviewResult create
   */
  export type SharedInterviewResultCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedInterviewResult
     */
    select?: SharedInterviewResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharedInterviewResultInclude<ExtArgs> | null
    /**
     * The data needed to create a SharedInterviewResult.
     */
    data: XOR<SharedInterviewResultCreateInput, SharedInterviewResultUncheckedCreateInput>
  }

  /**
   * SharedInterviewResult createMany
   */
  export type SharedInterviewResultCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SharedInterviewResults.
     */
    data: SharedInterviewResultCreateManyInput | SharedInterviewResultCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SharedInterviewResult createManyAndReturn
   */
  export type SharedInterviewResultCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedInterviewResult
     */
    select?: SharedInterviewResultSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SharedInterviewResults.
     */
    data: SharedInterviewResultCreateManyInput | SharedInterviewResultCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharedInterviewResultIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SharedInterviewResult update
   */
  export type SharedInterviewResultUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedInterviewResult
     */
    select?: SharedInterviewResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharedInterviewResultInclude<ExtArgs> | null
    /**
     * The data needed to update a SharedInterviewResult.
     */
    data: XOR<SharedInterviewResultUpdateInput, SharedInterviewResultUncheckedUpdateInput>
    /**
     * Choose, which SharedInterviewResult to update.
     */
    where: SharedInterviewResultWhereUniqueInput
  }

  /**
   * SharedInterviewResult updateMany
   */
  export type SharedInterviewResultUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SharedInterviewResults.
     */
    data: XOR<SharedInterviewResultUpdateManyMutationInput, SharedInterviewResultUncheckedUpdateManyInput>
    /**
     * Filter which SharedInterviewResults to update
     */
    where?: SharedInterviewResultWhereInput
  }

  /**
   * SharedInterviewResult upsert
   */
  export type SharedInterviewResultUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedInterviewResult
     */
    select?: SharedInterviewResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharedInterviewResultInclude<ExtArgs> | null
    /**
     * The filter to search for the SharedInterviewResult to update in case it exists.
     */
    where: SharedInterviewResultWhereUniqueInput
    /**
     * In case the SharedInterviewResult found by the `where` argument doesn't exist, create a new SharedInterviewResult with this data.
     */
    create: XOR<SharedInterviewResultCreateInput, SharedInterviewResultUncheckedCreateInput>
    /**
     * In case the SharedInterviewResult was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SharedInterviewResultUpdateInput, SharedInterviewResultUncheckedUpdateInput>
  }

  /**
   * SharedInterviewResult delete
   */
  export type SharedInterviewResultDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedInterviewResult
     */
    select?: SharedInterviewResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharedInterviewResultInclude<ExtArgs> | null
    /**
     * Filter which SharedInterviewResult to delete.
     */
    where: SharedInterviewResultWhereUniqueInput
  }

  /**
   * SharedInterviewResult deleteMany
   */
  export type SharedInterviewResultDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SharedInterviewResults to delete
     */
    where?: SharedInterviewResultWhereInput
  }

  /**
   * SharedInterviewResult without action
   */
  export type SharedInterviewResultDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SharedInterviewResult
     */
    select?: SharedInterviewResultSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SharedInterviewResultInclude<ExtArgs> | null
  }


  /**
   * Model InterviewAnalytics
   */

  export type AggregateInterviewAnalytics = {
    _count: InterviewAnalyticsCountAggregateOutputType | null
    _avg: InterviewAnalyticsAvgAggregateOutputType | null
    _sum: InterviewAnalyticsSumAggregateOutputType | null
    _min: InterviewAnalyticsMinAggregateOutputType | null
    _max: InterviewAnalyticsMaxAggregateOutputType | null
  }

  export type InterviewAnalyticsAvgAggregateOutputType = {
    totalInterviews: number | null
    averageScore: number | null
    averageCommunication: number | null
    averageTechnical: number | null
    averageConfidence: number | null
  }

  export type InterviewAnalyticsSumAggregateOutputType = {
    totalInterviews: number | null
    averageScore: number | null
    averageCommunication: number | null
    averageTechnical: number | null
    averageConfidence: number | null
  }

  export type InterviewAnalyticsMinAggregateOutputType = {
    id: string | null
    userId: string | null
    totalInterviews: number | null
    averageScore: number | null
    averageCommunication: number | null
    averageTechnical: number | null
    averageConfidence: number | null
    lastUpdated: Date | null
  }

  export type InterviewAnalyticsMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    totalInterviews: number | null
    averageScore: number | null
    averageCommunication: number | null
    averageTechnical: number | null
    averageConfidence: number | null
    lastUpdated: Date | null
  }

  export type InterviewAnalyticsCountAggregateOutputType = {
    id: number
    userId: number
    totalInterviews: number
    averageScore: number
    averageCommunication: number
    averageTechnical: number
    averageConfidence: number
    roleStats: number
    monthlyScores: number
    topStrengths: number
    topWeaknesses: number
    lastUpdated: number
    _all: number
  }


  export type InterviewAnalyticsAvgAggregateInputType = {
    totalInterviews?: true
    averageScore?: true
    averageCommunication?: true
    averageTechnical?: true
    averageConfidence?: true
  }

  export type InterviewAnalyticsSumAggregateInputType = {
    totalInterviews?: true
    averageScore?: true
    averageCommunication?: true
    averageTechnical?: true
    averageConfidence?: true
  }

  export type InterviewAnalyticsMinAggregateInputType = {
    id?: true
    userId?: true
    totalInterviews?: true
    averageScore?: true
    averageCommunication?: true
    averageTechnical?: true
    averageConfidence?: true
    lastUpdated?: true
  }

  export type InterviewAnalyticsMaxAggregateInputType = {
    id?: true
    userId?: true
    totalInterviews?: true
    averageScore?: true
    averageCommunication?: true
    averageTechnical?: true
    averageConfidence?: true
    lastUpdated?: true
  }

  export type InterviewAnalyticsCountAggregateInputType = {
    id?: true
    userId?: true
    totalInterviews?: true
    averageScore?: true
    averageCommunication?: true
    averageTechnical?: true
    averageConfidence?: true
    roleStats?: true
    monthlyScores?: true
    topStrengths?: true
    topWeaknesses?: true
    lastUpdated?: true
    _all?: true
  }

  export type InterviewAnalyticsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InterviewAnalytics to aggregate.
     */
    where?: InterviewAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InterviewAnalytics to fetch.
     */
    orderBy?: InterviewAnalyticsOrderByWithRelationInput | InterviewAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InterviewAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InterviewAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InterviewAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InterviewAnalytics
    **/
    _count?: true | InterviewAnalyticsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InterviewAnalyticsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InterviewAnalyticsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InterviewAnalyticsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InterviewAnalyticsMaxAggregateInputType
  }

  export type GetInterviewAnalyticsAggregateType<T extends InterviewAnalyticsAggregateArgs> = {
        [P in keyof T & keyof AggregateInterviewAnalytics]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInterviewAnalytics[P]>
      : GetScalarType<T[P], AggregateInterviewAnalytics[P]>
  }




  export type InterviewAnalyticsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InterviewAnalyticsWhereInput
    orderBy?: InterviewAnalyticsOrderByWithAggregationInput | InterviewAnalyticsOrderByWithAggregationInput[]
    by: InterviewAnalyticsScalarFieldEnum[] | InterviewAnalyticsScalarFieldEnum
    having?: InterviewAnalyticsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InterviewAnalyticsCountAggregateInputType | true
    _avg?: InterviewAnalyticsAvgAggregateInputType
    _sum?: InterviewAnalyticsSumAggregateInputType
    _min?: InterviewAnalyticsMinAggregateInputType
    _max?: InterviewAnalyticsMaxAggregateInputType
  }

  export type InterviewAnalyticsGroupByOutputType = {
    id: string
    userId: string
    totalInterviews: number
    averageScore: number
    averageCommunication: number
    averageTechnical: number
    averageConfidence: number
    roleStats: JsonValue
    monthlyScores: JsonValue
    topStrengths: string[]
    topWeaknesses: string[]
    lastUpdated: Date
    _count: InterviewAnalyticsCountAggregateOutputType | null
    _avg: InterviewAnalyticsAvgAggregateOutputType | null
    _sum: InterviewAnalyticsSumAggregateOutputType | null
    _min: InterviewAnalyticsMinAggregateOutputType | null
    _max: InterviewAnalyticsMaxAggregateOutputType | null
  }

  type GetInterviewAnalyticsGroupByPayload<T extends InterviewAnalyticsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InterviewAnalyticsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InterviewAnalyticsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InterviewAnalyticsGroupByOutputType[P]>
            : GetScalarType<T[P], InterviewAnalyticsGroupByOutputType[P]>
        }
      >
    >


  export type InterviewAnalyticsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    totalInterviews?: boolean
    averageScore?: boolean
    averageCommunication?: boolean
    averageTechnical?: boolean
    averageConfidence?: boolean
    roleStats?: boolean
    monthlyScores?: boolean
    topStrengths?: boolean
    topWeaknesses?: boolean
    lastUpdated?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["interviewAnalytics"]>

  export type InterviewAnalyticsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    totalInterviews?: boolean
    averageScore?: boolean
    averageCommunication?: boolean
    averageTechnical?: boolean
    averageConfidence?: boolean
    roleStats?: boolean
    monthlyScores?: boolean
    topStrengths?: boolean
    topWeaknesses?: boolean
    lastUpdated?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["interviewAnalytics"]>

  export type InterviewAnalyticsSelectScalar = {
    id?: boolean
    userId?: boolean
    totalInterviews?: boolean
    averageScore?: boolean
    averageCommunication?: boolean
    averageTechnical?: boolean
    averageConfidence?: boolean
    roleStats?: boolean
    monthlyScores?: boolean
    topStrengths?: boolean
    topWeaknesses?: boolean
    lastUpdated?: boolean
  }

  export type InterviewAnalyticsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type InterviewAnalyticsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $InterviewAnalyticsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InterviewAnalytics"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      totalInterviews: number
      averageScore: number
      averageCommunication: number
      averageTechnical: number
      averageConfidence: number
      roleStats: Prisma.JsonValue
      monthlyScores: Prisma.JsonValue
      topStrengths: string[]
      topWeaknesses: string[]
      lastUpdated: Date
    }, ExtArgs["result"]["interviewAnalytics"]>
    composites: {}
  }

  type InterviewAnalyticsGetPayload<S extends boolean | null | undefined | InterviewAnalyticsDefaultArgs> = $Result.GetResult<Prisma.$InterviewAnalyticsPayload, S>

  type InterviewAnalyticsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InterviewAnalyticsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InterviewAnalyticsCountAggregateInputType | true
    }

  export interface InterviewAnalyticsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InterviewAnalytics'], meta: { name: 'InterviewAnalytics' } }
    /**
     * Find zero or one InterviewAnalytics that matches the filter.
     * @param {InterviewAnalyticsFindUniqueArgs} args - Arguments to find a InterviewAnalytics
     * @example
     * // Get one InterviewAnalytics
     * const interviewAnalytics = await prisma.interviewAnalytics.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InterviewAnalyticsFindUniqueArgs>(args: SelectSubset<T, InterviewAnalyticsFindUniqueArgs<ExtArgs>>): Prisma__InterviewAnalyticsClient<$Result.GetResult<Prisma.$InterviewAnalyticsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one InterviewAnalytics that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InterviewAnalyticsFindUniqueOrThrowArgs} args - Arguments to find a InterviewAnalytics
     * @example
     * // Get one InterviewAnalytics
     * const interviewAnalytics = await prisma.interviewAnalytics.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InterviewAnalyticsFindUniqueOrThrowArgs>(args: SelectSubset<T, InterviewAnalyticsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InterviewAnalyticsClient<$Result.GetResult<Prisma.$InterviewAnalyticsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first InterviewAnalytics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewAnalyticsFindFirstArgs} args - Arguments to find a InterviewAnalytics
     * @example
     * // Get one InterviewAnalytics
     * const interviewAnalytics = await prisma.interviewAnalytics.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InterviewAnalyticsFindFirstArgs>(args?: SelectSubset<T, InterviewAnalyticsFindFirstArgs<ExtArgs>>): Prisma__InterviewAnalyticsClient<$Result.GetResult<Prisma.$InterviewAnalyticsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first InterviewAnalytics that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewAnalyticsFindFirstOrThrowArgs} args - Arguments to find a InterviewAnalytics
     * @example
     * // Get one InterviewAnalytics
     * const interviewAnalytics = await prisma.interviewAnalytics.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InterviewAnalyticsFindFirstOrThrowArgs>(args?: SelectSubset<T, InterviewAnalyticsFindFirstOrThrowArgs<ExtArgs>>): Prisma__InterviewAnalyticsClient<$Result.GetResult<Prisma.$InterviewAnalyticsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more InterviewAnalytics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewAnalyticsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InterviewAnalytics
     * const interviewAnalytics = await prisma.interviewAnalytics.findMany()
     * 
     * // Get first 10 InterviewAnalytics
     * const interviewAnalytics = await prisma.interviewAnalytics.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const interviewAnalyticsWithIdOnly = await prisma.interviewAnalytics.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InterviewAnalyticsFindManyArgs>(args?: SelectSubset<T, InterviewAnalyticsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterviewAnalyticsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a InterviewAnalytics.
     * @param {InterviewAnalyticsCreateArgs} args - Arguments to create a InterviewAnalytics.
     * @example
     * // Create one InterviewAnalytics
     * const InterviewAnalytics = await prisma.interviewAnalytics.create({
     *   data: {
     *     // ... data to create a InterviewAnalytics
     *   }
     * })
     * 
     */
    create<T extends InterviewAnalyticsCreateArgs>(args: SelectSubset<T, InterviewAnalyticsCreateArgs<ExtArgs>>): Prisma__InterviewAnalyticsClient<$Result.GetResult<Prisma.$InterviewAnalyticsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many InterviewAnalytics.
     * @param {InterviewAnalyticsCreateManyArgs} args - Arguments to create many InterviewAnalytics.
     * @example
     * // Create many InterviewAnalytics
     * const interviewAnalytics = await prisma.interviewAnalytics.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InterviewAnalyticsCreateManyArgs>(args?: SelectSubset<T, InterviewAnalyticsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InterviewAnalytics and returns the data saved in the database.
     * @param {InterviewAnalyticsCreateManyAndReturnArgs} args - Arguments to create many InterviewAnalytics.
     * @example
     * // Create many InterviewAnalytics
     * const interviewAnalytics = await prisma.interviewAnalytics.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InterviewAnalytics and only return the `id`
     * const interviewAnalyticsWithIdOnly = await prisma.interviewAnalytics.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InterviewAnalyticsCreateManyAndReturnArgs>(args?: SelectSubset<T, InterviewAnalyticsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterviewAnalyticsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a InterviewAnalytics.
     * @param {InterviewAnalyticsDeleteArgs} args - Arguments to delete one InterviewAnalytics.
     * @example
     * // Delete one InterviewAnalytics
     * const InterviewAnalytics = await prisma.interviewAnalytics.delete({
     *   where: {
     *     // ... filter to delete one InterviewAnalytics
     *   }
     * })
     * 
     */
    delete<T extends InterviewAnalyticsDeleteArgs>(args: SelectSubset<T, InterviewAnalyticsDeleteArgs<ExtArgs>>): Prisma__InterviewAnalyticsClient<$Result.GetResult<Prisma.$InterviewAnalyticsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one InterviewAnalytics.
     * @param {InterviewAnalyticsUpdateArgs} args - Arguments to update one InterviewAnalytics.
     * @example
     * // Update one InterviewAnalytics
     * const interviewAnalytics = await prisma.interviewAnalytics.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InterviewAnalyticsUpdateArgs>(args: SelectSubset<T, InterviewAnalyticsUpdateArgs<ExtArgs>>): Prisma__InterviewAnalyticsClient<$Result.GetResult<Prisma.$InterviewAnalyticsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more InterviewAnalytics.
     * @param {InterviewAnalyticsDeleteManyArgs} args - Arguments to filter InterviewAnalytics to delete.
     * @example
     * // Delete a few InterviewAnalytics
     * const { count } = await prisma.interviewAnalytics.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InterviewAnalyticsDeleteManyArgs>(args?: SelectSubset<T, InterviewAnalyticsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InterviewAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewAnalyticsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InterviewAnalytics
     * const interviewAnalytics = await prisma.interviewAnalytics.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InterviewAnalyticsUpdateManyArgs>(args: SelectSubset<T, InterviewAnalyticsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InterviewAnalytics.
     * @param {InterviewAnalyticsUpsertArgs} args - Arguments to update or create a InterviewAnalytics.
     * @example
     * // Update or create a InterviewAnalytics
     * const interviewAnalytics = await prisma.interviewAnalytics.upsert({
     *   create: {
     *     // ... data to create a InterviewAnalytics
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InterviewAnalytics we want to update
     *   }
     * })
     */
    upsert<T extends InterviewAnalyticsUpsertArgs>(args: SelectSubset<T, InterviewAnalyticsUpsertArgs<ExtArgs>>): Prisma__InterviewAnalyticsClient<$Result.GetResult<Prisma.$InterviewAnalyticsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of InterviewAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewAnalyticsCountArgs} args - Arguments to filter InterviewAnalytics to count.
     * @example
     * // Count the number of InterviewAnalytics
     * const count = await prisma.interviewAnalytics.count({
     *   where: {
     *     // ... the filter for the InterviewAnalytics we want to count
     *   }
     * })
    **/
    count<T extends InterviewAnalyticsCountArgs>(
      args?: Subset<T, InterviewAnalyticsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InterviewAnalyticsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InterviewAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewAnalyticsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InterviewAnalyticsAggregateArgs>(args: Subset<T, InterviewAnalyticsAggregateArgs>): Prisma.PrismaPromise<GetInterviewAnalyticsAggregateType<T>>

    /**
     * Group by InterviewAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterviewAnalyticsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InterviewAnalyticsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InterviewAnalyticsGroupByArgs['orderBy'] }
        : { orderBy?: InterviewAnalyticsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InterviewAnalyticsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInterviewAnalyticsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InterviewAnalytics model
   */
  readonly fields: InterviewAnalyticsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InterviewAnalytics.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InterviewAnalyticsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InterviewAnalytics model
   */ 
  interface InterviewAnalyticsFieldRefs {
    readonly id: FieldRef<"InterviewAnalytics", 'String'>
    readonly userId: FieldRef<"InterviewAnalytics", 'String'>
    readonly totalInterviews: FieldRef<"InterviewAnalytics", 'Int'>
    readonly averageScore: FieldRef<"InterviewAnalytics", 'Float'>
    readonly averageCommunication: FieldRef<"InterviewAnalytics", 'Float'>
    readonly averageTechnical: FieldRef<"InterviewAnalytics", 'Float'>
    readonly averageConfidence: FieldRef<"InterviewAnalytics", 'Float'>
    readonly roleStats: FieldRef<"InterviewAnalytics", 'Json'>
    readonly monthlyScores: FieldRef<"InterviewAnalytics", 'Json'>
    readonly topStrengths: FieldRef<"InterviewAnalytics", 'String[]'>
    readonly topWeaknesses: FieldRef<"InterviewAnalytics", 'String[]'>
    readonly lastUpdated: FieldRef<"InterviewAnalytics", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InterviewAnalytics findUnique
   */
  export type InterviewAnalyticsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewAnalytics
     */
    select?: InterviewAnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which InterviewAnalytics to fetch.
     */
    where: InterviewAnalyticsWhereUniqueInput
  }

  /**
   * InterviewAnalytics findUniqueOrThrow
   */
  export type InterviewAnalyticsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewAnalytics
     */
    select?: InterviewAnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which InterviewAnalytics to fetch.
     */
    where: InterviewAnalyticsWhereUniqueInput
  }

  /**
   * InterviewAnalytics findFirst
   */
  export type InterviewAnalyticsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewAnalytics
     */
    select?: InterviewAnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which InterviewAnalytics to fetch.
     */
    where?: InterviewAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InterviewAnalytics to fetch.
     */
    orderBy?: InterviewAnalyticsOrderByWithRelationInput | InterviewAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InterviewAnalytics.
     */
    cursor?: InterviewAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InterviewAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InterviewAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InterviewAnalytics.
     */
    distinct?: InterviewAnalyticsScalarFieldEnum | InterviewAnalyticsScalarFieldEnum[]
  }

  /**
   * InterviewAnalytics findFirstOrThrow
   */
  export type InterviewAnalyticsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewAnalytics
     */
    select?: InterviewAnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which InterviewAnalytics to fetch.
     */
    where?: InterviewAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InterviewAnalytics to fetch.
     */
    orderBy?: InterviewAnalyticsOrderByWithRelationInput | InterviewAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InterviewAnalytics.
     */
    cursor?: InterviewAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InterviewAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InterviewAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InterviewAnalytics.
     */
    distinct?: InterviewAnalyticsScalarFieldEnum | InterviewAnalyticsScalarFieldEnum[]
  }

  /**
   * InterviewAnalytics findMany
   */
  export type InterviewAnalyticsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewAnalytics
     */
    select?: InterviewAnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which InterviewAnalytics to fetch.
     */
    where?: InterviewAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InterviewAnalytics to fetch.
     */
    orderBy?: InterviewAnalyticsOrderByWithRelationInput | InterviewAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InterviewAnalytics.
     */
    cursor?: InterviewAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InterviewAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InterviewAnalytics.
     */
    skip?: number
    distinct?: InterviewAnalyticsScalarFieldEnum | InterviewAnalyticsScalarFieldEnum[]
  }

  /**
   * InterviewAnalytics create
   */
  export type InterviewAnalyticsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewAnalytics
     */
    select?: InterviewAnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewAnalyticsInclude<ExtArgs> | null
    /**
     * The data needed to create a InterviewAnalytics.
     */
    data: XOR<InterviewAnalyticsCreateInput, InterviewAnalyticsUncheckedCreateInput>
  }

  /**
   * InterviewAnalytics createMany
   */
  export type InterviewAnalyticsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InterviewAnalytics.
     */
    data: InterviewAnalyticsCreateManyInput | InterviewAnalyticsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InterviewAnalytics createManyAndReturn
   */
  export type InterviewAnalyticsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewAnalytics
     */
    select?: InterviewAnalyticsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many InterviewAnalytics.
     */
    data: InterviewAnalyticsCreateManyInput | InterviewAnalyticsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewAnalyticsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InterviewAnalytics update
   */
  export type InterviewAnalyticsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewAnalytics
     */
    select?: InterviewAnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewAnalyticsInclude<ExtArgs> | null
    /**
     * The data needed to update a InterviewAnalytics.
     */
    data: XOR<InterviewAnalyticsUpdateInput, InterviewAnalyticsUncheckedUpdateInput>
    /**
     * Choose, which InterviewAnalytics to update.
     */
    where: InterviewAnalyticsWhereUniqueInput
  }

  /**
   * InterviewAnalytics updateMany
   */
  export type InterviewAnalyticsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InterviewAnalytics.
     */
    data: XOR<InterviewAnalyticsUpdateManyMutationInput, InterviewAnalyticsUncheckedUpdateManyInput>
    /**
     * Filter which InterviewAnalytics to update
     */
    where?: InterviewAnalyticsWhereInput
  }

  /**
   * InterviewAnalytics upsert
   */
  export type InterviewAnalyticsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewAnalytics
     */
    select?: InterviewAnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewAnalyticsInclude<ExtArgs> | null
    /**
     * The filter to search for the InterviewAnalytics to update in case it exists.
     */
    where: InterviewAnalyticsWhereUniqueInput
    /**
     * In case the InterviewAnalytics found by the `where` argument doesn't exist, create a new InterviewAnalytics with this data.
     */
    create: XOR<InterviewAnalyticsCreateInput, InterviewAnalyticsUncheckedCreateInput>
    /**
     * In case the InterviewAnalytics was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InterviewAnalyticsUpdateInput, InterviewAnalyticsUncheckedUpdateInput>
  }

  /**
   * InterviewAnalytics delete
   */
  export type InterviewAnalyticsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewAnalytics
     */
    select?: InterviewAnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewAnalyticsInclude<ExtArgs> | null
    /**
     * Filter which InterviewAnalytics to delete.
     */
    where: InterviewAnalyticsWhereUniqueInput
  }

  /**
   * InterviewAnalytics deleteMany
   */
  export type InterviewAnalyticsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InterviewAnalytics to delete
     */
    where?: InterviewAnalyticsWhereInput
  }

  /**
   * InterviewAnalytics without action
   */
  export type InterviewAnalyticsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterviewAnalytics
     */
    select?: InterviewAnalyticsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterviewAnalyticsInclude<ExtArgs> | null
  }


  /**
   * Model Roadmap
   */

  export type AggregateRoadmap = {
    _count: RoadmapCountAggregateOutputType | null
    _avg: RoadmapAvgAggregateOutputType | null
    _sum: RoadmapSumAggregateOutputType | null
    _min: RoadmapMinAggregateOutputType | null
    _max: RoadmapMaxAggregateOutputType | null
  }

  export type RoadmapAvgAggregateOutputType = {
    popularity: number | null
    order: number | null
  }

  export type RoadmapSumAggregateOutputType = {
    popularity: number | null
    order: number | null
  }

  export type RoadmapMinAggregateOutputType = {
    id: string | null
    slug: string | null
    title: string | null
    description: string | null
    icon: string | null
    level: string | null
    duration: string | null
    gradient: string | null
    popularity: number | null
    isActive: boolean | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoadmapMaxAggregateOutputType = {
    id: string | null
    slug: string | null
    title: string | null
    description: string | null
    icon: string | null
    level: string | null
    duration: string | null
    gradient: string | null
    popularity: number | null
    isActive: boolean | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoadmapCountAggregateOutputType = {
    id: number
    slug: number
    title: number
    description: number
    icon: number
    level: number
    duration: number
    gradient: number
    skills: number
    popularity: number
    isActive: number
    order: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RoadmapAvgAggregateInputType = {
    popularity?: true
    order?: true
  }

  export type RoadmapSumAggregateInputType = {
    popularity?: true
    order?: true
  }

  export type RoadmapMinAggregateInputType = {
    id?: true
    slug?: true
    title?: true
    description?: true
    icon?: true
    level?: true
    duration?: true
    gradient?: true
    popularity?: true
    isActive?: true
    order?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoadmapMaxAggregateInputType = {
    id?: true
    slug?: true
    title?: true
    description?: true
    icon?: true
    level?: true
    duration?: true
    gradient?: true
    popularity?: true
    isActive?: true
    order?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoadmapCountAggregateInputType = {
    id?: true
    slug?: true
    title?: true
    description?: true
    icon?: true
    level?: true
    duration?: true
    gradient?: true
    skills?: true
    popularity?: true
    isActive?: true
    order?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RoadmapAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roadmap to aggregate.
     */
    where?: RoadmapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roadmaps to fetch.
     */
    orderBy?: RoadmapOrderByWithRelationInput | RoadmapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoadmapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roadmaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roadmaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roadmaps
    **/
    _count?: true | RoadmapCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoadmapAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoadmapSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoadmapMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoadmapMaxAggregateInputType
  }

  export type GetRoadmapAggregateType<T extends RoadmapAggregateArgs> = {
        [P in keyof T & keyof AggregateRoadmap]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoadmap[P]>
      : GetScalarType<T[P], AggregateRoadmap[P]>
  }




  export type RoadmapGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoadmapWhereInput
    orderBy?: RoadmapOrderByWithAggregationInput | RoadmapOrderByWithAggregationInput[]
    by: RoadmapScalarFieldEnum[] | RoadmapScalarFieldEnum
    having?: RoadmapScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoadmapCountAggregateInputType | true
    _avg?: RoadmapAvgAggregateInputType
    _sum?: RoadmapSumAggregateInputType
    _min?: RoadmapMinAggregateInputType
    _max?: RoadmapMaxAggregateInputType
  }

  export type RoadmapGroupByOutputType = {
    id: string
    slug: string
    title: string
    description: string
    icon: string
    level: string
    duration: string
    gradient: string
    skills: string[]
    popularity: number
    isActive: boolean
    order: number
    createdAt: Date
    updatedAt: Date
    _count: RoadmapCountAggregateOutputType | null
    _avg: RoadmapAvgAggregateOutputType | null
    _sum: RoadmapSumAggregateOutputType | null
    _min: RoadmapMinAggregateOutputType | null
    _max: RoadmapMaxAggregateOutputType | null
  }

  type GetRoadmapGroupByPayload<T extends RoadmapGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoadmapGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoadmapGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoadmapGroupByOutputType[P]>
            : GetScalarType<T[P], RoadmapGroupByOutputType[P]>
        }
      >
    >


  export type RoadmapSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    title?: boolean
    description?: boolean
    icon?: boolean
    level?: boolean
    duration?: boolean
    gradient?: boolean
    skills?: boolean
    popularity?: boolean
    isActive?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    phases?: boolean | Roadmap$phasesArgs<ExtArgs>
    progress?: boolean | Roadmap$progressArgs<ExtArgs>
    _count?: boolean | RoadmapCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roadmap"]>

  export type RoadmapSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    title?: boolean
    description?: boolean
    icon?: boolean
    level?: boolean
    duration?: boolean
    gradient?: boolean
    skills?: boolean
    popularity?: boolean
    isActive?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["roadmap"]>

  export type RoadmapSelectScalar = {
    id?: boolean
    slug?: boolean
    title?: boolean
    description?: boolean
    icon?: boolean
    level?: boolean
    duration?: boolean
    gradient?: boolean
    skills?: boolean
    popularity?: boolean
    isActive?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RoadmapInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    phases?: boolean | Roadmap$phasesArgs<ExtArgs>
    progress?: boolean | Roadmap$progressArgs<ExtArgs>
    _count?: boolean | RoadmapCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RoadmapIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RoadmapPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Roadmap"
    objects: {
      phases: Prisma.$RoadmapPhasePayload<ExtArgs>[]
      progress: Prisma.$RoadmapProgressPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      slug: string
      title: string
      description: string
      icon: string
      level: string
      duration: string
      gradient: string
      skills: string[]
      popularity: number
      isActive: boolean
      order: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["roadmap"]>
    composites: {}
  }

  type RoadmapGetPayload<S extends boolean | null | undefined | RoadmapDefaultArgs> = $Result.GetResult<Prisma.$RoadmapPayload, S>

  type RoadmapCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RoadmapFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RoadmapCountAggregateInputType | true
    }

  export interface RoadmapDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Roadmap'], meta: { name: 'Roadmap' } }
    /**
     * Find zero or one Roadmap that matches the filter.
     * @param {RoadmapFindUniqueArgs} args - Arguments to find a Roadmap
     * @example
     * // Get one Roadmap
     * const roadmap = await prisma.roadmap.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoadmapFindUniqueArgs>(args: SelectSubset<T, RoadmapFindUniqueArgs<ExtArgs>>): Prisma__RoadmapClient<$Result.GetResult<Prisma.$RoadmapPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Roadmap that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RoadmapFindUniqueOrThrowArgs} args - Arguments to find a Roadmap
     * @example
     * // Get one Roadmap
     * const roadmap = await prisma.roadmap.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoadmapFindUniqueOrThrowArgs>(args: SelectSubset<T, RoadmapFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoadmapClient<$Result.GetResult<Prisma.$RoadmapPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Roadmap that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapFindFirstArgs} args - Arguments to find a Roadmap
     * @example
     * // Get one Roadmap
     * const roadmap = await prisma.roadmap.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoadmapFindFirstArgs>(args?: SelectSubset<T, RoadmapFindFirstArgs<ExtArgs>>): Prisma__RoadmapClient<$Result.GetResult<Prisma.$RoadmapPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Roadmap that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapFindFirstOrThrowArgs} args - Arguments to find a Roadmap
     * @example
     * // Get one Roadmap
     * const roadmap = await prisma.roadmap.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoadmapFindFirstOrThrowArgs>(args?: SelectSubset<T, RoadmapFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoadmapClient<$Result.GetResult<Prisma.$RoadmapPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Roadmaps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roadmaps
     * const roadmaps = await prisma.roadmap.findMany()
     * 
     * // Get first 10 Roadmaps
     * const roadmaps = await prisma.roadmap.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roadmapWithIdOnly = await prisma.roadmap.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoadmapFindManyArgs>(args?: SelectSubset<T, RoadmapFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoadmapPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Roadmap.
     * @param {RoadmapCreateArgs} args - Arguments to create a Roadmap.
     * @example
     * // Create one Roadmap
     * const Roadmap = await prisma.roadmap.create({
     *   data: {
     *     // ... data to create a Roadmap
     *   }
     * })
     * 
     */
    create<T extends RoadmapCreateArgs>(args: SelectSubset<T, RoadmapCreateArgs<ExtArgs>>): Prisma__RoadmapClient<$Result.GetResult<Prisma.$RoadmapPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Roadmaps.
     * @param {RoadmapCreateManyArgs} args - Arguments to create many Roadmaps.
     * @example
     * // Create many Roadmaps
     * const roadmap = await prisma.roadmap.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoadmapCreateManyArgs>(args?: SelectSubset<T, RoadmapCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Roadmaps and returns the data saved in the database.
     * @param {RoadmapCreateManyAndReturnArgs} args - Arguments to create many Roadmaps.
     * @example
     * // Create many Roadmaps
     * const roadmap = await prisma.roadmap.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Roadmaps and only return the `id`
     * const roadmapWithIdOnly = await prisma.roadmap.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoadmapCreateManyAndReturnArgs>(args?: SelectSubset<T, RoadmapCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoadmapPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Roadmap.
     * @param {RoadmapDeleteArgs} args - Arguments to delete one Roadmap.
     * @example
     * // Delete one Roadmap
     * const Roadmap = await prisma.roadmap.delete({
     *   where: {
     *     // ... filter to delete one Roadmap
     *   }
     * })
     * 
     */
    delete<T extends RoadmapDeleteArgs>(args: SelectSubset<T, RoadmapDeleteArgs<ExtArgs>>): Prisma__RoadmapClient<$Result.GetResult<Prisma.$RoadmapPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Roadmap.
     * @param {RoadmapUpdateArgs} args - Arguments to update one Roadmap.
     * @example
     * // Update one Roadmap
     * const roadmap = await prisma.roadmap.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoadmapUpdateArgs>(args: SelectSubset<T, RoadmapUpdateArgs<ExtArgs>>): Prisma__RoadmapClient<$Result.GetResult<Prisma.$RoadmapPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Roadmaps.
     * @param {RoadmapDeleteManyArgs} args - Arguments to filter Roadmaps to delete.
     * @example
     * // Delete a few Roadmaps
     * const { count } = await prisma.roadmap.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoadmapDeleteManyArgs>(args?: SelectSubset<T, RoadmapDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roadmaps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roadmaps
     * const roadmap = await prisma.roadmap.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoadmapUpdateManyArgs>(args: SelectSubset<T, RoadmapUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Roadmap.
     * @param {RoadmapUpsertArgs} args - Arguments to update or create a Roadmap.
     * @example
     * // Update or create a Roadmap
     * const roadmap = await prisma.roadmap.upsert({
     *   create: {
     *     // ... data to create a Roadmap
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Roadmap we want to update
     *   }
     * })
     */
    upsert<T extends RoadmapUpsertArgs>(args: SelectSubset<T, RoadmapUpsertArgs<ExtArgs>>): Prisma__RoadmapClient<$Result.GetResult<Prisma.$RoadmapPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Roadmaps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapCountArgs} args - Arguments to filter Roadmaps to count.
     * @example
     * // Count the number of Roadmaps
     * const count = await prisma.roadmap.count({
     *   where: {
     *     // ... the filter for the Roadmaps we want to count
     *   }
     * })
    **/
    count<T extends RoadmapCountArgs>(
      args?: Subset<T, RoadmapCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoadmapCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Roadmap.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoadmapAggregateArgs>(args: Subset<T, RoadmapAggregateArgs>): Prisma.PrismaPromise<GetRoadmapAggregateType<T>>

    /**
     * Group by Roadmap.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoadmapGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoadmapGroupByArgs['orderBy'] }
        : { orderBy?: RoadmapGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoadmapGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoadmapGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Roadmap model
   */
  readonly fields: RoadmapFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Roadmap.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoadmapClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    phases<T extends Roadmap$phasesArgs<ExtArgs> = {}>(args?: Subset<T, Roadmap$phasesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoadmapPhasePayload<ExtArgs>, T, "findMany"> | Null>
    progress<T extends Roadmap$progressArgs<ExtArgs> = {}>(args?: Subset<T, Roadmap$progressArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoadmapProgressPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Roadmap model
   */ 
  interface RoadmapFieldRefs {
    readonly id: FieldRef<"Roadmap", 'String'>
    readonly slug: FieldRef<"Roadmap", 'String'>
    readonly title: FieldRef<"Roadmap", 'String'>
    readonly description: FieldRef<"Roadmap", 'String'>
    readonly icon: FieldRef<"Roadmap", 'String'>
    readonly level: FieldRef<"Roadmap", 'String'>
    readonly duration: FieldRef<"Roadmap", 'String'>
    readonly gradient: FieldRef<"Roadmap", 'String'>
    readonly skills: FieldRef<"Roadmap", 'String[]'>
    readonly popularity: FieldRef<"Roadmap", 'Int'>
    readonly isActive: FieldRef<"Roadmap", 'Boolean'>
    readonly order: FieldRef<"Roadmap", 'Int'>
    readonly createdAt: FieldRef<"Roadmap", 'DateTime'>
    readonly updatedAt: FieldRef<"Roadmap", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Roadmap findUnique
   */
  export type RoadmapFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roadmap
     */
    select?: RoadmapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapInclude<ExtArgs> | null
    /**
     * Filter, which Roadmap to fetch.
     */
    where: RoadmapWhereUniqueInput
  }

  /**
   * Roadmap findUniqueOrThrow
   */
  export type RoadmapFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roadmap
     */
    select?: RoadmapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapInclude<ExtArgs> | null
    /**
     * Filter, which Roadmap to fetch.
     */
    where: RoadmapWhereUniqueInput
  }

  /**
   * Roadmap findFirst
   */
  export type RoadmapFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roadmap
     */
    select?: RoadmapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapInclude<ExtArgs> | null
    /**
     * Filter, which Roadmap to fetch.
     */
    where?: RoadmapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roadmaps to fetch.
     */
    orderBy?: RoadmapOrderByWithRelationInput | RoadmapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roadmaps.
     */
    cursor?: RoadmapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roadmaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roadmaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roadmaps.
     */
    distinct?: RoadmapScalarFieldEnum | RoadmapScalarFieldEnum[]
  }

  /**
   * Roadmap findFirstOrThrow
   */
  export type RoadmapFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roadmap
     */
    select?: RoadmapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapInclude<ExtArgs> | null
    /**
     * Filter, which Roadmap to fetch.
     */
    where?: RoadmapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roadmaps to fetch.
     */
    orderBy?: RoadmapOrderByWithRelationInput | RoadmapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roadmaps.
     */
    cursor?: RoadmapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roadmaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roadmaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roadmaps.
     */
    distinct?: RoadmapScalarFieldEnum | RoadmapScalarFieldEnum[]
  }

  /**
   * Roadmap findMany
   */
  export type RoadmapFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roadmap
     */
    select?: RoadmapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapInclude<ExtArgs> | null
    /**
     * Filter, which Roadmaps to fetch.
     */
    where?: RoadmapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roadmaps to fetch.
     */
    orderBy?: RoadmapOrderByWithRelationInput | RoadmapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roadmaps.
     */
    cursor?: RoadmapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roadmaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roadmaps.
     */
    skip?: number
    distinct?: RoadmapScalarFieldEnum | RoadmapScalarFieldEnum[]
  }

  /**
   * Roadmap create
   */
  export type RoadmapCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roadmap
     */
    select?: RoadmapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapInclude<ExtArgs> | null
    /**
     * The data needed to create a Roadmap.
     */
    data: XOR<RoadmapCreateInput, RoadmapUncheckedCreateInput>
  }

  /**
   * Roadmap createMany
   */
  export type RoadmapCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Roadmaps.
     */
    data: RoadmapCreateManyInput | RoadmapCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Roadmap createManyAndReturn
   */
  export type RoadmapCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roadmap
     */
    select?: RoadmapSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Roadmaps.
     */
    data: RoadmapCreateManyInput | RoadmapCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Roadmap update
   */
  export type RoadmapUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roadmap
     */
    select?: RoadmapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapInclude<ExtArgs> | null
    /**
     * The data needed to update a Roadmap.
     */
    data: XOR<RoadmapUpdateInput, RoadmapUncheckedUpdateInput>
    /**
     * Choose, which Roadmap to update.
     */
    where: RoadmapWhereUniqueInput
  }

  /**
   * Roadmap updateMany
   */
  export type RoadmapUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Roadmaps.
     */
    data: XOR<RoadmapUpdateManyMutationInput, RoadmapUncheckedUpdateManyInput>
    /**
     * Filter which Roadmaps to update
     */
    where?: RoadmapWhereInput
  }

  /**
   * Roadmap upsert
   */
  export type RoadmapUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roadmap
     */
    select?: RoadmapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapInclude<ExtArgs> | null
    /**
     * The filter to search for the Roadmap to update in case it exists.
     */
    where: RoadmapWhereUniqueInput
    /**
     * In case the Roadmap found by the `where` argument doesn't exist, create a new Roadmap with this data.
     */
    create: XOR<RoadmapCreateInput, RoadmapUncheckedCreateInput>
    /**
     * In case the Roadmap was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoadmapUpdateInput, RoadmapUncheckedUpdateInput>
  }

  /**
   * Roadmap delete
   */
  export type RoadmapDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roadmap
     */
    select?: RoadmapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapInclude<ExtArgs> | null
    /**
     * Filter which Roadmap to delete.
     */
    where: RoadmapWhereUniqueInput
  }

  /**
   * Roadmap deleteMany
   */
  export type RoadmapDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roadmaps to delete
     */
    where?: RoadmapWhereInput
  }

  /**
   * Roadmap.phases
   */
  export type Roadmap$phasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapPhase
     */
    select?: RoadmapPhaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapPhaseInclude<ExtArgs> | null
    where?: RoadmapPhaseWhereInput
    orderBy?: RoadmapPhaseOrderByWithRelationInput | RoadmapPhaseOrderByWithRelationInput[]
    cursor?: RoadmapPhaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoadmapPhaseScalarFieldEnum | RoadmapPhaseScalarFieldEnum[]
  }

  /**
   * Roadmap.progress
   */
  export type Roadmap$progressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapProgress
     */
    select?: RoadmapProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapProgressInclude<ExtArgs> | null
    where?: RoadmapProgressWhereInput
    orderBy?: RoadmapProgressOrderByWithRelationInput | RoadmapProgressOrderByWithRelationInput[]
    cursor?: RoadmapProgressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoadmapProgressScalarFieldEnum | RoadmapProgressScalarFieldEnum[]
  }

  /**
   * Roadmap without action
   */
  export type RoadmapDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roadmap
     */
    select?: RoadmapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapInclude<ExtArgs> | null
  }


  /**
   * Model RoadmapPhase
   */

  export type AggregateRoadmapPhase = {
    _count: RoadmapPhaseCountAggregateOutputType | null
    _avg: RoadmapPhaseAvgAggregateOutputType | null
    _sum: RoadmapPhaseSumAggregateOutputType | null
    _min: RoadmapPhaseMinAggregateOutputType | null
    _max: RoadmapPhaseMaxAggregateOutputType | null
  }

  export type RoadmapPhaseAvgAggregateOutputType = {
    order: number | null
  }

  export type RoadmapPhaseSumAggregateOutputType = {
    order: number | null
  }

  export type RoadmapPhaseMinAggregateOutputType = {
    id: string | null
    roadmapId: string | null
    title: string | null
    description: string | null
    order: number | null
  }

  export type RoadmapPhaseMaxAggregateOutputType = {
    id: string | null
    roadmapId: string | null
    title: string | null
    description: string | null
    order: number | null
  }

  export type RoadmapPhaseCountAggregateOutputType = {
    id: number
    roadmapId: number
    title: number
    description: number
    order: number
    _all: number
  }


  export type RoadmapPhaseAvgAggregateInputType = {
    order?: true
  }

  export type RoadmapPhaseSumAggregateInputType = {
    order?: true
  }

  export type RoadmapPhaseMinAggregateInputType = {
    id?: true
    roadmapId?: true
    title?: true
    description?: true
    order?: true
  }

  export type RoadmapPhaseMaxAggregateInputType = {
    id?: true
    roadmapId?: true
    title?: true
    description?: true
    order?: true
  }

  export type RoadmapPhaseCountAggregateInputType = {
    id?: true
    roadmapId?: true
    title?: true
    description?: true
    order?: true
    _all?: true
  }

  export type RoadmapPhaseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoadmapPhase to aggregate.
     */
    where?: RoadmapPhaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoadmapPhases to fetch.
     */
    orderBy?: RoadmapPhaseOrderByWithRelationInput | RoadmapPhaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoadmapPhaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoadmapPhases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoadmapPhases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RoadmapPhases
    **/
    _count?: true | RoadmapPhaseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoadmapPhaseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoadmapPhaseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoadmapPhaseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoadmapPhaseMaxAggregateInputType
  }

  export type GetRoadmapPhaseAggregateType<T extends RoadmapPhaseAggregateArgs> = {
        [P in keyof T & keyof AggregateRoadmapPhase]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoadmapPhase[P]>
      : GetScalarType<T[P], AggregateRoadmapPhase[P]>
  }




  export type RoadmapPhaseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoadmapPhaseWhereInput
    orderBy?: RoadmapPhaseOrderByWithAggregationInput | RoadmapPhaseOrderByWithAggregationInput[]
    by: RoadmapPhaseScalarFieldEnum[] | RoadmapPhaseScalarFieldEnum
    having?: RoadmapPhaseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoadmapPhaseCountAggregateInputType | true
    _avg?: RoadmapPhaseAvgAggregateInputType
    _sum?: RoadmapPhaseSumAggregateInputType
    _min?: RoadmapPhaseMinAggregateInputType
    _max?: RoadmapPhaseMaxAggregateInputType
  }

  export type RoadmapPhaseGroupByOutputType = {
    id: string
    roadmapId: string
    title: string
    description: string
    order: number
    _count: RoadmapPhaseCountAggregateOutputType | null
    _avg: RoadmapPhaseAvgAggregateOutputType | null
    _sum: RoadmapPhaseSumAggregateOutputType | null
    _min: RoadmapPhaseMinAggregateOutputType | null
    _max: RoadmapPhaseMaxAggregateOutputType | null
  }

  type GetRoadmapPhaseGroupByPayload<T extends RoadmapPhaseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoadmapPhaseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoadmapPhaseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoadmapPhaseGroupByOutputType[P]>
            : GetScalarType<T[P], RoadmapPhaseGroupByOutputType[P]>
        }
      >
    >


  export type RoadmapPhaseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roadmapId?: boolean
    title?: boolean
    description?: boolean
    order?: boolean
    roadmap?: boolean | RoadmapDefaultArgs<ExtArgs>
    steps?: boolean | RoadmapPhase$stepsArgs<ExtArgs>
    _count?: boolean | RoadmapPhaseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roadmapPhase"]>

  export type RoadmapPhaseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roadmapId?: boolean
    title?: boolean
    description?: boolean
    order?: boolean
    roadmap?: boolean | RoadmapDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roadmapPhase"]>

  export type RoadmapPhaseSelectScalar = {
    id?: boolean
    roadmapId?: boolean
    title?: boolean
    description?: boolean
    order?: boolean
  }

  export type RoadmapPhaseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roadmap?: boolean | RoadmapDefaultArgs<ExtArgs>
    steps?: boolean | RoadmapPhase$stepsArgs<ExtArgs>
    _count?: boolean | RoadmapPhaseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RoadmapPhaseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roadmap?: boolean | RoadmapDefaultArgs<ExtArgs>
  }

  export type $RoadmapPhasePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RoadmapPhase"
    objects: {
      roadmap: Prisma.$RoadmapPayload<ExtArgs>
      steps: Prisma.$RoadmapStepPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      roadmapId: string
      title: string
      description: string
      order: number
    }, ExtArgs["result"]["roadmapPhase"]>
    composites: {}
  }

  type RoadmapPhaseGetPayload<S extends boolean | null | undefined | RoadmapPhaseDefaultArgs> = $Result.GetResult<Prisma.$RoadmapPhasePayload, S>

  type RoadmapPhaseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RoadmapPhaseFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RoadmapPhaseCountAggregateInputType | true
    }

  export interface RoadmapPhaseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RoadmapPhase'], meta: { name: 'RoadmapPhase' } }
    /**
     * Find zero or one RoadmapPhase that matches the filter.
     * @param {RoadmapPhaseFindUniqueArgs} args - Arguments to find a RoadmapPhase
     * @example
     * // Get one RoadmapPhase
     * const roadmapPhase = await prisma.roadmapPhase.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoadmapPhaseFindUniqueArgs>(args: SelectSubset<T, RoadmapPhaseFindUniqueArgs<ExtArgs>>): Prisma__RoadmapPhaseClient<$Result.GetResult<Prisma.$RoadmapPhasePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RoadmapPhase that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RoadmapPhaseFindUniqueOrThrowArgs} args - Arguments to find a RoadmapPhase
     * @example
     * // Get one RoadmapPhase
     * const roadmapPhase = await prisma.roadmapPhase.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoadmapPhaseFindUniqueOrThrowArgs>(args: SelectSubset<T, RoadmapPhaseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoadmapPhaseClient<$Result.GetResult<Prisma.$RoadmapPhasePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RoadmapPhase that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapPhaseFindFirstArgs} args - Arguments to find a RoadmapPhase
     * @example
     * // Get one RoadmapPhase
     * const roadmapPhase = await prisma.roadmapPhase.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoadmapPhaseFindFirstArgs>(args?: SelectSubset<T, RoadmapPhaseFindFirstArgs<ExtArgs>>): Prisma__RoadmapPhaseClient<$Result.GetResult<Prisma.$RoadmapPhasePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RoadmapPhase that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapPhaseFindFirstOrThrowArgs} args - Arguments to find a RoadmapPhase
     * @example
     * // Get one RoadmapPhase
     * const roadmapPhase = await prisma.roadmapPhase.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoadmapPhaseFindFirstOrThrowArgs>(args?: SelectSubset<T, RoadmapPhaseFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoadmapPhaseClient<$Result.GetResult<Prisma.$RoadmapPhasePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RoadmapPhases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapPhaseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RoadmapPhases
     * const roadmapPhases = await prisma.roadmapPhase.findMany()
     * 
     * // Get first 10 RoadmapPhases
     * const roadmapPhases = await prisma.roadmapPhase.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roadmapPhaseWithIdOnly = await prisma.roadmapPhase.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoadmapPhaseFindManyArgs>(args?: SelectSubset<T, RoadmapPhaseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoadmapPhasePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RoadmapPhase.
     * @param {RoadmapPhaseCreateArgs} args - Arguments to create a RoadmapPhase.
     * @example
     * // Create one RoadmapPhase
     * const RoadmapPhase = await prisma.roadmapPhase.create({
     *   data: {
     *     // ... data to create a RoadmapPhase
     *   }
     * })
     * 
     */
    create<T extends RoadmapPhaseCreateArgs>(args: SelectSubset<T, RoadmapPhaseCreateArgs<ExtArgs>>): Prisma__RoadmapPhaseClient<$Result.GetResult<Prisma.$RoadmapPhasePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RoadmapPhases.
     * @param {RoadmapPhaseCreateManyArgs} args - Arguments to create many RoadmapPhases.
     * @example
     * // Create many RoadmapPhases
     * const roadmapPhase = await prisma.roadmapPhase.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoadmapPhaseCreateManyArgs>(args?: SelectSubset<T, RoadmapPhaseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RoadmapPhases and returns the data saved in the database.
     * @param {RoadmapPhaseCreateManyAndReturnArgs} args - Arguments to create many RoadmapPhases.
     * @example
     * // Create many RoadmapPhases
     * const roadmapPhase = await prisma.roadmapPhase.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RoadmapPhases and only return the `id`
     * const roadmapPhaseWithIdOnly = await prisma.roadmapPhase.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoadmapPhaseCreateManyAndReturnArgs>(args?: SelectSubset<T, RoadmapPhaseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoadmapPhasePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RoadmapPhase.
     * @param {RoadmapPhaseDeleteArgs} args - Arguments to delete one RoadmapPhase.
     * @example
     * // Delete one RoadmapPhase
     * const RoadmapPhase = await prisma.roadmapPhase.delete({
     *   where: {
     *     // ... filter to delete one RoadmapPhase
     *   }
     * })
     * 
     */
    delete<T extends RoadmapPhaseDeleteArgs>(args: SelectSubset<T, RoadmapPhaseDeleteArgs<ExtArgs>>): Prisma__RoadmapPhaseClient<$Result.GetResult<Prisma.$RoadmapPhasePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RoadmapPhase.
     * @param {RoadmapPhaseUpdateArgs} args - Arguments to update one RoadmapPhase.
     * @example
     * // Update one RoadmapPhase
     * const roadmapPhase = await prisma.roadmapPhase.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoadmapPhaseUpdateArgs>(args: SelectSubset<T, RoadmapPhaseUpdateArgs<ExtArgs>>): Prisma__RoadmapPhaseClient<$Result.GetResult<Prisma.$RoadmapPhasePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RoadmapPhases.
     * @param {RoadmapPhaseDeleteManyArgs} args - Arguments to filter RoadmapPhases to delete.
     * @example
     * // Delete a few RoadmapPhases
     * const { count } = await prisma.roadmapPhase.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoadmapPhaseDeleteManyArgs>(args?: SelectSubset<T, RoadmapPhaseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RoadmapPhases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapPhaseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RoadmapPhases
     * const roadmapPhase = await prisma.roadmapPhase.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoadmapPhaseUpdateManyArgs>(args: SelectSubset<T, RoadmapPhaseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RoadmapPhase.
     * @param {RoadmapPhaseUpsertArgs} args - Arguments to update or create a RoadmapPhase.
     * @example
     * // Update or create a RoadmapPhase
     * const roadmapPhase = await prisma.roadmapPhase.upsert({
     *   create: {
     *     // ... data to create a RoadmapPhase
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RoadmapPhase we want to update
     *   }
     * })
     */
    upsert<T extends RoadmapPhaseUpsertArgs>(args: SelectSubset<T, RoadmapPhaseUpsertArgs<ExtArgs>>): Prisma__RoadmapPhaseClient<$Result.GetResult<Prisma.$RoadmapPhasePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RoadmapPhases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapPhaseCountArgs} args - Arguments to filter RoadmapPhases to count.
     * @example
     * // Count the number of RoadmapPhases
     * const count = await prisma.roadmapPhase.count({
     *   where: {
     *     // ... the filter for the RoadmapPhases we want to count
     *   }
     * })
    **/
    count<T extends RoadmapPhaseCountArgs>(
      args?: Subset<T, RoadmapPhaseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoadmapPhaseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RoadmapPhase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapPhaseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoadmapPhaseAggregateArgs>(args: Subset<T, RoadmapPhaseAggregateArgs>): Prisma.PrismaPromise<GetRoadmapPhaseAggregateType<T>>

    /**
     * Group by RoadmapPhase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapPhaseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoadmapPhaseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoadmapPhaseGroupByArgs['orderBy'] }
        : { orderBy?: RoadmapPhaseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoadmapPhaseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoadmapPhaseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RoadmapPhase model
   */
  readonly fields: RoadmapPhaseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RoadmapPhase.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoadmapPhaseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    roadmap<T extends RoadmapDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoadmapDefaultArgs<ExtArgs>>): Prisma__RoadmapClient<$Result.GetResult<Prisma.$RoadmapPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    steps<T extends RoadmapPhase$stepsArgs<ExtArgs> = {}>(args?: Subset<T, RoadmapPhase$stepsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoadmapStepPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RoadmapPhase model
   */ 
  interface RoadmapPhaseFieldRefs {
    readonly id: FieldRef<"RoadmapPhase", 'String'>
    readonly roadmapId: FieldRef<"RoadmapPhase", 'String'>
    readonly title: FieldRef<"RoadmapPhase", 'String'>
    readonly description: FieldRef<"RoadmapPhase", 'String'>
    readonly order: FieldRef<"RoadmapPhase", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * RoadmapPhase findUnique
   */
  export type RoadmapPhaseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapPhase
     */
    select?: RoadmapPhaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapPhaseInclude<ExtArgs> | null
    /**
     * Filter, which RoadmapPhase to fetch.
     */
    where: RoadmapPhaseWhereUniqueInput
  }

  /**
   * RoadmapPhase findUniqueOrThrow
   */
  export type RoadmapPhaseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapPhase
     */
    select?: RoadmapPhaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapPhaseInclude<ExtArgs> | null
    /**
     * Filter, which RoadmapPhase to fetch.
     */
    where: RoadmapPhaseWhereUniqueInput
  }

  /**
   * RoadmapPhase findFirst
   */
  export type RoadmapPhaseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapPhase
     */
    select?: RoadmapPhaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapPhaseInclude<ExtArgs> | null
    /**
     * Filter, which RoadmapPhase to fetch.
     */
    where?: RoadmapPhaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoadmapPhases to fetch.
     */
    orderBy?: RoadmapPhaseOrderByWithRelationInput | RoadmapPhaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoadmapPhases.
     */
    cursor?: RoadmapPhaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoadmapPhases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoadmapPhases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoadmapPhases.
     */
    distinct?: RoadmapPhaseScalarFieldEnum | RoadmapPhaseScalarFieldEnum[]
  }

  /**
   * RoadmapPhase findFirstOrThrow
   */
  export type RoadmapPhaseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapPhase
     */
    select?: RoadmapPhaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapPhaseInclude<ExtArgs> | null
    /**
     * Filter, which RoadmapPhase to fetch.
     */
    where?: RoadmapPhaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoadmapPhases to fetch.
     */
    orderBy?: RoadmapPhaseOrderByWithRelationInput | RoadmapPhaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoadmapPhases.
     */
    cursor?: RoadmapPhaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoadmapPhases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoadmapPhases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoadmapPhases.
     */
    distinct?: RoadmapPhaseScalarFieldEnum | RoadmapPhaseScalarFieldEnum[]
  }

  /**
   * RoadmapPhase findMany
   */
  export type RoadmapPhaseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapPhase
     */
    select?: RoadmapPhaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapPhaseInclude<ExtArgs> | null
    /**
     * Filter, which RoadmapPhases to fetch.
     */
    where?: RoadmapPhaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoadmapPhases to fetch.
     */
    orderBy?: RoadmapPhaseOrderByWithRelationInput | RoadmapPhaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RoadmapPhases.
     */
    cursor?: RoadmapPhaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoadmapPhases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoadmapPhases.
     */
    skip?: number
    distinct?: RoadmapPhaseScalarFieldEnum | RoadmapPhaseScalarFieldEnum[]
  }

  /**
   * RoadmapPhase create
   */
  export type RoadmapPhaseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapPhase
     */
    select?: RoadmapPhaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapPhaseInclude<ExtArgs> | null
    /**
     * The data needed to create a RoadmapPhase.
     */
    data: XOR<RoadmapPhaseCreateInput, RoadmapPhaseUncheckedCreateInput>
  }

  /**
   * RoadmapPhase createMany
   */
  export type RoadmapPhaseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RoadmapPhases.
     */
    data: RoadmapPhaseCreateManyInput | RoadmapPhaseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RoadmapPhase createManyAndReturn
   */
  export type RoadmapPhaseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapPhase
     */
    select?: RoadmapPhaseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RoadmapPhases.
     */
    data: RoadmapPhaseCreateManyInput | RoadmapPhaseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapPhaseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RoadmapPhase update
   */
  export type RoadmapPhaseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapPhase
     */
    select?: RoadmapPhaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapPhaseInclude<ExtArgs> | null
    /**
     * The data needed to update a RoadmapPhase.
     */
    data: XOR<RoadmapPhaseUpdateInput, RoadmapPhaseUncheckedUpdateInput>
    /**
     * Choose, which RoadmapPhase to update.
     */
    where: RoadmapPhaseWhereUniqueInput
  }

  /**
   * RoadmapPhase updateMany
   */
  export type RoadmapPhaseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RoadmapPhases.
     */
    data: XOR<RoadmapPhaseUpdateManyMutationInput, RoadmapPhaseUncheckedUpdateManyInput>
    /**
     * Filter which RoadmapPhases to update
     */
    where?: RoadmapPhaseWhereInput
  }

  /**
   * RoadmapPhase upsert
   */
  export type RoadmapPhaseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapPhase
     */
    select?: RoadmapPhaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapPhaseInclude<ExtArgs> | null
    /**
     * The filter to search for the RoadmapPhase to update in case it exists.
     */
    where: RoadmapPhaseWhereUniqueInput
    /**
     * In case the RoadmapPhase found by the `where` argument doesn't exist, create a new RoadmapPhase with this data.
     */
    create: XOR<RoadmapPhaseCreateInput, RoadmapPhaseUncheckedCreateInput>
    /**
     * In case the RoadmapPhase was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoadmapPhaseUpdateInput, RoadmapPhaseUncheckedUpdateInput>
  }

  /**
   * RoadmapPhase delete
   */
  export type RoadmapPhaseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapPhase
     */
    select?: RoadmapPhaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapPhaseInclude<ExtArgs> | null
    /**
     * Filter which RoadmapPhase to delete.
     */
    where: RoadmapPhaseWhereUniqueInput
  }

  /**
   * RoadmapPhase deleteMany
   */
  export type RoadmapPhaseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoadmapPhases to delete
     */
    where?: RoadmapPhaseWhereInput
  }

  /**
   * RoadmapPhase.steps
   */
  export type RoadmapPhase$stepsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapStep
     */
    select?: RoadmapStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapStepInclude<ExtArgs> | null
    where?: RoadmapStepWhereInput
    orderBy?: RoadmapStepOrderByWithRelationInput | RoadmapStepOrderByWithRelationInput[]
    cursor?: RoadmapStepWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoadmapStepScalarFieldEnum | RoadmapStepScalarFieldEnum[]
  }

  /**
   * RoadmapPhase without action
   */
  export type RoadmapPhaseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapPhase
     */
    select?: RoadmapPhaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapPhaseInclude<ExtArgs> | null
  }


  /**
   * Model RoadmapStep
   */

  export type AggregateRoadmapStep = {
    _count: RoadmapStepCountAggregateOutputType | null
    _avg: RoadmapStepAvgAggregateOutputType | null
    _sum: RoadmapStepSumAggregateOutputType | null
    _min: RoadmapStepMinAggregateOutputType | null
    _max: RoadmapStepMaxAggregateOutputType | null
  }

  export type RoadmapStepAvgAggregateOutputType = {
    order: number | null
  }

  export type RoadmapStepSumAggregateOutputType = {
    order: number | null
  }

  export type RoadmapStepMinAggregateOutputType = {
    id: string | null
    phaseId: string | null
    title: string | null
    description: string | null
    difficulty: string | null
    estimatedTime: string | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoadmapStepMaxAggregateOutputType = {
    id: string | null
    phaseId: string | null
    title: string | null
    description: string | null
    difficulty: string | null
    estimatedTime: string | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoadmapStepCountAggregateOutputType = {
    id: number
    phaseId: number
    title: number
    description: number
    difficulty: number
    estimatedTime: number
    order: number
    topics: number
    prerequisites: number
    resources: number
    checkpoints: number
    relatedCheatsheets: number
    relatedDSA: number
    relatedInterviews: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RoadmapStepAvgAggregateInputType = {
    order?: true
  }

  export type RoadmapStepSumAggregateInputType = {
    order?: true
  }

  export type RoadmapStepMinAggregateInputType = {
    id?: true
    phaseId?: true
    title?: true
    description?: true
    difficulty?: true
    estimatedTime?: true
    order?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoadmapStepMaxAggregateInputType = {
    id?: true
    phaseId?: true
    title?: true
    description?: true
    difficulty?: true
    estimatedTime?: true
    order?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoadmapStepCountAggregateInputType = {
    id?: true
    phaseId?: true
    title?: true
    description?: true
    difficulty?: true
    estimatedTime?: true
    order?: true
    topics?: true
    prerequisites?: true
    resources?: true
    checkpoints?: true
    relatedCheatsheets?: true
    relatedDSA?: true
    relatedInterviews?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RoadmapStepAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoadmapStep to aggregate.
     */
    where?: RoadmapStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoadmapSteps to fetch.
     */
    orderBy?: RoadmapStepOrderByWithRelationInput | RoadmapStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoadmapStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoadmapSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoadmapSteps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RoadmapSteps
    **/
    _count?: true | RoadmapStepCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoadmapStepAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoadmapStepSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoadmapStepMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoadmapStepMaxAggregateInputType
  }

  export type GetRoadmapStepAggregateType<T extends RoadmapStepAggregateArgs> = {
        [P in keyof T & keyof AggregateRoadmapStep]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoadmapStep[P]>
      : GetScalarType<T[P], AggregateRoadmapStep[P]>
  }




  export type RoadmapStepGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoadmapStepWhereInput
    orderBy?: RoadmapStepOrderByWithAggregationInput | RoadmapStepOrderByWithAggregationInput[]
    by: RoadmapStepScalarFieldEnum[] | RoadmapStepScalarFieldEnum
    having?: RoadmapStepScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoadmapStepCountAggregateInputType | true
    _avg?: RoadmapStepAvgAggregateInputType
    _sum?: RoadmapStepSumAggregateInputType
    _min?: RoadmapStepMinAggregateInputType
    _max?: RoadmapStepMaxAggregateInputType
  }

  export type RoadmapStepGroupByOutputType = {
    id: string
    phaseId: string
    title: string
    description: string
    difficulty: string
    estimatedTime: string
    order: number
    topics: string[]
    prerequisites: string[]
    resources: JsonValue
    checkpoints: string[]
    relatedCheatsheets: string[]
    relatedDSA: string[]
    relatedInterviews: string[]
    createdAt: Date
    updatedAt: Date
    _count: RoadmapStepCountAggregateOutputType | null
    _avg: RoadmapStepAvgAggregateOutputType | null
    _sum: RoadmapStepSumAggregateOutputType | null
    _min: RoadmapStepMinAggregateOutputType | null
    _max: RoadmapStepMaxAggregateOutputType | null
  }

  type GetRoadmapStepGroupByPayload<T extends RoadmapStepGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoadmapStepGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoadmapStepGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoadmapStepGroupByOutputType[P]>
            : GetScalarType<T[P], RoadmapStepGroupByOutputType[P]>
        }
      >
    >


  export type RoadmapStepSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    phaseId?: boolean
    title?: boolean
    description?: boolean
    difficulty?: boolean
    estimatedTime?: boolean
    order?: boolean
    topics?: boolean
    prerequisites?: boolean
    resources?: boolean
    checkpoints?: boolean
    relatedCheatsheets?: boolean
    relatedDSA?: boolean
    relatedInterviews?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    phase?: boolean | RoadmapPhaseDefaultArgs<ExtArgs>
    progress?: boolean | RoadmapStep$progressArgs<ExtArgs>
    _count?: boolean | RoadmapStepCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roadmapStep"]>

  export type RoadmapStepSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    phaseId?: boolean
    title?: boolean
    description?: boolean
    difficulty?: boolean
    estimatedTime?: boolean
    order?: boolean
    topics?: boolean
    prerequisites?: boolean
    resources?: boolean
    checkpoints?: boolean
    relatedCheatsheets?: boolean
    relatedDSA?: boolean
    relatedInterviews?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    phase?: boolean | RoadmapPhaseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roadmapStep"]>

  export type RoadmapStepSelectScalar = {
    id?: boolean
    phaseId?: boolean
    title?: boolean
    description?: boolean
    difficulty?: boolean
    estimatedTime?: boolean
    order?: boolean
    topics?: boolean
    prerequisites?: boolean
    resources?: boolean
    checkpoints?: boolean
    relatedCheatsheets?: boolean
    relatedDSA?: boolean
    relatedInterviews?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RoadmapStepInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    phase?: boolean | RoadmapPhaseDefaultArgs<ExtArgs>
    progress?: boolean | RoadmapStep$progressArgs<ExtArgs>
    _count?: boolean | RoadmapStepCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RoadmapStepIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    phase?: boolean | RoadmapPhaseDefaultArgs<ExtArgs>
  }

  export type $RoadmapStepPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RoadmapStep"
    objects: {
      phase: Prisma.$RoadmapPhasePayload<ExtArgs>
      progress: Prisma.$RoadmapProgressPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      phaseId: string
      title: string
      description: string
      difficulty: string
      estimatedTime: string
      order: number
      topics: string[]
      prerequisites: string[]
      resources: Prisma.JsonValue
      checkpoints: string[]
      relatedCheatsheets: string[]
      relatedDSA: string[]
      relatedInterviews: string[]
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["roadmapStep"]>
    composites: {}
  }

  type RoadmapStepGetPayload<S extends boolean | null | undefined | RoadmapStepDefaultArgs> = $Result.GetResult<Prisma.$RoadmapStepPayload, S>

  type RoadmapStepCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RoadmapStepFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RoadmapStepCountAggregateInputType | true
    }

  export interface RoadmapStepDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RoadmapStep'], meta: { name: 'RoadmapStep' } }
    /**
     * Find zero or one RoadmapStep that matches the filter.
     * @param {RoadmapStepFindUniqueArgs} args - Arguments to find a RoadmapStep
     * @example
     * // Get one RoadmapStep
     * const roadmapStep = await prisma.roadmapStep.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoadmapStepFindUniqueArgs>(args: SelectSubset<T, RoadmapStepFindUniqueArgs<ExtArgs>>): Prisma__RoadmapStepClient<$Result.GetResult<Prisma.$RoadmapStepPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RoadmapStep that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RoadmapStepFindUniqueOrThrowArgs} args - Arguments to find a RoadmapStep
     * @example
     * // Get one RoadmapStep
     * const roadmapStep = await prisma.roadmapStep.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoadmapStepFindUniqueOrThrowArgs>(args: SelectSubset<T, RoadmapStepFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoadmapStepClient<$Result.GetResult<Prisma.$RoadmapStepPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RoadmapStep that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapStepFindFirstArgs} args - Arguments to find a RoadmapStep
     * @example
     * // Get one RoadmapStep
     * const roadmapStep = await prisma.roadmapStep.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoadmapStepFindFirstArgs>(args?: SelectSubset<T, RoadmapStepFindFirstArgs<ExtArgs>>): Prisma__RoadmapStepClient<$Result.GetResult<Prisma.$RoadmapStepPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RoadmapStep that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapStepFindFirstOrThrowArgs} args - Arguments to find a RoadmapStep
     * @example
     * // Get one RoadmapStep
     * const roadmapStep = await prisma.roadmapStep.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoadmapStepFindFirstOrThrowArgs>(args?: SelectSubset<T, RoadmapStepFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoadmapStepClient<$Result.GetResult<Prisma.$RoadmapStepPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RoadmapSteps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapStepFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RoadmapSteps
     * const roadmapSteps = await prisma.roadmapStep.findMany()
     * 
     * // Get first 10 RoadmapSteps
     * const roadmapSteps = await prisma.roadmapStep.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roadmapStepWithIdOnly = await prisma.roadmapStep.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoadmapStepFindManyArgs>(args?: SelectSubset<T, RoadmapStepFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoadmapStepPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RoadmapStep.
     * @param {RoadmapStepCreateArgs} args - Arguments to create a RoadmapStep.
     * @example
     * // Create one RoadmapStep
     * const RoadmapStep = await prisma.roadmapStep.create({
     *   data: {
     *     // ... data to create a RoadmapStep
     *   }
     * })
     * 
     */
    create<T extends RoadmapStepCreateArgs>(args: SelectSubset<T, RoadmapStepCreateArgs<ExtArgs>>): Prisma__RoadmapStepClient<$Result.GetResult<Prisma.$RoadmapStepPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RoadmapSteps.
     * @param {RoadmapStepCreateManyArgs} args - Arguments to create many RoadmapSteps.
     * @example
     * // Create many RoadmapSteps
     * const roadmapStep = await prisma.roadmapStep.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoadmapStepCreateManyArgs>(args?: SelectSubset<T, RoadmapStepCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RoadmapSteps and returns the data saved in the database.
     * @param {RoadmapStepCreateManyAndReturnArgs} args - Arguments to create many RoadmapSteps.
     * @example
     * // Create many RoadmapSteps
     * const roadmapStep = await prisma.roadmapStep.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RoadmapSteps and only return the `id`
     * const roadmapStepWithIdOnly = await prisma.roadmapStep.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoadmapStepCreateManyAndReturnArgs>(args?: SelectSubset<T, RoadmapStepCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoadmapStepPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RoadmapStep.
     * @param {RoadmapStepDeleteArgs} args - Arguments to delete one RoadmapStep.
     * @example
     * // Delete one RoadmapStep
     * const RoadmapStep = await prisma.roadmapStep.delete({
     *   where: {
     *     // ... filter to delete one RoadmapStep
     *   }
     * })
     * 
     */
    delete<T extends RoadmapStepDeleteArgs>(args: SelectSubset<T, RoadmapStepDeleteArgs<ExtArgs>>): Prisma__RoadmapStepClient<$Result.GetResult<Prisma.$RoadmapStepPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RoadmapStep.
     * @param {RoadmapStepUpdateArgs} args - Arguments to update one RoadmapStep.
     * @example
     * // Update one RoadmapStep
     * const roadmapStep = await prisma.roadmapStep.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoadmapStepUpdateArgs>(args: SelectSubset<T, RoadmapStepUpdateArgs<ExtArgs>>): Prisma__RoadmapStepClient<$Result.GetResult<Prisma.$RoadmapStepPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RoadmapSteps.
     * @param {RoadmapStepDeleteManyArgs} args - Arguments to filter RoadmapSteps to delete.
     * @example
     * // Delete a few RoadmapSteps
     * const { count } = await prisma.roadmapStep.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoadmapStepDeleteManyArgs>(args?: SelectSubset<T, RoadmapStepDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RoadmapSteps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapStepUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RoadmapSteps
     * const roadmapStep = await prisma.roadmapStep.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoadmapStepUpdateManyArgs>(args: SelectSubset<T, RoadmapStepUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RoadmapStep.
     * @param {RoadmapStepUpsertArgs} args - Arguments to update or create a RoadmapStep.
     * @example
     * // Update or create a RoadmapStep
     * const roadmapStep = await prisma.roadmapStep.upsert({
     *   create: {
     *     // ... data to create a RoadmapStep
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RoadmapStep we want to update
     *   }
     * })
     */
    upsert<T extends RoadmapStepUpsertArgs>(args: SelectSubset<T, RoadmapStepUpsertArgs<ExtArgs>>): Prisma__RoadmapStepClient<$Result.GetResult<Prisma.$RoadmapStepPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RoadmapSteps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapStepCountArgs} args - Arguments to filter RoadmapSteps to count.
     * @example
     * // Count the number of RoadmapSteps
     * const count = await prisma.roadmapStep.count({
     *   where: {
     *     // ... the filter for the RoadmapSteps we want to count
     *   }
     * })
    **/
    count<T extends RoadmapStepCountArgs>(
      args?: Subset<T, RoadmapStepCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoadmapStepCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RoadmapStep.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapStepAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoadmapStepAggregateArgs>(args: Subset<T, RoadmapStepAggregateArgs>): Prisma.PrismaPromise<GetRoadmapStepAggregateType<T>>

    /**
     * Group by RoadmapStep.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapStepGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoadmapStepGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoadmapStepGroupByArgs['orderBy'] }
        : { orderBy?: RoadmapStepGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoadmapStepGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoadmapStepGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RoadmapStep model
   */
  readonly fields: RoadmapStepFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RoadmapStep.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoadmapStepClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    phase<T extends RoadmapPhaseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoadmapPhaseDefaultArgs<ExtArgs>>): Prisma__RoadmapPhaseClient<$Result.GetResult<Prisma.$RoadmapPhasePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    progress<T extends RoadmapStep$progressArgs<ExtArgs> = {}>(args?: Subset<T, RoadmapStep$progressArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoadmapProgressPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RoadmapStep model
   */ 
  interface RoadmapStepFieldRefs {
    readonly id: FieldRef<"RoadmapStep", 'String'>
    readonly phaseId: FieldRef<"RoadmapStep", 'String'>
    readonly title: FieldRef<"RoadmapStep", 'String'>
    readonly description: FieldRef<"RoadmapStep", 'String'>
    readonly difficulty: FieldRef<"RoadmapStep", 'String'>
    readonly estimatedTime: FieldRef<"RoadmapStep", 'String'>
    readonly order: FieldRef<"RoadmapStep", 'Int'>
    readonly topics: FieldRef<"RoadmapStep", 'String[]'>
    readonly prerequisites: FieldRef<"RoadmapStep", 'String[]'>
    readonly resources: FieldRef<"RoadmapStep", 'Json'>
    readonly checkpoints: FieldRef<"RoadmapStep", 'String[]'>
    readonly relatedCheatsheets: FieldRef<"RoadmapStep", 'String[]'>
    readonly relatedDSA: FieldRef<"RoadmapStep", 'String[]'>
    readonly relatedInterviews: FieldRef<"RoadmapStep", 'String[]'>
    readonly createdAt: FieldRef<"RoadmapStep", 'DateTime'>
    readonly updatedAt: FieldRef<"RoadmapStep", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RoadmapStep findUnique
   */
  export type RoadmapStepFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapStep
     */
    select?: RoadmapStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapStepInclude<ExtArgs> | null
    /**
     * Filter, which RoadmapStep to fetch.
     */
    where: RoadmapStepWhereUniqueInput
  }

  /**
   * RoadmapStep findUniqueOrThrow
   */
  export type RoadmapStepFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapStep
     */
    select?: RoadmapStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapStepInclude<ExtArgs> | null
    /**
     * Filter, which RoadmapStep to fetch.
     */
    where: RoadmapStepWhereUniqueInput
  }

  /**
   * RoadmapStep findFirst
   */
  export type RoadmapStepFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapStep
     */
    select?: RoadmapStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapStepInclude<ExtArgs> | null
    /**
     * Filter, which RoadmapStep to fetch.
     */
    where?: RoadmapStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoadmapSteps to fetch.
     */
    orderBy?: RoadmapStepOrderByWithRelationInput | RoadmapStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoadmapSteps.
     */
    cursor?: RoadmapStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoadmapSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoadmapSteps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoadmapSteps.
     */
    distinct?: RoadmapStepScalarFieldEnum | RoadmapStepScalarFieldEnum[]
  }

  /**
   * RoadmapStep findFirstOrThrow
   */
  export type RoadmapStepFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapStep
     */
    select?: RoadmapStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapStepInclude<ExtArgs> | null
    /**
     * Filter, which RoadmapStep to fetch.
     */
    where?: RoadmapStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoadmapSteps to fetch.
     */
    orderBy?: RoadmapStepOrderByWithRelationInput | RoadmapStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoadmapSteps.
     */
    cursor?: RoadmapStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoadmapSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoadmapSteps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoadmapSteps.
     */
    distinct?: RoadmapStepScalarFieldEnum | RoadmapStepScalarFieldEnum[]
  }

  /**
   * RoadmapStep findMany
   */
  export type RoadmapStepFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapStep
     */
    select?: RoadmapStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapStepInclude<ExtArgs> | null
    /**
     * Filter, which RoadmapSteps to fetch.
     */
    where?: RoadmapStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoadmapSteps to fetch.
     */
    orderBy?: RoadmapStepOrderByWithRelationInput | RoadmapStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RoadmapSteps.
     */
    cursor?: RoadmapStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoadmapSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoadmapSteps.
     */
    skip?: number
    distinct?: RoadmapStepScalarFieldEnum | RoadmapStepScalarFieldEnum[]
  }

  /**
   * RoadmapStep create
   */
  export type RoadmapStepCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapStep
     */
    select?: RoadmapStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapStepInclude<ExtArgs> | null
    /**
     * The data needed to create a RoadmapStep.
     */
    data: XOR<RoadmapStepCreateInput, RoadmapStepUncheckedCreateInput>
  }

  /**
   * RoadmapStep createMany
   */
  export type RoadmapStepCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RoadmapSteps.
     */
    data: RoadmapStepCreateManyInput | RoadmapStepCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RoadmapStep createManyAndReturn
   */
  export type RoadmapStepCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapStep
     */
    select?: RoadmapStepSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RoadmapSteps.
     */
    data: RoadmapStepCreateManyInput | RoadmapStepCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapStepIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RoadmapStep update
   */
  export type RoadmapStepUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapStep
     */
    select?: RoadmapStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapStepInclude<ExtArgs> | null
    /**
     * The data needed to update a RoadmapStep.
     */
    data: XOR<RoadmapStepUpdateInput, RoadmapStepUncheckedUpdateInput>
    /**
     * Choose, which RoadmapStep to update.
     */
    where: RoadmapStepWhereUniqueInput
  }

  /**
   * RoadmapStep updateMany
   */
  export type RoadmapStepUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RoadmapSteps.
     */
    data: XOR<RoadmapStepUpdateManyMutationInput, RoadmapStepUncheckedUpdateManyInput>
    /**
     * Filter which RoadmapSteps to update
     */
    where?: RoadmapStepWhereInput
  }

  /**
   * RoadmapStep upsert
   */
  export type RoadmapStepUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapStep
     */
    select?: RoadmapStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapStepInclude<ExtArgs> | null
    /**
     * The filter to search for the RoadmapStep to update in case it exists.
     */
    where: RoadmapStepWhereUniqueInput
    /**
     * In case the RoadmapStep found by the `where` argument doesn't exist, create a new RoadmapStep with this data.
     */
    create: XOR<RoadmapStepCreateInput, RoadmapStepUncheckedCreateInput>
    /**
     * In case the RoadmapStep was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoadmapStepUpdateInput, RoadmapStepUncheckedUpdateInput>
  }

  /**
   * RoadmapStep delete
   */
  export type RoadmapStepDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapStep
     */
    select?: RoadmapStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapStepInclude<ExtArgs> | null
    /**
     * Filter which RoadmapStep to delete.
     */
    where: RoadmapStepWhereUniqueInput
  }

  /**
   * RoadmapStep deleteMany
   */
  export type RoadmapStepDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoadmapSteps to delete
     */
    where?: RoadmapStepWhereInput
  }

  /**
   * RoadmapStep.progress
   */
  export type RoadmapStep$progressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapProgress
     */
    select?: RoadmapProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapProgressInclude<ExtArgs> | null
    where?: RoadmapProgressWhereInput
    orderBy?: RoadmapProgressOrderByWithRelationInput | RoadmapProgressOrderByWithRelationInput[]
    cursor?: RoadmapProgressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoadmapProgressScalarFieldEnum | RoadmapProgressScalarFieldEnum[]
  }

  /**
   * RoadmapStep without action
   */
  export type RoadmapStepDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapStep
     */
    select?: RoadmapStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapStepInclude<ExtArgs> | null
  }


  /**
   * Model RoadmapProgress
   */

  export type AggregateRoadmapProgress = {
    _count: RoadmapProgressCountAggregateOutputType | null
    _min: RoadmapProgressMinAggregateOutputType | null
    _max: RoadmapProgressMaxAggregateOutputType | null
  }

  export type RoadmapProgressMinAggregateOutputType = {
    id: string | null
    userId: string | null
    roadmapId: string | null
    stepId: string | null
    completed: boolean | null
    notes: string | null
    completedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoadmapProgressMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    roadmapId: string | null
    stepId: string | null
    completed: boolean | null
    notes: string | null
    completedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoadmapProgressCountAggregateOutputType = {
    id: number
    userId: number
    roadmapId: number
    stepId: number
    completed: number
    notes: number
    completedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RoadmapProgressMinAggregateInputType = {
    id?: true
    userId?: true
    roadmapId?: true
    stepId?: true
    completed?: true
    notes?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoadmapProgressMaxAggregateInputType = {
    id?: true
    userId?: true
    roadmapId?: true
    stepId?: true
    completed?: true
    notes?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoadmapProgressCountAggregateInputType = {
    id?: true
    userId?: true
    roadmapId?: true
    stepId?: true
    completed?: true
    notes?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RoadmapProgressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoadmapProgress to aggregate.
     */
    where?: RoadmapProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoadmapProgresses to fetch.
     */
    orderBy?: RoadmapProgressOrderByWithRelationInput | RoadmapProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoadmapProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoadmapProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoadmapProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RoadmapProgresses
    **/
    _count?: true | RoadmapProgressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoadmapProgressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoadmapProgressMaxAggregateInputType
  }

  export type GetRoadmapProgressAggregateType<T extends RoadmapProgressAggregateArgs> = {
        [P in keyof T & keyof AggregateRoadmapProgress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoadmapProgress[P]>
      : GetScalarType<T[P], AggregateRoadmapProgress[P]>
  }




  export type RoadmapProgressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoadmapProgressWhereInput
    orderBy?: RoadmapProgressOrderByWithAggregationInput | RoadmapProgressOrderByWithAggregationInput[]
    by: RoadmapProgressScalarFieldEnum[] | RoadmapProgressScalarFieldEnum
    having?: RoadmapProgressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoadmapProgressCountAggregateInputType | true
    _min?: RoadmapProgressMinAggregateInputType
    _max?: RoadmapProgressMaxAggregateInputType
  }

  export type RoadmapProgressGroupByOutputType = {
    id: string
    userId: string
    roadmapId: string
    stepId: string
    completed: boolean
    notes: string | null
    completedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: RoadmapProgressCountAggregateOutputType | null
    _min: RoadmapProgressMinAggregateOutputType | null
    _max: RoadmapProgressMaxAggregateOutputType | null
  }

  type GetRoadmapProgressGroupByPayload<T extends RoadmapProgressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoadmapProgressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoadmapProgressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoadmapProgressGroupByOutputType[P]>
            : GetScalarType<T[P], RoadmapProgressGroupByOutputType[P]>
        }
      >
    >


  export type RoadmapProgressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    roadmapId?: boolean
    stepId?: boolean
    completed?: boolean
    notes?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    roadmap?: boolean | RoadmapDefaultArgs<ExtArgs>
    step?: boolean | RoadmapStepDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roadmapProgress"]>

  export type RoadmapProgressSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    roadmapId?: boolean
    stepId?: boolean
    completed?: boolean
    notes?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    roadmap?: boolean | RoadmapDefaultArgs<ExtArgs>
    step?: boolean | RoadmapStepDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roadmapProgress"]>

  export type RoadmapProgressSelectScalar = {
    id?: boolean
    userId?: boolean
    roadmapId?: boolean
    stepId?: boolean
    completed?: boolean
    notes?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RoadmapProgressInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roadmap?: boolean | RoadmapDefaultArgs<ExtArgs>
    step?: boolean | RoadmapStepDefaultArgs<ExtArgs>
  }
  export type RoadmapProgressIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roadmap?: boolean | RoadmapDefaultArgs<ExtArgs>
    step?: boolean | RoadmapStepDefaultArgs<ExtArgs>
  }

  export type $RoadmapProgressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RoadmapProgress"
    objects: {
      roadmap: Prisma.$RoadmapPayload<ExtArgs>
      step: Prisma.$RoadmapStepPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      roadmapId: string
      stepId: string
      completed: boolean
      notes: string | null
      completedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["roadmapProgress"]>
    composites: {}
  }

  type RoadmapProgressGetPayload<S extends boolean | null | undefined | RoadmapProgressDefaultArgs> = $Result.GetResult<Prisma.$RoadmapProgressPayload, S>

  type RoadmapProgressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RoadmapProgressFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RoadmapProgressCountAggregateInputType | true
    }

  export interface RoadmapProgressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RoadmapProgress'], meta: { name: 'RoadmapProgress' } }
    /**
     * Find zero or one RoadmapProgress that matches the filter.
     * @param {RoadmapProgressFindUniqueArgs} args - Arguments to find a RoadmapProgress
     * @example
     * // Get one RoadmapProgress
     * const roadmapProgress = await prisma.roadmapProgress.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoadmapProgressFindUniqueArgs>(args: SelectSubset<T, RoadmapProgressFindUniqueArgs<ExtArgs>>): Prisma__RoadmapProgressClient<$Result.GetResult<Prisma.$RoadmapProgressPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RoadmapProgress that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RoadmapProgressFindUniqueOrThrowArgs} args - Arguments to find a RoadmapProgress
     * @example
     * // Get one RoadmapProgress
     * const roadmapProgress = await prisma.roadmapProgress.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoadmapProgressFindUniqueOrThrowArgs>(args: SelectSubset<T, RoadmapProgressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoadmapProgressClient<$Result.GetResult<Prisma.$RoadmapProgressPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RoadmapProgress that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapProgressFindFirstArgs} args - Arguments to find a RoadmapProgress
     * @example
     * // Get one RoadmapProgress
     * const roadmapProgress = await prisma.roadmapProgress.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoadmapProgressFindFirstArgs>(args?: SelectSubset<T, RoadmapProgressFindFirstArgs<ExtArgs>>): Prisma__RoadmapProgressClient<$Result.GetResult<Prisma.$RoadmapProgressPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RoadmapProgress that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapProgressFindFirstOrThrowArgs} args - Arguments to find a RoadmapProgress
     * @example
     * // Get one RoadmapProgress
     * const roadmapProgress = await prisma.roadmapProgress.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoadmapProgressFindFirstOrThrowArgs>(args?: SelectSubset<T, RoadmapProgressFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoadmapProgressClient<$Result.GetResult<Prisma.$RoadmapProgressPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RoadmapProgresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapProgressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RoadmapProgresses
     * const roadmapProgresses = await prisma.roadmapProgress.findMany()
     * 
     * // Get first 10 RoadmapProgresses
     * const roadmapProgresses = await prisma.roadmapProgress.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roadmapProgressWithIdOnly = await prisma.roadmapProgress.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoadmapProgressFindManyArgs>(args?: SelectSubset<T, RoadmapProgressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoadmapProgressPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RoadmapProgress.
     * @param {RoadmapProgressCreateArgs} args - Arguments to create a RoadmapProgress.
     * @example
     * // Create one RoadmapProgress
     * const RoadmapProgress = await prisma.roadmapProgress.create({
     *   data: {
     *     // ... data to create a RoadmapProgress
     *   }
     * })
     * 
     */
    create<T extends RoadmapProgressCreateArgs>(args: SelectSubset<T, RoadmapProgressCreateArgs<ExtArgs>>): Prisma__RoadmapProgressClient<$Result.GetResult<Prisma.$RoadmapProgressPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RoadmapProgresses.
     * @param {RoadmapProgressCreateManyArgs} args - Arguments to create many RoadmapProgresses.
     * @example
     * // Create many RoadmapProgresses
     * const roadmapProgress = await prisma.roadmapProgress.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoadmapProgressCreateManyArgs>(args?: SelectSubset<T, RoadmapProgressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RoadmapProgresses and returns the data saved in the database.
     * @param {RoadmapProgressCreateManyAndReturnArgs} args - Arguments to create many RoadmapProgresses.
     * @example
     * // Create many RoadmapProgresses
     * const roadmapProgress = await prisma.roadmapProgress.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RoadmapProgresses and only return the `id`
     * const roadmapProgressWithIdOnly = await prisma.roadmapProgress.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoadmapProgressCreateManyAndReturnArgs>(args?: SelectSubset<T, RoadmapProgressCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoadmapProgressPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RoadmapProgress.
     * @param {RoadmapProgressDeleteArgs} args - Arguments to delete one RoadmapProgress.
     * @example
     * // Delete one RoadmapProgress
     * const RoadmapProgress = await prisma.roadmapProgress.delete({
     *   where: {
     *     // ... filter to delete one RoadmapProgress
     *   }
     * })
     * 
     */
    delete<T extends RoadmapProgressDeleteArgs>(args: SelectSubset<T, RoadmapProgressDeleteArgs<ExtArgs>>): Prisma__RoadmapProgressClient<$Result.GetResult<Prisma.$RoadmapProgressPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RoadmapProgress.
     * @param {RoadmapProgressUpdateArgs} args - Arguments to update one RoadmapProgress.
     * @example
     * // Update one RoadmapProgress
     * const roadmapProgress = await prisma.roadmapProgress.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoadmapProgressUpdateArgs>(args: SelectSubset<T, RoadmapProgressUpdateArgs<ExtArgs>>): Prisma__RoadmapProgressClient<$Result.GetResult<Prisma.$RoadmapProgressPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RoadmapProgresses.
     * @param {RoadmapProgressDeleteManyArgs} args - Arguments to filter RoadmapProgresses to delete.
     * @example
     * // Delete a few RoadmapProgresses
     * const { count } = await prisma.roadmapProgress.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoadmapProgressDeleteManyArgs>(args?: SelectSubset<T, RoadmapProgressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RoadmapProgresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapProgressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RoadmapProgresses
     * const roadmapProgress = await prisma.roadmapProgress.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoadmapProgressUpdateManyArgs>(args: SelectSubset<T, RoadmapProgressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RoadmapProgress.
     * @param {RoadmapProgressUpsertArgs} args - Arguments to update or create a RoadmapProgress.
     * @example
     * // Update or create a RoadmapProgress
     * const roadmapProgress = await prisma.roadmapProgress.upsert({
     *   create: {
     *     // ... data to create a RoadmapProgress
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RoadmapProgress we want to update
     *   }
     * })
     */
    upsert<T extends RoadmapProgressUpsertArgs>(args: SelectSubset<T, RoadmapProgressUpsertArgs<ExtArgs>>): Prisma__RoadmapProgressClient<$Result.GetResult<Prisma.$RoadmapProgressPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RoadmapProgresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapProgressCountArgs} args - Arguments to filter RoadmapProgresses to count.
     * @example
     * // Count the number of RoadmapProgresses
     * const count = await prisma.roadmapProgress.count({
     *   where: {
     *     // ... the filter for the RoadmapProgresses we want to count
     *   }
     * })
    **/
    count<T extends RoadmapProgressCountArgs>(
      args?: Subset<T, RoadmapProgressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoadmapProgressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RoadmapProgress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapProgressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoadmapProgressAggregateArgs>(args: Subset<T, RoadmapProgressAggregateArgs>): Prisma.PrismaPromise<GetRoadmapProgressAggregateType<T>>

    /**
     * Group by RoadmapProgress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapProgressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoadmapProgressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoadmapProgressGroupByArgs['orderBy'] }
        : { orderBy?: RoadmapProgressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoadmapProgressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoadmapProgressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RoadmapProgress model
   */
  readonly fields: RoadmapProgressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RoadmapProgress.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoadmapProgressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    roadmap<T extends RoadmapDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoadmapDefaultArgs<ExtArgs>>): Prisma__RoadmapClient<$Result.GetResult<Prisma.$RoadmapPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    step<T extends RoadmapStepDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoadmapStepDefaultArgs<ExtArgs>>): Prisma__RoadmapStepClient<$Result.GetResult<Prisma.$RoadmapStepPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RoadmapProgress model
   */ 
  interface RoadmapProgressFieldRefs {
    readonly id: FieldRef<"RoadmapProgress", 'String'>
    readonly userId: FieldRef<"RoadmapProgress", 'String'>
    readonly roadmapId: FieldRef<"RoadmapProgress", 'String'>
    readonly stepId: FieldRef<"RoadmapProgress", 'String'>
    readonly completed: FieldRef<"RoadmapProgress", 'Boolean'>
    readonly notes: FieldRef<"RoadmapProgress", 'String'>
    readonly completedAt: FieldRef<"RoadmapProgress", 'DateTime'>
    readonly createdAt: FieldRef<"RoadmapProgress", 'DateTime'>
    readonly updatedAt: FieldRef<"RoadmapProgress", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RoadmapProgress findUnique
   */
  export type RoadmapProgressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapProgress
     */
    select?: RoadmapProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapProgressInclude<ExtArgs> | null
    /**
     * Filter, which RoadmapProgress to fetch.
     */
    where: RoadmapProgressWhereUniqueInput
  }

  /**
   * RoadmapProgress findUniqueOrThrow
   */
  export type RoadmapProgressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapProgress
     */
    select?: RoadmapProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapProgressInclude<ExtArgs> | null
    /**
     * Filter, which RoadmapProgress to fetch.
     */
    where: RoadmapProgressWhereUniqueInput
  }

  /**
   * RoadmapProgress findFirst
   */
  export type RoadmapProgressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapProgress
     */
    select?: RoadmapProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapProgressInclude<ExtArgs> | null
    /**
     * Filter, which RoadmapProgress to fetch.
     */
    where?: RoadmapProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoadmapProgresses to fetch.
     */
    orderBy?: RoadmapProgressOrderByWithRelationInput | RoadmapProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoadmapProgresses.
     */
    cursor?: RoadmapProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoadmapProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoadmapProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoadmapProgresses.
     */
    distinct?: RoadmapProgressScalarFieldEnum | RoadmapProgressScalarFieldEnum[]
  }

  /**
   * RoadmapProgress findFirstOrThrow
   */
  export type RoadmapProgressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapProgress
     */
    select?: RoadmapProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapProgressInclude<ExtArgs> | null
    /**
     * Filter, which RoadmapProgress to fetch.
     */
    where?: RoadmapProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoadmapProgresses to fetch.
     */
    orderBy?: RoadmapProgressOrderByWithRelationInput | RoadmapProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoadmapProgresses.
     */
    cursor?: RoadmapProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoadmapProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoadmapProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoadmapProgresses.
     */
    distinct?: RoadmapProgressScalarFieldEnum | RoadmapProgressScalarFieldEnum[]
  }

  /**
   * RoadmapProgress findMany
   */
  export type RoadmapProgressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapProgress
     */
    select?: RoadmapProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapProgressInclude<ExtArgs> | null
    /**
     * Filter, which RoadmapProgresses to fetch.
     */
    where?: RoadmapProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoadmapProgresses to fetch.
     */
    orderBy?: RoadmapProgressOrderByWithRelationInput | RoadmapProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RoadmapProgresses.
     */
    cursor?: RoadmapProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoadmapProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoadmapProgresses.
     */
    skip?: number
    distinct?: RoadmapProgressScalarFieldEnum | RoadmapProgressScalarFieldEnum[]
  }

  /**
   * RoadmapProgress create
   */
  export type RoadmapProgressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapProgress
     */
    select?: RoadmapProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapProgressInclude<ExtArgs> | null
    /**
     * The data needed to create a RoadmapProgress.
     */
    data: XOR<RoadmapProgressCreateInput, RoadmapProgressUncheckedCreateInput>
  }

  /**
   * RoadmapProgress createMany
   */
  export type RoadmapProgressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RoadmapProgresses.
     */
    data: RoadmapProgressCreateManyInput | RoadmapProgressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RoadmapProgress createManyAndReturn
   */
  export type RoadmapProgressCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapProgress
     */
    select?: RoadmapProgressSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RoadmapProgresses.
     */
    data: RoadmapProgressCreateManyInput | RoadmapProgressCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapProgressIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RoadmapProgress update
   */
  export type RoadmapProgressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapProgress
     */
    select?: RoadmapProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapProgressInclude<ExtArgs> | null
    /**
     * The data needed to update a RoadmapProgress.
     */
    data: XOR<RoadmapProgressUpdateInput, RoadmapProgressUncheckedUpdateInput>
    /**
     * Choose, which RoadmapProgress to update.
     */
    where: RoadmapProgressWhereUniqueInput
  }

  /**
   * RoadmapProgress updateMany
   */
  export type RoadmapProgressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RoadmapProgresses.
     */
    data: XOR<RoadmapProgressUpdateManyMutationInput, RoadmapProgressUncheckedUpdateManyInput>
    /**
     * Filter which RoadmapProgresses to update
     */
    where?: RoadmapProgressWhereInput
  }

  /**
   * RoadmapProgress upsert
   */
  export type RoadmapProgressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapProgress
     */
    select?: RoadmapProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapProgressInclude<ExtArgs> | null
    /**
     * The filter to search for the RoadmapProgress to update in case it exists.
     */
    where: RoadmapProgressWhereUniqueInput
    /**
     * In case the RoadmapProgress found by the `where` argument doesn't exist, create a new RoadmapProgress with this data.
     */
    create: XOR<RoadmapProgressCreateInput, RoadmapProgressUncheckedCreateInput>
    /**
     * In case the RoadmapProgress was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoadmapProgressUpdateInput, RoadmapProgressUncheckedUpdateInput>
  }

  /**
   * RoadmapProgress delete
   */
  export type RoadmapProgressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapProgress
     */
    select?: RoadmapProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapProgressInclude<ExtArgs> | null
    /**
     * Filter which RoadmapProgress to delete.
     */
    where: RoadmapProgressWhereUniqueInput
  }

  /**
   * RoadmapProgress deleteMany
   */
  export type RoadmapProgressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoadmapProgresses to delete
     */
    where?: RoadmapProgressWhereInput
  }

  /**
   * RoadmapProgress without action
   */
  export type RoadmapProgressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapProgress
     */
    select?: RoadmapProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapProgressInclude<ExtArgs> | null
  }


  /**
   * Model CheatsheetCategory
   */

  export type AggregateCheatsheetCategory = {
    _count: CheatsheetCategoryCountAggregateOutputType | null
    _avg: CheatsheetCategoryAvgAggregateOutputType | null
    _sum: CheatsheetCategorySumAggregateOutputType | null
    _min: CheatsheetCategoryMinAggregateOutputType | null
    _max: CheatsheetCategoryMaxAggregateOutputType | null
  }

  export type CheatsheetCategoryAvgAggregateOutputType = {
    order: number | null
  }

  export type CheatsheetCategorySumAggregateOutputType = {
    order: number | null
  }

  export type CheatsheetCategoryMinAggregateOutputType = {
    id: string | null
    slug: string | null
    title: string | null
    description: string | null
    icon: string | null
    order: number | null
    color: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CheatsheetCategoryMaxAggregateOutputType = {
    id: string | null
    slug: string | null
    title: string | null
    description: string | null
    icon: string | null
    order: number | null
    color: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CheatsheetCategoryCountAggregateOutputType = {
    id: number
    slug: number
    title: number
    description: number
    icon: number
    order: number
    color: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CheatsheetCategoryAvgAggregateInputType = {
    order?: true
  }

  export type CheatsheetCategorySumAggregateInputType = {
    order?: true
  }

  export type CheatsheetCategoryMinAggregateInputType = {
    id?: true
    slug?: true
    title?: true
    description?: true
    icon?: true
    order?: true
    color?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CheatsheetCategoryMaxAggregateInputType = {
    id?: true
    slug?: true
    title?: true
    description?: true
    icon?: true
    order?: true
    color?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CheatsheetCategoryCountAggregateInputType = {
    id?: true
    slug?: true
    title?: true
    description?: true
    icon?: true
    order?: true
    color?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CheatsheetCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CheatsheetCategory to aggregate.
     */
    where?: CheatsheetCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CheatsheetCategories to fetch.
     */
    orderBy?: CheatsheetCategoryOrderByWithRelationInput | CheatsheetCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CheatsheetCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CheatsheetCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CheatsheetCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CheatsheetCategories
    **/
    _count?: true | CheatsheetCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CheatsheetCategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CheatsheetCategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CheatsheetCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CheatsheetCategoryMaxAggregateInputType
  }

  export type GetCheatsheetCategoryAggregateType<T extends CheatsheetCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCheatsheetCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCheatsheetCategory[P]>
      : GetScalarType<T[P], AggregateCheatsheetCategory[P]>
  }




  export type CheatsheetCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CheatsheetCategoryWhereInput
    orderBy?: CheatsheetCategoryOrderByWithAggregationInput | CheatsheetCategoryOrderByWithAggregationInput[]
    by: CheatsheetCategoryScalarFieldEnum[] | CheatsheetCategoryScalarFieldEnum
    having?: CheatsheetCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CheatsheetCategoryCountAggregateInputType | true
    _avg?: CheatsheetCategoryAvgAggregateInputType
    _sum?: CheatsheetCategorySumAggregateInputType
    _min?: CheatsheetCategoryMinAggregateInputType
    _max?: CheatsheetCategoryMaxAggregateInputType
  }

  export type CheatsheetCategoryGroupByOutputType = {
    id: string
    slug: string
    title: string
    description: string | null
    icon: string | null
    order: number
    color: string | null
    createdAt: Date
    updatedAt: Date
    _count: CheatsheetCategoryCountAggregateOutputType | null
    _avg: CheatsheetCategoryAvgAggregateOutputType | null
    _sum: CheatsheetCategorySumAggregateOutputType | null
    _min: CheatsheetCategoryMinAggregateOutputType | null
    _max: CheatsheetCategoryMaxAggregateOutputType | null
  }

  type GetCheatsheetCategoryGroupByPayload<T extends CheatsheetCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CheatsheetCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CheatsheetCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CheatsheetCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CheatsheetCategoryGroupByOutputType[P]>
        }
      >
    >


  export type CheatsheetCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    title?: boolean
    description?: boolean
    icon?: boolean
    order?: boolean
    color?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cheatsheets?: boolean | CheatsheetCategory$cheatsheetsArgs<ExtArgs>
    _count?: boolean | CheatsheetCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cheatsheetCategory"]>

  export type CheatsheetCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    title?: boolean
    description?: boolean
    icon?: boolean
    order?: boolean
    color?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["cheatsheetCategory"]>

  export type CheatsheetCategorySelectScalar = {
    id?: boolean
    slug?: boolean
    title?: boolean
    description?: boolean
    icon?: boolean
    order?: boolean
    color?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CheatsheetCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cheatsheets?: boolean | CheatsheetCategory$cheatsheetsArgs<ExtArgs>
    _count?: boolean | CheatsheetCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CheatsheetCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CheatsheetCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CheatsheetCategory"
    objects: {
      cheatsheets: Prisma.$CheatsheetPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      slug: string
      title: string
      description: string | null
      icon: string | null
      order: number
      color: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["cheatsheetCategory"]>
    composites: {}
  }

  type CheatsheetCategoryGetPayload<S extends boolean | null | undefined | CheatsheetCategoryDefaultArgs> = $Result.GetResult<Prisma.$CheatsheetCategoryPayload, S>

  type CheatsheetCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CheatsheetCategoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CheatsheetCategoryCountAggregateInputType | true
    }

  export interface CheatsheetCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CheatsheetCategory'], meta: { name: 'CheatsheetCategory' } }
    /**
     * Find zero or one CheatsheetCategory that matches the filter.
     * @param {CheatsheetCategoryFindUniqueArgs} args - Arguments to find a CheatsheetCategory
     * @example
     * // Get one CheatsheetCategory
     * const cheatsheetCategory = await prisma.cheatsheetCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CheatsheetCategoryFindUniqueArgs>(args: SelectSubset<T, CheatsheetCategoryFindUniqueArgs<ExtArgs>>): Prisma__CheatsheetCategoryClient<$Result.GetResult<Prisma.$CheatsheetCategoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CheatsheetCategory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CheatsheetCategoryFindUniqueOrThrowArgs} args - Arguments to find a CheatsheetCategory
     * @example
     * // Get one CheatsheetCategory
     * const cheatsheetCategory = await prisma.cheatsheetCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CheatsheetCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, CheatsheetCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CheatsheetCategoryClient<$Result.GetResult<Prisma.$CheatsheetCategoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CheatsheetCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheatsheetCategoryFindFirstArgs} args - Arguments to find a CheatsheetCategory
     * @example
     * // Get one CheatsheetCategory
     * const cheatsheetCategory = await prisma.cheatsheetCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CheatsheetCategoryFindFirstArgs>(args?: SelectSubset<T, CheatsheetCategoryFindFirstArgs<ExtArgs>>): Prisma__CheatsheetCategoryClient<$Result.GetResult<Prisma.$CheatsheetCategoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CheatsheetCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheatsheetCategoryFindFirstOrThrowArgs} args - Arguments to find a CheatsheetCategory
     * @example
     * // Get one CheatsheetCategory
     * const cheatsheetCategory = await prisma.cheatsheetCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CheatsheetCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, CheatsheetCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CheatsheetCategoryClient<$Result.GetResult<Prisma.$CheatsheetCategoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CheatsheetCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheatsheetCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CheatsheetCategories
     * const cheatsheetCategories = await prisma.cheatsheetCategory.findMany()
     * 
     * // Get first 10 CheatsheetCategories
     * const cheatsheetCategories = await prisma.cheatsheetCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cheatsheetCategoryWithIdOnly = await prisma.cheatsheetCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CheatsheetCategoryFindManyArgs>(args?: SelectSubset<T, CheatsheetCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CheatsheetCategoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CheatsheetCategory.
     * @param {CheatsheetCategoryCreateArgs} args - Arguments to create a CheatsheetCategory.
     * @example
     * // Create one CheatsheetCategory
     * const CheatsheetCategory = await prisma.cheatsheetCategory.create({
     *   data: {
     *     // ... data to create a CheatsheetCategory
     *   }
     * })
     * 
     */
    create<T extends CheatsheetCategoryCreateArgs>(args: SelectSubset<T, CheatsheetCategoryCreateArgs<ExtArgs>>): Prisma__CheatsheetCategoryClient<$Result.GetResult<Prisma.$CheatsheetCategoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CheatsheetCategories.
     * @param {CheatsheetCategoryCreateManyArgs} args - Arguments to create many CheatsheetCategories.
     * @example
     * // Create many CheatsheetCategories
     * const cheatsheetCategory = await prisma.cheatsheetCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CheatsheetCategoryCreateManyArgs>(args?: SelectSubset<T, CheatsheetCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CheatsheetCategories and returns the data saved in the database.
     * @param {CheatsheetCategoryCreateManyAndReturnArgs} args - Arguments to create many CheatsheetCategories.
     * @example
     * // Create many CheatsheetCategories
     * const cheatsheetCategory = await prisma.cheatsheetCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CheatsheetCategories and only return the `id`
     * const cheatsheetCategoryWithIdOnly = await prisma.cheatsheetCategory.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CheatsheetCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, CheatsheetCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CheatsheetCategoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CheatsheetCategory.
     * @param {CheatsheetCategoryDeleteArgs} args - Arguments to delete one CheatsheetCategory.
     * @example
     * // Delete one CheatsheetCategory
     * const CheatsheetCategory = await prisma.cheatsheetCategory.delete({
     *   where: {
     *     // ... filter to delete one CheatsheetCategory
     *   }
     * })
     * 
     */
    delete<T extends CheatsheetCategoryDeleteArgs>(args: SelectSubset<T, CheatsheetCategoryDeleteArgs<ExtArgs>>): Prisma__CheatsheetCategoryClient<$Result.GetResult<Prisma.$CheatsheetCategoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CheatsheetCategory.
     * @param {CheatsheetCategoryUpdateArgs} args - Arguments to update one CheatsheetCategory.
     * @example
     * // Update one CheatsheetCategory
     * const cheatsheetCategory = await prisma.cheatsheetCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CheatsheetCategoryUpdateArgs>(args: SelectSubset<T, CheatsheetCategoryUpdateArgs<ExtArgs>>): Prisma__CheatsheetCategoryClient<$Result.GetResult<Prisma.$CheatsheetCategoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CheatsheetCategories.
     * @param {CheatsheetCategoryDeleteManyArgs} args - Arguments to filter CheatsheetCategories to delete.
     * @example
     * // Delete a few CheatsheetCategories
     * const { count } = await prisma.cheatsheetCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CheatsheetCategoryDeleteManyArgs>(args?: SelectSubset<T, CheatsheetCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CheatsheetCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheatsheetCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CheatsheetCategories
     * const cheatsheetCategory = await prisma.cheatsheetCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CheatsheetCategoryUpdateManyArgs>(args: SelectSubset<T, CheatsheetCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CheatsheetCategory.
     * @param {CheatsheetCategoryUpsertArgs} args - Arguments to update or create a CheatsheetCategory.
     * @example
     * // Update or create a CheatsheetCategory
     * const cheatsheetCategory = await prisma.cheatsheetCategory.upsert({
     *   create: {
     *     // ... data to create a CheatsheetCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CheatsheetCategory we want to update
     *   }
     * })
     */
    upsert<T extends CheatsheetCategoryUpsertArgs>(args: SelectSubset<T, CheatsheetCategoryUpsertArgs<ExtArgs>>): Prisma__CheatsheetCategoryClient<$Result.GetResult<Prisma.$CheatsheetCategoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CheatsheetCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheatsheetCategoryCountArgs} args - Arguments to filter CheatsheetCategories to count.
     * @example
     * // Count the number of CheatsheetCategories
     * const count = await prisma.cheatsheetCategory.count({
     *   where: {
     *     // ... the filter for the CheatsheetCategories we want to count
     *   }
     * })
    **/
    count<T extends CheatsheetCategoryCountArgs>(
      args?: Subset<T, CheatsheetCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CheatsheetCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CheatsheetCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheatsheetCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CheatsheetCategoryAggregateArgs>(args: Subset<T, CheatsheetCategoryAggregateArgs>): Prisma.PrismaPromise<GetCheatsheetCategoryAggregateType<T>>

    /**
     * Group by CheatsheetCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheatsheetCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CheatsheetCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CheatsheetCategoryGroupByArgs['orderBy'] }
        : { orderBy?: CheatsheetCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CheatsheetCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCheatsheetCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CheatsheetCategory model
   */
  readonly fields: CheatsheetCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CheatsheetCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CheatsheetCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cheatsheets<T extends CheatsheetCategory$cheatsheetsArgs<ExtArgs> = {}>(args?: Subset<T, CheatsheetCategory$cheatsheetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CheatsheetPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CheatsheetCategory model
   */ 
  interface CheatsheetCategoryFieldRefs {
    readonly id: FieldRef<"CheatsheetCategory", 'String'>
    readonly slug: FieldRef<"CheatsheetCategory", 'String'>
    readonly title: FieldRef<"CheatsheetCategory", 'String'>
    readonly description: FieldRef<"CheatsheetCategory", 'String'>
    readonly icon: FieldRef<"CheatsheetCategory", 'String'>
    readonly order: FieldRef<"CheatsheetCategory", 'Int'>
    readonly color: FieldRef<"CheatsheetCategory", 'String'>
    readonly createdAt: FieldRef<"CheatsheetCategory", 'DateTime'>
    readonly updatedAt: FieldRef<"CheatsheetCategory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CheatsheetCategory findUnique
   */
  export type CheatsheetCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheatsheetCategory
     */
    select?: CheatsheetCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheatsheetCategoryInclude<ExtArgs> | null
    /**
     * Filter, which CheatsheetCategory to fetch.
     */
    where: CheatsheetCategoryWhereUniqueInput
  }

  /**
   * CheatsheetCategory findUniqueOrThrow
   */
  export type CheatsheetCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheatsheetCategory
     */
    select?: CheatsheetCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheatsheetCategoryInclude<ExtArgs> | null
    /**
     * Filter, which CheatsheetCategory to fetch.
     */
    where: CheatsheetCategoryWhereUniqueInput
  }

  /**
   * CheatsheetCategory findFirst
   */
  export type CheatsheetCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheatsheetCategory
     */
    select?: CheatsheetCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheatsheetCategoryInclude<ExtArgs> | null
    /**
     * Filter, which CheatsheetCategory to fetch.
     */
    where?: CheatsheetCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CheatsheetCategories to fetch.
     */
    orderBy?: CheatsheetCategoryOrderByWithRelationInput | CheatsheetCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CheatsheetCategories.
     */
    cursor?: CheatsheetCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CheatsheetCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CheatsheetCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CheatsheetCategories.
     */
    distinct?: CheatsheetCategoryScalarFieldEnum | CheatsheetCategoryScalarFieldEnum[]
  }

  /**
   * CheatsheetCategory findFirstOrThrow
   */
  export type CheatsheetCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheatsheetCategory
     */
    select?: CheatsheetCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheatsheetCategoryInclude<ExtArgs> | null
    /**
     * Filter, which CheatsheetCategory to fetch.
     */
    where?: CheatsheetCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CheatsheetCategories to fetch.
     */
    orderBy?: CheatsheetCategoryOrderByWithRelationInput | CheatsheetCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CheatsheetCategories.
     */
    cursor?: CheatsheetCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CheatsheetCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CheatsheetCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CheatsheetCategories.
     */
    distinct?: CheatsheetCategoryScalarFieldEnum | CheatsheetCategoryScalarFieldEnum[]
  }

  /**
   * CheatsheetCategory findMany
   */
  export type CheatsheetCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheatsheetCategory
     */
    select?: CheatsheetCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheatsheetCategoryInclude<ExtArgs> | null
    /**
     * Filter, which CheatsheetCategories to fetch.
     */
    where?: CheatsheetCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CheatsheetCategories to fetch.
     */
    orderBy?: CheatsheetCategoryOrderByWithRelationInput | CheatsheetCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CheatsheetCategories.
     */
    cursor?: CheatsheetCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CheatsheetCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CheatsheetCategories.
     */
    skip?: number
    distinct?: CheatsheetCategoryScalarFieldEnum | CheatsheetCategoryScalarFieldEnum[]
  }

  /**
   * CheatsheetCategory create
   */
  export type CheatsheetCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheatsheetCategory
     */
    select?: CheatsheetCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheatsheetCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a CheatsheetCategory.
     */
    data: XOR<CheatsheetCategoryCreateInput, CheatsheetCategoryUncheckedCreateInput>
  }

  /**
   * CheatsheetCategory createMany
   */
  export type CheatsheetCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CheatsheetCategories.
     */
    data: CheatsheetCategoryCreateManyInput | CheatsheetCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CheatsheetCategory createManyAndReturn
   */
  export type CheatsheetCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheatsheetCategory
     */
    select?: CheatsheetCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CheatsheetCategories.
     */
    data: CheatsheetCategoryCreateManyInput | CheatsheetCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CheatsheetCategory update
   */
  export type CheatsheetCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheatsheetCategory
     */
    select?: CheatsheetCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheatsheetCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a CheatsheetCategory.
     */
    data: XOR<CheatsheetCategoryUpdateInput, CheatsheetCategoryUncheckedUpdateInput>
    /**
     * Choose, which CheatsheetCategory to update.
     */
    where: CheatsheetCategoryWhereUniqueInput
  }

  /**
   * CheatsheetCategory updateMany
   */
  export type CheatsheetCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CheatsheetCategories.
     */
    data: XOR<CheatsheetCategoryUpdateManyMutationInput, CheatsheetCategoryUncheckedUpdateManyInput>
    /**
     * Filter which CheatsheetCategories to update
     */
    where?: CheatsheetCategoryWhereInput
  }

  /**
   * CheatsheetCategory upsert
   */
  export type CheatsheetCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheatsheetCategory
     */
    select?: CheatsheetCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheatsheetCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the CheatsheetCategory to update in case it exists.
     */
    where: CheatsheetCategoryWhereUniqueInput
    /**
     * In case the CheatsheetCategory found by the `where` argument doesn't exist, create a new CheatsheetCategory with this data.
     */
    create: XOR<CheatsheetCategoryCreateInput, CheatsheetCategoryUncheckedCreateInput>
    /**
     * In case the CheatsheetCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CheatsheetCategoryUpdateInput, CheatsheetCategoryUncheckedUpdateInput>
  }

  /**
   * CheatsheetCategory delete
   */
  export type CheatsheetCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheatsheetCategory
     */
    select?: CheatsheetCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheatsheetCategoryInclude<ExtArgs> | null
    /**
     * Filter which CheatsheetCategory to delete.
     */
    where: CheatsheetCategoryWhereUniqueInput
  }

  /**
   * CheatsheetCategory deleteMany
   */
  export type CheatsheetCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CheatsheetCategories to delete
     */
    where?: CheatsheetCategoryWhereInput
  }

  /**
   * CheatsheetCategory.cheatsheets
   */
  export type CheatsheetCategory$cheatsheetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cheatsheet
     */
    select?: CheatsheetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheatsheetInclude<ExtArgs> | null
    where?: CheatsheetWhereInput
    orderBy?: CheatsheetOrderByWithRelationInput | CheatsheetOrderByWithRelationInput[]
    cursor?: CheatsheetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CheatsheetScalarFieldEnum | CheatsheetScalarFieldEnum[]
  }

  /**
   * CheatsheetCategory without action
   */
  export type CheatsheetCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CheatsheetCategory
     */
    select?: CheatsheetCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheatsheetCategoryInclude<ExtArgs> | null
  }


  /**
   * Model Cheatsheet
   */

  export type AggregateCheatsheet = {
    _count: CheatsheetCountAggregateOutputType | null
    _avg: CheatsheetAvgAggregateOutputType | null
    _sum: CheatsheetSumAggregateOutputType | null
    _min: CheatsheetMinAggregateOutputType | null
    _max: CheatsheetMaxAggregateOutputType | null
  }

  export type CheatsheetAvgAggregateOutputType = {
    popularity: number | null
  }

  export type CheatsheetSumAggregateOutputType = {
    popularity: number | null
  }

  export type CheatsheetMinAggregateOutputType = {
    id: string | null
    categoryId: string | null
    slug: string | null
    title: string | null
    subtitle: string | null
    description: string | null
    icon: string | null
    difficulty: string | null
    popularity: number | null
    overview: string | null
    aiExplanation: string | null
    voiceExplainer: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CheatsheetMaxAggregateOutputType = {
    id: string | null
    categoryId: string | null
    slug: string | null
    title: string | null
    subtitle: string | null
    description: string | null
    icon: string | null
    difficulty: string | null
    popularity: number | null
    overview: string | null
    aiExplanation: string | null
    voiceExplainer: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CheatsheetCountAggregateOutputType = {
    id: number
    categoryId: number
    slug: number
    title: number
    subtitle: number
    description: number
    icon: number
    difficulty: number
    tags: number
    popularity: number
    overview: number
    syntax: number
    operations: number
    examples: number
    mistakes: number
    tips: number
    relatedCheatsheets: number
    relatedRoadmaps: number
    relatedDSA: number
    aiExplanation: number
    voiceExplainer: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CheatsheetAvgAggregateInputType = {
    popularity?: true
  }

  export type CheatsheetSumAggregateInputType = {
    popularity?: true
  }

  export type CheatsheetMinAggregateInputType = {
    id?: true
    categoryId?: true
    slug?: true
    title?: true
    subtitle?: true
    description?: true
    icon?: true
    difficulty?: true
    popularity?: true
    overview?: true
    aiExplanation?: true
    voiceExplainer?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CheatsheetMaxAggregateInputType = {
    id?: true
    categoryId?: true
    slug?: true
    title?: true
    subtitle?: true
    description?: true
    icon?: true
    difficulty?: true
    popularity?: true
    overview?: true
    aiExplanation?: true
    voiceExplainer?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CheatsheetCountAggregateInputType = {
    id?: true
    categoryId?: true
    slug?: true
    title?: true
    subtitle?: true
    description?: true
    icon?: true
    difficulty?: true
    tags?: true
    popularity?: true
    overview?: true
    syntax?: true
    operations?: true
    examples?: true
    mistakes?: true
    tips?: true
    relatedCheatsheets?: true
    relatedRoadmaps?: true
    relatedDSA?: true
    aiExplanation?: true
    voiceExplainer?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CheatsheetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cheatsheet to aggregate.
     */
    where?: CheatsheetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cheatsheets to fetch.
     */
    orderBy?: CheatsheetOrderByWithRelationInput | CheatsheetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CheatsheetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cheatsheets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cheatsheets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Cheatsheets
    **/
    _count?: true | CheatsheetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CheatsheetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CheatsheetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CheatsheetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CheatsheetMaxAggregateInputType
  }

  export type GetCheatsheetAggregateType<T extends CheatsheetAggregateArgs> = {
        [P in keyof T & keyof AggregateCheatsheet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCheatsheet[P]>
      : GetScalarType<T[P], AggregateCheatsheet[P]>
  }




  export type CheatsheetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CheatsheetWhereInput
    orderBy?: CheatsheetOrderByWithAggregationInput | CheatsheetOrderByWithAggregationInput[]
    by: CheatsheetScalarFieldEnum[] | CheatsheetScalarFieldEnum
    having?: CheatsheetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CheatsheetCountAggregateInputType | true
    _avg?: CheatsheetAvgAggregateInputType
    _sum?: CheatsheetSumAggregateInputType
    _min?: CheatsheetMinAggregateInputType
    _max?: CheatsheetMaxAggregateInputType
  }

  export type CheatsheetGroupByOutputType = {
    id: string
    categoryId: string
    slug: string
    title: string
    subtitle: string | null
    description: string | null
    icon: string | null
    difficulty: string | null
    tags: string[]
    popularity: number
    overview: string | null
    syntax: JsonValue | null
    operations: JsonValue | null
    examples: JsonValue | null
    mistakes: string[]
    tips: string[]
    relatedCheatsheets: string[]
    relatedRoadmaps: string[]
    relatedDSA: string[]
    aiExplanation: string | null
    voiceExplainer: string | null
    createdAt: Date
    updatedAt: Date
    _count: CheatsheetCountAggregateOutputType | null
    _avg: CheatsheetAvgAggregateOutputType | null
    _sum: CheatsheetSumAggregateOutputType | null
    _min: CheatsheetMinAggregateOutputType | null
    _max: CheatsheetMaxAggregateOutputType | null
  }

  type GetCheatsheetGroupByPayload<T extends CheatsheetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CheatsheetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CheatsheetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CheatsheetGroupByOutputType[P]>
            : GetScalarType<T[P], CheatsheetGroupByOutputType[P]>
        }
      >
    >


  export type CheatsheetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    categoryId?: boolean
    slug?: boolean
    title?: boolean
    subtitle?: boolean
    description?: boolean
    icon?: boolean
    difficulty?: boolean
    tags?: boolean
    popularity?: boolean
    overview?: boolean
    syntax?: boolean
    operations?: boolean
    examples?: boolean
    mistakes?: boolean
    tips?: boolean
    relatedCheatsheets?: boolean
    relatedRoadmaps?: boolean
    relatedDSA?: boolean
    aiExplanation?: boolean
    voiceExplainer?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    category?: boolean | CheatsheetCategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cheatsheet"]>

  export type CheatsheetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    categoryId?: boolean
    slug?: boolean
    title?: boolean
    subtitle?: boolean
    description?: boolean
    icon?: boolean
    difficulty?: boolean
    tags?: boolean
    popularity?: boolean
    overview?: boolean
    syntax?: boolean
    operations?: boolean
    examples?: boolean
    mistakes?: boolean
    tips?: boolean
    relatedCheatsheets?: boolean
    relatedRoadmaps?: boolean
    relatedDSA?: boolean
    aiExplanation?: boolean
    voiceExplainer?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    category?: boolean | CheatsheetCategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cheatsheet"]>

  export type CheatsheetSelectScalar = {
    id?: boolean
    categoryId?: boolean
    slug?: boolean
    title?: boolean
    subtitle?: boolean
    description?: boolean
    icon?: boolean
    difficulty?: boolean
    tags?: boolean
    popularity?: boolean
    overview?: boolean
    syntax?: boolean
    operations?: boolean
    examples?: boolean
    mistakes?: boolean
    tips?: boolean
    relatedCheatsheets?: boolean
    relatedRoadmaps?: boolean
    relatedDSA?: boolean
    aiExplanation?: boolean
    voiceExplainer?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CheatsheetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | CheatsheetCategoryDefaultArgs<ExtArgs>
  }
  export type CheatsheetIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | CheatsheetCategoryDefaultArgs<ExtArgs>
  }

  export type $CheatsheetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Cheatsheet"
    objects: {
      category: Prisma.$CheatsheetCategoryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      categoryId: string
      slug: string
      title: string
      subtitle: string | null
      description: string | null
      icon: string | null
      difficulty: string | null
      tags: string[]
      popularity: number
      overview: string | null
      syntax: Prisma.JsonValue | null
      operations: Prisma.JsonValue | null
      examples: Prisma.JsonValue | null
      mistakes: string[]
      tips: string[]
      relatedCheatsheets: string[]
      relatedRoadmaps: string[]
      relatedDSA: string[]
      aiExplanation: string | null
      voiceExplainer: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["cheatsheet"]>
    composites: {}
  }

  type CheatsheetGetPayload<S extends boolean | null | undefined | CheatsheetDefaultArgs> = $Result.GetResult<Prisma.$CheatsheetPayload, S>

  type CheatsheetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CheatsheetFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CheatsheetCountAggregateInputType | true
    }

  export interface CheatsheetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Cheatsheet'], meta: { name: 'Cheatsheet' } }
    /**
     * Find zero or one Cheatsheet that matches the filter.
     * @param {CheatsheetFindUniqueArgs} args - Arguments to find a Cheatsheet
     * @example
     * // Get one Cheatsheet
     * const cheatsheet = await prisma.cheatsheet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CheatsheetFindUniqueArgs>(args: SelectSubset<T, CheatsheetFindUniqueArgs<ExtArgs>>): Prisma__CheatsheetClient<$Result.GetResult<Prisma.$CheatsheetPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Cheatsheet that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CheatsheetFindUniqueOrThrowArgs} args - Arguments to find a Cheatsheet
     * @example
     * // Get one Cheatsheet
     * const cheatsheet = await prisma.cheatsheet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CheatsheetFindUniqueOrThrowArgs>(args: SelectSubset<T, CheatsheetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CheatsheetClient<$Result.GetResult<Prisma.$CheatsheetPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Cheatsheet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheatsheetFindFirstArgs} args - Arguments to find a Cheatsheet
     * @example
     * // Get one Cheatsheet
     * const cheatsheet = await prisma.cheatsheet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CheatsheetFindFirstArgs>(args?: SelectSubset<T, CheatsheetFindFirstArgs<ExtArgs>>): Prisma__CheatsheetClient<$Result.GetResult<Prisma.$CheatsheetPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Cheatsheet that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheatsheetFindFirstOrThrowArgs} args - Arguments to find a Cheatsheet
     * @example
     * // Get one Cheatsheet
     * const cheatsheet = await prisma.cheatsheet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CheatsheetFindFirstOrThrowArgs>(args?: SelectSubset<T, CheatsheetFindFirstOrThrowArgs<ExtArgs>>): Prisma__CheatsheetClient<$Result.GetResult<Prisma.$CheatsheetPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Cheatsheets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheatsheetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cheatsheets
     * const cheatsheets = await prisma.cheatsheet.findMany()
     * 
     * // Get first 10 Cheatsheets
     * const cheatsheets = await prisma.cheatsheet.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cheatsheetWithIdOnly = await prisma.cheatsheet.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CheatsheetFindManyArgs>(args?: SelectSubset<T, CheatsheetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CheatsheetPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Cheatsheet.
     * @param {CheatsheetCreateArgs} args - Arguments to create a Cheatsheet.
     * @example
     * // Create one Cheatsheet
     * const Cheatsheet = await prisma.cheatsheet.create({
     *   data: {
     *     // ... data to create a Cheatsheet
     *   }
     * })
     * 
     */
    create<T extends CheatsheetCreateArgs>(args: SelectSubset<T, CheatsheetCreateArgs<ExtArgs>>): Prisma__CheatsheetClient<$Result.GetResult<Prisma.$CheatsheetPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Cheatsheets.
     * @param {CheatsheetCreateManyArgs} args - Arguments to create many Cheatsheets.
     * @example
     * // Create many Cheatsheets
     * const cheatsheet = await prisma.cheatsheet.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CheatsheetCreateManyArgs>(args?: SelectSubset<T, CheatsheetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Cheatsheets and returns the data saved in the database.
     * @param {CheatsheetCreateManyAndReturnArgs} args - Arguments to create many Cheatsheets.
     * @example
     * // Create many Cheatsheets
     * const cheatsheet = await prisma.cheatsheet.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Cheatsheets and only return the `id`
     * const cheatsheetWithIdOnly = await prisma.cheatsheet.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CheatsheetCreateManyAndReturnArgs>(args?: SelectSubset<T, CheatsheetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CheatsheetPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Cheatsheet.
     * @param {CheatsheetDeleteArgs} args - Arguments to delete one Cheatsheet.
     * @example
     * // Delete one Cheatsheet
     * const Cheatsheet = await prisma.cheatsheet.delete({
     *   where: {
     *     // ... filter to delete one Cheatsheet
     *   }
     * })
     * 
     */
    delete<T extends CheatsheetDeleteArgs>(args: SelectSubset<T, CheatsheetDeleteArgs<ExtArgs>>): Prisma__CheatsheetClient<$Result.GetResult<Prisma.$CheatsheetPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Cheatsheet.
     * @param {CheatsheetUpdateArgs} args - Arguments to update one Cheatsheet.
     * @example
     * // Update one Cheatsheet
     * const cheatsheet = await prisma.cheatsheet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CheatsheetUpdateArgs>(args: SelectSubset<T, CheatsheetUpdateArgs<ExtArgs>>): Prisma__CheatsheetClient<$Result.GetResult<Prisma.$CheatsheetPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Cheatsheets.
     * @param {CheatsheetDeleteManyArgs} args - Arguments to filter Cheatsheets to delete.
     * @example
     * // Delete a few Cheatsheets
     * const { count } = await prisma.cheatsheet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CheatsheetDeleteManyArgs>(args?: SelectSubset<T, CheatsheetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cheatsheets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheatsheetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cheatsheets
     * const cheatsheet = await prisma.cheatsheet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CheatsheetUpdateManyArgs>(args: SelectSubset<T, CheatsheetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Cheatsheet.
     * @param {CheatsheetUpsertArgs} args - Arguments to update or create a Cheatsheet.
     * @example
     * // Update or create a Cheatsheet
     * const cheatsheet = await prisma.cheatsheet.upsert({
     *   create: {
     *     // ... data to create a Cheatsheet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cheatsheet we want to update
     *   }
     * })
     */
    upsert<T extends CheatsheetUpsertArgs>(args: SelectSubset<T, CheatsheetUpsertArgs<ExtArgs>>): Prisma__CheatsheetClient<$Result.GetResult<Prisma.$CheatsheetPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Cheatsheets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheatsheetCountArgs} args - Arguments to filter Cheatsheets to count.
     * @example
     * // Count the number of Cheatsheets
     * const count = await prisma.cheatsheet.count({
     *   where: {
     *     // ... the filter for the Cheatsheets we want to count
     *   }
     * })
    **/
    count<T extends CheatsheetCountArgs>(
      args?: Subset<T, CheatsheetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CheatsheetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cheatsheet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheatsheetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CheatsheetAggregateArgs>(args: Subset<T, CheatsheetAggregateArgs>): Prisma.PrismaPromise<GetCheatsheetAggregateType<T>>

    /**
     * Group by Cheatsheet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheatsheetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CheatsheetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CheatsheetGroupByArgs['orderBy'] }
        : { orderBy?: CheatsheetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CheatsheetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCheatsheetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Cheatsheet model
   */
  readonly fields: CheatsheetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Cheatsheet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CheatsheetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    category<T extends CheatsheetCategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CheatsheetCategoryDefaultArgs<ExtArgs>>): Prisma__CheatsheetCategoryClient<$Result.GetResult<Prisma.$CheatsheetCategoryPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Cheatsheet model
   */ 
  interface CheatsheetFieldRefs {
    readonly id: FieldRef<"Cheatsheet", 'String'>
    readonly categoryId: FieldRef<"Cheatsheet", 'String'>
    readonly slug: FieldRef<"Cheatsheet", 'String'>
    readonly title: FieldRef<"Cheatsheet", 'String'>
    readonly subtitle: FieldRef<"Cheatsheet", 'String'>
    readonly description: FieldRef<"Cheatsheet", 'String'>
    readonly icon: FieldRef<"Cheatsheet", 'String'>
    readonly difficulty: FieldRef<"Cheatsheet", 'String'>
    readonly tags: FieldRef<"Cheatsheet", 'String[]'>
    readonly popularity: FieldRef<"Cheatsheet", 'Int'>
    readonly overview: FieldRef<"Cheatsheet", 'String'>
    readonly syntax: FieldRef<"Cheatsheet", 'Json'>
    readonly operations: FieldRef<"Cheatsheet", 'Json'>
    readonly examples: FieldRef<"Cheatsheet", 'Json'>
    readonly mistakes: FieldRef<"Cheatsheet", 'String[]'>
    readonly tips: FieldRef<"Cheatsheet", 'String[]'>
    readonly relatedCheatsheets: FieldRef<"Cheatsheet", 'String[]'>
    readonly relatedRoadmaps: FieldRef<"Cheatsheet", 'String[]'>
    readonly relatedDSA: FieldRef<"Cheatsheet", 'String[]'>
    readonly aiExplanation: FieldRef<"Cheatsheet", 'String'>
    readonly voiceExplainer: FieldRef<"Cheatsheet", 'String'>
    readonly createdAt: FieldRef<"Cheatsheet", 'DateTime'>
    readonly updatedAt: FieldRef<"Cheatsheet", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Cheatsheet findUnique
   */
  export type CheatsheetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cheatsheet
     */
    select?: CheatsheetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheatsheetInclude<ExtArgs> | null
    /**
     * Filter, which Cheatsheet to fetch.
     */
    where: CheatsheetWhereUniqueInput
  }

  /**
   * Cheatsheet findUniqueOrThrow
   */
  export type CheatsheetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cheatsheet
     */
    select?: CheatsheetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheatsheetInclude<ExtArgs> | null
    /**
     * Filter, which Cheatsheet to fetch.
     */
    where: CheatsheetWhereUniqueInput
  }

  /**
   * Cheatsheet findFirst
   */
  export type CheatsheetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cheatsheet
     */
    select?: CheatsheetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheatsheetInclude<ExtArgs> | null
    /**
     * Filter, which Cheatsheet to fetch.
     */
    where?: CheatsheetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cheatsheets to fetch.
     */
    orderBy?: CheatsheetOrderByWithRelationInput | CheatsheetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cheatsheets.
     */
    cursor?: CheatsheetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cheatsheets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cheatsheets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cheatsheets.
     */
    distinct?: CheatsheetScalarFieldEnum | CheatsheetScalarFieldEnum[]
  }

  /**
   * Cheatsheet findFirstOrThrow
   */
  export type CheatsheetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cheatsheet
     */
    select?: CheatsheetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheatsheetInclude<ExtArgs> | null
    /**
     * Filter, which Cheatsheet to fetch.
     */
    where?: CheatsheetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cheatsheets to fetch.
     */
    orderBy?: CheatsheetOrderByWithRelationInput | CheatsheetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cheatsheets.
     */
    cursor?: CheatsheetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cheatsheets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cheatsheets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cheatsheets.
     */
    distinct?: CheatsheetScalarFieldEnum | CheatsheetScalarFieldEnum[]
  }

  /**
   * Cheatsheet findMany
   */
  export type CheatsheetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cheatsheet
     */
    select?: CheatsheetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheatsheetInclude<ExtArgs> | null
    /**
     * Filter, which Cheatsheets to fetch.
     */
    where?: CheatsheetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cheatsheets to fetch.
     */
    orderBy?: CheatsheetOrderByWithRelationInput | CheatsheetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Cheatsheets.
     */
    cursor?: CheatsheetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cheatsheets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cheatsheets.
     */
    skip?: number
    distinct?: CheatsheetScalarFieldEnum | CheatsheetScalarFieldEnum[]
  }

  /**
   * Cheatsheet create
   */
  export type CheatsheetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cheatsheet
     */
    select?: CheatsheetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheatsheetInclude<ExtArgs> | null
    /**
     * The data needed to create a Cheatsheet.
     */
    data: XOR<CheatsheetCreateInput, CheatsheetUncheckedCreateInput>
  }

  /**
   * Cheatsheet createMany
   */
  export type CheatsheetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Cheatsheets.
     */
    data: CheatsheetCreateManyInput | CheatsheetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Cheatsheet createManyAndReturn
   */
  export type CheatsheetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cheatsheet
     */
    select?: CheatsheetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Cheatsheets.
     */
    data: CheatsheetCreateManyInput | CheatsheetCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheatsheetIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Cheatsheet update
   */
  export type CheatsheetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cheatsheet
     */
    select?: CheatsheetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheatsheetInclude<ExtArgs> | null
    /**
     * The data needed to update a Cheatsheet.
     */
    data: XOR<CheatsheetUpdateInput, CheatsheetUncheckedUpdateInput>
    /**
     * Choose, which Cheatsheet to update.
     */
    where: CheatsheetWhereUniqueInput
  }

  /**
   * Cheatsheet updateMany
   */
  export type CheatsheetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Cheatsheets.
     */
    data: XOR<CheatsheetUpdateManyMutationInput, CheatsheetUncheckedUpdateManyInput>
    /**
     * Filter which Cheatsheets to update
     */
    where?: CheatsheetWhereInput
  }

  /**
   * Cheatsheet upsert
   */
  export type CheatsheetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cheatsheet
     */
    select?: CheatsheetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheatsheetInclude<ExtArgs> | null
    /**
     * The filter to search for the Cheatsheet to update in case it exists.
     */
    where: CheatsheetWhereUniqueInput
    /**
     * In case the Cheatsheet found by the `where` argument doesn't exist, create a new Cheatsheet with this data.
     */
    create: XOR<CheatsheetCreateInput, CheatsheetUncheckedCreateInput>
    /**
     * In case the Cheatsheet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CheatsheetUpdateInput, CheatsheetUncheckedUpdateInput>
  }

  /**
   * Cheatsheet delete
   */
  export type CheatsheetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cheatsheet
     */
    select?: CheatsheetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheatsheetInclude<ExtArgs> | null
    /**
     * Filter which Cheatsheet to delete.
     */
    where: CheatsheetWhereUniqueInput
  }

  /**
   * Cheatsheet deleteMany
   */
  export type CheatsheetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cheatsheets to delete
     */
    where?: CheatsheetWhereInput
  }

  /**
   * Cheatsheet without action
   */
  export type CheatsheetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cheatsheet
     */
    select?: CheatsheetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheatsheetInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const DSATopicScalarFieldEnum: {
    id: 'id',
    slug: 'slug',
    title: 'title',
    category: 'category',
    order: 'order',
    targetCount: 'targetCount',
    createdAt: 'createdAt'
  };

  export type DSATopicScalarFieldEnum = (typeof DSATopicScalarFieldEnum)[keyof typeof DSATopicScalarFieldEnum]


  export const DSALessonScalarFieldEnum: {
    id: 'id',
    topicId: 'topicId',
    slug: 'slug',
    title: 'title',
    content: 'content',
    codeExamples: 'codeExamples',
    difficulty: 'difficulty',
    order: 'order',
    createdAt: 'createdAt'
  };

  export type DSALessonScalarFieldEnum = (typeof DSALessonScalarFieldEnum)[keyof typeof DSALessonScalarFieldEnum]


  export const ProblemScalarFieldEnum: {
    id: 'id',
    title: 'title',
    slug: 'slug',
    difficulty: 'difficulty',
    description: 'description',
    examples: 'examples',
    constraints: 'constraints',
    starterCode: 'starterCode',
    solutions: 'solutions',
    testCases: 'testCases',
    pattern: 'pattern',
    sheets: 'sheets',
    order: 'order',
    createdAt: 'createdAt'
  };

  export type ProblemScalarFieldEnum = (typeof ProblemScalarFieldEnum)[keyof typeof ProblemScalarFieldEnum]


  export const UserProgressScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    problemId: 'problemId',
    status: 'status',
    starred: 'starred',
    lastAttempt: 'lastAttempt',
    createdAt: 'createdAt'
  };

  export type UserProgressScalarFieldEnum = (typeof UserProgressScalarFieldEnum)[keyof typeof UserProgressScalarFieldEnum]


  export const SubmissionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    problemId: 'problemId',
    code: 'code',
    language: 'language',
    status: 'status',
    runtime: 'runtime',
    memory: 'memory',
    createdAt: 'createdAt'
  };

  export type SubmissionScalarFieldEnum = (typeof SubmissionScalarFieldEnum)[keyof typeof SubmissionScalarFieldEnum]


  export const LearnDomainScalarFieldEnum: {
    id: 'id',
    slug: 'slug',
    title: 'title',
    createdAt: 'createdAt'
  };

  export type LearnDomainScalarFieldEnum = (typeof LearnDomainScalarFieldEnum)[keyof typeof LearnDomainScalarFieldEnum]


  export const LearnCategoryScalarFieldEnum: {
    id: 'id',
    title: 'title',
    order: 'order',
    domainId: 'domainId'
  };

  export type LearnCategoryScalarFieldEnum = (typeof LearnCategoryScalarFieldEnum)[keyof typeof LearnCategoryScalarFieldEnum]


  export const LearnTopicScalarFieldEnum: {
    id: 'id',
    title: 'title',
    slug: 'slug',
    order: 'order',
    content: 'content',
    categoryId: 'categoryId',
    createdAt: 'createdAt'
  };

  export type LearnTopicScalarFieldEnum = (typeof LearnTopicScalarFieldEnum)[keyof typeof LearnTopicScalarFieldEnum]


  export const InterviewSessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    role: 'role',
    duration: 'duration',
    status: 'status',
    resumeSnapshot: 'resumeSnapshot',
    jobDescription: 'jobDescription',
    resumeSummary: 'resumeSummary',
    jdSummary: 'jdSummary',
    vapiCallId: 'vapiCallId',
    vapiAssistantId: 'vapiAssistantId',
    transcript: 'transcript',
    videoUrl: 'videoUrl',
    videoRecorded: 'videoRecorded',
    createdAt: 'createdAt',
    startedAt: 'startedAt',
    endedAt: 'endedAt'
  };

  export type InterviewSessionScalarFieldEnum = (typeof InterviewSessionScalarFieldEnum)[keyof typeof InterviewSessionScalarFieldEnum]


  export const InterviewFeedbackScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    overallScore: 'overallScore',
    communicationClarity: 'communicationClarity',
    technicalDepth: 'technicalDepth',
    confidence: 'confidence',
    roleAlignment: 'roleAlignment',
    skillRatings: 'skillRatings',
    strengths: 'strengths',
    weaknesses: 'weaknesses',
    improvements: 'improvements',
    suggestedTopics: 'suggestedTopics',
    learningRoadmap: 'learningRoadmap',
    aiSummary: 'aiSummary',
    createdAt: 'createdAt'
  };

  export type InterviewFeedbackScalarFieldEnum = (typeof InterviewFeedbackScalarFieldEnum)[keyof typeof InterviewFeedbackScalarFieldEnum]


  export const QuestionBankScalarFieldEnum: {
    id: 'id',
    role: 'role',
    difficulty: 'difficulty',
    category: 'category',
    question: 'question',
    followUps: 'followUps',
    keyPoints: 'keyPoints',
    tags: 'tags',
    active: 'active',
    usageCount: 'usageCount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type QuestionBankScalarFieldEnum = (typeof QuestionBankScalarFieldEnum)[keyof typeof QuestionBankScalarFieldEnum]


  export const SharedInterviewResultScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    userId: 'userId',
    shareToken: 'shareToken',
    isPublic: 'isPublic',
    expiresAt: 'expiresAt',
    viewCount: 'viewCount',
    lastViewedAt: 'lastViewedAt',
    createdAt: 'createdAt'
  };

  export type SharedInterviewResultScalarFieldEnum = (typeof SharedInterviewResultScalarFieldEnum)[keyof typeof SharedInterviewResultScalarFieldEnum]


  export const InterviewAnalyticsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    totalInterviews: 'totalInterviews',
    averageScore: 'averageScore',
    averageCommunication: 'averageCommunication',
    averageTechnical: 'averageTechnical',
    averageConfidence: 'averageConfidence',
    roleStats: 'roleStats',
    monthlyScores: 'monthlyScores',
    topStrengths: 'topStrengths',
    topWeaknesses: 'topWeaknesses',
    lastUpdated: 'lastUpdated'
  };

  export type InterviewAnalyticsScalarFieldEnum = (typeof InterviewAnalyticsScalarFieldEnum)[keyof typeof InterviewAnalyticsScalarFieldEnum]


  export const RoadmapScalarFieldEnum: {
    id: 'id',
    slug: 'slug',
    title: 'title',
    description: 'description',
    icon: 'icon',
    level: 'level',
    duration: 'duration',
    gradient: 'gradient',
    skills: 'skills',
    popularity: 'popularity',
    isActive: 'isActive',
    order: 'order',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RoadmapScalarFieldEnum = (typeof RoadmapScalarFieldEnum)[keyof typeof RoadmapScalarFieldEnum]


  export const RoadmapPhaseScalarFieldEnum: {
    id: 'id',
    roadmapId: 'roadmapId',
    title: 'title',
    description: 'description',
    order: 'order'
  };

  export type RoadmapPhaseScalarFieldEnum = (typeof RoadmapPhaseScalarFieldEnum)[keyof typeof RoadmapPhaseScalarFieldEnum]


  export const RoadmapStepScalarFieldEnum: {
    id: 'id',
    phaseId: 'phaseId',
    title: 'title',
    description: 'description',
    difficulty: 'difficulty',
    estimatedTime: 'estimatedTime',
    order: 'order',
    topics: 'topics',
    prerequisites: 'prerequisites',
    resources: 'resources',
    checkpoints: 'checkpoints',
    relatedCheatsheets: 'relatedCheatsheets',
    relatedDSA: 'relatedDSA',
    relatedInterviews: 'relatedInterviews',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RoadmapStepScalarFieldEnum = (typeof RoadmapStepScalarFieldEnum)[keyof typeof RoadmapStepScalarFieldEnum]


  export const RoadmapProgressScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    roadmapId: 'roadmapId',
    stepId: 'stepId',
    completed: 'completed',
    notes: 'notes',
    completedAt: 'completedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RoadmapProgressScalarFieldEnum = (typeof RoadmapProgressScalarFieldEnum)[keyof typeof RoadmapProgressScalarFieldEnum]


  export const CheatsheetCategoryScalarFieldEnum: {
    id: 'id',
    slug: 'slug',
    title: 'title',
    description: 'description',
    icon: 'icon',
    order: 'order',
    color: 'color',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CheatsheetCategoryScalarFieldEnum = (typeof CheatsheetCategoryScalarFieldEnum)[keyof typeof CheatsheetCategoryScalarFieldEnum]


  export const CheatsheetScalarFieldEnum: {
    id: 'id',
    categoryId: 'categoryId',
    slug: 'slug',
    title: 'title',
    subtitle: 'subtitle',
    description: 'description',
    icon: 'icon',
    difficulty: 'difficulty',
    tags: 'tags',
    popularity: 'popularity',
    overview: 'overview',
    syntax: 'syntax',
    operations: 'operations',
    examples: 'examples',
    mistakes: 'mistakes',
    tips: 'tips',
    relatedCheatsheets: 'relatedCheatsheets',
    relatedRoadmaps: 'relatedRoadmaps',
    relatedDSA: 'relatedDSA',
    aiExplanation: 'aiExplanation',
    voiceExplainer: 'voiceExplainer',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CheatsheetScalarFieldEnum = (typeof CheatsheetScalarFieldEnum)[keyof typeof CheatsheetScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    progress?: UserProgressListRelationFilter
    submissions?: SubmissionListRelationFilter
    interviewSessions?: InterviewSessionListRelationFilter
    sharedResults?: SharedInterviewResultListRelationFilter
    analytics?: XOR<InterviewAnalyticsNullableRelationFilter, InterviewAnalyticsWhereInput> | null
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    progress?: UserProgressOrderByRelationAggregateInput
    submissions?: SubmissionOrderByRelationAggregateInput
    interviewSessions?: InterviewSessionOrderByRelationAggregateInput
    sharedResults?: SharedInterviewResultOrderByRelationAggregateInput
    analytics?: InterviewAnalyticsOrderByWithRelationInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    progress?: UserProgressListRelationFilter
    submissions?: SubmissionListRelationFilter
    interviewSessions?: InterviewSessionListRelationFilter
    sharedResults?: SharedInterviewResultListRelationFilter
    analytics?: XOR<InterviewAnalyticsNullableRelationFilter, InterviewAnalyticsWhereInput> | null
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type DSATopicWhereInput = {
    AND?: DSATopicWhereInput | DSATopicWhereInput[]
    OR?: DSATopicWhereInput[]
    NOT?: DSATopicWhereInput | DSATopicWhereInput[]
    id?: StringFilter<"DSATopic"> | string
    slug?: StringFilter<"DSATopic"> | string
    title?: StringFilter<"DSATopic"> | string
    category?: StringNullableFilter<"DSATopic"> | string | null
    order?: IntFilter<"DSATopic"> | number
    targetCount?: IntFilter<"DSATopic"> | number
    createdAt?: DateTimeFilter<"DSATopic"> | Date | string
    lessons?: DSALessonListRelationFilter
  }

  export type DSATopicOrderByWithRelationInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    category?: SortOrderInput | SortOrder
    order?: SortOrder
    targetCount?: SortOrder
    createdAt?: SortOrder
    lessons?: DSALessonOrderByRelationAggregateInput
  }

  export type DSATopicWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: DSATopicWhereInput | DSATopicWhereInput[]
    OR?: DSATopicWhereInput[]
    NOT?: DSATopicWhereInput | DSATopicWhereInput[]
    title?: StringFilter<"DSATopic"> | string
    category?: StringNullableFilter<"DSATopic"> | string | null
    order?: IntFilter<"DSATopic"> | number
    targetCount?: IntFilter<"DSATopic"> | number
    createdAt?: DateTimeFilter<"DSATopic"> | Date | string
    lessons?: DSALessonListRelationFilter
  }, "id" | "slug">

  export type DSATopicOrderByWithAggregationInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    category?: SortOrderInput | SortOrder
    order?: SortOrder
    targetCount?: SortOrder
    createdAt?: SortOrder
    _count?: DSATopicCountOrderByAggregateInput
    _avg?: DSATopicAvgOrderByAggregateInput
    _max?: DSATopicMaxOrderByAggregateInput
    _min?: DSATopicMinOrderByAggregateInput
    _sum?: DSATopicSumOrderByAggregateInput
  }

  export type DSATopicScalarWhereWithAggregatesInput = {
    AND?: DSATopicScalarWhereWithAggregatesInput | DSATopicScalarWhereWithAggregatesInput[]
    OR?: DSATopicScalarWhereWithAggregatesInput[]
    NOT?: DSATopicScalarWhereWithAggregatesInput | DSATopicScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DSATopic"> | string
    slug?: StringWithAggregatesFilter<"DSATopic"> | string
    title?: StringWithAggregatesFilter<"DSATopic"> | string
    category?: StringNullableWithAggregatesFilter<"DSATopic"> | string | null
    order?: IntWithAggregatesFilter<"DSATopic"> | number
    targetCount?: IntWithAggregatesFilter<"DSATopic"> | number
    createdAt?: DateTimeWithAggregatesFilter<"DSATopic"> | Date | string
  }

  export type DSALessonWhereInput = {
    AND?: DSALessonWhereInput | DSALessonWhereInput[]
    OR?: DSALessonWhereInput[]
    NOT?: DSALessonWhereInput | DSALessonWhereInput[]
    id?: StringFilter<"DSALesson"> | string
    topicId?: StringFilter<"DSALesson"> | string
    slug?: StringFilter<"DSALesson"> | string
    title?: StringFilter<"DSALesson"> | string
    content?: StringFilter<"DSALesson"> | string
    codeExamples?: JsonNullableFilter<"DSALesson">
    difficulty?: StringNullableFilter<"DSALesson"> | string | null
    order?: IntFilter<"DSALesson"> | number
    createdAt?: DateTimeFilter<"DSALesson"> | Date | string
    topic?: XOR<DSATopicRelationFilter, DSATopicWhereInput>
  }

  export type DSALessonOrderByWithRelationInput = {
    id?: SortOrder
    topicId?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    content?: SortOrder
    codeExamples?: SortOrderInput | SortOrder
    difficulty?: SortOrderInput | SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    topic?: DSATopicOrderByWithRelationInput
  }

  export type DSALessonWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: DSALessonWhereInput | DSALessonWhereInput[]
    OR?: DSALessonWhereInput[]
    NOT?: DSALessonWhereInput | DSALessonWhereInput[]
    topicId?: StringFilter<"DSALesson"> | string
    title?: StringFilter<"DSALesson"> | string
    content?: StringFilter<"DSALesson"> | string
    codeExamples?: JsonNullableFilter<"DSALesson">
    difficulty?: StringNullableFilter<"DSALesson"> | string | null
    order?: IntFilter<"DSALesson"> | number
    createdAt?: DateTimeFilter<"DSALesson"> | Date | string
    topic?: XOR<DSATopicRelationFilter, DSATopicWhereInput>
  }, "id" | "slug">

  export type DSALessonOrderByWithAggregationInput = {
    id?: SortOrder
    topicId?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    content?: SortOrder
    codeExamples?: SortOrderInput | SortOrder
    difficulty?: SortOrderInput | SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    _count?: DSALessonCountOrderByAggregateInput
    _avg?: DSALessonAvgOrderByAggregateInput
    _max?: DSALessonMaxOrderByAggregateInput
    _min?: DSALessonMinOrderByAggregateInput
    _sum?: DSALessonSumOrderByAggregateInput
  }

  export type DSALessonScalarWhereWithAggregatesInput = {
    AND?: DSALessonScalarWhereWithAggregatesInput | DSALessonScalarWhereWithAggregatesInput[]
    OR?: DSALessonScalarWhereWithAggregatesInput[]
    NOT?: DSALessonScalarWhereWithAggregatesInput | DSALessonScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DSALesson"> | string
    topicId?: StringWithAggregatesFilter<"DSALesson"> | string
    slug?: StringWithAggregatesFilter<"DSALesson"> | string
    title?: StringWithAggregatesFilter<"DSALesson"> | string
    content?: StringWithAggregatesFilter<"DSALesson"> | string
    codeExamples?: JsonNullableWithAggregatesFilter<"DSALesson">
    difficulty?: StringNullableWithAggregatesFilter<"DSALesson"> | string | null
    order?: IntWithAggregatesFilter<"DSALesson"> | number
    createdAt?: DateTimeWithAggregatesFilter<"DSALesson"> | Date | string
  }

  export type ProblemWhereInput = {
    AND?: ProblemWhereInput | ProblemWhereInput[]
    OR?: ProblemWhereInput[]
    NOT?: ProblemWhereInput | ProblemWhereInput[]
    id?: StringFilter<"Problem"> | string
    title?: StringFilter<"Problem"> | string
    slug?: StringFilter<"Problem"> | string
    difficulty?: StringFilter<"Problem"> | string
    description?: StringFilter<"Problem"> | string
    examples?: JsonFilter<"Problem">
    constraints?: StringNullableListFilter<"Problem">
    starterCode?: JsonFilter<"Problem">
    solutions?: JsonNullableFilter<"Problem">
    testCases?: JsonNullableFilter<"Problem">
    pattern?: StringFilter<"Problem"> | string
    sheets?: StringNullableListFilter<"Problem">
    order?: IntFilter<"Problem"> | number
    createdAt?: DateTimeFilter<"Problem"> | Date | string
    progress?: UserProgressListRelationFilter
    submissions?: SubmissionListRelationFilter
  }

  export type ProblemOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    difficulty?: SortOrder
    description?: SortOrder
    examples?: SortOrder
    constraints?: SortOrder
    starterCode?: SortOrder
    solutions?: SortOrderInput | SortOrder
    testCases?: SortOrderInput | SortOrder
    pattern?: SortOrder
    sheets?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    progress?: UserProgressOrderByRelationAggregateInput
    submissions?: SubmissionOrderByRelationAggregateInput
  }

  export type ProblemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: ProblemWhereInput | ProblemWhereInput[]
    OR?: ProblemWhereInput[]
    NOT?: ProblemWhereInput | ProblemWhereInput[]
    title?: StringFilter<"Problem"> | string
    difficulty?: StringFilter<"Problem"> | string
    description?: StringFilter<"Problem"> | string
    examples?: JsonFilter<"Problem">
    constraints?: StringNullableListFilter<"Problem">
    starterCode?: JsonFilter<"Problem">
    solutions?: JsonNullableFilter<"Problem">
    testCases?: JsonNullableFilter<"Problem">
    pattern?: StringFilter<"Problem"> | string
    sheets?: StringNullableListFilter<"Problem">
    order?: IntFilter<"Problem"> | number
    createdAt?: DateTimeFilter<"Problem"> | Date | string
    progress?: UserProgressListRelationFilter
    submissions?: SubmissionListRelationFilter
  }, "id" | "slug">

  export type ProblemOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    difficulty?: SortOrder
    description?: SortOrder
    examples?: SortOrder
    constraints?: SortOrder
    starterCode?: SortOrder
    solutions?: SortOrderInput | SortOrder
    testCases?: SortOrderInput | SortOrder
    pattern?: SortOrder
    sheets?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    _count?: ProblemCountOrderByAggregateInput
    _avg?: ProblemAvgOrderByAggregateInput
    _max?: ProblemMaxOrderByAggregateInput
    _min?: ProblemMinOrderByAggregateInput
    _sum?: ProblemSumOrderByAggregateInput
  }

  export type ProblemScalarWhereWithAggregatesInput = {
    AND?: ProblemScalarWhereWithAggregatesInput | ProblemScalarWhereWithAggregatesInput[]
    OR?: ProblemScalarWhereWithAggregatesInput[]
    NOT?: ProblemScalarWhereWithAggregatesInput | ProblemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Problem"> | string
    title?: StringWithAggregatesFilter<"Problem"> | string
    slug?: StringWithAggregatesFilter<"Problem"> | string
    difficulty?: StringWithAggregatesFilter<"Problem"> | string
    description?: StringWithAggregatesFilter<"Problem"> | string
    examples?: JsonWithAggregatesFilter<"Problem">
    constraints?: StringNullableListFilter<"Problem">
    starterCode?: JsonWithAggregatesFilter<"Problem">
    solutions?: JsonNullableWithAggregatesFilter<"Problem">
    testCases?: JsonNullableWithAggregatesFilter<"Problem">
    pattern?: StringWithAggregatesFilter<"Problem"> | string
    sheets?: StringNullableListFilter<"Problem">
    order?: IntWithAggregatesFilter<"Problem"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Problem"> | Date | string
  }

  export type UserProgressWhereInput = {
    AND?: UserProgressWhereInput | UserProgressWhereInput[]
    OR?: UserProgressWhereInput[]
    NOT?: UserProgressWhereInput | UserProgressWhereInput[]
    id?: StringFilter<"UserProgress"> | string
    userId?: StringFilter<"UserProgress"> | string
    problemId?: StringFilter<"UserProgress"> | string
    status?: StringFilter<"UserProgress"> | string
    starred?: BoolFilter<"UserProgress"> | boolean
    lastAttempt?: DateTimeFilter<"UserProgress"> | Date | string
    createdAt?: DateTimeFilter<"UserProgress"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    problem?: XOR<ProblemRelationFilter, ProblemWhereInput>
  }

  export type UserProgressOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    problemId?: SortOrder
    status?: SortOrder
    starred?: SortOrder
    lastAttempt?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    problem?: ProblemOrderByWithRelationInput
  }

  export type UserProgressWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_problemId?: UserProgressUserIdProblemIdCompoundUniqueInput
    AND?: UserProgressWhereInput | UserProgressWhereInput[]
    OR?: UserProgressWhereInput[]
    NOT?: UserProgressWhereInput | UserProgressWhereInput[]
    userId?: StringFilter<"UserProgress"> | string
    problemId?: StringFilter<"UserProgress"> | string
    status?: StringFilter<"UserProgress"> | string
    starred?: BoolFilter<"UserProgress"> | boolean
    lastAttempt?: DateTimeFilter<"UserProgress"> | Date | string
    createdAt?: DateTimeFilter<"UserProgress"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    problem?: XOR<ProblemRelationFilter, ProblemWhereInput>
  }, "id" | "userId_problemId">

  export type UserProgressOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    problemId?: SortOrder
    status?: SortOrder
    starred?: SortOrder
    lastAttempt?: SortOrder
    createdAt?: SortOrder
    _count?: UserProgressCountOrderByAggregateInput
    _max?: UserProgressMaxOrderByAggregateInput
    _min?: UserProgressMinOrderByAggregateInput
  }

  export type UserProgressScalarWhereWithAggregatesInput = {
    AND?: UserProgressScalarWhereWithAggregatesInput | UserProgressScalarWhereWithAggregatesInput[]
    OR?: UserProgressScalarWhereWithAggregatesInput[]
    NOT?: UserProgressScalarWhereWithAggregatesInput | UserProgressScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserProgress"> | string
    userId?: StringWithAggregatesFilter<"UserProgress"> | string
    problemId?: StringWithAggregatesFilter<"UserProgress"> | string
    status?: StringWithAggregatesFilter<"UserProgress"> | string
    starred?: BoolWithAggregatesFilter<"UserProgress"> | boolean
    lastAttempt?: DateTimeWithAggregatesFilter<"UserProgress"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"UserProgress"> | Date | string
  }

  export type SubmissionWhereInput = {
    AND?: SubmissionWhereInput | SubmissionWhereInput[]
    OR?: SubmissionWhereInput[]
    NOT?: SubmissionWhereInput | SubmissionWhereInput[]
    id?: StringFilter<"Submission"> | string
    userId?: StringFilter<"Submission"> | string
    problemId?: StringFilter<"Submission"> | string
    code?: StringFilter<"Submission"> | string
    language?: StringFilter<"Submission"> | string
    status?: StringFilter<"Submission"> | string
    runtime?: IntNullableFilter<"Submission"> | number | null
    memory?: IntNullableFilter<"Submission"> | number | null
    createdAt?: DateTimeFilter<"Submission"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    problem?: XOR<ProblemRelationFilter, ProblemWhereInput>
  }

  export type SubmissionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    problemId?: SortOrder
    code?: SortOrder
    language?: SortOrder
    status?: SortOrder
    runtime?: SortOrderInput | SortOrder
    memory?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    problem?: ProblemOrderByWithRelationInput
  }

  export type SubmissionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SubmissionWhereInput | SubmissionWhereInput[]
    OR?: SubmissionWhereInput[]
    NOT?: SubmissionWhereInput | SubmissionWhereInput[]
    userId?: StringFilter<"Submission"> | string
    problemId?: StringFilter<"Submission"> | string
    code?: StringFilter<"Submission"> | string
    language?: StringFilter<"Submission"> | string
    status?: StringFilter<"Submission"> | string
    runtime?: IntNullableFilter<"Submission"> | number | null
    memory?: IntNullableFilter<"Submission"> | number | null
    createdAt?: DateTimeFilter<"Submission"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    problem?: XOR<ProblemRelationFilter, ProblemWhereInput>
  }, "id">

  export type SubmissionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    problemId?: SortOrder
    code?: SortOrder
    language?: SortOrder
    status?: SortOrder
    runtime?: SortOrderInput | SortOrder
    memory?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: SubmissionCountOrderByAggregateInput
    _avg?: SubmissionAvgOrderByAggregateInput
    _max?: SubmissionMaxOrderByAggregateInput
    _min?: SubmissionMinOrderByAggregateInput
    _sum?: SubmissionSumOrderByAggregateInput
  }

  export type SubmissionScalarWhereWithAggregatesInput = {
    AND?: SubmissionScalarWhereWithAggregatesInput | SubmissionScalarWhereWithAggregatesInput[]
    OR?: SubmissionScalarWhereWithAggregatesInput[]
    NOT?: SubmissionScalarWhereWithAggregatesInput | SubmissionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Submission"> | string
    userId?: StringWithAggregatesFilter<"Submission"> | string
    problemId?: StringWithAggregatesFilter<"Submission"> | string
    code?: StringWithAggregatesFilter<"Submission"> | string
    language?: StringWithAggregatesFilter<"Submission"> | string
    status?: StringWithAggregatesFilter<"Submission"> | string
    runtime?: IntNullableWithAggregatesFilter<"Submission"> | number | null
    memory?: IntNullableWithAggregatesFilter<"Submission"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Submission"> | Date | string
  }

  export type LearnDomainWhereInput = {
    AND?: LearnDomainWhereInput | LearnDomainWhereInput[]
    OR?: LearnDomainWhereInput[]
    NOT?: LearnDomainWhereInput | LearnDomainWhereInput[]
    id?: StringFilter<"LearnDomain"> | string
    slug?: StringFilter<"LearnDomain"> | string
    title?: StringFilter<"LearnDomain"> | string
    createdAt?: DateTimeFilter<"LearnDomain"> | Date | string
    categories?: LearnCategoryListRelationFilter
  }

  export type LearnDomainOrderByWithRelationInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    categories?: LearnCategoryOrderByRelationAggregateInput
  }

  export type LearnDomainWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: LearnDomainWhereInput | LearnDomainWhereInput[]
    OR?: LearnDomainWhereInput[]
    NOT?: LearnDomainWhereInput | LearnDomainWhereInput[]
    title?: StringFilter<"LearnDomain"> | string
    createdAt?: DateTimeFilter<"LearnDomain"> | Date | string
    categories?: LearnCategoryListRelationFilter
  }, "id" | "slug">

  export type LearnDomainOrderByWithAggregationInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    _count?: LearnDomainCountOrderByAggregateInput
    _max?: LearnDomainMaxOrderByAggregateInput
    _min?: LearnDomainMinOrderByAggregateInput
  }

  export type LearnDomainScalarWhereWithAggregatesInput = {
    AND?: LearnDomainScalarWhereWithAggregatesInput | LearnDomainScalarWhereWithAggregatesInput[]
    OR?: LearnDomainScalarWhereWithAggregatesInput[]
    NOT?: LearnDomainScalarWhereWithAggregatesInput | LearnDomainScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LearnDomain"> | string
    slug?: StringWithAggregatesFilter<"LearnDomain"> | string
    title?: StringWithAggregatesFilter<"LearnDomain"> | string
    createdAt?: DateTimeWithAggregatesFilter<"LearnDomain"> | Date | string
  }

  export type LearnCategoryWhereInput = {
    AND?: LearnCategoryWhereInput | LearnCategoryWhereInput[]
    OR?: LearnCategoryWhereInput[]
    NOT?: LearnCategoryWhereInput | LearnCategoryWhereInput[]
    id?: StringFilter<"LearnCategory"> | string
    title?: StringFilter<"LearnCategory"> | string
    order?: IntFilter<"LearnCategory"> | number
    domainId?: StringFilter<"LearnCategory"> | string
    domain?: XOR<LearnDomainRelationFilter, LearnDomainWhereInput>
    topics?: LearnTopicListRelationFilter
  }

  export type LearnCategoryOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    order?: SortOrder
    domainId?: SortOrder
    domain?: LearnDomainOrderByWithRelationInput
    topics?: LearnTopicOrderByRelationAggregateInput
  }

  export type LearnCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LearnCategoryWhereInput | LearnCategoryWhereInput[]
    OR?: LearnCategoryWhereInput[]
    NOT?: LearnCategoryWhereInput | LearnCategoryWhereInput[]
    title?: StringFilter<"LearnCategory"> | string
    order?: IntFilter<"LearnCategory"> | number
    domainId?: StringFilter<"LearnCategory"> | string
    domain?: XOR<LearnDomainRelationFilter, LearnDomainWhereInput>
    topics?: LearnTopicListRelationFilter
  }, "id">

  export type LearnCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    order?: SortOrder
    domainId?: SortOrder
    _count?: LearnCategoryCountOrderByAggregateInput
    _avg?: LearnCategoryAvgOrderByAggregateInput
    _max?: LearnCategoryMaxOrderByAggregateInput
    _min?: LearnCategoryMinOrderByAggregateInput
    _sum?: LearnCategorySumOrderByAggregateInput
  }

  export type LearnCategoryScalarWhereWithAggregatesInput = {
    AND?: LearnCategoryScalarWhereWithAggregatesInput | LearnCategoryScalarWhereWithAggregatesInput[]
    OR?: LearnCategoryScalarWhereWithAggregatesInput[]
    NOT?: LearnCategoryScalarWhereWithAggregatesInput | LearnCategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LearnCategory"> | string
    title?: StringWithAggregatesFilter<"LearnCategory"> | string
    order?: IntWithAggregatesFilter<"LearnCategory"> | number
    domainId?: StringWithAggregatesFilter<"LearnCategory"> | string
  }

  export type LearnTopicWhereInput = {
    AND?: LearnTopicWhereInput | LearnTopicWhereInput[]
    OR?: LearnTopicWhereInput[]
    NOT?: LearnTopicWhereInput | LearnTopicWhereInput[]
    id?: StringFilter<"LearnTopic"> | string
    title?: StringFilter<"LearnTopic"> | string
    slug?: StringFilter<"LearnTopic"> | string
    order?: IntFilter<"LearnTopic"> | number
    content?: StringFilter<"LearnTopic"> | string
    categoryId?: StringFilter<"LearnTopic"> | string
    createdAt?: DateTimeFilter<"LearnTopic"> | Date | string
    category?: XOR<LearnCategoryRelationFilter, LearnCategoryWhereInput>
  }

  export type LearnTopicOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    order?: SortOrder
    content?: SortOrder
    categoryId?: SortOrder
    createdAt?: SortOrder
    category?: LearnCategoryOrderByWithRelationInput
  }

  export type LearnTopicWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: LearnTopicWhereInput | LearnTopicWhereInput[]
    OR?: LearnTopicWhereInput[]
    NOT?: LearnTopicWhereInput | LearnTopicWhereInput[]
    title?: StringFilter<"LearnTopic"> | string
    order?: IntFilter<"LearnTopic"> | number
    content?: StringFilter<"LearnTopic"> | string
    categoryId?: StringFilter<"LearnTopic"> | string
    createdAt?: DateTimeFilter<"LearnTopic"> | Date | string
    category?: XOR<LearnCategoryRelationFilter, LearnCategoryWhereInput>
  }, "id" | "slug">

  export type LearnTopicOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    order?: SortOrder
    content?: SortOrder
    categoryId?: SortOrder
    createdAt?: SortOrder
    _count?: LearnTopicCountOrderByAggregateInput
    _avg?: LearnTopicAvgOrderByAggregateInput
    _max?: LearnTopicMaxOrderByAggregateInput
    _min?: LearnTopicMinOrderByAggregateInput
    _sum?: LearnTopicSumOrderByAggregateInput
  }

  export type LearnTopicScalarWhereWithAggregatesInput = {
    AND?: LearnTopicScalarWhereWithAggregatesInput | LearnTopicScalarWhereWithAggregatesInput[]
    OR?: LearnTopicScalarWhereWithAggregatesInput[]
    NOT?: LearnTopicScalarWhereWithAggregatesInput | LearnTopicScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LearnTopic"> | string
    title?: StringWithAggregatesFilter<"LearnTopic"> | string
    slug?: StringWithAggregatesFilter<"LearnTopic"> | string
    order?: IntWithAggregatesFilter<"LearnTopic"> | number
    content?: StringWithAggregatesFilter<"LearnTopic"> | string
    categoryId?: StringWithAggregatesFilter<"LearnTopic"> | string
    createdAt?: DateTimeWithAggregatesFilter<"LearnTopic"> | Date | string
  }

  export type InterviewSessionWhereInput = {
    AND?: InterviewSessionWhereInput | InterviewSessionWhereInput[]
    OR?: InterviewSessionWhereInput[]
    NOT?: InterviewSessionWhereInput | InterviewSessionWhereInput[]
    id?: StringFilter<"InterviewSession"> | string
    userId?: StringFilter<"InterviewSession"> | string
    role?: StringFilter<"InterviewSession"> | string
    duration?: IntFilter<"InterviewSession"> | number
    status?: StringFilter<"InterviewSession"> | string
    resumeSnapshot?: StringFilter<"InterviewSession"> | string
    jobDescription?: StringNullableFilter<"InterviewSession"> | string | null
    resumeSummary?: StringNullableFilter<"InterviewSession"> | string | null
    jdSummary?: StringNullableFilter<"InterviewSession"> | string | null
    vapiCallId?: StringNullableFilter<"InterviewSession"> | string | null
    vapiAssistantId?: StringNullableFilter<"InterviewSession"> | string | null
    transcript?: JsonNullableFilter<"InterviewSession">
    videoUrl?: StringNullableFilter<"InterviewSession"> | string | null
    videoRecorded?: BoolFilter<"InterviewSession"> | boolean
    createdAt?: DateTimeFilter<"InterviewSession"> | Date | string
    startedAt?: DateTimeNullableFilter<"InterviewSession"> | Date | string | null
    endedAt?: DateTimeNullableFilter<"InterviewSession"> | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    feedback?: XOR<InterviewFeedbackNullableRelationFilter, InterviewFeedbackWhereInput> | null
    sharedResult?: XOR<SharedInterviewResultNullableRelationFilter, SharedInterviewResultWhereInput> | null
  }

  export type InterviewSessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    duration?: SortOrder
    status?: SortOrder
    resumeSnapshot?: SortOrder
    jobDescription?: SortOrderInput | SortOrder
    resumeSummary?: SortOrderInput | SortOrder
    jdSummary?: SortOrderInput | SortOrder
    vapiCallId?: SortOrderInput | SortOrder
    vapiAssistantId?: SortOrderInput | SortOrder
    transcript?: SortOrderInput | SortOrder
    videoUrl?: SortOrderInput | SortOrder
    videoRecorded?: SortOrder
    createdAt?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    endedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    feedback?: InterviewFeedbackOrderByWithRelationInput
    sharedResult?: SharedInterviewResultOrderByWithRelationInput
  }

  export type InterviewSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InterviewSessionWhereInput | InterviewSessionWhereInput[]
    OR?: InterviewSessionWhereInput[]
    NOT?: InterviewSessionWhereInput | InterviewSessionWhereInput[]
    userId?: StringFilter<"InterviewSession"> | string
    role?: StringFilter<"InterviewSession"> | string
    duration?: IntFilter<"InterviewSession"> | number
    status?: StringFilter<"InterviewSession"> | string
    resumeSnapshot?: StringFilter<"InterviewSession"> | string
    jobDescription?: StringNullableFilter<"InterviewSession"> | string | null
    resumeSummary?: StringNullableFilter<"InterviewSession"> | string | null
    jdSummary?: StringNullableFilter<"InterviewSession"> | string | null
    vapiCallId?: StringNullableFilter<"InterviewSession"> | string | null
    vapiAssistantId?: StringNullableFilter<"InterviewSession"> | string | null
    transcript?: JsonNullableFilter<"InterviewSession">
    videoUrl?: StringNullableFilter<"InterviewSession"> | string | null
    videoRecorded?: BoolFilter<"InterviewSession"> | boolean
    createdAt?: DateTimeFilter<"InterviewSession"> | Date | string
    startedAt?: DateTimeNullableFilter<"InterviewSession"> | Date | string | null
    endedAt?: DateTimeNullableFilter<"InterviewSession"> | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    feedback?: XOR<InterviewFeedbackNullableRelationFilter, InterviewFeedbackWhereInput> | null
    sharedResult?: XOR<SharedInterviewResultNullableRelationFilter, SharedInterviewResultWhereInput> | null
  }, "id">

  export type InterviewSessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    duration?: SortOrder
    status?: SortOrder
    resumeSnapshot?: SortOrder
    jobDescription?: SortOrderInput | SortOrder
    resumeSummary?: SortOrderInput | SortOrder
    jdSummary?: SortOrderInput | SortOrder
    vapiCallId?: SortOrderInput | SortOrder
    vapiAssistantId?: SortOrderInput | SortOrder
    transcript?: SortOrderInput | SortOrder
    videoUrl?: SortOrderInput | SortOrder
    videoRecorded?: SortOrder
    createdAt?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    endedAt?: SortOrderInput | SortOrder
    _count?: InterviewSessionCountOrderByAggregateInput
    _avg?: InterviewSessionAvgOrderByAggregateInput
    _max?: InterviewSessionMaxOrderByAggregateInput
    _min?: InterviewSessionMinOrderByAggregateInput
    _sum?: InterviewSessionSumOrderByAggregateInput
  }

  export type InterviewSessionScalarWhereWithAggregatesInput = {
    AND?: InterviewSessionScalarWhereWithAggregatesInput | InterviewSessionScalarWhereWithAggregatesInput[]
    OR?: InterviewSessionScalarWhereWithAggregatesInput[]
    NOT?: InterviewSessionScalarWhereWithAggregatesInput | InterviewSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InterviewSession"> | string
    userId?: StringWithAggregatesFilter<"InterviewSession"> | string
    role?: StringWithAggregatesFilter<"InterviewSession"> | string
    duration?: IntWithAggregatesFilter<"InterviewSession"> | number
    status?: StringWithAggregatesFilter<"InterviewSession"> | string
    resumeSnapshot?: StringWithAggregatesFilter<"InterviewSession"> | string
    jobDescription?: StringNullableWithAggregatesFilter<"InterviewSession"> | string | null
    resumeSummary?: StringNullableWithAggregatesFilter<"InterviewSession"> | string | null
    jdSummary?: StringNullableWithAggregatesFilter<"InterviewSession"> | string | null
    vapiCallId?: StringNullableWithAggregatesFilter<"InterviewSession"> | string | null
    vapiAssistantId?: StringNullableWithAggregatesFilter<"InterviewSession"> | string | null
    transcript?: JsonNullableWithAggregatesFilter<"InterviewSession">
    videoUrl?: StringNullableWithAggregatesFilter<"InterviewSession"> | string | null
    videoRecorded?: BoolWithAggregatesFilter<"InterviewSession"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"InterviewSession"> | Date | string
    startedAt?: DateTimeNullableWithAggregatesFilter<"InterviewSession"> | Date | string | null
    endedAt?: DateTimeNullableWithAggregatesFilter<"InterviewSession"> | Date | string | null
  }

  export type InterviewFeedbackWhereInput = {
    AND?: InterviewFeedbackWhereInput | InterviewFeedbackWhereInput[]
    OR?: InterviewFeedbackWhereInput[]
    NOT?: InterviewFeedbackWhereInput | InterviewFeedbackWhereInput[]
    id?: StringFilter<"InterviewFeedback"> | string
    sessionId?: StringFilter<"InterviewFeedback"> | string
    overallScore?: IntFilter<"InterviewFeedback"> | number
    communicationClarity?: IntFilter<"InterviewFeedback"> | number
    technicalDepth?: IntFilter<"InterviewFeedback"> | number
    confidence?: IntFilter<"InterviewFeedback"> | number
    roleAlignment?: IntFilter<"InterviewFeedback"> | number
    skillRatings?: JsonFilter<"InterviewFeedback">
    strengths?: StringNullableListFilter<"InterviewFeedback">
    weaknesses?: StringNullableListFilter<"InterviewFeedback">
    improvements?: StringNullableListFilter<"InterviewFeedback">
    suggestedTopics?: StringNullableListFilter<"InterviewFeedback">
    learningRoadmap?: StringFilter<"InterviewFeedback"> | string
    aiSummary?: StringFilter<"InterviewFeedback"> | string
    createdAt?: DateTimeFilter<"InterviewFeedback"> | Date | string
    session?: XOR<InterviewSessionRelationFilter, InterviewSessionWhereInput>
  }

  export type InterviewFeedbackOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    overallScore?: SortOrder
    communicationClarity?: SortOrder
    technicalDepth?: SortOrder
    confidence?: SortOrder
    roleAlignment?: SortOrder
    skillRatings?: SortOrder
    strengths?: SortOrder
    weaknesses?: SortOrder
    improvements?: SortOrder
    suggestedTopics?: SortOrder
    learningRoadmap?: SortOrder
    aiSummary?: SortOrder
    createdAt?: SortOrder
    session?: InterviewSessionOrderByWithRelationInput
  }

  export type InterviewFeedbackWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sessionId?: string
    AND?: InterviewFeedbackWhereInput | InterviewFeedbackWhereInput[]
    OR?: InterviewFeedbackWhereInput[]
    NOT?: InterviewFeedbackWhereInput | InterviewFeedbackWhereInput[]
    overallScore?: IntFilter<"InterviewFeedback"> | number
    communicationClarity?: IntFilter<"InterviewFeedback"> | number
    technicalDepth?: IntFilter<"InterviewFeedback"> | number
    confidence?: IntFilter<"InterviewFeedback"> | number
    roleAlignment?: IntFilter<"InterviewFeedback"> | number
    skillRatings?: JsonFilter<"InterviewFeedback">
    strengths?: StringNullableListFilter<"InterviewFeedback">
    weaknesses?: StringNullableListFilter<"InterviewFeedback">
    improvements?: StringNullableListFilter<"InterviewFeedback">
    suggestedTopics?: StringNullableListFilter<"InterviewFeedback">
    learningRoadmap?: StringFilter<"InterviewFeedback"> | string
    aiSummary?: StringFilter<"InterviewFeedback"> | string
    createdAt?: DateTimeFilter<"InterviewFeedback"> | Date | string
    session?: XOR<InterviewSessionRelationFilter, InterviewSessionWhereInput>
  }, "id" | "sessionId">

  export type InterviewFeedbackOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    overallScore?: SortOrder
    communicationClarity?: SortOrder
    technicalDepth?: SortOrder
    confidence?: SortOrder
    roleAlignment?: SortOrder
    skillRatings?: SortOrder
    strengths?: SortOrder
    weaknesses?: SortOrder
    improvements?: SortOrder
    suggestedTopics?: SortOrder
    learningRoadmap?: SortOrder
    aiSummary?: SortOrder
    createdAt?: SortOrder
    _count?: InterviewFeedbackCountOrderByAggregateInput
    _avg?: InterviewFeedbackAvgOrderByAggregateInput
    _max?: InterviewFeedbackMaxOrderByAggregateInput
    _min?: InterviewFeedbackMinOrderByAggregateInput
    _sum?: InterviewFeedbackSumOrderByAggregateInput
  }

  export type InterviewFeedbackScalarWhereWithAggregatesInput = {
    AND?: InterviewFeedbackScalarWhereWithAggregatesInput | InterviewFeedbackScalarWhereWithAggregatesInput[]
    OR?: InterviewFeedbackScalarWhereWithAggregatesInput[]
    NOT?: InterviewFeedbackScalarWhereWithAggregatesInput | InterviewFeedbackScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InterviewFeedback"> | string
    sessionId?: StringWithAggregatesFilter<"InterviewFeedback"> | string
    overallScore?: IntWithAggregatesFilter<"InterviewFeedback"> | number
    communicationClarity?: IntWithAggregatesFilter<"InterviewFeedback"> | number
    technicalDepth?: IntWithAggregatesFilter<"InterviewFeedback"> | number
    confidence?: IntWithAggregatesFilter<"InterviewFeedback"> | number
    roleAlignment?: IntWithAggregatesFilter<"InterviewFeedback"> | number
    skillRatings?: JsonWithAggregatesFilter<"InterviewFeedback">
    strengths?: StringNullableListFilter<"InterviewFeedback">
    weaknesses?: StringNullableListFilter<"InterviewFeedback">
    improvements?: StringNullableListFilter<"InterviewFeedback">
    suggestedTopics?: StringNullableListFilter<"InterviewFeedback">
    learningRoadmap?: StringWithAggregatesFilter<"InterviewFeedback"> | string
    aiSummary?: StringWithAggregatesFilter<"InterviewFeedback"> | string
    createdAt?: DateTimeWithAggregatesFilter<"InterviewFeedback"> | Date | string
  }

  export type QuestionBankWhereInput = {
    AND?: QuestionBankWhereInput | QuestionBankWhereInput[]
    OR?: QuestionBankWhereInput[]
    NOT?: QuestionBankWhereInput | QuestionBankWhereInput[]
    id?: StringFilter<"QuestionBank"> | string
    role?: StringFilter<"QuestionBank"> | string
    difficulty?: StringFilter<"QuestionBank"> | string
    category?: StringFilter<"QuestionBank"> | string
    question?: StringFilter<"QuestionBank"> | string
    followUps?: StringNullableListFilter<"QuestionBank">
    keyPoints?: StringNullableListFilter<"QuestionBank">
    tags?: StringNullableListFilter<"QuestionBank">
    active?: BoolFilter<"QuestionBank"> | boolean
    usageCount?: IntFilter<"QuestionBank"> | number
    createdAt?: DateTimeFilter<"QuestionBank"> | Date | string
    updatedAt?: DateTimeFilter<"QuestionBank"> | Date | string
  }

  export type QuestionBankOrderByWithRelationInput = {
    id?: SortOrder
    role?: SortOrder
    difficulty?: SortOrder
    category?: SortOrder
    question?: SortOrder
    followUps?: SortOrder
    keyPoints?: SortOrder
    tags?: SortOrder
    active?: SortOrder
    usageCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuestionBankWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: QuestionBankWhereInput | QuestionBankWhereInput[]
    OR?: QuestionBankWhereInput[]
    NOT?: QuestionBankWhereInput | QuestionBankWhereInput[]
    role?: StringFilter<"QuestionBank"> | string
    difficulty?: StringFilter<"QuestionBank"> | string
    category?: StringFilter<"QuestionBank"> | string
    question?: StringFilter<"QuestionBank"> | string
    followUps?: StringNullableListFilter<"QuestionBank">
    keyPoints?: StringNullableListFilter<"QuestionBank">
    tags?: StringNullableListFilter<"QuestionBank">
    active?: BoolFilter<"QuestionBank"> | boolean
    usageCount?: IntFilter<"QuestionBank"> | number
    createdAt?: DateTimeFilter<"QuestionBank"> | Date | string
    updatedAt?: DateTimeFilter<"QuestionBank"> | Date | string
  }, "id">

  export type QuestionBankOrderByWithAggregationInput = {
    id?: SortOrder
    role?: SortOrder
    difficulty?: SortOrder
    category?: SortOrder
    question?: SortOrder
    followUps?: SortOrder
    keyPoints?: SortOrder
    tags?: SortOrder
    active?: SortOrder
    usageCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: QuestionBankCountOrderByAggregateInput
    _avg?: QuestionBankAvgOrderByAggregateInput
    _max?: QuestionBankMaxOrderByAggregateInput
    _min?: QuestionBankMinOrderByAggregateInput
    _sum?: QuestionBankSumOrderByAggregateInput
  }

  export type QuestionBankScalarWhereWithAggregatesInput = {
    AND?: QuestionBankScalarWhereWithAggregatesInput | QuestionBankScalarWhereWithAggregatesInput[]
    OR?: QuestionBankScalarWhereWithAggregatesInput[]
    NOT?: QuestionBankScalarWhereWithAggregatesInput | QuestionBankScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"QuestionBank"> | string
    role?: StringWithAggregatesFilter<"QuestionBank"> | string
    difficulty?: StringWithAggregatesFilter<"QuestionBank"> | string
    category?: StringWithAggregatesFilter<"QuestionBank"> | string
    question?: StringWithAggregatesFilter<"QuestionBank"> | string
    followUps?: StringNullableListFilter<"QuestionBank">
    keyPoints?: StringNullableListFilter<"QuestionBank">
    tags?: StringNullableListFilter<"QuestionBank">
    active?: BoolWithAggregatesFilter<"QuestionBank"> | boolean
    usageCount?: IntWithAggregatesFilter<"QuestionBank"> | number
    createdAt?: DateTimeWithAggregatesFilter<"QuestionBank"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"QuestionBank"> | Date | string
  }

  export type SharedInterviewResultWhereInput = {
    AND?: SharedInterviewResultWhereInput | SharedInterviewResultWhereInput[]
    OR?: SharedInterviewResultWhereInput[]
    NOT?: SharedInterviewResultWhereInput | SharedInterviewResultWhereInput[]
    id?: StringFilter<"SharedInterviewResult"> | string
    sessionId?: StringFilter<"SharedInterviewResult"> | string
    userId?: StringFilter<"SharedInterviewResult"> | string
    shareToken?: StringFilter<"SharedInterviewResult"> | string
    isPublic?: BoolFilter<"SharedInterviewResult"> | boolean
    expiresAt?: DateTimeNullableFilter<"SharedInterviewResult"> | Date | string | null
    viewCount?: IntFilter<"SharedInterviewResult"> | number
    lastViewedAt?: DateTimeNullableFilter<"SharedInterviewResult"> | Date | string | null
    createdAt?: DateTimeFilter<"SharedInterviewResult"> | Date | string
    session?: XOR<InterviewSessionRelationFilter, InterviewSessionWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type SharedInterviewResultOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrder
    shareToken?: SortOrder
    isPublic?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    viewCount?: SortOrder
    lastViewedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    session?: InterviewSessionOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type SharedInterviewResultWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sessionId?: string
    shareToken?: string
    AND?: SharedInterviewResultWhereInput | SharedInterviewResultWhereInput[]
    OR?: SharedInterviewResultWhereInput[]
    NOT?: SharedInterviewResultWhereInput | SharedInterviewResultWhereInput[]
    userId?: StringFilter<"SharedInterviewResult"> | string
    isPublic?: BoolFilter<"SharedInterviewResult"> | boolean
    expiresAt?: DateTimeNullableFilter<"SharedInterviewResult"> | Date | string | null
    viewCount?: IntFilter<"SharedInterviewResult"> | number
    lastViewedAt?: DateTimeNullableFilter<"SharedInterviewResult"> | Date | string | null
    createdAt?: DateTimeFilter<"SharedInterviewResult"> | Date | string
    session?: XOR<InterviewSessionRelationFilter, InterviewSessionWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "sessionId" | "shareToken">

  export type SharedInterviewResultOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrder
    shareToken?: SortOrder
    isPublic?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    viewCount?: SortOrder
    lastViewedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: SharedInterviewResultCountOrderByAggregateInput
    _avg?: SharedInterviewResultAvgOrderByAggregateInput
    _max?: SharedInterviewResultMaxOrderByAggregateInput
    _min?: SharedInterviewResultMinOrderByAggregateInput
    _sum?: SharedInterviewResultSumOrderByAggregateInput
  }

  export type SharedInterviewResultScalarWhereWithAggregatesInput = {
    AND?: SharedInterviewResultScalarWhereWithAggregatesInput | SharedInterviewResultScalarWhereWithAggregatesInput[]
    OR?: SharedInterviewResultScalarWhereWithAggregatesInput[]
    NOT?: SharedInterviewResultScalarWhereWithAggregatesInput | SharedInterviewResultScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SharedInterviewResult"> | string
    sessionId?: StringWithAggregatesFilter<"SharedInterviewResult"> | string
    userId?: StringWithAggregatesFilter<"SharedInterviewResult"> | string
    shareToken?: StringWithAggregatesFilter<"SharedInterviewResult"> | string
    isPublic?: BoolWithAggregatesFilter<"SharedInterviewResult"> | boolean
    expiresAt?: DateTimeNullableWithAggregatesFilter<"SharedInterviewResult"> | Date | string | null
    viewCount?: IntWithAggregatesFilter<"SharedInterviewResult"> | number
    lastViewedAt?: DateTimeNullableWithAggregatesFilter<"SharedInterviewResult"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SharedInterviewResult"> | Date | string
  }

  export type InterviewAnalyticsWhereInput = {
    AND?: InterviewAnalyticsWhereInput | InterviewAnalyticsWhereInput[]
    OR?: InterviewAnalyticsWhereInput[]
    NOT?: InterviewAnalyticsWhereInput | InterviewAnalyticsWhereInput[]
    id?: StringFilter<"InterviewAnalytics"> | string
    userId?: StringFilter<"InterviewAnalytics"> | string
    totalInterviews?: IntFilter<"InterviewAnalytics"> | number
    averageScore?: FloatFilter<"InterviewAnalytics"> | number
    averageCommunication?: FloatFilter<"InterviewAnalytics"> | number
    averageTechnical?: FloatFilter<"InterviewAnalytics"> | number
    averageConfidence?: FloatFilter<"InterviewAnalytics"> | number
    roleStats?: JsonFilter<"InterviewAnalytics">
    monthlyScores?: JsonFilter<"InterviewAnalytics">
    topStrengths?: StringNullableListFilter<"InterviewAnalytics">
    topWeaknesses?: StringNullableListFilter<"InterviewAnalytics">
    lastUpdated?: DateTimeFilter<"InterviewAnalytics"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type InterviewAnalyticsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    totalInterviews?: SortOrder
    averageScore?: SortOrder
    averageCommunication?: SortOrder
    averageTechnical?: SortOrder
    averageConfidence?: SortOrder
    roleStats?: SortOrder
    monthlyScores?: SortOrder
    topStrengths?: SortOrder
    topWeaknesses?: SortOrder
    lastUpdated?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type InterviewAnalyticsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: InterviewAnalyticsWhereInput | InterviewAnalyticsWhereInput[]
    OR?: InterviewAnalyticsWhereInput[]
    NOT?: InterviewAnalyticsWhereInput | InterviewAnalyticsWhereInput[]
    totalInterviews?: IntFilter<"InterviewAnalytics"> | number
    averageScore?: FloatFilter<"InterviewAnalytics"> | number
    averageCommunication?: FloatFilter<"InterviewAnalytics"> | number
    averageTechnical?: FloatFilter<"InterviewAnalytics"> | number
    averageConfidence?: FloatFilter<"InterviewAnalytics"> | number
    roleStats?: JsonFilter<"InterviewAnalytics">
    monthlyScores?: JsonFilter<"InterviewAnalytics">
    topStrengths?: StringNullableListFilter<"InterviewAnalytics">
    topWeaknesses?: StringNullableListFilter<"InterviewAnalytics">
    lastUpdated?: DateTimeFilter<"InterviewAnalytics"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type InterviewAnalyticsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    totalInterviews?: SortOrder
    averageScore?: SortOrder
    averageCommunication?: SortOrder
    averageTechnical?: SortOrder
    averageConfidence?: SortOrder
    roleStats?: SortOrder
    monthlyScores?: SortOrder
    topStrengths?: SortOrder
    topWeaknesses?: SortOrder
    lastUpdated?: SortOrder
    _count?: InterviewAnalyticsCountOrderByAggregateInput
    _avg?: InterviewAnalyticsAvgOrderByAggregateInput
    _max?: InterviewAnalyticsMaxOrderByAggregateInput
    _min?: InterviewAnalyticsMinOrderByAggregateInput
    _sum?: InterviewAnalyticsSumOrderByAggregateInput
  }

  export type InterviewAnalyticsScalarWhereWithAggregatesInput = {
    AND?: InterviewAnalyticsScalarWhereWithAggregatesInput | InterviewAnalyticsScalarWhereWithAggregatesInput[]
    OR?: InterviewAnalyticsScalarWhereWithAggregatesInput[]
    NOT?: InterviewAnalyticsScalarWhereWithAggregatesInput | InterviewAnalyticsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InterviewAnalytics"> | string
    userId?: StringWithAggregatesFilter<"InterviewAnalytics"> | string
    totalInterviews?: IntWithAggregatesFilter<"InterviewAnalytics"> | number
    averageScore?: FloatWithAggregatesFilter<"InterviewAnalytics"> | number
    averageCommunication?: FloatWithAggregatesFilter<"InterviewAnalytics"> | number
    averageTechnical?: FloatWithAggregatesFilter<"InterviewAnalytics"> | number
    averageConfidence?: FloatWithAggregatesFilter<"InterviewAnalytics"> | number
    roleStats?: JsonWithAggregatesFilter<"InterviewAnalytics">
    monthlyScores?: JsonWithAggregatesFilter<"InterviewAnalytics">
    topStrengths?: StringNullableListFilter<"InterviewAnalytics">
    topWeaknesses?: StringNullableListFilter<"InterviewAnalytics">
    lastUpdated?: DateTimeWithAggregatesFilter<"InterviewAnalytics"> | Date | string
  }

  export type RoadmapWhereInput = {
    AND?: RoadmapWhereInput | RoadmapWhereInput[]
    OR?: RoadmapWhereInput[]
    NOT?: RoadmapWhereInput | RoadmapWhereInput[]
    id?: StringFilter<"Roadmap"> | string
    slug?: StringFilter<"Roadmap"> | string
    title?: StringFilter<"Roadmap"> | string
    description?: StringFilter<"Roadmap"> | string
    icon?: StringFilter<"Roadmap"> | string
    level?: StringFilter<"Roadmap"> | string
    duration?: StringFilter<"Roadmap"> | string
    gradient?: StringFilter<"Roadmap"> | string
    skills?: StringNullableListFilter<"Roadmap">
    popularity?: IntFilter<"Roadmap"> | number
    isActive?: BoolFilter<"Roadmap"> | boolean
    order?: IntFilter<"Roadmap"> | number
    createdAt?: DateTimeFilter<"Roadmap"> | Date | string
    updatedAt?: DateTimeFilter<"Roadmap"> | Date | string
    phases?: RoadmapPhaseListRelationFilter
    progress?: RoadmapProgressListRelationFilter
  }

  export type RoadmapOrderByWithRelationInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    level?: SortOrder
    duration?: SortOrder
    gradient?: SortOrder
    skills?: SortOrder
    popularity?: SortOrder
    isActive?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    phases?: RoadmapPhaseOrderByRelationAggregateInput
    progress?: RoadmapProgressOrderByRelationAggregateInput
  }

  export type RoadmapWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: RoadmapWhereInput | RoadmapWhereInput[]
    OR?: RoadmapWhereInput[]
    NOT?: RoadmapWhereInput | RoadmapWhereInput[]
    title?: StringFilter<"Roadmap"> | string
    description?: StringFilter<"Roadmap"> | string
    icon?: StringFilter<"Roadmap"> | string
    level?: StringFilter<"Roadmap"> | string
    duration?: StringFilter<"Roadmap"> | string
    gradient?: StringFilter<"Roadmap"> | string
    skills?: StringNullableListFilter<"Roadmap">
    popularity?: IntFilter<"Roadmap"> | number
    isActive?: BoolFilter<"Roadmap"> | boolean
    order?: IntFilter<"Roadmap"> | number
    createdAt?: DateTimeFilter<"Roadmap"> | Date | string
    updatedAt?: DateTimeFilter<"Roadmap"> | Date | string
    phases?: RoadmapPhaseListRelationFilter
    progress?: RoadmapProgressListRelationFilter
  }, "id" | "slug">

  export type RoadmapOrderByWithAggregationInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    level?: SortOrder
    duration?: SortOrder
    gradient?: SortOrder
    skills?: SortOrder
    popularity?: SortOrder
    isActive?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RoadmapCountOrderByAggregateInput
    _avg?: RoadmapAvgOrderByAggregateInput
    _max?: RoadmapMaxOrderByAggregateInput
    _min?: RoadmapMinOrderByAggregateInput
    _sum?: RoadmapSumOrderByAggregateInput
  }

  export type RoadmapScalarWhereWithAggregatesInput = {
    AND?: RoadmapScalarWhereWithAggregatesInput | RoadmapScalarWhereWithAggregatesInput[]
    OR?: RoadmapScalarWhereWithAggregatesInput[]
    NOT?: RoadmapScalarWhereWithAggregatesInput | RoadmapScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Roadmap"> | string
    slug?: StringWithAggregatesFilter<"Roadmap"> | string
    title?: StringWithAggregatesFilter<"Roadmap"> | string
    description?: StringWithAggregatesFilter<"Roadmap"> | string
    icon?: StringWithAggregatesFilter<"Roadmap"> | string
    level?: StringWithAggregatesFilter<"Roadmap"> | string
    duration?: StringWithAggregatesFilter<"Roadmap"> | string
    gradient?: StringWithAggregatesFilter<"Roadmap"> | string
    skills?: StringNullableListFilter<"Roadmap">
    popularity?: IntWithAggregatesFilter<"Roadmap"> | number
    isActive?: BoolWithAggregatesFilter<"Roadmap"> | boolean
    order?: IntWithAggregatesFilter<"Roadmap"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Roadmap"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Roadmap"> | Date | string
  }

  export type RoadmapPhaseWhereInput = {
    AND?: RoadmapPhaseWhereInput | RoadmapPhaseWhereInput[]
    OR?: RoadmapPhaseWhereInput[]
    NOT?: RoadmapPhaseWhereInput | RoadmapPhaseWhereInput[]
    id?: StringFilter<"RoadmapPhase"> | string
    roadmapId?: StringFilter<"RoadmapPhase"> | string
    title?: StringFilter<"RoadmapPhase"> | string
    description?: StringFilter<"RoadmapPhase"> | string
    order?: IntFilter<"RoadmapPhase"> | number
    roadmap?: XOR<RoadmapRelationFilter, RoadmapWhereInput>
    steps?: RoadmapStepListRelationFilter
  }

  export type RoadmapPhaseOrderByWithRelationInput = {
    id?: SortOrder
    roadmapId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    order?: SortOrder
    roadmap?: RoadmapOrderByWithRelationInput
    steps?: RoadmapStepOrderByRelationAggregateInput
  }

  export type RoadmapPhaseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RoadmapPhaseWhereInput | RoadmapPhaseWhereInput[]
    OR?: RoadmapPhaseWhereInput[]
    NOT?: RoadmapPhaseWhereInput | RoadmapPhaseWhereInput[]
    roadmapId?: StringFilter<"RoadmapPhase"> | string
    title?: StringFilter<"RoadmapPhase"> | string
    description?: StringFilter<"RoadmapPhase"> | string
    order?: IntFilter<"RoadmapPhase"> | number
    roadmap?: XOR<RoadmapRelationFilter, RoadmapWhereInput>
    steps?: RoadmapStepListRelationFilter
  }, "id">

  export type RoadmapPhaseOrderByWithAggregationInput = {
    id?: SortOrder
    roadmapId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    order?: SortOrder
    _count?: RoadmapPhaseCountOrderByAggregateInput
    _avg?: RoadmapPhaseAvgOrderByAggregateInput
    _max?: RoadmapPhaseMaxOrderByAggregateInput
    _min?: RoadmapPhaseMinOrderByAggregateInput
    _sum?: RoadmapPhaseSumOrderByAggregateInput
  }

  export type RoadmapPhaseScalarWhereWithAggregatesInput = {
    AND?: RoadmapPhaseScalarWhereWithAggregatesInput | RoadmapPhaseScalarWhereWithAggregatesInput[]
    OR?: RoadmapPhaseScalarWhereWithAggregatesInput[]
    NOT?: RoadmapPhaseScalarWhereWithAggregatesInput | RoadmapPhaseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RoadmapPhase"> | string
    roadmapId?: StringWithAggregatesFilter<"RoadmapPhase"> | string
    title?: StringWithAggregatesFilter<"RoadmapPhase"> | string
    description?: StringWithAggregatesFilter<"RoadmapPhase"> | string
    order?: IntWithAggregatesFilter<"RoadmapPhase"> | number
  }

  export type RoadmapStepWhereInput = {
    AND?: RoadmapStepWhereInput | RoadmapStepWhereInput[]
    OR?: RoadmapStepWhereInput[]
    NOT?: RoadmapStepWhereInput | RoadmapStepWhereInput[]
    id?: StringFilter<"RoadmapStep"> | string
    phaseId?: StringFilter<"RoadmapStep"> | string
    title?: StringFilter<"RoadmapStep"> | string
    description?: StringFilter<"RoadmapStep"> | string
    difficulty?: StringFilter<"RoadmapStep"> | string
    estimatedTime?: StringFilter<"RoadmapStep"> | string
    order?: IntFilter<"RoadmapStep"> | number
    topics?: StringNullableListFilter<"RoadmapStep">
    prerequisites?: StringNullableListFilter<"RoadmapStep">
    resources?: JsonFilter<"RoadmapStep">
    checkpoints?: StringNullableListFilter<"RoadmapStep">
    relatedCheatsheets?: StringNullableListFilter<"RoadmapStep">
    relatedDSA?: StringNullableListFilter<"RoadmapStep">
    relatedInterviews?: StringNullableListFilter<"RoadmapStep">
    createdAt?: DateTimeFilter<"RoadmapStep"> | Date | string
    updatedAt?: DateTimeFilter<"RoadmapStep"> | Date | string
    phase?: XOR<RoadmapPhaseRelationFilter, RoadmapPhaseWhereInput>
    progress?: RoadmapProgressListRelationFilter
  }

  export type RoadmapStepOrderByWithRelationInput = {
    id?: SortOrder
    phaseId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    difficulty?: SortOrder
    estimatedTime?: SortOrder
    order?: SortOrder
    topics?: SortOrder
    prerequisites?: SortOrder
    resources?: SortOrder
    checkpoints?: SortOrder
    relatedCheatsheets?: SortOrder
    relatedDSA?: SortOrder
    relatedInterviews?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    phase?: RoadmapPhaseOrderByWithRelationInput
    progress?: RoadmapProgressOrderByRelationAggregateInput
  }

  export type RoadmapStepWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RoadmapStepWhereInput | RoadmapStepWhereInput[]
    OR?: RoadmapStepWhereInput[]
    NOT?: RoadmapStepWhereInput | RoadmapStepWhereInput[]
    phaseId?: StringFilter<"RoadmapStep"> | string
    title?: StringFilter<"RoadmapStep"> | string
    description?: StringFilter<"RoadmapStep"> | string
    difficulty?: StringFilter<"RoadmapStep"> | string
    estimatedTime?: StringFilter<"RoadmapStep"> | string
    order?: IntFilter<"RoadmapStep"> | number
    topics?: StringNullableListFilter<"RoadmapStep">
    prerequisites?: StringNullableListFilter<"RoadmapStep">
    resources?: JsonFilter<"RoadmapStep">
    checkpoints?: StringNullableListFilter<"RoadmapStep">
    relatedCheatsheets?: StringNullableListFilter<"RoadmapStep">
    relatedDSA?: StringNullableListFilter<"RoadmapStep">
    relatedInterviews?: StringNullableListFilter<"RoadmapStep">
    createdAt?: DateTimeFilter<"RoadmapStep"> | Date | string
    updatedAt?: DateTimeFilter<"RoadmapStep"> | Date | string
    phase?: XOR<RoadmapPhaseRelationFilter, RoadmapPhaseWhereInput>
    progress?: RoadmapProgressListRelationFilter
  }, "id">

  export type RoadmapStepOrderByWithAggregationInput = {
    id?: SortOrder
    phaseId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    difficulty?: SortOrder
    estimatedTime?: SortOrder
    order?: SortOrder
    topics?: SortOrder
    prerequisites?: SortOrder
    resources?: SortOrder
    checkpoints?: SortOrder
    relatedCheatsheets?: SortOrder
    relatedDSA?: SortOrder
    relatedInterviews?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RoadmapStepCountOrderByAggregateInput
    _avg?: RoadmapStepAvgOrderByAggregateInput
    _max?: RoadmapStepMaxOrderByAggregateInput
    _min?: RoadmapStepMinOrderByAggregateInput
    _sum?: RoadmapStepSumOrderByAggregateInput
  }

  export type RoadmapStepScalarWhereWithAggregatesInput = {
    AND?: RoadmapStepScalarWhereWithAggregatesInput | RoadmapStepScalarWhereWithAggregatesInput[]
    OR?: RoadmapStepScalarWhereWithAggregatesInput[]
    NOT?: RoadmapStepScalarWhereWithAggregatesInput | RoadmapStepScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RoadmapStep"> | string
    phaseId?: StringWithAggregatesFilter<"RoadmapStep"> | string
    title?: StringWithAggregatesFilter<"RoadmapStep"> | string
    description?: StringWithAggregatesFilter<"RoadmapStep"> | string
    difficulty?: StringWithAggregatesFilter<"RoadmapStep"> | string
    estimatedTime?: StringWithAggregatesFilter<"RoadmapStep"> | string
    order?: IntWithAggregatesFilter<"RoadmapStep"> | number
    topics?: StringNullableListFilter<"RoadmapStep">
    prerequisites?: StringNullableListFilter<"RoadmapStep">
    resources?: JsonWithAggregatesFilter<"RoadmapStep">
    checkpoints?: StringNullableListFilter<"RoadmapStep">
    relatedCheatsheets?: StringNullableListFilter<"RoadmapStep">
    relatedDSA?: StringNullableListFilter<"RoadmapStep">
    relatedInterviews?: StringNullableListFilter<"RoadmapStep">
    createdAt?: DateTimeWithAggregatesFilter<"RoadmapStep"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RoadmapStep"> | Date | string
  }

  export type RoadmapProgressWhereInput = {
    AND?: RoadmapProgressWhereInput | RoadmapProgressWhereInput[]
    OR?: RoadmapProgressWhereInput[]
    NOT?: RoadmapProgressWhereInput | RoadmapProgressWhereInput[]
    id?: StringFilter<"RoadmapProgress"> | string
    userId?: StringFilter<"RoadmapProgress"> | string
    roadmapId?: StringFilter<"RoadmapProgress"> | string
    stepId?: StringFilter<"RoadmapProgress"> | string
    completed?: BoolFilter<"RoadmapProgress"> | boolean
    notes?: StringNullableFilter<"RoadmapProgress"> | string | null
    completedAt?: DateTimeNullableFilter<"RoadmapProgress"> | Date | string | null
    createdAt?: DateTimeFilter<"RoadmapProgress"> | Date | string
    updatedAt?: DateTimeFilter<"RoadmapProgress"> | Date | string
    roadmap?: XOR<RoadmapRelationFilter, RoadmapWhereInput>
    step?: XOR<RoadmapStepRelationFilter, RoadmapStepWhereInput>
  }

  export type RoadmapProgressOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    roadmapId?: SortOrder
    stepId?: SortOrder
    completed?: SortOrder
    notes?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    roadmap?: RoadmapOrderByWithRelationInput
    step?: RoadmapStepOrderByWithRelationInput
  }

  export type RoadmapProgressWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_stepId?: RoadmapProgressUserIdStepIdCompoundUniqueInput
    AND?: RoadmapProgressWhereInput | RoadmapProgressWhereInput[]
    OR?: RoadmapProgressWhereInput[]
    NOT?: RoadmapProgressWhereInput | RoadmapProgressWhereInput[]
    userId?: StringFilter<"RoadmapProgress"> | string
    roadmapId?: StringFilter<"RoadmapProgress"> | string
    stepId?: StringFilter<"RoadmapProgress"> | string
    completed?: BoolFilter<"RoadmapProgress"> | boolean
    notes?: StringNullableFilter<"RoadmapProgress"> | string | null
    completedAt?: DateTimeNullableFilter<"RoadmapProgress"> | Date | string | null
    createdAt?: DateTimeFilter<"RoadmapProgress"> | Date | string
    updatedAt?: DateTimeFilter<"RoadmapProgress"> | Date | string
    roadmap?: XOR<RoadmapRelationFilter, RoadmapWhereInput>
    step?: XOR<RoadmapStepRelationFilter, RoadmapStepWhereInput>
  }, "id" | "userId_stepId">

  export type RoadmapProgressOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    roadmapId?: SortOrder
    stepId?: SortOrder
    completed?: SortOrder
    notes?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RoadmapProgressCountOrderByAggregateInput
    _max?: RoadmapProgressMaxOrderByAggregateInput
    _min?: RoadmapProgressMinOrderByAggregateInput
  }

  export type RoadmapProgressScalarWhereWithAggregatesInput = {
    AND?: RoadmapProgressScalarWhereWithAggregatesInput | RoadmapProgressScalarWhereWithAggregatesInput[]
    OR?: RoadmapProgressScalarWhereWithAggregatesInput[]
    NOT?: RoadmapProgressScalarWhereWithAggregatesInput | RoadmapProgressScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RoadmapProgress"> | string
    userId?: StringWithAggregatesFilter<"RoadmapProgress"> | string
    roadmapId?: StringWithAggregatesFilter<"RoadmapProgress"> | string
    stepId?: StringWithAggregatesFilter<"RoadmapProgress"> | string
    completed?: BoolWithAggregatesFilter<"RoadmapProgress"> | boolean
    notes?: StringNullableWithAggregatesFilter<"RoadmapProgress"> | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"RoadmapProgress"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"RoadmapProgress"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RoadmapProgress"> | Date | string
  }

  export type CheatsheetCategoryWhereInput = {
    AND?: CheatsheetCategoryWhereInput | CheatsheetCategoryWhereInput[]
    OR?: CheatsheetCategoryWhereInput[]
    NOT?: CheatsheetCategoryWhereInput | CheatsheetCategoryWhereInput[]
    id?: StringFilter<"CheatsheetCategory"> | string
    slug?: StringFilter<"CheatsheetCategory"> | string
    title?: StringFilter<"CheatsheetCategory"> | string
    description?: StringNullableFilter<"CheatsheetCategory"> | string | null
    icon?: StringNullableFilter<"CheatsheetCategory"> | string | null
    order?: IntFilter<"CheatsheetCategory"> | number
    color?: StringNullableFilter<"CheatsheetCategory"> | string | null
    createdAt?: DateTimeFilter<"CheatsheetCategory"> | Date | string
    updatedAt?: DateTimeFilter<"CheatsheetCategory"> | Date | string
    cheatsheets?: CheatsheetListRelationFilter
  }

  export type CheatsheetCategoryOrderByWithRelationInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    order?: SortOrder
    color?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cheatsheets?: CheatsheetOrderByRelationAggregateInput
  }

  export type CheatsheetCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: CheatsheetCategoryWhereInput | CheatsheetCategoryWhereInput[]
    OR?: CheatsheetCategoryWhereInput[]
    NOT?: CheatsheetCategoryWhereInput | CheatsheetCategoryWhereInput[]
    title?: StringFilter<"CheatsheetCategory"> | string
    description?: StringNullableFilter<"CheatsheetCategory"> | string | null
    icon?: StringNullableFilter<"CheatsheetCategory"> | string | null
    order?: IntFilter<"CheatsheetCategory"> | number
    color?: StringNullableFilter<"CheatsheetCategory"> | string | null
    createdAt?: DateTimeFilter<"CheatsheetCategory"> | Date | string
    updatedAt?: DateTimeFilter<"CheatsheetCategory"> | Date | string
    cheatsheets?: CheatsheetListRelationFilter
  }, "id" | "slug">

  export type CheatsheetCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    order?: SortOrder
    color?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CheatsheetCategoryCountOrderByAggregateInput
    _avg?: CheatsheetCategoryAvgOrderByAggregateInput
    _max?: CheatsheetCategoryMaxOrderByAggregateInput
    _min?: CheatsheetCategoryMinOrderByAggregateInput
    _sum?: CheatsheetCategorySumOrderByAggregateInput
  }

  export type CheatsheetCategoryScalarWhereWithAggregatesInput = {
    AND?: CheatsheetCategoryScalarWhereWithAggregatesInput | CheatsheetCategoryScalarWhereWithAggregatesInput[]
    OR?: CheatsheetCategoryScalarWhereWithAggregatesInput[]
    NOT?: CheatsheetCategoryScalarWhereWithAggregatesInput | CheatsheetCategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CheatsheetCategory"> | string
    slug?: StringWithAggregatesFilter<"CheatsheetCategory"> | string
    title?: StringWithAggregatesFilter<"CheatsheetCategory"> | string
    description?: StringNullableWithAggregatesFilter<"CheatsheetCategory"> | string | null
    icon?: StringNullableWithAggregatesFilter<"CheatsheetCategory"> | string | null
    order?: IntWithAggregatesFilter<"CheatsheetCategory"> | number
    color?: StringNullableWithAggregatesFilter<"CheatsheetCategory"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CheatsheetCategory"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CheatsheetCategory"> | Date | string
  }

  export type CheatsheetWhereInput = {
    AND?: CheatsheetWhereInput | CheatsheetWhereInput[]
    OR?: CheatsheetWhereInput[]
    NOT?: CheatsheetWhereInput | CheatsheetWhereInput[]
    id?: StringFilter<"Cheatsheet"> | string
    categoryId?: StringFilter<"Cheatsheet"> | string
    slug?: StringFilter<"Cheatsheet"> | string
    title?: StringFilter<"Cheatsheet"> | string
    subtitle?: StringNullableFilter<"Cheatsheet"> | string | null
    description?: StringNullableFilter<"Cheatsheet"> | string | null
    icon?: StringNullableFilter<"Cheatsheet"> | string | null
    difficulty?: StringNullableFilter<"Cheatsheet"> | string | null
    tags?: StringNullableListFilter<"Cheatsheet">
    popularity?: IntFilter<"Cheatsheet"> | number
    overview?: StringNullableFilter<"Cheatsheet"> | string | null
    syntax?: JsonNullableFilter<"Cheatsheet">
    operations?: JsonNullableFilter<"Cheatsheet">
    examples?: JsonNullableFilter<"Cheatsheet">
    mistakes?: StringNullableListFilter<"Cheatsheet">
    tips?: StringNullableListFilter<"Cheatsheet">
    relatedCheatsheets?: StringNullableListFilter<"Cheatsheet">
    relatedRoadmaps?: StringNullableListFilter<"Cheatsheet">
    relatedDSA?: StringNullableListFilter<"Cheatsheet">
    aiExplanation?: StringNullableFilter<"Cheatsheet"> | string | null
    voiceExplainer?: StringNullableFilter<"Cheatsheet"> | string | null
    createdAt?: DateTimeFilter<"Cheatsheet"> | Date | string
    updatedAt?: DateTimeFilter<"Cheatsheet"> | Date | string
    category?: XOR<CheatsheetCategoryRelationFilter, CheatsheetCategoryWhereInput>
  }

  export type CheatsheetOrderByWithRelationInput = {
    id?: SortOrder
    categoryId?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    subtitle?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    difficulty?: SortOrderInput | SortOrder
    tags?: SortOrder
    popularity?: SortOrder
    overview?: SortOrderInput | SortOrder
    syntax?: SortOrderInput | SortOrder
    operations?: SortOrderInput | SortOrder
    examples?: SortOrderInput | SortOrder
    mistakes?: SortOrder
    tips?: SortOrder
    relatedCheatsheets?: SortOrder
    relatedRoadmaps?: SortOrder
    relatedDSA?: SortOrder
    aiExplanation?: SortOrderInput | SortOrder
    voiceExplainer?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    category?: CheatsheetCategoryOrderByWithRelationInput
  }

  export type CheatsheetWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: CheatsheetWhereInput | CheatsheetWhereInput[]
    OR?: CheatsheetWhereInput[]
    NOT?: CheatsheetWhereInput | CheatsheetWhereInput[]
    categoryId?: StringFilter<"Cheatsheet"> | string
    title?: StringFilter<"Cheatsheet"> | string
    subtitle?: StringNullableFilter<"Cheatsheet"> | string | null
    description?: StringNullableFilter<"Cheatsheet"> | string | null
    icon?: StringNullableFilter<"Cheatsheet"> | string | null
    difficulty?: StringNullableFilter<"Cheatsheet"> | string | null
    tags?: StringNullableListFilter<"Cheatsheet">
    popularity?: IntFilter<"Cheatsheet"> | number
    overview?: StringNullableFilter<"Cheatsheet"> | string | null
    syntax?: JsonNullableFilter<"Cheatsheet">
    operations?: JsonNullableFilter<"Cheatsheet">
    examples?: JsonNullableFilter<"Cheatsheet">
    mistakes?: StringNullableListFilter<"Cheatsheet">
    tips?: StringNullableListFilter<"Cheatsheet">
    relatedCheatsheets?: StringNullableListFilter<"Cheatsheet">
    relatedRoadmaps?: StringNullableListFilter<"Cheatsheet">
    relatedDSA?: StringNullableListFilter<"Cheatsheet">
    aiExplanation?: StringNullableFilter<"Cheatsheet"> | string | null
    voiceExplainer?: StringNullableFilter<"Cheatsheet"> | string | null
    createdAt?: DateTimeFilter<"Cheatsheet"> | Date | string
    updatedAt?: DateTimeFilter<"Cheatsheet"> | Date | string
    category?: XOR<CheatsheetCategoryRelationFilter, CheatsheetCategoryWhereInput>
  }, "id" | "slug">

  export type CheatsheetOrderByWithAggregationInput = {
    id?: SortOrder
    categoryId?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    subtitle?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    difficulty?: SortOrderInput | SortOrder
    tags?: SortOrder
    popularity?: SortOrder
    overview?: SortOrderInput | SortOrder
    syntax?: SortOrderInput | SortOrder
    operations?: SortOrderInput | SortOrder
    examples?: SortOrderInput | SortOrder
    mistakes?: SortOrder
    tips?: SortOrder
    relatedCheatsheets?: SortOrder
    relatedRoadmaps?: SortOrder
    relatedDSA?: SortOrder
    aiExplanation?: SortOrderInput | SortOrder
    voiceExplainer?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CheatsheetCountOrderByAggregateInput
    _avg?: CheatsheetAvgOrderByAggregateInput
    _max?: CheatsheetMaxOrderByAggregateInput
    _min?: CheatsheetMinOrderByAggregateInput
    _sum?: CheatsheetSumOrderByAggregateInput
  }

  export type CheatsheetScalarWhereWithAggregatesInput = {
    AND?: CheatsheetScalarWhereWithAggregatesInput | CheatsheetScalarWhereWithAggregatesInput[]
    OR?: CheatsheetScalarWhereWithAggregatesInput[]
    NOT?: CheatsheetScalarWhereWithAggregatesInput | CheatsheetScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Cheatsheet"> | string
    categoryId?: StringWithAggregatesFilter<"Cheatsheet"> | string
    slug?: StringWithAggregatesFilter<"Cheatsheet"> | string
    title?: StringWithAggregatesFilter<"Cheatsheet"> | string
    subtitle?: StringNullableWithAggregatesFilter<"Cheatsheet"> | string | null
    description?: StringNullableWithAggregatesFilter<"Cheatsheet"> | string | null
    icon?: StringNullableWithAggregatesFilter<"Cheatsheet"> | string | null
    difficulty?: StringNullableWithAggregatesFilter<"Cheatsheet"> | string | null
    tags?: StringNullableListFilter<"Cheatsheet">
    popularity?: IntWithAggregatesFilter<"Cheatsheet"> | number
    overview?: StringNullableWithAggregatesFilter<"Cheatsheet"> | string | null
    syntax?: JsonNullableWithAggregatesFilter<"Cheatsheet">
    operations?: JsonNullableWithAggregatesFilter<"Cheatsheet">
    examples?: JsonNullableWithAggregatesFilter<"Cheatsheet">
    mistakes?: StringNullableListFilter<"Cheatsheet">
    tips?: StringNullableListFilter<"Cheatsheet">
    relatedCheatsheets?: StringNullableListFilter<"Cheatsheet">
    relatedRoadmaps?: StringNullableListFilter<"Cheatsheet">
    relatedDSA?: StringNullableListFilter<"Cheatsheet">
    aiExplanation?: StringNullableWithAggregatesFilter<"Cheatsheet"> | string | null
    voiceExplainer?: StringNullableWithAggregatesFilter<"Cheatsheet"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Cheatsheet"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Cheatsheet"> | Date | string
  }

  export type UserCreateInput = {
    id: string
    email: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    progress?: UserProgressCreateNestedManyWithoutUserInput
    submissions?: SubmissionCreateNestedManyWithoutUserInput
    interviewSessions?: InterviewSessionCreateNestedManyWithoutUserInput
    sharedResults?: SharedInterviewResultCreateNestedManyWithoutUserInput
    analytics?: InterviewAnalyticsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id: string
    email: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    progress?: UserProgressUncheckedCreateNestedManyWithoutUserInput
    submissions?: SubmissionUncheckedCreateNestedManyWithoutUserInput
    interviewSessions?: InterviewSessionUncheckedCreateNestedManyWithoutUserInput
    sharedResults?: SharedInterviewResultUncheckedCreateNestedManyWithoutUserInput
    analytics?: InterviewAnalyticsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: UserProgressUpdateManyWithoutUserNestedInput
    submissions?: SubmissionUpdateManyWithoutUserNestedInput
    interviewSessions?: InterviewSessionUpdateManyWithoutUserNestedInput
    sharedResults?: SharedInterviewResultUpdateManyWithoutUserNestedInput
    analytics?: InterviewAnalyticsUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: UserProgressUncheckedUpdateManyWithoutUserNestedInput
    submissions?: SubmissionUncheckedUpdateManyWithoutUserNestedInput
    interviewSessions?: InterviewSessionUncheckedUpdateManyWithoutUserNestedInput
    sharedResults?: SharedInterviewResultUncheckedUpdateManyWithoutUserNestedInput
    analytics?: InterviewAnalyticsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id: string
    email: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DSATopicCreateInput = {
    id?: string
    slug: string
    title: string
    category?: string | null
    order: number
    targetCount?: number
    createdAt?: Date | string
    lessons?: DSALessonCreateNestedManyWithoutTopicInput
  }

  export type DSATopicUncheckedCreateInput = {
    id?: string
    slug: string
    title: string
    category?: string | null
    order: number
    targetCount?: number
    createdAt?: Date | string
    lessons?: DSALessonUncheckedCreateNestedManyWithoutTopicInput
  }

  export type DSATopicUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    targetCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lessons?: DSALessonUpdateManyWithoutTopicNestedInput
  }

  export type DSATopicUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    targetCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lessons?: DSALessonUncheckedUpdateManyWithoutTopicNestedInput
  }

  export type DSATopicCreateManyInput = {
    id?: string
    slug: string
    title: string
    category?: string | null
    order: number
    targetCount?: number
    createdAt?: Date | string
  }

  export type DSATopicUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    targetCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DSATopicUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    targetCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DSALessonCreateInput = {
    id?: string
    slug: string
    title: string
    content: string
    codeExamples?: NullableJsonNullValueInput | InputJsonValue
    difficulty?: string | null
    order: number
    createdAt?: Date | string
    topic: DSATopicCreateNestedOneWithoutLessonsInput
  }

  export type DSALessonUncheckedCreateInput = {
    id?: string
    topicId: string
    slug: string
    title: string
    content: string
    codeExamples?: NullableJsonNullValueInput | InputJsonValue
    difficulty?: string | null
    order: number
    createdAt?: Date | string
  }

  export type DSALessonUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    codeExamples?: NullableJsonNullValueInput | InputJsonValue
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    topic?: DSATopicUpdateOneRequiredWithoutLessonsNestedInput
  }

  export type DSALessonUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    codeExamples?: NullableJsonNullValueInput | InputJsonValue
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DSALessonCreateManyInput = {
    id?: string
    topicId: string
    slug: string
    title: string
    content: string
    codeExamples?: NullableJsonNullValueInput | InputJsonValue
    difficulty?: string | null
    order: number
    createdAt?: Date | string
  }

  export type DSALessonUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    codeExamples?: NullableJsonNullValueInput | InputJsonValue
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DSALessonUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    codeExamples?: NullableJsonNullValueInput | InputJsonValue
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProblemCreateInput = {
    id?: string
    title: string
    slug: string
    difficulty: string
    description: string
    examples: JsonNullValueInput | InputJsonValue
    constraints?: ProblemCreateconstraintsInput | string[]
    starterCode: JsonNullValueInput | InputJsonValue
    solutions?: NullableJsonNullValueInput | InputJsonValue
    testCases?: NullableJsonNullValueInput | InputJsonValue
    pattern: string
    sheets?: ProblemCreatesheetsInput | string[]
    order: number
    createdAt?: Date | string
    progress?: UserProgressCreateNestedManyWithoutProblemInput
    submissions?: SubmissionCreateNestedManyWithoutProblemInput
  }

  export type ProblemUncheckedCreateInput = {
    id?: string
    title: string
    slug: string
    difficulty: string
    description: string
    examples: JsonNullValueInput | InputJsonValue
    constraints?: ProblemCreateconstraintsInput | string[]
    starterCode: JsonNullValueInput | InputJsonValue
    solutions?: NullableJsonNullValueInput | InputJsonValue
    testCases?: NullableJsonNullValueInput | InputJsonValue
    pattern: string
    sheets?: ProblemCreatesheetsInput | string[]
    order: number
    createdAt?: Date | string
    progress?: UserProgressUncheckedCreateNestedManyWithoutProblemInput
    submissions?: SubmissionUncheckedCreateNestedManyWithoutProblemInput
  }

  export type ProblemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    examples?: JsonNullValueInput | InputJsonValue
    constraints?: ProblemUpdateconstraintsInput | string[]
    starterCode?: JsonNullValueInput | InputJsonValue
    solutions?: NullableJsonNullValueInput | InputJsonValue
    testCases?: NullableJsonNullValueInput | InputJsonValue
    pattern?: StringFieldUpdateOperationsInput | string
    sheets?: ProblemUpdatesheetsInput | string[]
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: UserProgressUpdateManyWithoutProblemNestedInput
    submissions?: SubmissionUpdateManyWithoutProblemNestedInput
  }

  export type ProblemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    examples?: JsonNullValueInput | InputJsonValue
    constraints?: ProblemUpdateconstraintsInput | string[]
    starterCode?: JsonNullValueInput | InputJsonValue
    solutions?: NullableJsonNullValueInput | InputJsonValue
    testCases?: NullableJsonNullValueInput | InputJsonValue
    pattern?: StringFieldUpdateOperationsInput | string
    sheets?: ProblemUpdatesheetsInput | string[]
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: UserProgressUncheckedUpdateManyWithoutProblemNestedInput
    submissions?: SubmissionUncheckedUpdateManyWithoutProblemNestedInput
  }

  export type ProblemCreateManyInput = {
    id?: string
    title: string
    slug: string
    difficulty: string
    description: string
    examples: JsonNullValueInput | InputJsonValue
    constraints?: ProblemCreateconstraintsInput | string[]
    starterCode: JsonNullValueInput | InputJsonValue
    solutions?: NullableJsonNullValueInput | InputJsonValue
    testCases?: NullableJsonNullValueInput | InputJsonValue
    pattern: string
    sheets?: ProblemCreatesheetsInput | string[]
    order: number
    createdAt?: Date | string
  }

  export type ProblemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    examples?: JsonNullValueInput | InputJsonValue
    constraints?: ProblemUpdateconstraintsInput | string[]
    starterCode?: JsonNullValueInput | InputJsonValue
    solutions?: NullableJsonNullValueInput | InputJsonValue
    testCases?: NullableJsonNullValueInput | InputJsonValue
    pattern?: StringFieldUpdateOperationsInput | string
    sheets?: ProblemUpdatesheetsInput | string[]
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProblemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    examples?: JsonNullValueInput | InputJsonValue
    constraints?: ProblemUpdateconstraintsInput | string[]
    starterCode?: JsonNullValueInput | InputJsonValue
    solutions?: NullableJsonNullValueInput | InputJsonValue
    testCases?: NullableJsonNullValueInput | InputJsonValue
    pattern?: StringFieldUpdateOperationsInput | string
    sheets?: ProblemUpdatesheetsInput | string[]
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserProgressCreateInput = {
    id?: string
    status: string
    starred?: boolean
    lastAttempt?: Date | string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutProgressInput
    problem: ProblemCreateNestedOneWithoutProgressInput
  }

  export type UserProgressUncheckedCreateInput = {
    id?: string
    userId: string
    problemId: string
    status: string
    starred?: boolean
    lastAttempt?: Date | string
    createdAt?: Date | string
  }

  export type UserProgressUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    starred?: BoolFieldUpdateOperationsInput | boolean
    lastAttempt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProgressNestedInput
    problem?: ProblemUpdateOneRequiredWithoutProgressNestedInput
  }

  export type UserProgressUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    problemId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    starred?: BoolFieldUpdateOperationsInput | boolean
    lastAttempt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserProgressCreateManyInput = {
    id?: string
    userId: string
    problemId: string
    status: string
    starred?: boolean
    lastAttempt?: Date | string
    createdAt?: Date | string
  }

  export type UserProgressUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    starred?: BoolFieldUpdateOperationsInput | boolean
    lastAttempt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserProgressUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    problemId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    starred?: BoolFieldUpdateOperationsInput | boolean
    lastAttempt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubmissionCreateInput = {
    id?: string
    code: string
    language: string
    status: string
    runtime?: number | null
    memory?: number | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutSubmissionsInput
    problem: ProblemCreateNestedOneWithoutSubmissionsInput
  }

  export type SubmissionUncheckedCreateInput = {
    id?: string
    userId: string
    problemId: string
    code: string
    language: string
    status: string
    runtime?: number | null
    memory?: number | null
    createdAt?: Date | string
  }

  export type SubmissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    runtime?: NullableIntFieldUpdateOperationsInput | number | null
    memory?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSubmissionsNestedInput
    problem?: ProblemUpdateOneRequiredWithoutSubmissionsNestedInput
  }

  export type SubmissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    problemId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    runtime?: NullableIntFieldUpdateOperationsInput | number | null
    memory?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubmissionCreateManyInput = {
    id?: string
    userId: string
    problemId: string
    code: string
    language: string
    status: string
    runtime?: number | null
    memory?: number | null
    createdAt?: Date | string
  }

  export type SubmissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    runtime?: NullableIntFieldUpdateOperationsInput | number | null
    memory?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubmissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    problemId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    runtime?: NullableIntFieldUpdateOperationsInput | number | null
    memory?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LearnDomainCreateInput = {
    id?: string
    slug: string
    title: string
    createdAt?: Date | string
    categories?: LearnCategoryCreateNestedManyWithoutDomainInput
  }

  export type LearnDomainUncheckedCreateInput = {
    id?: string
    slug: string
    title: string
    createdAt?: Date | string
    categories?: LearnCategoryUncheckedCreateNestedManyWithoutDomainInput
  }

  export type LearnDomainUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: LearnCategoryUpdateManyWithoutDomainNestedInput
  }

  export type LearnDomainUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: LearnCategoryUncheckedUpdateManyWithoutDomainNestedInput
  }

  export type LearnDomainCreateManyInput = {
    id?: string
    slug: string
    title: string
    createdAt?: Date | string
  }

  export type LearnDomainUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LearnDomainUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LearnCategoryCreateInput = {
    id?: string
    title: string
    order: number
    domain: LearnDomainCreateNestedOneWithoutCategoriesInput
    topics?: LearnTopicCreateNestedManyWithoutCategoryInput
  }

  export type LearnCategoryUncheckedCreateInput = {
    id?: string
    title: string
    order: number
    domainId: string
    topics?: LearnTopicUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type LearnCategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    domain?: LearnDomainUpdateOneRequiredWithoutCategoriesNestedInput
    topics?: LearnTopicUpdateManyWithoutCategoryNestedInput
  }

  export type LearnCategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    domainId?: StringFieldUpdateOperationsInput | string
    topics?: LearnTopicUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type LearnCategoryCreateManyInput = {
    id?: string
    title: string
    order: number
    domainId: string
  }

  export type LearnCategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
  }

  export type LearnCategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    domainId?: StringFieldUpdateOperationsInput | string
  }

  export type LearnTopicCreateInput = {
    id?: string
    title: string
    slug: string
    order: number
    content: string
    createdAt?: Date | string
    category: LearnCategoryCreateNestedOneWithoutTopicsInput
  }

  export type LearnTopicUncheckedCreateInput = {
    id?: string
    title: string
    slug: string
    order: number
    content: string
    categoryId: string
    createdAt?: Date | string
  }

  export type LearnTopicUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: LearnCategoryUpdateOneRequiredWithoutTopicsNestedInput
  }

  export type LearnTopicUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LearnTopicCreateManyInput = {
    id?: string
    title: string
    slug: string
    order: number
    content: string
    categoryId: string
    createdAt?: Date | string
  }

  export type LearnTopicUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LearnTopicUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterviewSessionCreateInput = {
    id?: string
    role: string
    duration: number
    status: string
    resumeSnapshot: string
    jobDescription?: string | null
    resumeSummary?: string | null
    jdSummary?: string | null
    vapiCallId?: string | null
    vapiAssistantId?: string | null
    transcript?: NullableJsonNullValueInput | InputJsonValue
    videoUrl?: string | null
    videoRecorded?: boolean
    createdAt?: Date | string
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    user: UserCreateNestedOneWithoutInterviewSessionsInput
    feedback?: InterviewFeedbackCreateNestedOneWithoutSessionInput
    sharedResult?: SharedInterviewResultCreateNestedOneWithoutSessionInput
  }

  export type InterviewSessionUncheckedCreateInput = {
    id?: string
    userId: string
    role: string
    duration: number
    status: string
    resumeSnapshot: string
    jobDescription?: string | null
    resumeSummary?: string | null
    jdSummary?: string | null
    vapiCallId?: string | null
    vapiAssistantId?: string | null
    transcript?: NullableJsonNullValueInput | InputJsonValue
    videoUrl?: string | null
    videoRecorded?: boolean
    createdAt?: Date | string
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    feedback?: InterviewFeedbackUncheckedCreateNestedOneWithoutSessionInput
    sharedResult?: SharedInterviewResultUncheckedCreateNestedOneWithoutSessionInput
  }

  export type InterviewSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    resumeSnapshot?: StringFieldUpdateOperationsInput | string
    jobDescription?: NullableStringFieldUpdateOperationsInput | string | null
    resumeSummary?: NullableStringFieldUpdateOperationsInput | string | null
    jdSummary?: NullableStringFieldUpdateOperationsInput | string | null
    vapiCallId?: NullableStringFieldUpdateOperationsInput | string | null
    vapiAssistantId?: NullableStringFieldUpdateOperationsInput | string | null
    transcript?: NullableJsonNullValueInput | InputJsonValue
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    videoRecorded?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutInterviewSessionsNestedInput
    feedback?: InterviewFeedbackUpdateOneWithoutSessionNestedInput
    sharedResult?: SharedInterviewResultUpdateOneWithoutSessionNestedInput
  }

  export type InterviewSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    resumeSnapshot?: StringFieldUpdateOperationsInput | string
    jobDescription?: NullableStringFieldUpdateOperationsInput | string | null
    resumeSummary?: NullableStringFieldUpdateOperationsInput | string | null
    jdSummary?: NullableStringFieldUpdateOperationsInput | string | null
    vapiCallId?: NullableStringFieldUpdateOperationsInput | string | null
    vapiAssistantId?: NullableStringFieldUpdateOperationsInput | string | null
    transcript?: NullableJsonNullValueInput | InputJsonValue
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    videoRecorded?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    feedback?: InterviewFeedbackUncheckedUpdateOneWithoutSessionNestedInput
    sharedResult?: SharedInterviewResultUncheckedUpdateOneWithoutSessionNestedInput
  }

  export type InterviewSessionCreateManyInput = {
    id?: string
    userId: string
    role: string
    duration: number
    status: string
    resumeSnapshot: string
    jobDescription?: string | null
    resumeSummary?: string | null
    jdSummary?: string | null
    vapiCallId?: string | null
    vapiAssistantId?: string | null
    transcript?: NullableJsonNullValueInput | InputJsonValue
    videoUrl?: string | null
    videoRecorded?: boolean
    createdAt?: Date | string
    startedAt?: Date | string | null
    endedAt?: Date | string | null
  }

  export type InterviewSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    resumeSnapshot?: StringFieldUpdateOperationsInput | string
    jobDescription?: NullableStringFieldUpdateOperationsInput | string | null
    resumeSummary?: NullableStringFieldUpdateOperationsInput | string | null
    jdSummary?: NullableStringFieldUpdateOperationsInput | string | null
    vapiCallId?: NullableStringFieldUpdateOperationsInput | string | null
    vapiAssistantId?: NullableStringFieldUpdateOperationsInput | string | null
    transcript?: NullableJsonNullValueInput | InputJsonValue
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    videoRecorded?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InterviewSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    resumeSnapshot?: StringFieldUpdateOperationsInput | string
    jobDescription?: NullableStringFieldUpdateOperationsInput | string | null
    resumeSummary?: NullableStringFieldUpdateOperationsInput | string | null
    jdSummary?: NullableStringFieldUpdateOperationsInput | string | null
    vapiCallId?: NullableStringFieldUpdateOperationsInput | string | null
    vapiAssistantId?: NullableStringFieldUpdateOperationsInput | string | null
    transcript?: NullableJsonNullValueInput | InputJsonValue
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    videoRecorded?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InterviewFeedbackCreateInput = {
    id?: string
    overallScore: number
    communicationClarity: number
    technicalDepth: number
    confidence: number
    roleAlignment: number
    skillRatings: JsonNullValueInput | InputJsonValue
    strengths?: InterviewFeedbackCreatestrengthsInput | string[]
    weaknesses?: InterviewFeedbackCreateweaknessesInput | string[]
    improvements?: InterviewFeedbackCreateimprovementsInput | string[]
    suggestedTopics?: InterviewFeedbackCreatesuggestedTopicsInput | string[]
    learningRoadmap: string
    aiSummary: string
    createdAt?: Date | string
    session: InterviewSessionCreateNestedOneWithoutFeedbackInput
  }

  export type InterviewFeedbackUncheckedCreateInput = {
    id?: string
    sessionId: string
    overallScore: number
    communicationClarity: number
    technicalDepth: number
    confidence: number
    roleAlignment: number
    skillRatings: JsonNullValueInput | InputJsonValue
    strengths?: InterviewFeedbackCreatestrengthsInput | string[]
    weaknesses?: InterviewFeedbackCreateweaknessesInput | string[]
    improvements?: InterviewFeedbackCreateimprovementsInput | string[]
    suggestedTopics?: InterviewFeedbackCreatesuggestedTopicsInput | string[]
    learningRoadmap: string
    aiSummary: string
    createdAt?: Date | string
  }

  export type InterviewFeedbackUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    overallScore?: IntFieldUpdateOperationsInput | number
    communicationClarity?: IntFieldUpdateOperationsInput | number
    technicalDepth?: IntFieldUpdateOperationsInput | number
    confidence?: IntFieldUpdateOperationsInput | number
    roleAlignment?: IntFieldUpdateOperationsInput | number
    skillRatings?: JsonNullValueInput | InputJsonValue
    strengths?: InterviewFeedbackUpdatestrengthsInput | string[]
    weaknesses?: InterviewFeedbackUpdateweaknessesInput | string[]
    improvements?: InterviewFeedbackUpdateimprovementsInput | string[]
    suggestedTopics?: InterviewFeedbackUpdatesuggestedTopicsInput | string[]
    learningRoadmap?: StringFieldUpdateOperationsInput | string
    aiSummary?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: InterviewSessionUpdateOneRequiredWithoutFeedbackNestedInput
  }

  export type InterviewFeedbackUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    overallScore?: IntFieldUpdateOperationsInput | number
    communicationClarity?: IntFieldUpdateOperationsInput | number
    technicalDepth?: IntFieldUpdateOperationsInput | number
    confidence?: IntFieldUpdateOperationsInput | number
    roleAlignment?: IntFieldUpdateOperationsInput | number
    skillRatings?: JsonNullValueInput | InputJsonValue
    strengths?: InterviewFeedbackUpdatestrengthsInput | string[]
    weaknesses?: InterviewFeedbackUpdateweaknessesInput | string[]
    improvements?: InterviewFeedbackUpdateimprovementsInput | string[]
    suggestedTopics?: InterviewFeedbackUpdatesuggestedTopicsInput | string[]
    learningRoadmap?: StringFieldUpdateOperationsInput | string
    aiSummary?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterviewFeedbackCreateManyInput = {
    id?: string
    sessionId: string
    overallScore: number
    communicationClarity: number
    technicalDepth: number
    confidence: number
    roleAlignment: number
    skillRatings: JsonNullValueInput | InputJsonValue
    strengths?: InterviewFeedbackCreatestrengthsInput | string[]
    weaknesses?: InterviewFeedbackCreateweaknessesInput | string[]
    improvements?: InterviewFeedbackCreateimprovementsInput | string[]
    suggestedTopics?: InterviewFeedbackCreatesuggestedTopicsInput | string[]
    learningRoadmap: string
    aiSummary: string
    createdAt?: Date | string
  }

  export type InterviewFeedbackUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    overallScore?: IntFieldUpdateOperationsInput | number
    communicationClarity?: IntFieldUpdateOperationsInput | number
    technicalDepth?: IntFieldUpdateOperationsInput | number
    confidence?: IntFieldUpdateOperationsInput | number
    roleAlignment?: IntFieldUpdateOperationsInput | number
    skillRatings?: JsonNullValueInput | InputJsonValue
    strengths?: InterviewFeedbackUpdatestrengthsInput | string[]
    weaknesses?: InterviewFeedbackUpdateweaknessesInput | string[]
    improvements?: InterviewFeedbackUpdateimprovementsInput | string[]
    suggestedTopics?: InterviewFeedbackUpdatesuggestedTopicsInput | string[]
    learningRoadmap?: StringFieldUpdateOperationsInput | string
    aiSummary?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterviewFeedbackUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    overallScore?: IntFieldUpdateOperationsInput | number
    communicationClarity?: IntFieldUpdateOperationsInput | number
    technicalDepth?: IntFieldUpdateOperationsInput | number
    confidence?: IntFieldUpdateOperationsInput | number
    roleAlignment?: IntFieldUpdateOperationsInput | number
    skillRatings?: JsonNullValueInput | InputJsonValue
    strengths?: InterviewFeedbackUpdatestrengthsInput | string[]
    weaknesses?: InterviewFeedbackUpdateweaknessesInput | string[]
    improvements?: InterviewFeedbackUpdateimprovementsInput | string[]
    suggestedTopics?: InterviewFeedbackUpdatesuggestedTopicsInput | string[]
    learningRoadmap?: StringFieldUpdateOperationsInput | string
    aiSummary?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionBankCreateInput = {
    id?: string
    role: string
    difficulty: string
    category: string
    question: string
    followUps?: QuestionBankCreatefollowUpsInput | string[]
    keyPoints?: QuestionBankCreatekeyPointsInput | string[]
    tags?: QuestionBankCreatetagsInput | string[]
    active?: boolean
    usageCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionBankUncheckedCreateInput = {
    id?: string
    role: string
    difficulty: string
    category: string
    question: string
    followUps?: QuestionBankCreatefollowUpsInput | string[]
    keyPoints?: QuestionBankCreatekeyPointsInput | string[]
    tags?: QuestionBankCreatetagsInput | string[]
    active?: boolean
    usageCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionBankUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    followUps?: QuestionBankUpdatefollowUpsInput | string[]
    keyPoints?: QuestionBankUpdatekeyPointsInput | string[]
    tags?: QuestionBankUpdatetagsInput | string[]
    active?: BoolFieldUpdateOperationsInput | boolean
    usageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionBankUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    followUps?: QuestionBankUpdatefollowUpsInput | string[]
    keyPoints?: QuestionBankUpdatekeyPointsInput | string[]
    tags?: QuestionBankUpdatetagsInput | string[]
    active?: BoolFieldUpdateOperationsInput | boolean
    usageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionBankCreateManyInput = {
    id?: string
    role: string
    difficulty: string
    category: string
    question: string
    followUps?: QuestionBankCreatefollowUpsInput | string[]
    keyPoints?: QuestionBankCreatekeyPointsInput | string[]
    tags?: QuestionBankCreatetagsInput | string[]
    active?: boolean
    usageCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionBankUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    followUps?: QuestionBankUpdatefollowUpsInput | string[]
    keyPoints?: QuestionBankUpdatekeyPointsInput | string[]
    tags?: QuestionBankUpdatetagsInput | string[]
    active?: BoolFieldUpdateOperationsInput | boolean
    usageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionBankUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    followUps?: QuestionBankUpdatefollowUpsInput | string[]
    keyPoints?: QuestionBankUpdatekeyPointsInput | string[]
    tags?: QuestionBankUpdatetagsInput | string[]
    active?: BoolFieldUpdateOperationsInput | boolean
    usageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SharedInterviewResultCreateInput = {
    id?: string
    shareToken: string
    isPublic?: boolean
    expiresAt?: Date | string | null
    viewCount?: number
    lastViewedAt?: Date | string | null
    createdAt?: Date | string
    session: InterviewSessionCreateNestedOneWithoutSharedResultInput
    user: UserCreateNestedOneWithoutSharedResultsInput
  }

  export type SharedInterviewResultUncheckedCreateInput = {
    id?: string
    sessionId: string
    userId: string
    shareToken: string
    isPublic?: boolean
    expiresAt?: Date | string | null
    viewCount?: number
    lastViewedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type SharedInterviewResultUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    shareToken?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    lastViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: InterviewSessionUpdateOneRequiredWithoutSharedResultNestedInput
    user?: UserUpdateOneRequiredWithoutSharedResultsNestedInput
  }

  export type SharedInterviewResultUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    shareToken?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    lastViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SharedInterviewResultCreateManyInput = {
    id?: string
    sessionId: string
    userId: string
    shareToken: string
    isPublic?: boolean
    expiresAt?: Date | string | null
    viewCount?: number
    lastViewedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type SharedInterviewResultUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    shareToken?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    lastViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SharedInterviewResultUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    shareToken?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    lastViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterviewAnalyticsCreateInput = {
    id?: string
    totalInterviews?: number
    averageScore?: number
    averageCommunication?: number
    averageTechnical?: number
    averageConfidence?: number
    roleStats: JsonNullValueInput | InputJsonValue
    monthlyScores: JsonNullValueInput | InputJsonValue
    topStrengths?: InterviewAnalyticsCreatetopStrengthsInput | string[]
    topWeaknesses?: InterviewAnalyticsCreatetopWeaknessesInput | string[]
    lastUpdated?: Date | string
    user: UserCreateNestedOneWithoutAnalyticsInput
  }

  export type InterviewAnalyticsUncheckedCreateInput = {
    id?: string
    userId: string
    totalInterviews?: number
    averageScore?: number
    averageCommunication?: number
    averageTechnical?: number
    averageConfidence?: number
    roleStats: JsonNullValueInput | InputJsonValue
    monthlyScores: JsonNullValueInput | InputJsonValue
    topStrengths?: InterviewAnalyticsCreatetopStrengthsInput | string[]
    topWeaknesses?: InterviewAnalyticsCreatetopWeaknessesInput | string[]
    lastUpdated?: Date | string
  }

  export type InterviewAnalyticsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalInterviews?: IntFieldUpdateOperationsInput | number
    averageScore?: FloatFieldUpdateOperationsInput | number
    averageCommunication?: FloatFieldUpdateOperationsInput | number
    averageTechnical?: FloatFieldUpdateOperationsInput | number
    averageConfidence?: FloatFieldUpdateOperationsInput | number
    roleStats?: JsonNullValueInput | InputJsonValue
    monthlyScores?: JsonNullValueInput | InputJsonValue
    topStrengths?: InterviewAnalyticsUpdatetopStrengthsInput | string[]
    topWeaknesses?: InterviewAnalyticsUpdatetopWeaknessesInput | string[]
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAnalyticsNestedInput
  }

  export type InterviewAnalyticsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    totalInterviews?: IntFieldUpdateOperationsInput | number
    averageScore?: FloatFieldUpdateOperationsInput | number
    averageCommunication?: FloatFieldUpdateOperationsInput | number
    averageTechnical?: FloatFieldUpdateOperationsInput | number
    averageConfidence?: FloatFieldUpdateOperationsInput | number
    roleStats?: JsonNullValueInput | InputJsonValue
    monthlyScores?: JsonNullValueInput | InputJsonValue
    topStrengths?: InterviewAnalyticsUpdatetopStrengthsInput | string[]
    topWeaknesses?: InterviewAnalyticsUpdatetopWeaknessesInput | string[]
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterviewAnalyticsCreateManyInput = {
    id?: string
    userId: string
    totalInterviews?: number
    averageScore?: number
    averageCommunication?: number
    averageTechnical?: number
    averageConfidence?: number
    roleStats: JsonNullValueInput | InputJsonValue
    monthlyScores: JsonNullValueInput | InputJsonValue
    topStrengths?: InterviewAnalyticsCreatetopStrengthsInput | string[]
    topWeaknesses?: InterviewAnalyticsCreatetopWeaknessesInput | string[]
    lastUpdated?: Date | string
  }

  export type InterviewAnalyticsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalInterviews?: IntFieldUpdateOperationsInput | number
    averageScore?: FloatFieldUpdateOperationsInput | number
    averageCommunication?: FloatFieldUpdateOperationsInput | number
    averageTechnical?: FloatFieldUpdateOperationsInput | number
    averageConfidence?: FloatFieldUpdateOperationsInput | number
    roleStats?: JsonNullValueInput | InputJsonValue
    monthlyScores?: JsonNullValueInput | InputJsonValue
    topStrengths?: InterviewAnalyticsUpdatetopStrengthsInput | string[]
    topWeaknesses?: InterviewAnalyticsUpdatetopWeaknessesInput | string[]
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterviewAnalyticsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    totalInterviews?: IntFieldUpdateOperationsInput | number
    averageScore?: FloatFieldUpdateOperationsInput | number
    averageCommunication?: FloatFieldUpdateOperationsInput | number
    averageTechnical?: FloatFieldUpdateOperationsInput | number
    averageConfidence?: FloatFieldUpdateOperationsInput | number
    roleStats?: JsonNullValueInput | InputJsonValue
    monthlyScores?: JsonNullValueInput | InputJsonValue
    topStrengths?: InterviewAnalyticsUpdatetopStrengthsInput | string[]
    topWeaknesses?: InterviewAnalyticsUpdatetopWeaknessesInput | string[]
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoadmapCreateInput = {
    id?: string
    slug: string
    title: string
    description: string
    icon: string
    level: string
    duration: string
    gradient: string
    skills?: RoadmapCreateskillsInput | string[]
    popularity?: number
    isActive?: boolean
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    phases?: RoadmapPhaseCreateNestedManyWithoutRoadmapInput
    progress?: RoadmapProgressCreateNestedManyWithoutRoadmapInput
  }

  export type RoadmapUncheckedCreateInput = {
    id?: string
    slug: string
    title: string
    description: string
    icon: string
    level: string
    duration: string
    gradient: string
    skills?: RoadmapCreateskillsInput | string[]
    popularity?: number
    isActive?: boolean
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    phases?: RoadmapPhaseUncheckedCreateNestedManyWithoutRoadmapInput
    progress?: RoadmapProgressUncheckedCreateNestedManyWithoutRoadmapInput
  }

  export type RoadmapUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    gradient?: StringFieldUpdateOperationsInput | string
    skills?: RoadmapUpdateskillsInput | string[]
    popularity?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phases?: RoadmapPhaseUpdateManyWithoutRoadmapNestedInput
    progress?: RoadmapProgressUpdateManyWithoutRoadmapNestedInput
  }

  export type RoadmapUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    gradient?: StringFieldUpdateOperationsInput | string
    skills?: RoadmapUpdateskillsInput | string[]
    popularity?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phases?: RoadmapPhaseUncheckedUpdateManyWithoutRoadmapNestedInput
    progress?: RoadmapProgressUncheckedUpdateManyWithoutRoadmapNestedInput
  }

  export type RoadmapCreateManyInput = {
    id?: string
    slug: string
    title: string
    description: string
    icon: string
    level: string
    duration: string
    gradient: string
    skills?: RoadmapCreateskillsInput | string[]
    popularity?: number
    isActive?: boolean
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoadmapUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    gradient?: StringFieldUpdateOperationsInput | string
    skills?: RoadmapUpdateskillsInput | string[]
    popularity?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoadmapUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    gradient?: StringFieldUpdateOperationsInput | string
    skills?: RoadmapUpdateskillsInput | string[]
    popularity?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoadmapPhaseCreateInput = {
    id?: string
    title: string
    description: string
    order: number
    roadmap: RoadmapCreateNestedOneWithoutPhasesInput
    steps?: RoadmapStepCreateNestedManyWithoutPhaseInput
  }

  export type RoadmapPhaseUncheckedCreateInput = {
    id?: string
    roadmapId: string
    title: string
    description: string
    order: number
    steps?: RoadmapStepUncheckedCreateNestedManyWithoutPhaseInput
  }

  export type RoadmapPhaseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    roadmap?: RoadmapUpdateOneRequiredWithoutPhasesNestedInput
    steps?: RoadmapStepUpdateManyWithoutPhaseNestedInput
  }

  export type RoadmapPhaseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    roadmapId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    steps?: RoadmapStepUncheckedUpdateManyWithoutPhaseNestedInput
  }

  export type RoadmapPhaseCreateManyInput = {
    id?: string
    roadmapId: string
    title: string
    description: string
    order: number
  }

  export type RoadmapPhaseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
  }

  export type RoadmapPhaseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    roadmapId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
  }

  export type RoadmapStepCreateInput = {
    id?: string
    title: string
    description: string
    difficulty: string
    estimatedTime: string
    order: number
    topics?: RoadmapStepCreatetopicsInput | string[]
    prerequisites?: RoadmapStepCreateprerequisitesInput | string[]
    resources: JsonNullValueInput | InputJsonValue
    checkpoints?: RoadmapStepCreatecheckpointsInput | string[]
    relatedCheatsheets?: RoadmapStepCreaterelatedCheatsheetsInput | string[]
    relatedDSA?: RoadmapStepCreaterelatedDSAInput | string[]
    relatedInterviews?: RoadmapStepCreaterelatedInterviewsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    phase: RoadmapPhaseCreateNestedOneWithoutStepsInput
    progress?: RoadmapProgressCreateNestedManyWithoutStepInput
  }

  export type RoadmapStepUncheckedCreateInput = {
    id?: string
    phaseId: string
    title: string
    description: string
    difficulty: string
    estimatedTime: string
    order: number
    topics?: RoadmapStepCreatetopicsInput | string[]
    prerequisites?: RoadmapStepCreateprerequisitesInput | string[]
    resources: JsonNullValueInput | InputJsonValue
    checkpoints?: RoadmapStepCreatecheckpointsInput | string[]
    relatedCheatsheets?: RoadmapStepCreaterelatedCheatsheetsInput | string[]
    relatedDSA?: RoadmapStepCreaterelatedDSAInput | string[]
    relatedInterviews?: RoadmapStepCreaterelatedInterviewsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    progress?: RoadmapProgressUncheckedCreateNestedManyWithoutStepInput
  }

  export type RoadmapStepUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    estimatedTime?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    topics?: RoadmapStepUpdatetopicsInput | string[]
    prerequisites?: RoadmapStepUpdateprerequisitesInput | string[]
    resources?: JsonNullValueInput | InputJsonValue
    checkpoints?: RoadmapStepUpdatecheckpointsInput | string[]
    relatedCheatsheets?: RoadmapStepUpdaterelatedCheatsheetsInput | string[]
    relatedDSA?: RoadmapStepUpdaterelatedDSAInput | string[]
    relatedInterviews?: RoadmapStepUpdaterelatedInterviewsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phase?: RoadmapPhaseUpdateOneRequiredWithoutStepsNestedInput
    progress?: RoadmapProgressUpdateManyWithoutStepNestedInput
  }

  export type RoadmapStepUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    phaseId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    estimatedTime?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    topics?: RoadmapStepUpdatetopicsInput | string[]
    prerequisites?: RoadmapStepUpdateprerequisitesInput | string[]
    resources?: JsonNullValueInput | InputJsonValue
    checkpoints?: RoadmapStepUpdatecheckpointsInput | string[]
    relatedCheatsheets?: RoadmapStepUpdaterelatedCheatsheetsInput | string[]
    relatedDSA?: RoadmapStepUpdaterelatedDSAInput | string[]
    relatedInterviews?: RoadmapStepUpdaterelatedInterviewsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: RoadmapProgressUncheckedUpdateManyWithoutStepNestedInput
  }

  export type RoadmapStepCreateManyInput = {
    id?: string
    phaseId: string
    title: string
    description: string
    difficulty: string
    estimatedTime: string
    order: number
    topics?: RoadmapStepCreatetopicsInput | string[]
    prerequisites?: RoadmapStepCreateprerequisitesInput | string[]
    resources: JsonNullValueInput | InputJsonValue
    checkpoints?: RoadmapStepCreatecheckpointsInput | string[]
    relatedCheatsheets?: RoadmapStepCreaterelatedCheatsheetsInput | string[]
    relatedDSA?: RoadmapStepCreaterelatedDSAInput | string[]
    relatedInterviews?: RoadmapStepCreaterelatedInterviewsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoadmapStepUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    estimatedTime?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    topics?: RoadmapStepUpdatetopicsInput | string[]
    prerequisites?: RoadmapStepUpdateprerequisitesInput | string[]
    resources?: JsonNullValueInput | InputJsonValue
    checkpoints?: RoadmapStepUpdatecheckpointsInput | string[]
    relatedCheatsheets?: RoadmapStepUpdaterelatedCheatsheetsInput | string[]
    relatedDSA?: RoadmapStepUpdaterelatedDSAInput | string[]
    relatedInterviews?: RoadmapStepUpdaterelatedInterviewsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoadmapStepUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    phaseId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    estimatedTime?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    topics?: RoadmapStepUpdatetopicsInput | string[]
    prerequisites?: RoadmapStepUpdateprerequisitesInput | string[]
    resources?: JsonNullValueInput | InputJsonValue
    checkpoints?: RoadmapStepUpdatecheckpointsInput | string[]
    relatedCheatsheets?: RoadmapStepUpdaterelatedCheatsheetsInput | string[]
    relatedDSA?: RoadmapStepUpdaterelatedDSAInput | string[]
    relatedInterviews?: RoadmapStepUpdaterelatedInterviewsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoadmapProgressCreateInput = {
    id?: string
    userId: string
    completed?: boolean
    notes?: string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roadmap: RoadmapCreateNestedOneWithoutProgressInput
    step: RoadmapStepCreateNestedOneWithoutProgressInput
  }

  export type RoadmapProgressUncheckedCreateInput = {
    id?: string
    userId: string
    roadmapId: string
    stepId: string
    completed?: boolean
    notes?: string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoadmapProgressUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roadmap?: RoadmapUpdateOneRequiredWithoutProgressNestedInput
    step?: RoadmapStepUpdateOneRequiredWithoutProgressNestedInput
  }

  export type RoadmapProgressUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    roadmapId?: StringFieldUpdateOperationsInput | string
    stepId?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoadmapProgressCreateManyInput = {
    id?: string
    userId: string
    roadmapId: string
    stepId: string
    completed?: boolean
    notes?: string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoadmapProgressUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoadmapProgressUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    roadmapId?: StringFieldUpdateOperationsInput | string
    stepId?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CheatsheetCategoryCreateInput = {
    id?: string
    slug: string
    title: string
    description?: string | null
    icon?: string | null
    order?: number
    color?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    cheatsheets?: CheatsheetCreateNestedManyWithoutCategoryInput
  }

  export type CheatsheetCategoryUncheckedCreateInput = {
    id?: string
    slug: string
    title: string
    description?: string | null
    icon?: string | null
    order?: number
    color?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    cheatsheets?: CheatsheetUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CheatsheetCategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cheatsheets?: CheatsheetUpdateManyWithoutCategoryNestedInput
  }

  export type CheatsheetCategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cheatsheets?: CheatsheetUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CheatsheetCategoryCreateManyInput = {
    id?: string
    slug: string
    title: string
    description?: string | null
    icon?: string | null
    order?: number
    color?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CheatsheetCategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CheatsheetCategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CheatsheetCreateInput = {
    id?: string
    slug: string
    title: string
    subtitle?: string | null
    description?: string | null
    icon?: string | null
    difficulty?: string | null
    tags?: CheatsheetCreatetagsInput | string[]
    popularity?: number
    overview?: string | null
    syntax?: NullableJsonNullValueInput | InputJsonValue
    operations?: NullableJsonNullValueInput | InputJsonValue
    examples?: NullableJsonNullValueInput | InputJsonValue
    mistakes?: CheatsheetCreatemistakesInput | string[]
    tips?: CheatsheetCreatetipsInput | string[]
    relatedCheatsheets?: CheatsheetCreaterelatedCheatsheetsInput | string[]
    relatedRoadmaps?: CheatsheetCreaterelatedRoadmapsInput | string[]
    relatedDSA?: CheatsheetCreaterelatedDSAInput | string[]
    aiExplanation?: string | null
    voiceExplainer?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    category: CheatsheetCategoryCreateNestedOneWithoutCheatsheetsInput
  }

  export type CheatsheetUncheckedCreateInput = {
    id?: string
    categoryId: string
    slug: string
    title: string
    subtitle?: string | null
    description?: string | null
    icon?: string | null
    difficulty?: string | null
    tags?: CheatsheetCreatetagsInput | string[]
    popularity?: number
    overview?: string | null
    syntax?: NullableJsonNullValueInput | InputJsonValue
    operations?: NullableJsonNullValueInput | InputJsonValue
    examples?: NullableJsonNullValueInput | InputJsonValue
    mistakes?: CheatsheetCreatemistakesInput | string[]
    tips?: CheatsheetCreatetipsInput | string[]
    relatedCheatsheets?: CheatsheetCreaterelatedCheatsheetsInput | string[]
    relatedRoadmaps?: CheatsheetCreaterelatedRoadmapsInput | string[]
    relatedDSA?: CheatsheetCreaterelatedDSAInput | string[]
    aiExplanation?: string | null
    voiceExplainer?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CheatsheetUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: CheatsheetUpdatetagsInput | string[]
    popularity?: IntFieldUpdateOperationsInput | number
    overview?: NullableStringFieldUpdateOperationsInput | string | null
    syntax?: NullableJsonNullValueInput | InputJsonValue
    operations?: NullableJsonNullValueInput | InputJsonValue
    examples?: NullableJsonNullValueInput | InputJsonValue
    mistakes?: CheatsheetUpdatemistakesInput | string[]
    tips?: CheatsheetUpdatetipsInput | string[]
    relatedCheatsheets?: CheatsheetUpdaterelatedCheatsheetsInput | string[]
    relatedRoadmaps?: CheatsheetUpdaterelatedRoadmapsInput | string[]
    relatedDSA?: CheatsheetUpdaterelatedDSAInput | string[]
    aiExplanation?: NullableStringFieldUpdateOperationsInput | string | null
    voiceExplainer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: CheatsheetCategoryUpdateOneRequiredWithoutCheatsheetsNestedInput
  }

  export type CheatsheetUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: CheatsheetUpdatetagsInput | string[]
    popularity?: IntFieldUpdateOperationsInput | number
    overview?: NullableStringFieldUpdateOperationsInput | string | null
    syntax?: NullableJsonNullValueInput | InputJsonValue
    operations?: NullableJsonNullValueInput | InputJsonValue
    examples?: NullableJsonNullValueInput | InputJsonValue
    mistakes?: CheatsheetUpdatemistakesInput | string[]
    tips?: CheatsheetUpdatetipsInput | string[]
    relatedCheatsheets?: CheatsheetUpdaterelatedCheatsheetsInput | string[]
    relatedRoadmaps?: CheatsheetUpdaterelatedRoadmapsInput | string[]
    relatedDSA?: CheatsheetUpdaterelatedDSAInput | string[]
    aiExplanation?: NullableStringFieldUpdateOperationsInput | string | null
    voiceExplainer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CheatsheetCreateManyInput = {
    id?: string
    categoryId: string
    slug: string
    title: string
    subtitle?: string | null
    description?: string | null
    icon?: string | null
    difficulty?: string | null
    tags?: CheatsheetCreatetagsInput | string[]
    popularity?: number
    overview?: string | null
    syntax?: NullableJsonNullValueInput | InputJsonValue
    operations?: NullableJsonNullValueInput | InputJsonValue
    examples?: NullableJsonNullValueInput | InputJsonValue
    mistakes?: CheatsheetCreatemistakesInput | string[]
    tips?: CheatsheetCreatetipsInput | string[]
    relatedCheatsheets?: CheatsheetCreaterelatedCheatsheetsInput | string[]
    relatedRoadmaps?: CheatsheetCreaterelatedRoadmapsInput | string[]
    relatedDSA?: CheatsheetCreaterelatedDSAInput | string[]
    aiExplanation?: string | null
    voiceExplainer?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CheatsheetUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: CheatsheetUpdatetagsInput | string[]
    popularity?: IntFieldUpdateOperationsInput | number
    overview?: NullableStringFieldUpdateOperationsInput | string | null
    syntax?: NullableJsonNullValueInput | InputJsonValue
    operations?: NullableJsonNullValueInput | InputJsonValue
    examples?: NullableJsonNullValueInput | InputJsonValue
    mistakes?: CheatsheetUpdatemistakesInput | string[]
    tips?: CheatsheetUpdatetipsInput | string[]
    relatedCheatsheets?: CheatsheetUpdaterelatedCheatsheetsInput | string[]
    relatedRoadmaps?: CheatsheetUpdaterelatedRoadmapsInput | string[]
    relatedDSA?: CheatsheetUpdaterelatedDSAInput | string[]
    aiExplanation?: NullableStringFieldUpdateOperationsInput | string | null
    voiceExplainer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CheatsheetUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: CheatsheetUpdatetagsInput | string[]
    popularity?: IntFieldUpdateOperationsInput | number
    overview?: NullableStringFieldUpdateOperationsInput | string | null
    syntax?: NullableJsonNullValueInput | InputJsonValue
    operations?: NullableJsonNullValueInput | InputJsonValue
    examples?: NullableJsonNullValueInput | InputJsonValue
    mistakes?: CheatsheetUpdatemistakesInput | string[]
    tips?: CheatsheetUpdatetipsInput | string[]
    relatedCheatsheets?: CheatsheetUpdaterelatedCheatsheetsInput | string[]
    relatedRoadmaps?: CheatsheetUpdaterelatedRoadmapsInput | string[]
    relatedDSA?: CheatsheetUpdaterelatedDSAInput | string[]
    aiExplanation?: NullableStringFieldUpdateOperationsInput | string | null
    voiceExplainer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserProgressListRelationFilter = {
    every?: UserProgressWhereInput
    some?: UserProgressWhereInput
    none?: UserProgressWhereInput
  }

  export type SubmissionListRelationFilter = {
    every?: SubmissionWhereInput
    some?: SubmissionWhereInput
    none?: SubmissionWhereInput
  }

  export type InterviewSessionListRelationFilter = {
    every?: InterviewSessionWhereInput
    some?: InterviewSessionWhereInput
    none?: InterviewSessionWhereInput
  }

  export type SharedInterviewResultListRelationFilter = {
    every?: SharedInterviewResultWhereInput
    some?: SharedInterviewResultWhereInput
    none?: SharedInterviewResultWhereInput
  }

  export type InterviewAnalyticsNullableRelationFilter = {
    is?: InterviewAnalyticsWhereInput | null
    isNot?: InterviewAnalyticsWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserProgressOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubmissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InterviewSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SharedInterviewResultOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DSALessonListRelationFilter = {
    every?: DSALessonWhereInput
    some?: DSALessonWhereInput
    none?: DSALessonWhereInput
  }

  export type DSALessonOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DSATopicCountOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    category?: SortOrder
    order?: SortOrder
    targetCount?: SortOrder
    createdAt?: SortOrder
  }

  export type DSATopicAvgOrderByAggregateInput = {
    order?: SortOrder
    targetCount?: SortOrder
  }

  export type DSATopicMaxOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    category?: SortOrder
    order?: SortOrder
    targetCount?: SortOrder
    createdAt?: SortOrder
  }

  export type DSATopicMinOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    category?: SortOrder
    order?: SortOrder
    targetCount?: SortOrder
    createdAt?: SortOrder
  }

  export type DSATopicSumOrderByAggregateInput = {
    order?: SortOrder
    targetCount?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type DSATopicRelationFilter = {
    is?: DSATopicWhereInput
    isNot?: DSATopicWhereInput
  }

  export type DSALessonCountOrderByAggregateInput = {
    id?: SortOrder
    topicId?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    content?: SortOrder
    codeExamples?: SortOrder
    difficulty?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
  }

  export type DSALessonAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type DSALessonMaxOrderByAggregateInput = {
    id?: SortOrder
    topicId?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    content?: SortOrder
    difficulty?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
  }

  export type DSALessonMinOrderByAggregateInput = {
    id?: SortOrder
    topicId?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    content?: SortOrder
    difficulty?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
  }

  export type DSALessonSumOrderByAggregateInput = {
    order?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type ProblemCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    difficulty?: SortOrder
    description?: SortOrder
    examples?: SortOrder
    constraints?: SortOrder
    starterCode?: SortOrder
    solutions?: SortOrder
    testCases?: SortOrder
    pattern?: SortOrder
    sheets?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
  }

  export type ProblemAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type ProblemMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    difficulty?: SortOrder
    description?: SortOrder
    pattern?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
  }

  export type ProblemMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    difficulty?: SortOrder
    description?: SortOrder
    pattern?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
  }

  export type ProblemSumOrderByAggregateInput = {
    order?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type ProblemRelationFilter = {
    is?: ProblemWhereInput
    isNot?: ProblemWhereInput
  }

  export type UserProgressUserIdProblemIdCompoundUniqueInput = {
    userId: string
    problemId: string
  }

  export type UserProgressCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    problemId?: SortOrder
    status?: SortOrder
    starred?: SortOrder
    lastAttempt?: SortOrder
    createdAt?: SortOrder
  }

  export type UserProgressMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    problemId?: SortOrder
    status?: SortOrder
    starred?: SortOrder
    lastAttempt?: SortOrder
    createdAt?: SortOrder
  }

  export type UserProgressMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    problemId?: SortOrder
    status?: SortOrder
    starred?: SortOrder
    lastAttempt?: SortOrder
    createdAt?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type SubmissionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    problemId?: SortOrder
    code?: SortOrder
    language?: SortOrder
    status?: SortOrder
    runtime?: SortOrder
    memory?: SortOrder
    createdAt?: SortOrder
  }

  export type SubmissionAvgOrderByAggregateInput = {
    runtime?: SortOrder
    memory?: SortOrder
  }

  export type SubmissionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    problemId?: SortOrder
    code?: SortOrder
    language?: SortOrder
    status?: SortOrder
    runtime?: SortOrder
    memory?: SortOrder
    createdAt?: SortOrder
  }

  export type SubmissionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    problemId?: SortOrder
    code?: SortOrder
    language?: SortOrder
    status?: SortOrder
    runtime?: SortOrder
    memory?: SortOrder
    createdAt?: SortOrder
  }

  export type SubmissionSumOrderByAggregateInput = {
    runtime?: SortOrder
    memory?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type LearnCategoryListRelationFilter = {
    every?: LearnCategoryWhereInput
    some?: LearnCategoryWhereInput
    none?: LearnCategoryWhereInput
  }

  export type LearnCategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LearnDomainCountOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
  }

  export type LearnDomainMaxOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
  }

  export type LearnDomainMinOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
  }

  export type LearnDomainRelationFilter = {
    is?: LearnDomainWhereInput
    isNot?: LearnDomainWhereInput
  }

  export type LearnTopicListRelationFilter = {
    every?: LearnTopicWhereInput
    some?: LearnTopicWhereInput
    none?: LearnTopicWhereInput
  }

  export type LearnTopicOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LearnCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    order?: SortOrder
    domainId?: SortOrder
  }

  export type LearnCategoryAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type LearnCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    order?: SortOrder
    domainId?: SortOrder
  }

  export type LearnCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    order?: SortOrder
    domainId?: SortOrder
  }

  export type LearnCategorySumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type LearnCategoryRelationFilter = {
    is?: LearnCategoryWhereInput
    isNot?: LearnCategoryWhereInput
  }

  export type LearnTopicCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    order?: SortOrder
    content?: SortOrder
    categoryId?: SortOrder
    createdAt?: SortOrder
  }

  export type LearnTopicAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type LearnTopicMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    order?: SortOrder
    content?: SortOrder
    categoryId?: SortOrder
    createdAt?: SortOrder
  }

  export type LearnTopicMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    order?: SortOrder
    content?: SortOrder
    categoryId?: SortOrder
    createdAt?: SortOrder
  }

  export type LearnTopicSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type InterviewFeedbackNullableRelationFilter = {
    is?: InterviewFeedbackWhereInput | null
    isNot?: InterviewFeedbackWhereInput | null
  }

  export type SharedInterviewResultNullableRelationFilter = {
    is?: SharedInterviewResultWhereInput | null
    isNot?: SharedInterviewResultWhereInput | null
  }

  export type InterviewSessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    duration?: SortOrder
    status?: SortOrder
    resumeSnapshot?: SortOrder
    jobDescription?: SortOrder
    resumeSummary?: SortOrder
    jdSummary?: SortOrder
    vapiCallId?: SortOrder
    vapiAssistantId?: SortOrder
    transcript?: SortOrder
    videoUrl?: SortOrder
    videoRecorded?: SortOrder
    createdAt?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
  }

  export type InterviewSessionAvgOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type InterviewSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    duration?: SortOrder
    status?: SortOrder
    resumeSnapshot?: SortOrder
    jobDescription?: SortOrder
    resumeSummary?: SortOrder
    jdSummary?: SortOrder
    vapiCallId?: SortOrder
    vapiAssistantId?: SortOrder
    videoUrl?: SortOrder
    videoRecorded?: SortOrder
    createdAt?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
  }

  export type InterviewSessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    duration?: SortOrder
    status?: SortOrder
    resumeSnapshot?: SortOrder
    jobDescription?: SortOrder
    resumeSummary?: SortOrder
    jdSummary?: SortOrder
    vapiCallId?: SortOrder
    vapiAssistantId?: SortOrder
    videoUrl?: SortOrder
    videoRecorded?: SortOrder
    createdAt?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
  }

  export type InterviewSessionSumOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type InterviewSessionRelationFilter = {
    is?: InterviewSessionWhereInput
    isNot?: InterviewSessionWhereInput
  }

  export type InterviewFeedbackCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    overallScore?: SortOrder
    communicationClarity?: SortOrder
    technicalDepth?: SortOrder
    confidence?: SortOrder
    roleAlignment?: SortOrder
    skillRatings?: SortOrder
    strengths?: SortOrder
    weaknesses?: SortOrder
    improvements?: SortOrder
    suggestedTopics?: SortOrder
    learningRoadmap?: SortOrder
    aiSummary?: SortOrder
    createdAt?: SortOrder
  }

  export type InterviewFeedbackAvgOrderByAggregateInput = {
    overallScore?: SortOrder
    communicationClarity?: SortOrder
    technicalDepth?: SortOrder
    confidence?: SortOrder
    roleAlignment?: SortOrder
  }

  export type InterviewFeedbackMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    overallScore?: SortOrder
    communicationClarity?: SortOrder
    technicalDepth?: SortOrder
    confidence?: SortOrder
    roleAlignment?: SortOrder
    learningRoadmap?: SortOrder
    aiSummary?: SortOrder
    createdAt?: SortOrder
  }

  export type InterviewFeedbackMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    overallScore?: SortOrder
    communicationClarity?: SortOrder
    technicalDepth?: SortOrder
    confidence?: SortOrder
    roleAlignment?: SortOrder
    learningRoadmap?: SortOrder
    aiSummary?: SortOrder
    createdAt?: SortOrder
  }

  export type InterviewFeedbackSumOrderByAggregateInput = {
    overallScore?: SortOrder
    communicationClarity?: SortOrder
    technicalDepth?: SortOrder
    confidence?: SortOrder
    roleAlignment?: SortOrder
  }

  export type QuestionBankCountOrderByAggregateInput = {
    id?: SortOrder
    role?: SortOrder
    difficulty?: SortOrder
    category?: SortOrder
    question?: SortOrder
    followUps?: SortOrder
    keyPoints?: SortOrder
    tags?: SortOrder
    active?: SortOrder
    usageCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuestionBankAvgOrderByAggregateInput = {
    usageCount?: SortOrder
  }

  export type QuestionBankMaxOrderByAggregateInput = {
    id?: SortOrder
    role?: SortOrder
    difficulty?: SortOrder
    category?: SortOrder
    question?: SortOrder
    active?: SortOrder
    usageCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuestionBankMinOrderByAggregateInput = {
    id?: SortOrder
    role?: SortOrder
    difficulty?: SortOrder
    category?: SortOrder
    question?: SortOrder
    active?: SortOrder
    usageCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuestionBankSumOrderByAggregateInput = {
    usageCount?: SortOrder
  }

  export type SharedInterviewResultCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrder
    shareToken?: SortOrder
    isPublic?: SortOrder
    expiresAt?: SortOrder
    viewCount?: SortOrder
    lastViewedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type SharedInterviewResultAvgOrderByAggregateInput = {
    viewCount?: SortOrder
  }

  export type SharedInterviewResultMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrder
    shareToken?: SortOrder
    isPublic?: SortOrder
    expiresAt?: SortOrder
    viewCount?: SortOrder
    lastViewedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type SharedInterviewResultMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    userId?: SortOrder
    shareToken?: SortOrder
    isPublic?: SortOrder
    expiresAt?: SortOrder
    viewCount?: SortOrder
    lastViewedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type SharedInterviewResultSumOrderByAggregateInput = {
    viewCount?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type InterviewAnalyticsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    totalInterviews?: SortOrder
    averageScore?: SortOrder
    averageCommunication?: SortOrder
    averageTechnical?: SortOrder
    averageConfidence?: SortOrder
    roleStats?: SortOrder
    monthlyScores?: SortOrder
    topStrengths?: SortOrder
    topWeaknesses?: SortOrder
    lastUpdated?: SortOrder
  }

  export type InterviewAnalyticsAvgOrderByAggregateInput = {
    totalInterviews?: SortOrder
    averageScore?: SortOrder
    averageCommunication?: SortOrder
    averageTechnical?: SortOrder
    averageConfidence?: SortOrder
  }

  export type InterviewAnalyticsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    totalInterviews?: SortOrder
    averageScore?: SortOrder
    averageCommunication?: SortOrder
    averageTechnical?: SortOrder
    averageConfidence?: SortOrder
    lastUpdated?: SortOrder
  }

  export type InterviewAnalyticsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    totalInterviews?: SortOrder
    averageScore?: SortOrder
    averageCommunication?: SortOrder
    averageTechnical?: SortOrder
    averageConfidence?: SortOrder
    lastUpdated?: SortOrder
  }

  export type InterviewAnalyticsSumOrderByAggregateInput = {
    totalInterviews?: SortOrder
    averageScore?: SortOrder
    averageCommunication?: SortOrder
    averageTechnical?: SortOrder
    averageConfidence?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type RoadmapPhaseListRelationFilter = {
    every?: RoadmapPhaseWhereInput
    some?: RoadmapPhaseWhereInput
    none?: RoadmapPhaseWhereInput
  }

  export type RoadmapProgressListRelationFilter = {
    every?: RoadmapProgressWhereInput
    some?: RoadmapProgressWhereInput
    none?: RoadmapProgressWhereInput
  }

  export type RoadmapPhaseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoadmapProgressOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoadmapCountOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    level?: SortOrder
    duration?: SortOrder
    gradient?: SortOrder
    skills?: SortOrder
    popularity?: SortOrder
    isActive?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoadmapAvgOrderByAggregateInput = {
    popularity?: SortOrder
    order?: SortOrder
  }

  export type RoadmapMaxOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    level?: SortOrder
    duration?: SortOrder
    gradient?: SortOrder
    popularity?: SortOrder
    isActive?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoadmapMinOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    level?: SortOrder
    duration?: SortOrder
    gradient?: SortOrder
    popularity?: SortOrder
    isActive?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoadmapSumOrderByAggregateInput = {
    popularity?: SortOrder
    order?: SortOrder
  }

  export type RoadmapRelationFilter = {
    is?: RoadmapWhereInput
    isNot?: RoadmapWhereInput
  }

  export type RoadmapStepListRelationFilter = {
    every?: RoadmapStepWhereInput
    some?: RoadmapStepWhereInput
    none?: RoadmapStepWhereInput
  }

  export type RoadmapStepOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoadmapPhaseCountOrderByAggregateInput = {
    id?: SortOrder
    roadmapId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    order?: SortOrder
  }

  export type RoadmapPhaseAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type RoadmapPhaseMaxOrderByAggregateInput = {
    id?: SortOrder
    roadmapId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    order?: SortOrder
  }

  export type RoadmapPhaseMinOrderByAggregateInput = {
    id?: SortOrder
    roadmapId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    order?: SortOrder
  }

  export type RoadmapPhaseSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type RoadmapPhaseRelationFilter = {
    is?: RoadmapPhaseWhereInput
    isNot?: RoadmapPhaseWhereInput
  }

  export type RoadmapStepCountOrderByAggregateInput = {
    id?: SortOrder
    phaseId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    difficulty?: SortOrder
    estimatedTime?: SortOrder
    order?: SortOrder
    topics?: SortOrder
    prerequisites?: SortOrder
    resources?: SortOrder
    checkpoints?: SortOrder
    relatedCheatsheets?: SortOrder
    relatedDSA?: SortOrder
    relatedInterviews?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoadmapStepAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type RoadmapStepMaxOrderByAggregateInput = {
    id?: SortOrder
    phaseId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    difficulty?: SortOrder
    estimatedTime?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoadmapStepMinOrderByAggregateInput = {
    id?: SortOrder
    phaseId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    difficulty?: SortOrder
    estimatedTime?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoadmapStepSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type RoadmapStepRelationFilter = {
    is?: RoadmapStepWhereInput
    isNot?: RoadmapStepWhereInput
  }

  export type RoadmapProgressUserIdStepIdCompoundUniqueInput = {
    userId: string
    stepId: string
  }

  export type RoadmapProgressCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roadmapId?: SortOrder
    stepId?: SortOrder
    completed?: SortOrder
    notes?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoadmapProgressMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roadmapId?: SortOrder
    stepId?: SortOrder
    completed?: SortOrder
    notes?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoadmapProgressMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    roadmapId?: SortOrder
    stepId?: SortOrder
    completed?: SortOrder
    notes?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CheatsheetListRelationFilter = {
    every?: CheatsheetWhereInput
    some?: CheatsheetWhereInput
    none?: CheatsheetWhereInput
  }

  export type CheatsheetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CheatsheetCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    order?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CheatsheetCategoryAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type CheatsheetCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    order?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CheatsheetCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    order?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CheatsheetCategorySumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type CheatsheetCategoryRelationFilter = {
    is?: CheatsheetCategoryWhereInput
    isNot?: CheatsheetCategoryWhereInput
  }

  export type CheatsheetCountOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    difficulty?: SortOrder
    tags?: SortOrder
    popularity?: SortOrder
    overview?: SortOrder
    syntax?: SortOrder
    operations?: SortOrder
    examples?: SortOrder
    mistakes?: SortOrder
    tips?: SortOrder
    relatedCheatsheets?: SortOrder
    relatedRoadmaps?: SortOrder
    relatedDSA?: SortOrder
    aiExplanation?: SortOrder
    voiceExplainer?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CheatsheetAvgOrderByAggregateInput = {
    popularity?: SortOrder
  }

  export type CheatsheetMaxOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    difficulty?: SortOrder
    popularity?: SortOrder
    overview?: SortOrder
    aiExplanation?: SortOrder
    voiceExplainer?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CheatsheetMinOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    difficulty?: SortOrder
    popularity?: SortOrder
    overview?: SortOrder
    aiExplanation?: SortOrder
    voiceExplainer?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CheatsheetSumOrderByAggregateInput = {
    popularity?: SortOrder
  }

  export type UserProgressCreateNestedManyWithoutUserInput = {
    create?: XOR<UserProgressCreateWithoutUserInput, UserProgressUncheckedCreateWithoutUserInput> | UserProgressCreateWithoutUserInput[] | UserProgressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserProgressCreateOrConnectWithoutUserInput | UserProgressCreateOrConnectWithoutUserInput[]
    createMany?: UserProgressCreateManyUserInputEnvelope
    connect?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
  }

  export type SubmissionCreateNestedManyWithoutUserInput = {
    create?: XOR<SubmissionCreateWithoutUserInput, SubmissionUncheckedCreateWithoutUserInput> | SubmissionCreateWithoutUserInput[] | SubmissionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SubmissionCreateOrConnectWithoutUserInput | SubmissionCreateOrConnectWithoutUserInput[]
    createMany?: SubmissionCreateManyUserInputEnvelope
    connect?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[]
  }

  export type InterviewSessionCreateNestedManyWithoutUserInput = {
    create?: XOR<InterviewSessionCreateWithoutUserInput, InterviewSessionUncheckedCreateWithoutUserInput> | InterviewSessionCreateWithoutUserInput[] | InterviewSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InterviewSessionCreateOrConnectWithoutUserInput | InterviewSessionCreateOrConnectWithoutUserInput[]
    createMany?: InterviewSessionCreateManyUserInputEnvelope
    connect?: InterviewSessionWhereUniqueInput | InterviewSessionWhereUniqueInput[]
  }

  export type SharedInterviewResultCreateNestedManyWithoutUserInput = {
    create?: XOR<SharedInterviewResultCreateWithoutUserInput, SharedInterviewResultUncheckedCreateWithoutUserInput> | SharedInterviewResultCreateWithoutUserInput[] | SharedInterviewResultUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SharedInterviewResultCreateOrConnectWithoutUserInput | SharedInterviewResultCreateOrConnectWithoutUserInput[]
    createMany?: SharedInterviewResultCreateManyUserInputEnvelope
    connect?: SharedInterviewResultWhereUniqueInput | SharedInterviewResultWhereUniqueInput[]
  }

  export type InterviewAnalyticsCreateNestedOneWithoutUserInput = {
    create?: XOR<InterviewAnalyticsCreateWithoutUserInput, InterviewAnalyticsUncheckedCreateWithoutUserInput>
    connectOrCreate?: InterviewAnalyticsCreateOrConnectWithoutUserInput
    connect?: InterviewAnalyticsWhereUniqueInput
  }

  export type UserProgressUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserProgressCreateWithoutUserInput, UserProgressUncheckedCreateWithoutUserInput> | UserProgressCreateWithoutUserInput[] | UserProgressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserProgressCreateOrConnectWithoutUserInput | UserProgressCreateOrConnectWithoutUserInput[]
    createMany?: UserProgressCreateManyUserInputEnvelope
    connect?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
  }

  export type SubmissionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SubmissionCreateWithoutUserInput, SubmissionUncheckedCreateWithoutUserInput> | SubmissionCreateWithoutUserInput[] | SubmissionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SubmissionCreateOrConnectWithoutUserInput | SubmissionCreateOrConnectWithoutUserInput[]
    createMany?: SubmissionCreateManyUserInputEnvelope
    connect?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[]
  }

  export type InterviewSessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<InterviewSessionCreateWithoutUserInput, InterviewSessionUncheckedCreateWithoutUserInput> | InterviewSessionCreateWithoutUserInput[] | InterviewSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InterviewSessionCreateOrConnectWithoutUserInput | InterviewSessionCreateOrConnectWithoutUserInput[]
    createMany?: InterviewSessionCreateManyUserInputEnvelope
    connect?: InterviewSessionWhereUniqueInput | InterviewSessionWhereUniqueInput[]
  }

  export type SharedInterviewResultUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SharedInterviewResultCreateWithoutUserInput, SharedInterviewResultUncheckedCreateWithoutUserInput> | SharedInterviewResultCreateWithoutUserInput[] | SharedInterviewResultUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SharedInterviewResultCreateOrConnectWithoutUserInput | SharedInterviewResultCreateOrConnectWithoutUserInput[]
    createMany?: SharedInterviewResultCreateManyUserInputEnvelope
    connect?: SharedInterviewResultWhereUniqueInput | SharedInterviewResultWhereUniqueInput[]
  }

  export type InterviewAnalyticsUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<InterviewAnalyticsCreateWithoutUserInput, InterviewAnalyticsUncheckedCreateWithoutUserInput>
    connectOrCreate?: InterviewAnalyticsCreateOrConnectWithoutUserInput
    connect?: InterviewAnalyticsWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserProgressUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserProgressCreateWithoutUserInput, UserProgressUncheckedCreateWithoutUserInput> | UserProgressCreateWithoutUserInput[] | UserProgressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserProgressCreateOrConnectWithoutUserInput | UserProgressCreateOrConnectWithoutUserInput[]
    upsert?: UserProgressUpsertWithWhereUniqueWithoutUserInput | UserProgressUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserProgressCreateManyUserInputEnvelope
    set?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    disconnect?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    delete?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    connect?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    update?: UserProgressUpdateWithWhereUniqueWithoutUserInput | UserProgressUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserProgressUpdateManyWithWhereWithoutUserInput | UserProgressUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserProgressScalarWhereInput | UserProgressScalarWhereInput[]
  }

  export type SubmissionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SubmissionCreateWithoutUserInput, SubmissionUncheckedCreateWithoutUserInput> | SubmissionCreateWithoutUserInput[] | SubmissionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SubmissionCreateOrConnectWithoutUserInput | SubmissionCreateOrConnectWithoutUserInput[]
    upsert?: SubmissionUpsertWithWhereUniqueWithoutUserInput | SubmissionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SubmissionCreateManyUserInputEnvelope
    set?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[]
    disconnect?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[]
    delete?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[]
    connect?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[]
    update?: SubmissionUpdateWithWhereUniqueWithoutUserInput | SubmissionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SubmissionUpdateManyWithWhereWithoutUserInput | SubmissionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SubmissionScalarWhereInput | SubmissionScalarWhereInput[]
  }

  export type InterviewSessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<InterviewSessionCreateWithoutUserInput, InterviewSessionUncheckedCreateWithoutUserInput> | InterviewSessionCreateWithoutUserInput[] | InterviewSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InterviewSessionCreateOrConnectWithoutUserInput | InterviewSessionCreateOrConnectWithoutUserInput[]
    upsert?: InterviewSessionUpsertWithWhereUniqueWithoutUserInput | InterviewSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InterviewSessionCreateManyUserInputEnvelope
    set?: InterviewSessionWhereUniqueInput | InterviewSessionWhereUniqueInput[]
    disconnect?: InterviewSessionWhereUniqueInput | InterviewSessionWhereUniqueInput[]
    delete?: InterviewSessionWhereUniqueInput | InterviewSessionWhereUniqueInput[]
    connect?: InterviewSessionWhereUniqueInput | InterviewSessionWhereUniqueInput[]
    update?: InterviewSessionUpdateWithWhereUniqueWithoutUserInput | InterviewSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InterviewSessionUpdateManyWithWhereWithoutUserInput | InterviewSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InterviewSessionScalarWhereInput | InterviewSessionScalarWhereInput[]
  }

  export type SharedInterviewResultUpdateManyWithoutUserNestedInput = {
    create?: XOR<SharedInterviewResultCreateWithoutUserInput, SharedInterviewResultUncheckedCreateWithoutUserInput> | SharedInterviewResultCreateWithoutUserInput[] | SharedInterviewResultUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SharedInterviewResultCreateOrConnectWithoutUserInput | SharedInterviewResultCreateOrConnectWithoutUserInput[]
    upsert?: SharedInterviewResultUpsertWithWhereUniqueWithoutUserInput | SharedInterviewResultUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SharedInterviewResultCreateManyUserInputEnvelope
    set?: SharedInterviewResultWhereUniqueInput | SharedInterviewResultWhereUniqueInput[]
    disconnect?: SharedInterviewResultWhereUniqueInput | SharedInterviewResultWhereUniqueInput[]
    delete?: SharedInterviewResultWhereUniqueInput | SharedInterviewResultWhereUniqueInput[]
    connect?: SharedInterviewResultWhereUniqueInput | SharedInterviewResultWhereUniqueInput[]
    update?: SharedInterviewResultUpdateWithWhereUniqueWithoutUserInput | SharedInterviewResultUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SharedInterviewResultUpdateManyWithWhereWithoutUserInput | SharedInterviewResultUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SharedInterviewResultScalarWhereInput | SharedInterviewResultScalarWhereInput[]
  }

  export type InterviewAnalyticsUpdateOneWithoutUserNestedInput = {
    create?: XOR<InterviewAnalyticsCreateWithoutUserInput, InterviewAnalyticsUncheckedCreateWithoutUserInput>
    connectOrCreate?: InterviewAnalyticsCreateOrConnectWithoutUserInput
    upsert?: InterviewAnalyticsUpsertWithoutUserInput
    disconnect?: InterviewAnalyticsWhereInput | boolean
    delete?: InterviewAnalyticsWhereInput | boolean
    connect?: InterviewAnalyticsWhereUniqueInput
    update?: XOR<XOR<InterviewAnalyticsUpdateToOneWithWhereWithoutUserInput, InterviewAnalyticsUpdateWithoutUserInput>, InterviewAnalyticsUncheckedUpdateWithoutUserInput>
  }

  export type UserProgressUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserProgressCreateWithoutUserInput, UserProgressUncheckedCreateWithoutUserInput> | UserProgressCreateWithoutUserInput[] | UserProgressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserProgressCreateOrConnectWithoutUserInput | UserProgressCreateOrConnectWithoutUserInput[]
    upsert?: UserProgressUpsertWithWhereUniqueWithoutUserInput | UserProgressUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserProgressCreateManyUserInputEnvelope
    set?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    disconnect?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    delete?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    connect?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    update?: UserProgressUpdateWithWhereUniqueWithoutUserInput | UserProgressUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserProgressUpdateManyWithWhereWithoutUserInput | UserProgressUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserProgressScalarWhereInput | UserProgressScalarWhereInput[]
  }

  export type SubmissionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SubmissionCreateWithoutUserInput, SubmissionUncheckedCreateWithoutUserInput> | SubmissionCreateWithoutUserInput[] | SubmissionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SubmissionCreateOrConnectWithoutUserInput | SubmissionCreateOrConnectWithoutUserInput[]
    upsert?: SubmissionUpsertWithWhereUniqueWithoutUserInput | SubmissionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SubmissionCreateManyUserInputEnvelope
    set?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[]
    disconnect?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[]
    delete?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[]
    connect?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[]
    update?: SubmissionUpdateWithWhereUniqueWithoutUserInput | SubmissionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SubmissionUpdateManyWithWhereWithoutUserInput | SubmissionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SubmissionScalarWhereInput | SubmissionScalarWhereInput[]
  }

  export type InterviewSessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<InterviewSessionCreateWithoutUserInput, InterviewSessionUncheckedCreateWithoutUserInput> | InterviewSessionCreateWithoutUserInput[] | InterviewSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InterviewSessionCreateOrConnectWithoutUserInput | InterviewSessionCreateOrConnectWithoutUserInput[]
    upsert?: InterviewSessionUpsertWithWhereUniqueWithoutUserInput | InterviewSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InterviewSessionCreateManyUserInputEnvelope
    set?: InterviewSessionWhereUniqueInput | InterviewSessionWhereUniqueInput[]
    disconnect?: InterviewSessionWhereUniqueInput | InterviewSessionWhereUniqueInput[]
    delete?: InterviewSessionWhereUniqueInput | InterviewSessionWhereUniqueInput[]
    connect?: InterviewSessionWhereUniqueInput | InterviewSessionWhereUniqueInput[]
    update?: InterviewSessionUpdateWithWhereUniqueWithoutUserInput | InterviewSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InterviewSessionUpdateManyWithWhereWithoutUserInput | InterviewSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InterviewSessionScalarWhereInput | InterviewSessionScalarWhereInput[]
  }

  export type SharedInterviewResultUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SharedInterviewResultCreateWithoutUserInput, SharedInterviewResultUncheckedCreateWithoutUserInput> | SharedInterviewResultCreateWithoutUserInput[] | SharedInterviewResultUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SharedInterviewResultCreateOrConnectWithoutUserInput | SharedInterviewResultCreateOrConnectWithoutUserInput[]
    upsert?: SharedInterviewResultUpsertWithWhereUniqueWithoutUserInput | SharedInterviewResultUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SharedInterviewResultCreateManyUserInputEnvelope
    set?: SharedInterviewResultWhereUniqueInput | SharedInterviewResultWhereUniqueInput[]
    disconnect?: SharedInterviewResultWhereUniqueInput | SharedInterviewResultWhereUniqueInput[]
    delete?: SharedInterviewResultWhereUniqueInput | SharedInterviewResultWhereUniqueInput[]
    connect?: SharedInterviewResultWhereUniqueInput | SharedInterviewResultWhereUniqueInput[]
    update?: SharedInterviewResultUpdateWithWhereUniqueWithoutUserInput | SharedInterviewResultUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SharedInterviewResultUpdateManyWithWhereWithoutUserInput | SharedInterviewResultUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SharedInterviewResultScalarWhereInput | SharedInterviewResultScalarWhereInput[]
  }

  export type InterviewAnalyticsUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<InterviewAnalyticsCreateWithoutUserInput, InterviewAnalyticsUncheckedCreateWithoutUserInput>
    connectOrCreate?: InterviewAnalyticsCreateOrConnectWithoutUserInput
    upsert?: InterviewAnalyticsUpsertWithoutUserInput
    disconnect?: InterviewAnalyticsWhereInput | boolean
    delete?: InterviewAnalyticsWhereInput | boolean
    connect?: InterviewAnalyticsWhereUniqueInput
    update?: XOR<XOR<InterviewAnalyticsUpdateToOneWithWhereWithoutUserInput, InterviewAnalyticsUpdateWithoutUserInput>, InterviewAnalyticsUncheckedUpdateWithoutUserInput>
  }

  export type DSALessonCreateNestedManyWithoutTopicInput = {
    create?: XOR<DSALessonCreateWithoutTopicInput, DSALessonUncheckedCreateWithoutTopicInput> | DSALessonCreateWithoutTopicInput[] | DSALessonUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: DSALessonCreateOrConnectWithoutTopicInput | DSALessonCreateOrConnectWithoutTopicInput[]
    createMany?: DSALessonCreateManyTopicInputEnvelope
    connect?: DSALessonWhereUniqueInput | DSALessonWhereUniqueInput[]
  }

  export type DSALessonUncheckedCreateNestedManyWithoutTopicInput = {
    create?: XOR<DSALessonCreateWithoutTopicInput, DSALessonUncheckedCreateWithoutTopicInput> | DSALessonCreateWithoutTopicInput[] | DSALessonUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: DSALessonCreateOrConnectWithoutTopicInput | DSALessonCreateOrConnectWithoutTopicInput[]
    createMany?: DSALessonCreateManyTopicInputEnvelope
    connect?: DSALessonWhereUniqueInput | DSALessonWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DSALessonUpdateManyWithoutTopicNestedInput = {
    create?: XOR<DSALessonCreateWithoutTopicInput, DSALessonUncheckedCreateWithoutTopicInput> | DSALessonCreateWithoutTopicInput[] | DSALessonUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: DSALessonCreateOrConnectWithoutTopicInput | DSALessonCreateOrConnectWithoutTopicInput[]
    upsert?: DSALessonUpsertWithWhereUniqueWithoutTopicInput | DSALessonUpsertWithWhereUniqueWithoutTopicInput[]
    createMany?: DSALessonCreateManyTopicInputEnvelope
    set?: DSALessonWhereUniqueInput | DSALessonWhereUniqueInput[]
    disconnect?: DSALessonWhereUniqueInput | DSALessonWhereUniqueInput[]
    delete?: DSALessonWhereUniqueInput | DSALessonWhereUniqueInput[]
    connect?: DSALessonWhereUniqueInput | DSALessonWhereUniqueInput[]
    update?: DSALessonUpdateWithWhereUniqueWithoutTopicInput | DSALessonUpdateWithWhereUniqueWithoutTopicInput[]
    updateMany?: DSALessonUpdateManyWithWhereWithoutTopicInput | DSALessonUpdateManyWithWhereWithoutTopicInput[]
    deleteMany?: DSALessonScalarWhereInput | DSALessonScalarWhereInput[]
  }

  export type DSALessonUncheckedUpdateManyWithoutTopicNestedInput = {
    create?: XOR<DSALessonCreateWithoutTopicInput, DSALessonUncheckedCreateWithoutTopicInput> | DSALessonCreateWithoutTopicInput[] | DSALessonUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: DSALessonCreateOrConnectWithoutTopicInput | DSALessonCreateOrConnectWithoutTopicInput[]
    upsert?: DSALessonUpsertWithWhereUniqueWithoutTopicInput | DSALessonUpsertWithWhereUniqueWithoutTopicInput[]
    createMany?: DSALessonCreateManyTopicInputEnvelope
    set?: DSALessonWhereUniqueInput | DSALessonWhereUniqueInput[]
    disconnect?: DSALessonWhereUniqueInput | DSALessonWhereUniqueInput[]
    delete?: DSALessonWhereUniqueInput | DSALessonWhereUniqueInput[]
    connect?: DSALessonWhereUniqueInput | DSALessonWhereUniqueInput[]
    update?: DSALessonUpdateWithWhereUniqueWithoutTopicInput | DSALessonUpdateWithWhereUniqueWithoutTopicInput[]
    updateMany?: DSALessonUpdateManyWithWhereWithoutTopicInput | DSALessonUpdateManyWithWhereWithoutTopicInput[]
    deleteMany?: DSALessonScalarWhereInput | DSALessonScalarWhereInput[]
  }

  export type DSATopicCreateNestedOneWithoutLessonsInput = {
    create?: XOR<DSATopicCreateWithoutLessonsInput, DSATopicUncheckedCreateWithoutLessonsInput>
    connectOrCreate?: DSATopicCreateOrConnectWithoutLessonsInput
    connect?: DSATopicWhereUniqueInput
  }

  export type DSATopicUpdateOneRequiredWithoutLessonsNestedInput = {
    create?: XOR<DSATopicCreateWithoutLessonsInput, DSATopicUncheckedCreateWithoutLessonsInput>
    connectOrCreate?: DSATopicCreateOrConnectWithoutLessonsInput
    upsert?: DSATopicUpsertWithoutLessonsInput
    connect?: DSATopicWhereUniqueInput
    update?: XOR<XOR<DSATopicUpdateToOneWithWhereWithoutLessonsInput, DSATopicUpdateWithoutLessonsInput>, DSATopicUncheckedUpdateWithoutLessonsInput>
  }

  export type ProblemCreateconstraintsInput = {
    set: string[]
  }

  export type ProblemCreatesheetsInput = {
    set: string[]
  }

  export type UserProgressCreateNestedManyWithoutProblemInput = {
    create?: XOR<UserProgressCreateWithoutProblemInput, UserProgressUncheckedCreateWithoutProblemInput> | UserProgressCreateWithoutProblemInput[] | UserProgressUncheckedCreateWithoutProblemInput[]
    connectOrCreate?: UserProgressCreateOrConnectWithoutProblemInput | UserProgressCreateOrConnectWithoutProblemInput[]
    createMany?: UserProgressCreateManyProblemInputEnvelope
    connect?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
  }

  export type SubmissionCreateNestedManyWithoutProblemInput = {
    create?: XOR<SubmissionCreateWithoutProblemInput, SubmissionUncheckedCreateWithoutProblemInput> | SubmissionCreateWithoutProblemInput[] | SubmissionUncheckedCreateWithoutProblemInput[]
    connectOrCreate?: SubmissionCreateOrConnectWithoutProblemInput | SubmissionCreateOrConnectWithoutProblemInput[]
    createMany?: SubmissionCreateManyProblemInputEnvelope
    connect?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[]
  }

  export type UserProgressUncheckedCreateNestedManyWithoutProblemInput = {
    create?: XOR<UserProgressCreateWithoutProblemInput, UserProgressUncheckedCreateWithoutProblemInput> | UserProgressCreateWithoutProblemInput[] | UserProgressUncheckedCreateWithoutProblemInput[]
    connectOrCreate?: UserProgressCreateOrConnectWithoutProblemInput | UserProgressCreateOrConnectWithoutProblemInput[]
    createMany?: UserProgressCreateManyProblemInputEnvelope
    connect?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
  }

  export type SubmissionUncheckedCreateNestedManyWithoutProblemInput = {
    create?: XOR<SubmissionCreateWithoutProblemInput, SubmissionUncheckedCreateWithoutProblemInput> | SubmissionCreateWithoutProblemInput[] | SubmissionUncheckedCreateWithoutProblemInput[]
    connectOrCreate?: SubmissionCreateOrConnectWithoutProblemInput | SubmissionCreateOrConnectWithoutProblemInput[]
    createMany?: SubmissionCreateManyProblemInputEnvelope
    connect?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[]
  }

  export type ProblemUpdateconstraintsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ProblemUpdatesheetsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserProgressUpdateManyWithoutProblemNestedInput = {
    create?: XOR<UserProgressCreateWithoutProblemInput, UserProgressUncheckedCreateWithoutProblemInput> | UserProgressCreateWithoutProblemInput[] | UserProgressUncheckedCreateWithoutProblemInput[]
    connectOrCreate?: UserProgressCreateOrConnectWithoutProblemInput | UserProgressCreateOrConnectWithoutProblemInput[]
    upsert?: UserProgressUpsertWithWhereUniqueWithoutProblemInput | UserProgressUpsertWithWhereUniqueWithoutProblemInput[]
    createMany?: UserProgressCreateManyProblemInputEnvelope
    set?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    disconnect?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    delete?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    connect?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    update?: UserProgressUpdateWithWhereUniqueWithoutProblemInput | UserProgressUpdateWithWhereUniqueWithoutProblemInput[]
    updateMany?: UserProgressUpdateManyWithWhereWithoutProblemInput | UserProgressUpdateManyWithWhereWithoutProblemInput[]
    deleteMany?: UserProgressScalarWhereInput | UserProgressScalarWhereInput[]
  }

  export type SubmissionUpdateManyWithoutProblemNestedInput = {
    create?: XOR<SubmissionCreateWithoutProblemInput, SubmissionUncheckedCreateWithoutProblemInput> | SubmissionCreateWithoutProblemInput[] | SubmissionUncheckedCreateWithoutProblemInput[]
    connectOrCreate?: SubmissionCreateOrConnectWithoutProblemInput | SubmissionCreateOrConnectWithoutProblemInput[]
    upsert?: SubmissionUpsertWithWhereUniqueWithoutProblemInput | SubmissionUpsertWithWhereUniqueWithoutProblemInput[]
    createMany?: SubmissionCreateManyProblemInputEnvelope
    set?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[]
    disconnect?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[]
    delete?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[]
    connect?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[]
    update?: SubmissionUpdateWithWhereUniqueWithoutProblemInput | SubmissionUpdateWithWhereUniqueWithoutProblemInput[]
    updateMany?: SubmissionUpdateManyWithWhereWithoutProblemInput | SubmissionUpdateManyWithWhereWithoutProblemInput[]
    deleteMany?: SubmissionScalarWhereInput | SubmissionScalarWhereInput[]
  }

  export type UserProgressUncheckedUpdateManyWithoutProblemNestedInput = {
    create?: XOR<UserProgressCreateWithoutProblemInput, UserProgressUncheckedCreateWithoutProblemInput> | UserProgressCreateWithoutProblemInput[] | UserProgressUncheckedCreateWithoutProblemInput[]
    connectOrCreate?: UserProgressCreateOrConnectWithoutProblemInput | UserProgressCreateOrConnectWithoutProblemInput[]
    upsert?: UserProgressUpsertWithWhereUniqueWithoutProblemInput | UserProgressUpsertWithWhereUniqueWithoutProblemInput[]
    createMany?: UserProgressCreateManyProblemInputEnvelope
    set?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    disconnect?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    delete?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    connect?: UserProgressWhereUniqueInput | UserProgressWhereUniqueInput[]
    update?: UserProgressUpdateWithWhereUniqueWithoutProblemInput | UserProgressUpdateWithWhereUniqueWithoutProblemInput[]
    updateMany?: UserProgressUpdateManyWithWhereWithoutProblemInput | UserProgressUpdateManyWithWhereWithoutProblemInput[]
    deleteMany?: UserProgressScalarWhereInput | UserProgressScalarWhereInput[]
  }

  export type SubmissionUncheckedUpdateManyWithoutProblemNestedInput = {
    create?: XOR<SubmissionCreateWithoutProblemInput, SubmissionUncheckedCreateWithoutProblemInput> | SubmissionCreateWithoutProblemInput[] | SubmissionUncheckedCreateWithoutProblemInput[]
    connectOrCreate?: SubmissionCreateOrConnectWithoutProblemInput | SubmissionCreateOrConnectWithoutProblemInput[]
    upsert?: SubmissionUpsertWithWhereUniqueWithoutProblemInput | SubmissionUpsertWithWhereUniqueWithoutProblemInput[]
    createMany?: SubmissionCreateManyProblemInputEnvelope
    set?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[]
    disconnect?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[]
    delete?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[]
    connect?: SubmissionWhereUniqueInput | SubmissionWhereUniqueInput[]
    update?: SubmissionUpdateWithWhereUniqueWithoutProblemInput | SubmissionUpdateWithWhereUniqueWithoutProblemInput[]
    updateMany?: SubmissionUpdateManyWithWhereWithoutProblemInput | SubmissionUpdateManyWithWhereWithoutProblemInput[]
    deleteMany?: SubmissionScalarWhereInput | SubmissionScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutProgressInput = {
    create?: XOR<UserCreateWithoutProgressInput, UserUncheckedCreateWithoutProgressInput>
    connectOrCreate?: UserCreateOrConnectWithoutProgressInput
    connect?: UserWhereUniqueInput
  }

  export type ProblemCreateNestedOneWithoutProgressInput = {
    create?: XOR<ProblemCreateWithoutProgressInput, ProblemUncheckedCreateWithoutProgressInput>
    connectOrCreate?: ProblemCreateOrConnectWithoutProgressInput
    connect?: ProblemWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UserUpdateOneRequiredWithoutProgressNestedInput = {
    create?: XOR<UserCreateWithoutProgressInput, UserUncheckedCreateWithoutProgressInput>
    connectOrCreate?: UserCreateOrConnectWithoutProgressInput
    upsert?: UserUpsertWithoutProgressInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProgressInput, UserUpdateWithoutProgressInput>, UserUncheckedUpdateWithoutProgressInput>
  }

  export type ProblemUpdateOneRequiredWithoutProgressNestedInput = {
    create?: XOR<ProblemCreateWithoutProgressInput, ProblemUncheckedCreateWithoutProgressInput>
    connectOrCreate?: ProblemCreateOrConnectWithoutProgressInput
    upsert?: ProblemUpsertWithoutProgressInput
    connect?: ProblemWhereUniqueInput
    update?: XOR<XOR<ProblemUpdateToOneWithWhereWithoutProgressInput, ProblemUpdateWithoutProgressInput>, ProblemUncheckedUpdateWithoutProgressInput>
  }

  export type UserCreateNestedOneWithoutSubmissionsInput = {
    create?: XOR<UserCreateWithoutSubmissionsInput, UserUncheckedCreateWithoutSubmissionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSubmissionsInput
    connect?: UserWhereUniqueInput
  }

  export type ProblemCreateNestedOneWithoutSubmissionsInput = {
    create?: XOR<ProblemCreateWithoutSubmissionsInput, ProblemUncheckedCreateWithoutSubmissionsInput>
    connectOrCreate?: ProblemCreateOrConnectWithoutSubmissionsInput
    connect?: ProblemWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutSubmissionsNestedInput = {
    create?: XOR<UserCreateWithoutSubmissionsInput, UserUncheckedCreateWithoutSubmissionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSubmissionsInput
    upsert?: UserUpsertWithoutSubmissionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSubmissionsInput, UserUpdateWithoutSubmissionsInput>, UserUncheckedUpdateWithoutSubmissionsInput>
  }

  export type ProblemUpdateOneRequiredWithoutSubmissionsNestedInput = {
    create?: XOR<ProblemCreateWithoutSubmissionsInput, ProblemUncheckedCreateWithoutSubmissionsInput>
    connectOrCreate?: ProblemCreateOrConnectWithoutSubmissionsInput
    upsert?: ProblemUpsertWithoutSubmissionsInput
    connect?: ProblemWhereUniqueInput
    update?: XOR<XOR<ProblemUpdateToOneWithWhereWithoutSubmissionsInput, ProblemUpdateWithoutSubmissionsInput>, ProblemUncheckedUpdateWithoutSubmissionsInput>
  }

  export type LearnCategoryCreateNestedManyWithoutDomainInput = {
    create?: XOR<LearnCategoryCreateWithoutDomainInput, LearnCategoryUncheckedCreateWithoutDomainInput> | LearnCategoryCreateWithoutDomainInput[] | LearnCategoryUncheckedCreateWithoutDomainInput[]
    connectOrCreate?: LearnCategoryCreateOrConnectWithoutDomainInput | LearnCategoryCreateOrConnectWithoutDomainInput[]
    createMany?: LearnCategoryCreateManyDomainInputEnvelope
    connect?: LearnCategoryWhereUniqueInput | LearnCategoryWhereUniqueInput[]
  }

  export type LearnCategoryUncheckedCreateNestedManyWithoutDomainInput = {
    create?: XOR<LearnCategoryCreateWithoutDomainInput, LearnCategoryUncheckedCreateWithoutDomainInput> | LearnCategoryCreateWithoutDomainInput[] | LearnCategoryUncheckedCreateWithoutDomainInput[]
    connectOrCreate?: LearnCategoryCreateOrConnectWithoutDomainInput | LearnCategoryCreateOrConnectWithoutDomainInput[]
    createMany?: LearnCategoryCreateManyDomainInputEnvelope
    connect?: LearnCategoryWhereUniqueInput | LearnCategoryWhereUniqueInput[]
  }

  export type LearnCategoryUpdateManyWithoutDomainNestedInput = {
    create?: XOR<LearnCategoryCreateWithoutDomainInput, LearnCategoryUncheckedCreateWithoutDomainInput> | LearnCategoryCreateWithoutDomainInput[] | LearnCategoryUncheckedCreateWithoutDomainInput[]
    connectOrCreate?: LearnCategoryCreateOrConnectWithoutDomainInput | LearnCategoryCreateOrConnectWithoutDomainInput[]
    upsert?: LearnCategoryUpsertWithWhereUniqueWithoutDomainInput | LearnCategoryUpsertWithWhereUniqueWithoutDomainInput[]
    createMany?: LearnCategoryCreateManyDomainInputEnvelope
    set?: LearnCategoryWhereUniqueInput | LearnCategoryWhereUniqueInput[]
    disconnect?: LearnCategoryWhereUniqueInput | LearnCategoryWhereUniqueInput[]
    delete?: LearnCategoryWhereUniqueInput | LearnCategoryWhereUniqueInput[]
    connect?: LearnCategoryWhereUniqueInput | LearnCategoryWhereUniqueInput[]
    update?: LearnCategoryUpdateWithWhereUniqueWithoutDomainInput | LearnCategoryUpdateWithWhereUniqueWithoutDomainInput[]
    updateMany?: LearnCategoryUpdateManyWithWhereWithoutDomainInput | LearnCategoryUpdateManyWithWhereWithoutDomainInput[]
    deleteMany?: LearnCategoryScalarWhereInput | LearnCategoryScalarWhereInput[]
  }

  export type LearnCategoryUncheckedUpdateManyWithoutDomainNestedInput = {
    create?: XOR<LearnCategoryCreateWithoutDomainInput, LearnCategoryUncheckedCreateWithoutDomainInput> | LearnCategoryCreateWithoutDomainInput[] | LearnCategoryUncheckedCreateWithoutDomainInput[]
    connectOrCreate?: LearnCategoryCreateOrConnectWithoutDomainInput | LearnCategoryCreateOrConnectWithoutDomainInput[]
    upsert?: LearnCategoryUpsertWithWhereUniqueWithoutDomainInput | LearnCategoryUpsertWithWhereUniqueWithoutDomainInput[]
    createMany?: LearnCategoryCreateManyDomainInputEnvelope
    set?: LearnCategoryWhereUniqueInput | LearnCategoryWhereUniqueInput[]
    disconnect?: LearnCategoryWhereUniqueInput | LearnCategoryWhereUniqueInput[]
    delete?: LearnCategoryWhereUniqueInput | LearnCategoryWhereUniqueInput[]
    connect?: LearnCategoryWhereUniqueInput | LearnCategoryWhereUniqueInput[]
    update?: LearnCategoryUpdateWithWhereUniqueWithoutDomainInput | LearnCategoryUpdateWithWhereUniqueWithoutDomainInput[]
    updateMany?: LearnCategoryUpdateManyWithWhereWithoutDomainInput | LearnCategoryUpdateManyWithWhereWithoutDomainInput[]
    deleteMany?: LearnCategoryScalarWhereInput | LearnCategoryScalarWhereInput[]
  }

  export type LearnDomainCreateNestedOneWithoutCategoriesInput = {
    create?: XOR<LearnDomainCreateWithoutCategoriesInput, LearnDomainUncheckedCreateWithoutCategoriesInput>
    connectOrCreate?: LearnDomainCreateOrConnectWithoutCategoriesInput
    connect?: LearnDomainWhereUniqueInput
  }

  export type LearnTopicCreateNestedManyWithoutCategoryInput = {
    create?: XOR<LearnTopicCreateWithoutCategoryInput, LearnTopicUncheckedCreateWithoutCategoryInput> | LearnTopicCreateWithoutCategoryInput[] | LearnTopicUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: LearnTopicCreateOrConnectWithoutCategoryInput | LearnTopicCreateOrConnectWithoutCategoryInput[]
    createMany?: LearnTopicCreateManyCategoryInputEnvelope
    connect?: LearnTopicWhereUniqueInput | LearnTopicWhereUniqueInput[]
  }

  export type LearnTopicUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<LearnTopicCreateWithoutCategoryInput, LearnTopicUncheckedCreateWithoutCategoryInput> | LearnTopicCreateWithoutCategoryInput[] | LearnTopicUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: LearnTopicCreateOrConnectWithoutCategoryInput | LearnTopicCreateOrConnectWithoutCategoryInput[]
    createMany?: LearnTopicCreateManyCategoryInputEnvelope
    connect?: LearnTopicWhereUniqueInput | LearnTopicWhereUniqueInput[]
  }

  export type LearnDomainUpdateOneRequiredWithoutCategoriesNestedInput = {
    create?: XOR<LearnDomainCreateWithoutCategoriesInput, LearnDomainUncheckedCreateWithoutCategoriesInput>
    connectOrCreate?: LearnDomainCreateOrConnectWithoutCategoriesInput
    upsert?: LearnDomainUpsertWithoutCategoriesInput
    connect?: LearnDomainWhereUniqueInput
    update?: XOR<XOR<LearnDomainUpdateToOneWithWhereWithoutCategoriesInput, LearnDomainUpdateWithoutCategoriesInput>, LearnDomainUncheckedUpdateWithoutCategoriesInput>
  }

  export type LearnTopicUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<LearnTopicCreateWithoutCategoryInput, LearnTopicUncheckedCreateWithoutCategoryInput> | LearnTopicCreateWithoutCategoryInput[] | LearnTopicUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: LearnTopicCreateOrConnectWithoutCategoryInput | LearnTopicCreateOrConnectWithoutCategoryInput[]
    upsert?: LearnTopicUpsertWithWhereUniqueWithoutCategoryInput | LearnTopicUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: LearnTopicCreateManyCategoryInputEnvelope
    set?: LearnTopicWhereUniqueInput | LearnTopicWhereUniqueInput[]
    disconnect?: LearnTopicWhereUniqueInput | LearnTopicWhereUniqueInput[]
    delete?: LearnTopicWhereUniqueInput | LearnTopicWhereUniqueInput[]
    connect?: LearnTopicWhereUniqueInput | LearnTopicWhereUniqueInput[]
    update?: LearnTopicUpdateWithWhereUniqueWithoutCategoryInput | LearnTopicUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: LearnTopicUpdateManyWithWhereWithoutCategoryInput | LearnTopicUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: LearnTopicScalarWhereInput | LearnTopicScalarWhereInput[]
  }

  export type LearnTopicUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<LearnTopicCreateWithoutCategoryInput, LearnTopicUncheckedCreateWithoutCategoryInput> | LearnTopicCreateWithoutCategoryInput[] | LearnTopicUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: LearnTopicCreateOrConnectWithoutCategoryInput | LearnTopicCreateOrConnectWithoutCategoryInput[]
    upsert?: LearnTopicUpsertWithWhereUniqueWithoutCategoryInput | LearnTopicUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: LearnTopicCreateManyCategoryInputEnvelope
    set?: LearnTopicWhereUniqueInput | LearnTopicWhereUniqueInput[]
    disconnect?: LearnTopicWhereUniqueInput | LearnTopicWhereUniqueInput[]
    delete?: LearnTopicWhereUniqueInput | LearnTopicWhereUniqueInput[]
    connect?: LearnTopicWhereUniqueInput | LearnTopicWhereUniqueInput[]
    update?: LearnTopicUpdateWithWhereUniqueWithoutCategoryInput | LearnTopicUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: LearnTopicUpdateManyWithWhereWithoutCategoryInput | LearnTopicUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: LearnTopicScalarWhereInput | LearnTopicScalarWhereInput[]
  }

  export type LearnCategoryCreateNestedOneWithoutTopicsInput = {
    create?: XOR<LearnCategoryCreateWithoutTopicsInput, LearnCategoryUncheckedCreateWithoutTopicsInput>
    connectOrCreate?: LearnCategoryCreateOrConnectWithoutTopicsInput
    connect?: LearnCategoryWhereUniqueInput
  }

  export type LearnCategoryUpdateOneRequiredWithoutTopicsNestedInput = {
    create?: XOR<LearnCategoryCreateWithoutTopicsInput, LearnCategoryUncheckedCreateWithoutTopicsInput>
    connectOrCreate?: LearnCategoryCreateOrConnectWithoutTopicsInput
    upsert?: LearnCategoryUpsertWithoutTopicsInput
    connect?: LearnCategoryWhereUniqueInput
    update?: XOR<XOR<LearnCategoryUpdateToOneWithWhereWithoutTopicsInput, LearnCategoryUpdateWithoutTopicsInput>, LearnCategoryUncheckedUpdateWithoutTopicsInput>
  }

  export type UserCreateNestedOneWithoutInterviewSessionsInput = {
    create?: XOR<UserCreateWithoutInterviewSessionsInput, UserUncheckedCreateWithoutInterviewSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInterviewSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type InterviewFeedbackCreateNestedOneWithoutSessionInput = {
    create?: XOR<InterviewFeedbackCreateWithoutSessionInput, InterviewFeedbackUncheckedCreateWithoutSessionInput>
    connectOrCreate?: InterviewFeedbackCreateOrConnectWithoutSessionInput
    connect?: InterviewFeedbackWhereUniqueInput
  }

  export type SharedInterviewResultCreateNestedOneWithoutSessionInput = {
    create?: XOR<SharedInterviewResultCreateWithoutSessionInput, SharedInterviewResultUncheckedCreateWithoutSessionInput>
    connectOrCreate?: SharedInterviewResultCreateOrConnectWithoutSessionInput
    connect?: SharedInterviewResultWhereUniqueInput
  }

  export type InterviewFeedbackUncheckedCreateNestedOneWithoutSessionInput = {
    create?: XOR<InterviewFeedbackCreateWithoutSessionInput, InterviewFeedbackUncheckedCreateWithoutSessionInput>
    connectOrCreate?: InterviewFeedbackCreateOrConnectWithoutSessionInput
    connect?: InterviewFeedbackWhereUniqueInput
  }

  export type SharedInterviewResultUncheckedCreateNestedOneWithoutSessionInput = {
    create?: XOR<SharedInterviewResultCreateWithoutSessionInput, SharedInterviewResultUncheckedCreateWithoutSessionInput>
    connectOrCreate?: SharedInterviewResultCreateOrConnectWithoutSessionInput
    connect?: SharedInterviewResultWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type UserUpdateOneRequiredWithoutInterviewSessionsNestedInput = {
    create?: XOR<UserCreateWithoutInterviewSessionsInput, UserUncheckedCreateWithoutInterviewSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInterviewSessionsInput
    upsert?: UserUpsertWithoutInterviewSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInterviewSessionsInput, UserUpdateWithoutInterviewSessionsInput>, UserUncheckedUpdateWithoutInterviewSessionsInput>
  }

  export type InterviewFeedbackUpdateOneWithoutSessionNestedInput = {
    create?: XOR<InterviewFeedbackCreateWithoutSessionInput, InterviewFeedbackUncheckedCreateWithoutSessionInput>
    connectOrCreate?: InterviewFeedbackCreateOrConnectWithoutSessionInput
    upsert?: InterviewFeedbackUpsertWithoutSessionInput
    disconnect?: InterviewFeedbackWhereInput | boolean
    delete?: InterviewFeedbackWhereInput | boolean
    connect?: InterviewFeedbackWhereUniqueInput
    update?: XOR<XOR<InterviewFeedbackUpdateToOneWithWhereWithoutSessionInput, InterviewFeedbackUpdateWithoutSessionInput>, InterviewFeedbackUncheckedUpdateWithoutSessionInput>
  }

  export type SharedInterviewResultUpdateOneWithoutSessionNestedInput = {
    create?: XOR<SharedInterviewResultCreateWithoutSessionInput, SharedInterviewResultUncheckedCreateWithoutSessionInput>
    connectOrCreate?: SharedInterviewResultCreateOrConnectWithoutSessionInput
    upsert?: SharedInterviewResultUpsertWithoutSessionInput
    disconnect?: SharedInterviewResultWhereInput | boolean
    delete?: SharedInterviewResultWhereInput | boolean
    connect?: SharedInterviewResultWhereUniqueInput
    update?: XOR<XOR<SharedInterviewResultUpdateToOneWithWhereWithoutSessionInput, SharedInterviewResultUpdateWithoutSessionInput>, SharedInterviewResultUncheckedUpdateWithoutSessionInput>
  }

  export type InterviewFeedbackUncheckedUpdateOneWithoutSessionNestedInput = {
    create?: XOR<InterviewFeedbackCreateWithoutSessionInput, InterviewFeedbackUncheckedCreateWithoutSessionInput>
    connectOrCreate?: InterviewFeedbackCreateOrConnectWithoutSessionInput
    upsert?: InterviewFeedbackUpsertWithoutSessionInput
    disconnect?: InterviewFeedbackWhereInput | boolean
    delete?: InterviewFeedbackWhereInput | boolean
    connect?: InterviewFeedbackWhereUniqueInput
    update?: XOR<XOR<InterviewFeedbackUpdateToOneWithWhereWithoutSessionInput, InterviewFeedbackUpdateWithoutSessionInput>, InterviewFeedbackUncheckedUpdateWithoutSessionInput>
  }

  export type SharedInterviewResultUncheckedUpdateOneWithoutSessionNestedInput = {
    create?: XOR<SharedInterviewResultCreateWithoutSessionInput, SharedInterviewResultUncheckedCreateWithoutSessionInput>
    connectOrCreate?: SharedInterviewResultCreateOrConnectWithoutSessionInput
    upsert?: SharedInterviewResultUpsertWithoutSessionInput
    disconnect?: SharedInterviewResultWhereInput | boolean
    delete?: SharedInterviewResultWhereInput | boolean
    connect?: SharedInterviewResultWhereUniqueInput
    update?: XOR<XOR<SharedInterviewResultUpdateToOneWithWhereWithoutSessionInput, SharedInterviewResultUpdateWithoutSessionInput>, SharedInterviewResultUncheckedUpdateWithoutSessionInput>
  }

  export type InterviewFeedbackCreatestrengthsInput = {
    set: string[]
  }

  export type InterviewFeedbackCreateweaknessesInput = {
    set: string[]
  }

  export type InterviewFeedbackCreateimprovementsInput = {
    set: string[]
  }

  export type InterviewFeedbackCreatesuggestedTopicsInput = {
    set: string[]
  }

  export type InterviewSessionCreateNestedOneWithoutFeedbackInput = {
    create?: XOR<InterviewSessionCreateWithoutFeedbackInput, InterviewSessionUncheckedCreateWithoutFeedbackInput>
    connectOrCreate?: InterviewSessionCreateOrConnectWithoutFeedbackInput
    connect?: InterviewSessionWhereUniqueInput
  }

  export type InterviewFeedbackUpdatestrengthsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type InterviewFeedbackUpdateweaknessesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type InterviewFeedbackUpdateimprovementsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type InterviewFeedbackUpdatesuggestedTopicsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type InterviewSessionUpdateOneRequiredWithoutFeedbackNestedInput = {
    create?: XOR<InterviewSessionCreateWithoutFeedbackInput, InterviewSessionUncheckedCreateWithoutFeedbackInput>
    connectOrCreate?: InterviewSessionCreateOrConnectWithoutFeedbackInput
    upsert?: InterviewSessionUpsertWithoutFeedbackInput
    connect?: InterviewSessionWhereUniqueInput
    update?: XOR<XOR<InterviewSessionUpdateToOneWithWhereWithoutFeedbackInput, InterviewSessionUpdateWithoutFeedbackInput>, InterviewSessionUncheckedUpdateWithoutFeedbackInput>
  }

  export type QuestionBankCreatefollowUpsInput = {
    set: string[]
  }

  export type QuestionBankCreatekeyPointsInput = {
    set: string[]
  }

  export type QuestionBankCreatetagsInput = {
    set: string[]
  }

  export type QuestionBankUpdatefollowUpsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type QuestionBankUpdatekeyPointsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type QuestionBankUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type InterviewSessionCreateNestedOneWithoutSharedResultInput = {
    create?: XOR<InterviewSessionCreateWithoutSharedResultInput, InterviewSessionUncheckedCreateWithoutSharedResultInput>
    connectOrCreate?: InterviewSessionCreateOrConnectWithoutSharedResultInput
    connect?: InterviewSessionWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSharedResultsInput = {
    create?: XOR<UserCreateWithoutSharedResultsInput, UserUncheckedCreateWithoutSharedResultsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSharedResultsInput
    connect?: UserWhereUniqueInput
  }

  export type InterviewSessionUpdateOneRequiredWithoutSharedResultNestedInput = {
    create?: XOR<InterviewSessionCreateWithoutSharedResultInput, InterviewSessionUncheckedCreateWithoutSharedResultInput>
    connectOrCreate?: InterviewSessionCreateOrConnectWithoutSharedResultInput
    upsert?: InterviewSessionUpsertWithoutSharedResultInput
    connect?: InterviewSessionWhereUniqueInput
    update?: XOR<XOR<InterviewSessionUpdateToOneWithWhereWithoutSharedResultInput, InterviewSessionUpdateWithoutSharedResultInput>, InterviewSessionUncheckedUpdateWithoutSharedResultInput>
  }

  export type UserUpdateOneRequiredWithoutSharedResultsNestedInput = {
    create?: XOR<UserCreateWithoutSharedResultsInput, UserUncheckedCreateWithoutSharedResultsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSharedResultsInput
    upsert?: UserUpsertWithoutSharedResultsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSharedResultsInput, UserUpdateWithoutSharedResultsInput>, UserUncheckedUpdateWithoutSharedResultsInput>
  }

  export type InterviewAnalyticsCreatetopStrengthsInput = {
    set: string[]
  }

  export type InterviewAnalyticsCreatetopWeaknessesInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutAnalyticsInput = {
    create?: XOR<UserCreateWithoutAnalyticsInput, UserUncheckedCreateWithoutAnalyticsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAnalyticsInput
    connect?: UserWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type InterviewAnalyticsUpdatetopStrengthsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type InterviewAnalyticsUpdatetopWeaknessesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutAnalyticsNestedInput = {
    create?: XOR<UserCreateWithoutAnalyticsInput, UserUncheckedCreateWithoutAnalyticsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAnalyticsInput
    upsert?: UserUpsertWithoutAnalyticsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAnalyticsInput, UserUpdateWithoutAnalyticsInput>, UserUncheckedUpdateWithoutAnalyticsInput>
  }

  export type RoadmapCreateskillsInput = {
    set: string[]
  }

  export type RoadmapPhaseCreateNestedManyWithoutRoadmapInput = {
    create?: XOR<RoadmapPhaseCreateWithoutRoadmapInput, RoadmapPhaseUncheckedCreateWithoutRoadmapInput> | RoadmapPhaseCreateWithoutRoadmapInput[] | RoadmapPhaseUncheckedCreateWithoutRoadmapInput[]
    connectOrCreate?: RoadmapPhaseCreateOrConnectWithoutRoadmapInput | RoadmapPhaseCreateOrConnectWithoutRoadmapInput[]
    createMany?: RoadmapPhaseCreateManyRoadmapInputEnvelope
    connect?: RoadmapPhaseWhereUniqueInput | RoadmapPhaseWhereUniqueInput[]
  }

  export type RoadmapProgressCreateNestedManyWithoutRoadmapInput = {
    create?: XOR<RoadmapProgressCreateWithoutRoadmapInput, RoadmapProgressUncheckedCreateWithoutRoadmapInput> | RoadmapProgressCreateWithoutRoadmapInput[] | RoadmapProgressUncheckedCreateWithoutRoadmapInput[]
    connectOrCreate?: RoadmapProgressCreateOrConnectWithoutRoadmapInput | RoadmapProgressCreateOrConnectWithoutRoadmapInput[]
    createMany?: RoadmapProgressCreateManyRoadmapInputEnvelope
    connect?: RoadmapProgressWhereUniqueInput | RoadmapProgressWhereUniqueInput[]
  }

  export type RoadmapPhaseUncheckedCreateNestedManyWithoutRoadmapInput = {
    create?: XOR<RoadmapPhaseCreateWithoutRoadmapInput, RoadmapPhaseUncheckedCreateWithoutRoadmapInput> | RoadmapPhaseCreateWithoutRoadmapInput[] | RoadmapPhaseUncheckedCreateWithoutRoadmapInput[]
    connectOrCreate?: RoadmapPhaseCreateOrConnectWithoutRoadmapInput | RoadmapPhaseCreateOrConnectWithoutRoadmapInput[]
    createMany?: RoadmapPhaseCreateManyRoadmapInputEnvelope
    connect?: RoadmapPhaseWhereUniqueInput | RoadmapPhaseWhereUniqueInput[]
  }

  export type RoadmapProgressUncheckedCreateNestedManyWithoutRoadmapInput = {
    create?: XOR<RoadmapProgressCreateWithoutRoadmapInput, RoadmapProgressUncheckedCreateWithoutRoadmapInput> | RoadmapProgressCreateWithoutRoadmapInput[] | RoadmapProgressUncheckedCreateWithoutRoadmapInput[]
    connectOrCreate?: RoadmapProgressCreateOrConnectWithoutRoadmapInput | RoadmapProgressCreateOrConnectWithoutRoadmapInput[]
    createMany?: RoadmapProgressCreateManyRoadmapInputEnvelope
    connect?: RoadmapProgressWhereUniqueInput | RoadmapProgressWhereUniqueInput[]
  }

  export type RoadmapUpdateskillsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type RoadmapPhaseUpdateManyWithoutRoadmapNestedInput = {
    create?: XOR<RoadmapPhaseCreateWithoutRoadmapInput, RoadmapPhaseUncheckedCreateWithoutRoadmapInput> | RoadmapPhaseCreateWithoutRoadmapInput[] | RoadmapPhaseUncheckedCreateWithoutRoadmapInput[]
    connectOrCreate?: RoadmapPhaseCreateOrConnectWithoutRoadmapInput | RoadmapPhaseCreateOrConnectWithoutRoadmapInput[]
    upsert?: RoadmapPhaseUpsertWithWhereUniqueWithoutRoadmapInput | RoadmapPhaseUpsertWithWhereUniqueWithoutRoadmapInput[]
    createMany?: RoadmapPhaseCreateManyRoadmapInputEnvelope
    set?: RoadmapPhaseWhereUniqueInput | RoadmapPhaseWhereUniqueInput[]
    disconnect?: RoadmapPhaseWhereUniqueInput | RoadmapPhaseWhereUniqueInput[]
    delete?: RoadmapPhaseWhereUniqueInput | RoadmapPhaseWhereUniqueInput[]
    connect?: RoadmapPhaseWhereUniqueInput | RoadmapPhaseWhereUniqueInput[]
    update?: RoadmapPhaseUpdateWithWhereUniqueWithoutRoadmapInput | RoadmapPhaseUpdateWithWhereUniqueWithoutRoadmapInput[]
    updateMany?: RoadmapPhaseUpdateManyWithWhereWithoutRoadmapInput | RoadmapPhaseUpdateManyWithWhereWithoutRoadmapInput[]
    deleteMany?: RoadmapPhaseScalarWhereInput | RoadmapPhaseScalarWhereInput[]
  }

  export type RoadmapProgressUpdateManyWithoutRoadmapNestedInput = {
    create?: XOR<RoadmapProgressCreateWithoutRoadmapInput, RoadmapProgressUncheckedCreateWithoutRoadmapInput> | RoadmapProgressCreateWithoutRoadmapInput[] | RoadmapProgressUncheckedCreateWithoutRoadmapInput[]
    connectOrCreate?: RoadmapProgressCreateOrConnectWithoutRoadmapInput | RoadmapProgressCreateOrConnectWithoutRoadmapInput[]
    upsert?: RoadmapProgressUpsertWithWhereUniqueWithoutRoadmapInput | RoadmapProgressUpsertWithWhereUniqueWithoutRoadmapInput[]
    createMany?: RoadmapProgressCreateManyRoadmapInputEnvelope
    set?: RoadmapProgressWhereUniqueInput | RoadmapProgressWhereUniqueInput[]
    disconnect?: RoadmapProgressWhereUniqueInput | RoadmapProgressWhereUniqueInput[]
    delete?: RoadmapProgressWhereUniqueInput | RoadmapProgressWhereUniqueInput[]
    connect?: RoadmapProgressWhereUniqueInput | RoadmapProgressWhereUniqueInput[]
    update?: RoadmapProgressUpdateWithWhereUniqueWithoutRoadmapInput | RoadmapProgressUpdateWithWhereUniqueWithoutRoadmapInput[]
    updateMany?: RoadmapProgressUpdateManyWithWhereWithoutRoadmapInput | RoadmapProgressUpdateManyWithWhereWithoutRoadmapInput[]
    deleteMany?: RoadmapProgressScalarWhereInput | RoadmapProgressScalarWhereInput[]
  }

  export type RoadmapPhaseUncheckedUpdateManyWithoutRoadmapNestedInput = {
    create?: XOR<RoadmapPhaseCreateWithoutRoadmapInput, RoadmapPhaseUncheckedCreateWithoutRoadmapInput> | RoadmapPhaseCreateWithoutRoadmapInput[] | RoadmapPhaseUncheckedCreateWithoutRoadmapInput[]
    connectOrCreate?: RoadmapPhaseCreateOrConnectWithoutRoadmapInput | RoadmapPhaseCreateOrConnectWithoutRoadmapInput[]
    upsert?: RoadmapPhaseUpsertWithWhereUniqueWithoutRoadmapInput | RoadmapPhaseUpsertWithWhereUniqueWithoutRoadmapInput[]
    createMany?: RoadmapPhaseCreateManyRoadmapInputEnvelope
    set?: RoadmapPhaseWhereUniqueInput | RoadmapPhaseWhereUniqueInput[]
    disconnect?: RoadmapPhaseWhereUniqueInput | RoadmapPhaseWhereUniqueInput[]
    delete?: RoadmapPhaseWhereUniqueInput | RoadmapPhaseWhereUniqueInput[]
    connect?: RoadmapPhaseWhereUniqueInput | RoadmapPhaseWhereUniqueInput[]
    update?: RoadmapPhaseUpdateWithWhereUniqueWithoutRoadmapInput | RoadmapPhaseUpdateWithWhereUniqueWithoutRoadmapInput[]
    updateMany?: RoadmapPhaseUpdateManyWithWhereWithoutRoadmapInput | RoadmapPhaseUpdateManyWithWhereWithoutRoadmapInput[]
    deleteMany?: RoadmapPhaseScalarWhereInput | RoadmapPhaseScalarWhereInput[]
  }

  export type RoadmapProgressUncheckedUpdateManyWithoutRoadmapNestedInput = {
    create?: XOR<RoadmapProgressCreateWithoutRoadmapInput, RoadmapProgressUncheckedCreateWithoutRoadmapInput> | RoadmapProgressCreateWithoutRoadmapInput[] | RoadmapProgressUncheckedCreateWithoutRoadmapInput[]
    connectOrCreate?: RoadmapProgressCreateOrConnectWithoutRoadmapInput | RoadmapProgressCreateOrConnectWithoutRoadmapInput[]
    upsert?: RoadmapProgressUpsertWithWhereUniqueWithoutRoadmapInput | RoadmapProgressUpsertWithWhereUniqueWithoutRoadmapInput[]
    createMany?: RoadmapProgressCreateManyRoadmapInputEnvelope
    set?: RoadmapProgressWhereUniqueInput | RoadmapProgressWhereUniqueInput[]
    disconnect?: RoadmapProgressWhereUniqueInput | RoadmapProgressWhereUniqueInput[]
    delete?: RoadmapProgressWhereUniqueInput | RoadmapProgressWhereUniqueInput[]
    connect?: RoadmapProgressWhereUniqueInput | RoadmapProgressWhereUniqueInput[]
    update?: RoadmapProgressUpdateWithWhereUniqueWithoutRoadmapInput | RoadmapProgressUpdateWithWhereUniqueWithoutRoadmapInput[]
    updateMany?: RoadmapProgressUpdateManyWithWhereWithoutRoadmapInput | RoadmapProgressUpdateManyWithWhereWithoutRoadmapInput[]
    deleteMany?: RoadmapProgressScalarWhereInput | RoadmapProgressScalarWhereInput[]
  }

  export type RoadmapCreateNestedOneWithoutPhasesInput = {
    create?: XOR<RoadmapCreateWithoutPhasesInput, RoadmapUncheckedCreateWithoutPhasesInput>
    connectOrCreate?: RoadmapCreateOrConnectWithoutPhasesInput
    connect?: RoadmapWhereUniqueInput
  }

  export type RoadmapStepCreateNestedManyWithoutPhaseInput = {
    create?: XOR<RoadmapStepCreateWithoutPhaseInput, RoadmapStepUncheckedCreateWithoutPhaseInput> | RoadmapStepCreateWithoutPhaseInput[] | RoadmapStepUncheckedCreateWithoutPhaseInput[]
    connectOrCreate?: RoadmapStepCreateOrConnectWithoutPhaseInput | RoadmapStepCreateOrConnectWithoutPhaseInput[]
    createMany?: RoadmapStepCreateManyPhaseInputEnvelope
    connect?: RoadmapStepWhereUniqueInput | RoadmapStepWhereUniqueInput[]
  }

  export type RoadmapStepUncheckedCreateNestedManyWithoutPhaseInput = {
    create?: XOR<RoadmapStepCreateWithoutPhaseInput, RoadmapStepUncheckedCreateWithoutPhaseInput> | RoadmapStepCreateWithoutPhaseInput[] | RoadmapStepUncheckedCreateWithoutPhaseInput[]
    connectOrCreate?: RoadmapStepCreateOrConnectWithoutPhaseInput | RoadmapStepCreateOrConnectWithoutPhaseInput[]
    createMany?: RoadmapStepCreateManyPhaseInputEnvelope
    connect?: RoadmapStepWhereUniqueInput | RoadmapStepWhereUniqueInput[]
  }

  export type RoadmapUpdateOneRequiredWithoutPhasesNestedInput = {
    create?: XOR<RoadmapCreateWithoutPhasesInput, RoadmapUncheckedCreateWithoutPhasesInput>
    connectOrCreate?: RoadmapCreateOrConnectWithoutPhasesInput
    upsert?: RoadmapUpsertWithoutPhasesInput
    connect?: RoadmapWhereUniqueInput
    update?: XOR<XOR<RoadmapUpdateToOneWithWhereWithoutPhasesInput, RoadmapUpdateWithoutPhasesInput>, RoadmapUncheckedUpdateWithoutPhasesInput>
  }

  export type RoadmapStepUpdateManyWithoutPhaseNestedInput = {
    create?: XOR<RoadmapStepCreateWithoutPhaseInput, RoadmapStepUncheckedCreateWithoutPhaseInput> | RoadmapStepCreateWithoutPhaseInput[] | RoadmapStepUncheckedCreateWithoutPhaseInput[]
    connectOrCreate?: RoadmapStepCreateOrConnectWithoutPhaseInput | RoadmapStepCreateOrConnectWithoutPhaseInput[]
    upsert?: RoadmapStepUpsertWithWhereUniqueWithoutPhaseInput | RoadmapStepUpsertWithWhereUniqueWithoutPhaseInput[]
    createMany?: RoadmapStepCreateManyPhaseInputEnvelope
    set?: RoadmapStepWhereUniqueInput | RoadmapStepWhereUniqueInput[]
    disconnect?: RoadmapStepWhereUniqueInput | RoadmapStepWhereUniqueInput[]
    delete?: RoadmapStepWhereUniqueInput | RoadmapStepWhereUniqueInput[]
    connect?: RoadmapStepWhereUniqueInput | RoadmapStepWhereUniqueInput[]
    update?: RoadmapStepUpdateWithWhereUniqueWithoutPhaseInput | RoadmapStepUpdateWithWhereUniqueWithoutPhaseInput[]
    updateMany?: RoadmapStepUpdateManyWithWhereWithoutPhaseInput | RoadmapStepUpdateManyWithWhereWithoutPhaseInput[]
    deleteMany?: RoadmapStepScalarWhereInput | RoadmapStepScalarWhereInput[]
  }

  export type RoadmapStepUncheckedUpdateManyWithoutPhaseNestedInput = {
    create?: XOR<RoadmapStepCreateWithoutPhaseInput, RoadmapStepUncheckedCreateWithoutPhaseInput> | RoadmapStepCreateWithoutPhaseInput[] | RoadmapStepUncheckedCreateWithoutPhaseInput[]
    connectOrCreate?: RoadmapStepCreateOrConnectWithoutPhaseInput | RoadmapStepCreateOrConnectWithoutPhaseInput[]
    upsert?: RoadmapStepUpsertWithWhereUniqueWithoutPhaseInput | RoadmapStepUpsertWithWhereUniqueWithoutPhaseInput[]
    createMany?: RoadmapStepCreateManyPhaseInputEnvelope
    set?: RoadmapStepWhereUniqueInput | RoadmapStepWhereUniqueInput[]
    disconnect?: RoadmapStepWhereUniqueInput | RoadmapStepWhereUniqueInput[]
    delete?: RoadmapStepWhereUniqueInput | RoadmapStepWhereUniqueInput[]
    connect?: RoadmapStepWhereUniqueInput | RoadmapStepWhereUniqueInput[]
    update?: RoadmapStepUpdateWithWhereUniqueWithoutPhaseInput | RoadmapStepUpdateWithWhereUniqueWithoutPhaseInput[]
    updateMany?: RoadmapStepUpdateManyWithWhereWithoutPhaseInput | RoadmapStepUpdateManyWithWhereWithoutPhaseInput[]
    deleteMany?: RoadmapStepScalarWhereInput | RoadmapStepScalarWhereInput[]
  }

  export type RoadmapStepCreatetopicsInput = {
    set: string[]
  }

  export type RoadmapStepCreateprerequisitesInput = {
    set: string[]
  }

  export type RoadmapStepCreatecheckpointsInput = {
    set: string[]
  }

  export type RoadmapStepCreaterelatedCheatsheetsInput = {
    set: string[]
  }

  export type RoadmapStepCreaterelatedDSAInput = {
    set: string[]
  }

  export type RoadmapStepCreaterelatedInterviewsInput = {
    set: string[]
  }

  export type RoadmapPhaseCreateNestedOneWithoutStepsInput = {
    create?: XOR<RoadmapPhaseCreateWithoutStepsInput, RoadmapPhaseUncheckedCreateWithoutStepsInput>
    connectOrCreate?: RoadmapPhaseCreateOrConnectWithoutStepsInput
    connect?: RoadmapPhaseWhereUniqueInput
  }

  export type RoadmapProgressCreateNestedManyWithoutStepInput = {
    create?: XOR<RoadmapProgressCreateWithoutStepInput, RoadmapProgressUncheckedCreateWithoutStepInput> | RoadmapProgressCreateWithoutStepInput[] | RoadmapProgressUncheckedCreateWithoutStepInput[]
    connectOrCreate?: RoadmapProgressCreateOrConnectWithoutStepInput | RoadmapProgressCreateOrConnectWithoutStepInput[]
    createMany?: RoadmapProgressCreateManyStepInputEnvelope
    connect?: RoadmapProgressWhereUniqueInput | RoadmapProgressWhereUniqueInput[]
  }

  export type RoadmapProgressUncheckedCreateNestedManyWithoutStepInput = {
    create?: XOR<RoadmapProgressCreateWithoutStepInput, RoadmapProgressUncheckedCreateWithoutStepInput> | RoadmapProgressCreateWithoutStepInput[] | RoadmapProgressUncheckedCreateWithoutStepInput[]
    connectOrCreate?: RoadmapProgressCreateOrConnectWithoutStepInput | RoadmapProgressCreateOrConnectWithoutStepInput[]
    createMany?: RoadmapProgressCreateManyStepInputEnvelope
    connect?: RoadmapProgressWhereUniqueInput | RoadmapProgressWhereUniqueInput[]
  }

  export type RoadmapStepUpdatetopicsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type RoadmapStepUpdateprerequisitesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type RoadmapStepUpdatecheckpointsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type RoadmapStepUpdaterelatedCheatsheetsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type RoadmapStepUpdaterelatedDSAInput = {
    set?: string[]
    push?: string | string[]
  }

  export type RoadmapStepUpdaterelatedInterviewsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type RoadmapPhaseUpdateOneRequiredWithoutStepsNestedInput = {
    create?: XOR<RoadmapPhaseCreateWithoutStepsInput, RoadmapPhaseUncheckedCreateWithoutStepsInput>
    connectOrCreate?: RoadmapPhaseCreateOrConnectWithoutStepsInput
    upsert?: RoadmapPhaseUpsertWithoutStepsInput
    connect?: RoadmapPhaseWhereUniqueInput
    update?: XOR<XOR<RoadmapPhaseUpdateToOneWithWhereWithoutStepsInput, RoadmapPhaseUpdateWithoutStepsInput>, RoadmapPhaseUncheckedUpdateWithoutStepsInput>
  }

  export type RoadmapProgressUpdateManyWithoutStepNestedInput = {
    create?: XOR<RoadmapProgressCreateWithoutStepInput, RoadmapProgressUncheckedCreateWithoutStepInput> | RoadmapProgressCreateWithoutStepInput[] | RoadmapProgressUncheckedCreateWithoutStepInput[]
    connectOrCreate?: RoadmapProgressCreateOrConnectWithoutStepInput | RoadmapProgressCreateOrConnectWithoutStepInput[]
    upsert?: RoadmapProgressUpsertWithWhereUniqueWithoutStepInput | RoadmapProgressUpsertWithWhereUniqueWithoutStepInput[]
    createMany?: RoadmapProgressCreateManyStepInputEnvelope
    set?: RoadmapProgressWhereUniqueInput | RoadmapProgressWhereUniqueInput[]
    disconnect?: RoadmapProgressWhereUniqueInput | RoadmapProgressWhereUniqueInput[]
    delete?: RoadmapProgressWhereUniqueInput | RoadmapProgressWhereUniqueInput[]
    connect?: RoadmapProgressWhereUniqueInput | RoadmapProgressWhereUniqueInput[]
    update?: RoadmapProgressUpdateWithWhereUniqueWithoutStepInput | RoadmapProgressUpdateWithWhereUniqueWithoutStepInput[]
    updateMany?: RoadmapProgressUpdateManyWithWhereWithoutStepInput | RoadmapProgressUpdateManyWithWhereWithoutStepInput[]
    deleteMany?: RoadmapProgressScalarWhereInput | RoadmapProgressScalarWhereInput[]
  }

  export type RoadmapProgressUncheckedUpdateManyWithoutStepNestedInput = {
    create?: XOR<RoadmapProgressCreateWithoutStepInput, RoadmapProgressUncheckedCreateWithoutStepInput> | RoadmapProgressCreateWithoutStepInput[] | RoadmapProgressUncheckedCreateWithoutStepInput[]
    connectOrCreate?: RoadmapProgressCreateOrConnectWithoutStepInput | RoadmapProgressCreateOrConnectWithoutStepInput[]
    upsert?: RoadmapProgressUpsertWithWhereUniqueWithoutStepInput | RoadmapProgressUpsertWithWhereUniqueWithoutStepInput[]
    createMany?: RoadmapProgressCreateManyStepInputEnvelope
    set?: RoadmapProgressWhereUniqueInput | RoadmapProgressWhereUniqueInput[]
    disconnect?: RoadmapProgressWhereUniqueInput | RoadmapProgressWhereUniqueInput[]
    delete?: RoadmapProgressWhereUniqueInput | RoadmapProgressWhereUniqueInput[]
    connect?: RoadmapProgressWhereUniqueInput | RoadmapProgressWhereUniqueInput[]
    update?: RoadmapProgressUpdateWithWhereUniqueWithoutStepInput | RoadmapProgressUpdateWithWhereUniqueWithoutStepInput[]
    updateMany?: RoadmapProgressUpdateManyWithWhereWithoutStepInput | RoadmapProgressUpdateManyWithWhereWithoutStepInput[]
    deleteMany?: RoadmapProgressScalarWhereInput | RoadmapProgressScalarWhereInput[]
  }

  export type RoadmapCreateNestedOneWithoutProgressInput = {
    create?: XOR<RoadmapCreateWithoutProgressInput, RoadmapUncheckedCreateWithoutProgressInput>
    connectOrCreate?: RoadmapCreateOrConnectWithoutProgressInput
    connect?: RoadmapWhereUniqueInput
  }

  export type RoadmapStepCreateNestedOneWithoutProgressInput = {
    create?: XOR<RoadmapStepCreateWithoutProgressInput, RoadmapStepUncheckedCreateWithoutProgressInput>
    connectOrCreate?: RoadmapStepCreateOrConnectWithoutProgressInput
    connect?: RoadmapStepWhereUniqueInput
  }

  export type RoadmapUpdateOneRequiredWithoutProgressNestedInput = {
    create?: XOR<RoadmapCreateWithoutProgressInput, RoadmapUncheckedCreateWithoutProgressInput>
    connectOrCreate?: RoadmapCreateOrConnectWithoutProgressInput
    upsert?: RoadmapUpsertWithoutProgressInput
    connect?: RoadmapWhereUniqueInput
    update?: XOR<XOR<RoadmapUpdateToOneWithWhereWithoutProgressInput, RoadmapUpdateWithoutProgressInput>, RoadmapUncheckedUpdateWithoutProgressInput>
  }

  export type RoadmapStepUpdateOneRequiredWithoutProgressNestedInput = {
    create?: XOR<RoadmapStepCreateWithoutProgressInput, RoadmapStepUncheckedCreateWithoutProgressInput>
    connectOrCreate?: RoadmapStepCreateOrConnectWithoutProgressInput
    upsert?: RoadmapStepUpsertWithoutProgressInput
    connect?: RoadmapStepWhereUniqueInput
    update?: XOR<XOR<RoadmapStepUpdateToOneWithWhereWithoutProgressInput, RoadmapStepUpdateWithoutProgressInput>, RoadmapStepUncheckedUpdateWithoutProgressInput>
  }

  export type CheatsheetCreateNestedManyWithoutCategoryInput = {
    create?: XOR<CheatsheetCreateWithoutCategoryInput, CheatsheetUncheckedCreateWithoutCategoryInput> | CheatsheetCreateWithoutCategoryInput[] | CheatsheetUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: CheatsheetCreateOrConnectWithoutCategoryInput | CheatsheetCreateOrConnectWithoutCategoryInput[]
    createMany?: CheatsheetCreateManyCategoryInputEnvelope
    connect?: CheatsheetWhereUniqueInput | CheatsheetWhereUniqueInput[]
  }

  export type CheatsheetUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<CheatsheetCreateWithoutCategoryInput, CheatsheetUncheckedCreateWithoutCategoryInput> | CheatsheetCreateWithoutCategoryInput[] | CheatsheetUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: CheatsheetCreateOrConnectWithoutCategoryInput | CheatsheetCreateOrConnectWithoutCategoryInput[]
    createMany?: CheatsheetCreateManyCategoryInputEnvelope
    connect?: CheatsheetWhereUniqueInput | CheatsheetWhereUniqueInput[]
  }

  export type CheatsheetUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<CheatsheetCreateWithoutCategoryInput, CheatsheetUncheckedCreateWithoutCategoryInput> | CheatsheetCreateWithoutCategoryInput[] | CheatsheetUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: CheatsheetCreateOrConnectWithoutCategoryInput | CheatsheetCreateOrConnectWithoutCategoryInput[]
    upsert?: CheatsheetUpsertWithWhereUniqueWithoutCategoryInput | CheatsheetUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: CheatsheetCreateManyCategoryInputEnvelope
    set?: CheatsheetWhereUniqueInput | CheatsheetWhereUniqueInput[]
    disconnect?: CheatsheetWhereUniqueInput | CheatsheetWhereUniqueInput[]
    delete?: CheatsheetWhereUniqueInput | CheatsheetWhereUniqueInput[]
    connect?: CheatsheetWhereUniqueInput | CheatsheetWhereUniqueInput[]
    update?: CheatsheetUpdateWithWhereUniqueWithoutCategoryInput | CheatsheetUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: CheatsheetUpdateManyWithWhereWithoutCategoryInput | CheatsheetUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: CheatsheetScalarWhereInput | CheatsheetScalarWhereInput[]
  }

  export type CheatsheetUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<CheatsheetCreateWithoutCategoryInput, CheatsheetUncheckedCreateWithoutCategoryInput> | CheatsheetCreateWithoutCategoryInput[] | CheatsheetUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: CheatsheetCreateOrConnectWithoutCategoryInput | CheatsheetCreateOrConnectWithoutCategoryInput[]
    upsert?: CheatsheetUpsertWithWhereUniqueWithoutCategoryInput | CheatsheetUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: CheatsheetCreateManyCategoryInputEnvelope
    set?: CheatsheetWhereUniqueInput | CheatsheetWhereUniqueInput[]
    disconnect?: CheatsheetWhereUniqueInput | CheatsheetWhereUniqueInput[]
    delete?: CheatsheetWhereUniqueInput | CheatsheetWhereUniqueInput[]
    connect?: CheatsheetWhereUniqueInput | CheatsheetWhereUniqueInput[]
    update?: CheatsheetUpdateWithWhereUniqueWithoutCategoryInput | CheatsheetUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: CheatsheetUpdateManyWithWhereWithoutCategoryInput | CheatsheetUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: CheatsheetScalarWhereInput | CheatsheetScalarWhereInput[]
  }

  export type CheatsheetCreatetagsInput = {
    set: string[]
  }

  export type CheatsheetCreatemistakesInput = {
    set: string[]
  }

  export type CheatsheetCreatetipsInput = {
    set: string[]
  }

  export type CheatsheetCreaterelatedCheatsheetsInput = {
    set: string[]
  }

  export type CheatsheetCreaterelatedRoadmapsInput = {
    set: string[]
  }

  export type CheatsheetCreaterelatedDSAInput = {
    set: string[]
  }

  export type CheatsheetCategoryCreateNestedOneWithoutCheatsheetsInput = {
    create?: XOR<CheatsheetCategoryCreateWithoutCheatsheetsInput, CheatsheetCategoryUncheckedCreateWithoutCheatsheetsInput>
    connectOrCreate?: CheatsheetCategoryCreateOrConnectWithoutCheatsheetsInput
    connect?: CheatsheetCategoryWhereUniqueInput
  }

  export type CheatsheetUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type CheatsheetUpdatemistakesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type CheatsheetUpdatetipsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type CheatsheetUpdaterelatedCheatsheetsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type CheatsheetUpdaterelatedRoadmapsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type CheatsheetUpdaterelatedDSAInput = {
    set?: string[]
    push?: string | string[]
  }

  export type CheatsheetCategoryUpdateOneRequiredWithoutCheatsheetsNestedInput = {
    create?: XOR<CheatsheetCategoryCreateWithoutCheatsheetsInput, CheatsheetCategoryUncheckedCreateWithoutCheatsheetsInput>
    connectOrCreate?: CheatsheetCategoryCreateOrConnectWithoutCheatsheetsInput
    upsert?: CheatsheetCategoryUpsertWithoutCheatsheetsInput
    connect?: CheatsheetCategoryWhereUniqueInput
    update?: XOR<XOR<CheatsheetCategoryUpdateToOneWithWhereWithoutCheatsheetsInput, CheatsheetCategoryUpdateWithoutCheatsheetsInput>, CheatsheetCategoryUncheckedUpdateWithoutCheatsheetsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type UserProgressCreateWithoutUserInput = {
    id?: string
    status: string
    starred?: boolean
    lastAttempt?: Date | string
    createdAt?: Date | string
    problem: ProblemCreateNestedOneWithoutProgressInput
  }

  export type UserProgressUncheckedCreateWithoutUserInput = {
    id?: string
    problemId: string
    status: string
    starred?: boolean
    lastAttempt?: Date | string
    createdAt?: Date | string
  }

  export type UserProgressCreateOrConnectWithoutUserInput = {
    where: UserProgressWhereUniqueInput
    create: XOR<UserProgressCreateWithoutUserInput, UserProgressUncheckedCreateWithoutUserInput>
  }

  export type UserProgressCreateManyUserInputEnvelope = {
    data: UserProgressCreateManyUserInput | UserProgressCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SubmissionCreateWithoutUserInput = {
    id?: string
    code: string
    language: string
    status: string
    runtime?: number | null
    memory?: number | null
    createdAt?: Date | string
    problem: ProblemCreateNestedOneWithoutSubmissionsInput
  }

  export type SubmissionUncheckedCreateWithoutUserInput = {
    id?: string
    problemId: string
    code: string
    language: string
    status: string
    runtime?: number | null
    memory?: number | null
    createdAt?: Date | string
  }

  export type SubmissionCreateOrConnectWithoutUserInput = {
    where: SubmissionWhereUniqueInput
    create: XOR<SubmissionCreateWithoutUserInput, SubmissionUncheckedCreateWithoutUserInput>
  }

  export type SubmissionCreateManyUserInputEnvelope = {
    data: SubmissionCreateManyUserInput | SubmissionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type InterviewSessionCreateWithoutUserInput = {
    id?: string
    role: string
    duration: number
    status: string
    resumeSnapshot: string
    jobDescription?: string | null
    resumeSummary?: string | null
    jdSummary?: string | null
    vapiCallId?: string | null
    vapiAssistantId?: string | null
    transcript?: NullableJsonNullValueInput | InputJsonValue
    videoUrl?: string | null
    videoRecorded?: boolean
    createdAt?: Date | string
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    feedback?: InterviewFeedbackCreateNestedOneWithoutSessionInput
    sharedResult?: SharedInterviewResultCreateNestedOneWithoutSessionInput
  }

  export type InterviewSessionUncheckedCreateWithoutUserInput = {
    id?: string
    role: string
    duration: number
    status: string
    resumeSnapshot: string
    jobDescription?: string | null
    resumeSummary?: string | null
    jdSummary?: string | null
    vapiCallId?: string | null
    vapiAssistantId?: string | null
    transcript?: NullableJsonNullValueInput | InputJsonValue
    videoUrl?: string | null
    videoRecorded?: boolean
    createdAt?: Date | string
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    feedback?: InterviewFeedbackUncheckedCreateNestedOneWithoutSessionInput
    sharedResult?: SharedInterviewResultUncheckedCreateNestedOneWithoutSessionInput
  }

  export type InterviewSessionCreateOrConnectWithoutUserInput = {
    where: InterviewSessionWhereUniqueInput
    create: XOR<InterviewSessionCreateWithoutUserInput, InterviewSessionUncheckedCreateWithoutUserInput>
  }

  export type InterviewSessionCreateManyUserInputEnvelope = {
    data: InterviewSessionCreateManyUserInput | InterviewSessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SharedInterviewResultCreateWithoutUserInput = {
    id?: string
    shareToken: string
    isPublic?: boolean
    expiresAt?: Date | string | null
    viewCount?: number
    lastViewedAt?: Date | string | null
    createdAt?: Date | string
    session: InterviewSessionCreateNestedOneWithoutSharedResultInput
  }

  export type SharedInterviewResultUncheckedCreateWithoutUserInput = {
    id?: string
    sessionId: string
    shareToken: string
    isPublic?: boolean
    expiresAt?: Date | string | null
    viewCount?: number
    lastViewedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type SharedInterviewResultCreateOrConnectWithoutUserInput = {
    where: SharedInterviewResultWhereUniqueInput
    create: XOR<SharedInterviewResultCreateWithoutUserInput, SharedInterviewResultUncheckedCreateWithoutUserInput>
  }

  export type SharedInterviewResultCreateManyUserInputEnvelope = {
    data: SharedInterviewResultCreateManyUserInput | SharedInterviewResultCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type InterviewAnalyticsCreateWithoutUserInput = {
    id?: string
    totalInterviews?: number
    averageScore?: number
    averageCommunication?: number
    averageTechnical?: number
    averageConfidence?: number
    roleStats: JsonNullValueInput | InputJsonValue
    monthlyScores: JsonNullValueInput | InputJsonValue
    topStrengths?: InterviewAnalyticsCreatetopStrengthsInput | string[]
    topWeaknesses?: InterviewAnalyticsCreatetopWeaknessesInput | string[]
    lastUpdated?: Date | string
  }

  export type InterviewAnalyticsUncheckedCreateWithoutUserInput = {
    id?: string
    totalInterviews?: number
    averageScore?: number
    averageCommunication?: number
    averageTechnical?: number
    averageConfidence?: number
    roleStats: JsonNullValueInput | InputJsonValue
    monthlyScores: JsonNullValueInput | InputJsonValue
    topStrengths?: InterviewAnalyticsCreatetopStrengthsInput | string[]
    topWeaknesses?: InterviewAnalyticsCreatetopWeaknessesInput | string[]
    lastUpdated?: Date | string
  }

  export type InterviewAnalyticsCreateOrConnectWithoutUserInput = {
    where: InterviewAnalyticsWhereUniqueInput
    create: XOR<InterviewAnalyticsCreateWithoutUserInput, InterviewAnalyticsUncheckedCreateWithoutUserInput>
  }

  export type UserProgressUpsertWithWhereUniqueWithoutUserInput = {
    where: UserProgressWhereUniqueInput
    update: XOR<UserProgressUpdateWithoutUserInput, UserProgressUncheckedUpdateWithoutUserInput>
    create: XOR<UserProgressCreateWithoutUserInput, UserProgressUncheckedCreateWithoutUserInput>
  }

  export type UserProgressUpdateWithWhereUniqueWithoutUserInput = {
    where: UserProgressWhereUniqueInput
    data: XOR<UserProgressUpdateWithoutUserInput, UserProgressUncheckedUpdateWithoutUserInput>
  }

  export type UserProgressUpdateManyWithWhereWithoutUserInput = {
    where: UserProgressScalarWhereInput
    data: XOR<UserProgressUpdateManyMutationInput, UserProgressUncheckedUpdateManyWithoutUserInput>
  }

  export type UserProgressScalarWhereInput = {
    AND?: UserProgressScalarWhereInput | UserProgressScalarWhereInput[]
    OR?: UserProgressScalarWhereInput[]
    NOT?: UserProgressScalarWhereInput | UserProgressScalarWhereInput[]
    id?: StringFilter<"UserProgress"> | string
    userId?: StringFilter<"UserProgress"> | string
    problemId?: StringFilter<"UserProgress"> | string
    status?: StringFilter<"UserProgress"> | string
    starred?: BoolFilter<"UserProgress"> | boolean
    lastAttempt?: DateTimeFilter<"UserProgress"> | Date | string
    createdAt?: DateTimeFilter<"UserProgress"> | Date | string
  }

  export type SubmissionUpsertWithWhereUniqueWithoutUserInput = {
    where: SubmissionWhereUniqueInput
    update: XOR<SubmissionUpdateWithoutUserInput, SubmissionUncheckedUpdateWithoutUserInput>
    create: XOR<SubmissionCreateWithoutUserInput, SubmissionUncheckedCreateWithoutUserInput>
  }

  export type SubmissionUpdateWithWhereUniqueWithoutUserInput = {
    where: SubmissionWhereUniqueInput
    data: XOR<SubmissionUpdateWithoutUserInput, SubmissionUncheckedUpdateWithoutUserInput>
  }

  export type SubmissionUpdateManyWithWhereWithoutUserInput = {
    where: SubmissionScalarWhereInput
    data: XOR<SubmissionUpdateManyMutationInput, SubmissionUncheckedUpdateManyWithoutUserInput>
  }

  export type SubmissionScalarWhereInput = {
    AND?: SubmissionScalarWhereInput | SubmissionScalarWhereInput[]
    OR?: SubmissionScalarWhereInput[]
    NOT?: SubmissionScalarWhereInput | SubmissionScalarWhereInput[]
    id?: StringFilter<"Submission"> | string
    userId?: StringFilter<"Submission"> | string
    problemId?: StringFilter<"Submission"> | string
    code?: StringFilter<"Submission"> | string
    language?: StringFilter<"Submission"> | string
    status?: StringFilter<"Submission"> | string
    runtime?: IntNullableFilter<"Submission"> | number | null
    memory?: IntNullableFilter<"Submission"> | number | null
    createdAt?: DateTimeFilter<"Submission"> | Date | string
  }

  export type InterviewSessionUpsertWithWhereUniqueWithoutUserInput = {
    where: InterviewSessionWhereUniqueInput
    update: XOR<InterviewSessionUpdateWithoutUserInput, InterviewSessionUncheckedUpdateWithoutUserInput>
    create: XOR<InterviewSessionCreateWithoutUserInput, InterviewSessionUncheckedCreateWithoutUserInput>
  }

  export type InterviewSessionUpdateWithWhereUniqueWithoutUserInput = {
    where: InterviewSessionWhereUniqueInput
    data: XOR<InterviewSessionUpdateWithoutUserInput, InterviewSessionUncheckedUpdateWithoutUserInput>
  }

  export type InterviewSessionUpdateManyWithWhereWithoutUserInput = {
    where: InterviewSessionScalarWhereInput
    data: XOR<InterviewSessionUpdateManyMutationInput, InterviewSessionUncheckedUpdateManyWithoutUserInput>
  }

  export type InterviewSessionScalarWhereInput = {
    AND?: InterviewSessionScalarWhereInput | InterviewSessionScalarWhereInput[]
    OR?: InterviewSessionScalarWhereInput[]
    NOT?: InterviewSessionScalarWhereInput | InterviewSessionScalarWhereInput[]
    id?: StringFilter<"InterviewSession"> | string
    userId?: StringFilter<"InterviewSession"> | string
    role?: StringFilter<"InterviewSession"> | string
    duration?: IntFilter<"InterviewSession"> | number
    status?: StringFilter<"InterviewSession"> | string
    resumeSnapshot?: StringFilter<"InterviewSession"> | string
    jobDescription?: StringNullableFilter<"InterviewSession"> | string | null
    resumeSummary?: StringNullableFilter<"InterviewSession"> | string | null
    jdSummary?: StringNullableFilter<"InterviewSession"> | string | null
    vapiCallId?: StringNullableFilter<"InterviewSession"> | string | null
    vapiAssistantId?: StringNullableFilter<"InterviewSession"> | string | null
    transcript?: JsonNullableFilter<"InterviewSession">
    videoUrl?: StringNullableFilter<"InterviewSession"> | string | null
    videoRecorded?: BoolFilter<"InterviewSession"> | boolean
    createdAt?: DateTimeFilter<"InterviewSession"> | Date | string
    startedAt?: DateTimeNullableFilter<"InterviewSession"> | Date | string | null
    endedAt?: DateTimeNullableFilter<"InterviewSession"> | Date | string | null
  }

  export type SharedInterviewResultUpsertWithWhereUniqueWithoutUserInput = {
    where: SharedInterviewResultWhereUniqueInput
    update: XOR<SharedInterviewResultUpdateWithoutUserInput, SharedInterviewResultUncheckedUpdateWithoutUserInput>
    create: XOR<SharedInterviewResultCreateWithoutUserInput, SharedInterviewResultUncheckedCreateWithoutUserInput>
  }

  export type SharedInterviewResultUpdateWithWhereUniqueWithoutUserInput = {
    where: SharedInterviewResultWhereUniqueInput
    data: XOR<SharedInterviewResultUpdateWithoutUserInput, SharedInterviewResultUncheckedUpdateWithoutUserInput>
  }

  export type SharedInterviewResultUpdateManyWithWhereWithoutUserInput = {
    where: SharedInterviewResultScalarWhereInput
    data: XOR<SharedInterviewResultUpdateManyMutationInput, SharedInterviewResultUncheckedUpdateManyWithoutUserInput>
  }

  export type SharedInterviewResultScalarWhereInput = {
    AND?: SharedInterviewResultScalarWhereInput | SharedInterviewResultScalarWhereInput[]
    OR?: SharedInterviewResultScalarWhereInput[]
    NOT?: SharedInterviewResultScalarWhereInput | SharedInterviewResultScalarWhereInput[]
    id?: StringFilter<"SharedInterviewResult"> | string
    sessionId?: StringFilter<"SharedInterviewResult"> | string
    userId?: StringFilter<"SharedInterviewResult"> | string
    shareToken?: StringFilter<"SharedInterviewResult"> | string
    isPublic?: BoolFilter<"SharedInterviewResult"> | boolean
    expiresAt?: DateTimeNullableFilter<"SharedInterviewResult"> | Date | string | null
    viewCount?: IntFilter<"SharedInterviewResult"> | number
    lastViewedAt?: DateTimeNullableFilter<"SharedInterviewResult"> | Date | string | null
    createdAt?: DateTimeFilter<"SharedInterviewResult"> | Date | string
  }

  export type InterviewAnalyticsUpsertWithoutUserInput = {
    update: XOR<InterviewAnalyticsUpdateWithoutUserInput, InterviewAnalyticsUncheckedUpdateWithoutUserInput>
    create: XOR<InterviewAnalyticsCreateWithoutUserInput, InterviewAnalyticsUncheckedCreateWithoutUserInput>
    where?: InterviewAnalyticsWhereInput
  }

  export type InterviewAnalyticsUpdateToOneWithWhereWithoutUserInput = {
    where?: InterviewAnalyticsWhereInput
    data: XOR<InterviewAnalyticsUpdateWithoutUserInput, InterviewAnalyticsUncheckedUpdateWithoutUserInput>
  }

  export type InterviewAnalyticsUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalInterviews?: IntFieldUpdateOperationsInput | number
    averageScore?: FloatFieldUpdateOperationsInput | number
    averageCommunication?: FloatFieldUpdateOperationsInput | number
    averageTechnical?: FloatFieldUpdateOperationsInput | number
    averageConfidence?: FloatFieldUpdateOperationsInput | number
    roleStats?: JsonNullValueInput | InputJsonValue
    monthlyScores?: JsonNullValueInput | InputJsonValue
    topStrengths?: InterviewAnalyticsUpdatetopStrengthsInput | string[]
    topWeaknesses?: InterviewAnalyticsUpdatetopWeaknessesInput | string[]
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterviewAnalyticsUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalInterviews?: IntFieldUpdateOperationsInput | number
    averageScore?: FloatFieldUpdateOperationsInput | number
    averageCommunication?: FloatFieldUpdateOperationsInput | number
    averageTechnical?: FloatFieldUpdateOperationsInput | number
    averageConfidence?: FloatFieldUpdateOperationsInput | number
    roleStats?: JsonNullValueInput | InputJsonValue
    monthlyScores?: JsonNullValueInput | InputJsonValue
    topStrengths?: InterviewAnalyticsUpdatetopStrengthsInput | string[]
    topWeaknesses?: InterviewAnalyticsUpdatetopWeaknessesInput | string[]
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DSALessonCreateWithoutTopicInput = {
    id?: string
    slug: string
    title: string
    content: string
    codeExamples?: NullableJsonNullValueInput | InputJsonValue
    difficulty?: string | null
    order: number
    createdAt?: Date | string
  }

  export type DSALessonUncheckedCreateWithoutTopicInput = {
    id?: string
    slug: string
    title: string
    content: string
    codeExamples?: NullableJsonNullValueInput | InputJsonValue
    difficulty?: string | null
    order: number
    createdAt?: Date | string
  }

  export type DSALessonCreateOrConnectWithoutTopicInput = {
    where: DSALessonWhereUniqueInput
    create: XOR<DSALessonCreateWithoutTopicInput, DSALessonUncheckedCreateWithoutTopicInput>
  }

  export type DSALessonCreateManyTopicInputEnvelope = {
    data: DSALessonCreateManyTopicInput | DSALessonCreateManyTopicInput[]
    skipDuplicates?: boolean
  }

  export type DSALessonUpsertWithWhereUniqueWithoutTopicInput = {
    where: DSALessonWhereUniqueInput
    update: XOR<DSALessonUpdateWithoutTopicInput, DSALessonUncheckedUpdateWithoutTopicInput>
    create: XOR<DSALessonCreateWithoutTopicInput, DSALessonUncheckedCreateWithoutTopicInput>
  }

  export type DSALessonUpdateWithWhereUniqueWithoutTopicInput = {
    where: DSALessonWhereUniqueInput
    data: XOR<DSALessonUpdateWithoutTopicInput, DSALessonUncheckedUpdateWithoutTopicInput>
  }

  export type DSALessonUpdateManyWithWhereWithoutTopicInput = {
    where: DSALessonScalarWhereInput
    data: XOR<DSALessonUpdateManyMutationInput, DSALessonUncheckedUpdateManyWithoutTopicInput>
  }

  export type DSALessonScalarWhereInput = {
    AND?: DSALessonScalarWhereInput | DSALessonScalarWhereInput[]
    OR?: DSALessonScalarWhereInput[]
    NOT?: DSALessonScalarWhereInput | DSALessonScalarWhereInput[]
    id?: StringFilter<"DSALesson"> | string
    topicId?: StringFilter<"DSALesson"> | string
    slug?: StringFilter<"DSALesson"> | string
    title?: StringFilter<"DSALesson"> | string
    content?: StringFilter<"DSALesson"> | string
    codeExamples?: JsonNullableFilter<"DSALesson">
    difficulty?: StringNullableFilter<"DSALesson"> | string | null
    order?: IntFilter<"DSALesson"> | number
    createdAt?: DateTimeFilter<"DSALesson"> | Date | string
  }

  export type DSATopicCreateWithoutLessonsInput = {
    id?: string
    slug: string
    title: string
    category?: string | null
    order: number
    targetCount?: number
    createdAt?: Date | string
  }

  export type DSATopicUncheckedCreateWithoutLessonsInput = {
    id?: string
    slug: string
    title: string
    category?: string | null
    order: number
    targetCount?: number
    createdAt?: Date | string
  }

  export type DSATopicCreateOrConnectWithoutLessonsInput = {
    where: DSATopicWhereUniqueInput
    create: XOR<DSATopicCreateWithoutLessonsInput, DSATopicUncheckedCreateWithoutLessonsInput>
  }

  export type DSATopicUpsertWithoutLessonsInput = {
    update: XOR<DSATopicUpdateWithoutLessonsInput, DSATopicUncheckedUpdateWithoutLessonsInput>
    create: XOR<DSATopicCreateWithoutLessonsInput, DSATopicUncheckedCreateWithoutLessonsInput>
    where?: DSATopicWhereInput
  }

  export type DSATopicUpdateToOneWithWhereWithoutLessonsInput = {
    where?: DSATopicWhereInput
    data: XOR<DSATopicUpdateWithoutLessonsInput, DSATopicUncheckedUpdateWithoutLessonsInput>
  }

  export type DSATopicUpdateWithoutLessonsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    targetCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DSATopicUncheckedUpdateWithoutLessonsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    targetCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserProgressCreateWithoutProblemInput = {
    id?: string
    status: string
    starred?: boolean
    lastAttempt?: Date | string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutProgressInput
  }

  export type UserProgressUncheckedCreateWithoutProblemInput = {
    id?: string
    userId: string
    status: string
    starred?: boolean
    lastAttempt?: Date | string
    createdAt?: Date | string
  }

  export type UserProgressCreateOrConnectWithoutProblemInput = {
    where: UserProgressWhereUniqueInput
    create: XOR<UserProgressCreateWithoutProblemInput, UserProgressUncheckedCreateWithoutProblemInput>
  }

  export type UserProgressCreateManyProblemInputEnvelope = {
    data: UserProgressCreateManyProblemInput | UserProgressCreateManyProblemInput[]
    skipDuplicates?: boolean
  }

  export type SubmissionCreateWithoutProblemInput = {
    id?: string
    code: string
    language: string
    status: string
    runtime?: number | null
    memory?: number | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutSubmissionsInput
  }

  export type SubmissionUncheckedCreateWithoutProblemInput = {
    id?: string
    userId: string
    code: string
    language: string
    status: string
    runtime?: number | null
    memory?: number | null
    createdAt?: Date | string
  }

  export type SubmissionCreateOrConnectWithoutProblemInput = {
    where: SubmissionWhereUniqueInput
    create: XOR<SubmissionCreateWithoutProblemInput, SubmissionUncheckedCreateWithoutProblemInput>
  }

  export type SubmissionCreateManyProblemInputEnvelope = {
    data: SubmissionCreateManyProblemInput | SubmissionCreateManyProblemInput[]
    skipDuplicates?: boolean
  }

  export type UserProgressUpsertWithWhereUniqueWithoutProblemInput = {
    where: UserProgressWhereUniqueInput
    update: XOR<UserProgressUpdateWithoutProblemInput, UserProgressUncheckedUpdateWithoutProblemInput>
    create: XOR<UserProgressCreateWithoutProblemInput, UserProgressUncheckedCreateWithoutProblemInput>
  }

  export type UserProgressUpdateWithWhereUniqueWithoutProblemInput = {
    where: UserProgressWhereUniqueInput
    data: XOR<UserProgressUpdateWithoutProblemInput, UserProgressUncheckedUpdateWithoutProblemInput>
  }

  export type UserProgressUpdateManyWithWhereWithoutProblemInput = {
    where: UserProgressScalarWhereInput
    data: XOR<UserProgressUpdateManyMutationInput, UserProgressUncheckedUpdateManyWithoutProblemInput>
  }

  export type SubmissionUpsertWithWhereUniqueWithoutProblemInput = {
    where: SubmissionWhereUniqueInput
    update: XOR<SubmissionUpdateWithoutProblemInput, SubmissionUncheckedUpdateWithoutProblemInput>
    create: XOR<SubmissionCreateWithoutProblemInput, SubmissionUncheckedCreateWithoutProblemInput>
  }

  export type SubmissionUpdateWithWhereUniqueWithoutProblemInput = {
    where: SubmissionWhereUniqueInput
    data: XOR<SubmissionUpdateWithoutProblemInput, SubmissionUncheckedUpdateWithoutProblemInput>
  }

  export type SubmissionUpdateManyWithWhereWithoutProblemInput = {
    where: SubmissionScalarWhereInput
    data: XOR<SubmissionUpdateManyMutationInput, SubmissionUncheckedUpdateManyWithoutProblemInput>
  }

  export type UserCreateWithoutProgressInput = {
    id: string
    email: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    submissions?: SubmissionCreateNestedManyWithoutUserInput
    interviewSessions?: InterviewSessionCreateNestedManyWithoutUserInput
    sharedResults?: SharedInterviewResultCreateNestedManyWithoutUserInput
    analytics?: InterviewAnalyticsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProgressInput = {
    id: string
    email: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    submissions?: SubmissionUncheckedCreateNestedManyWithoutUserInput
    interviewSessions?: InterviewSessionUncheckedCreateNestedManyWithoutUserInput
    sharedResults?: SharedInterviewResultUncheckedCreateNestedManyWithoutUserInput
    analytics?: InterviewAnalyticsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProgressInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProgressInput, UserUncheckedCreateWithoutProgressInput>
  }

  export type ProblemCreateWithoutProgressInput = {
    id?: string
    title: string
    slug: string
    difficulty: string
    description: string
    examples: JsonNullValueInput | InputJsonValue
    constraints?: ProblemCreateconstraintsInput | string[]
    starterCode: JsonNullValueInput | InputJsonValue
    solutions?: NullableJsonNullValueInput | InputJsonValue
    testCases?: NullableJsonNullValueInput | InputJsonValue
    pattern: string
    sheets?: ProblemCreatesheetsInput | string[]
    order: number
    createdAt?: Date | string
    submissions?: SubmissionCreateNestedManyWithoutProblemInput
  }

  export type ProblemUncheckedCreateWithoutProgressInput = {
    id?: string
    title: string
    slug: string
    difficulty: string
    description: string
    examples: JsonNullValueInput | InputJsonValue
    constraints?: ProblemCreateconstraintsInput | string[]
    starterCode: JsonNullValueInput | InputJsonValue
    solutions?: NullableJsonNullValueInput | InputJsonValue
    testCases?: NullableJsonNullValueInput | InputJsonValue
    pattern: string
    sheets?: ProblemCreatesheetsInput | string[]
    order: number
    createdAt?: Date | string
    submissions?: SubmissionUncheckedCreateNestedManyWithoutProblemInput
  }

  export type ProblemCreateOrConnectWithoutProgressInput = {
    where: ProblemWhereUniqueInput
    create: XOR<ProblemCreateWithoutProgressInput, ProblemUncheckedCreateWithoutProgressInput>
  }

  export type UserUpsertWithoutProgressInput = {
    update: XOR<UserUpdateWithoutProgressInput, UserUncheckedUpdateWithoutProgressInput>
    create: XOR<UserCreateWithoutProgressInput, UserUncheckedCreateWithoutProgressInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProgressInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProgressInput, UserUncheckedUpdateWithoutProgressInput>
  }

  export type UserUpdateWithoutProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submissions?: SubmissionUpdateManyWithoutUserNestedInput
    interviewSessions?: InterviewSessionUpdateManyWithoutUserNestedInput
    sharedResults?: SharedInterviewResultUpdateManyWithoutUserNestedInput
    analytics?: InterviewAnalyticsUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submissions?: SubmissionUncheckedUpdateManyWithoutUserNestedInput
    interviewSessions?: InterviewSessionUncheckedUpdateManyWithoutUserNestedInput
    sharedResults?: SharedInterviewResultUncheckedUpdateManyWithoutUserNestedInput
    analytics?: InterviewAnalyticsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type ProblemUpsertWithoutProgressInput = {
    update: XOR<ProblemUpdateWithoutProgressInput, ProblemUncheckedUpdateWithoutProgressInput>
    create: XOR<ProblemCreateWithoutProgressInput, ProblemUncheckedCreateWithoutProgressInput>
    where?: ProblemWhereInput
  }

  export type ProblemUpdateToOneWithWhereWithoutProgressInput = {
    where?: ProblemWhereInput
    data: XOR<ProblemUpdateWithoutProgressInput, ProblemUncheckedUpdateWithoutProgressInput>
  }

  export type ProblemUpdateWithoutProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    examples?: JsonNullValueInput | InputJsonValue
    constraints?: ProblemUpdateconstraintsInput | string[]
    starterCode?: JsonNullValueInput | InputJsonValue
    solutions?: NullableJsonNullValueInput | InputJsonValue
    testCases?: NullableJsonNullValueInput | InputJsonValue
    pattern?: StringFieldUpdateOperationsInput | string
    sheets?: ProblemUpdatesheetsInput | string[]
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submissions?: SubmissionUpdateManyWithoutProblemNestedInput
  }

  export type ProblemUncheckedUpdateWithoutProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    examples?: JsonNullValueInput | InputJsonValue
    constraints?: ProblemUpdateconstraintsInput | string[]
    starterCode?: JsonNullValueInput | InputJsonValue
    solutions?: NullableJsonNullValueInput | InputJsonValue
    testCases?: NullableJsonNullValueInput | InputJsonValue
    pattern?: StringFieldUpdateOperationsInput | string
    sheets?: ProblemUpdatesheetsInput | string[]
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submissions?: SubmissionUncheckedUpdateManyWithoutProblemNestedInput
  }

  export type UserCreateWithoutSubmissionsInput = {
    id: string
    email: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    progress?: UserProgressCreateNestedManyWithoutUserInput
    interviewSessions?: InterviewSessionCreateNestedManyWithoutUserInput
    sharedResults?: SharedInterviewResultCreateNestedManyWithoutUserInput
    analytics?: InterviewAnalyticsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSubmissionsInput = {
    id: string
    email: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    progress?: UserProgressUncheckedCreateNestedManyWithoutUserInput
    interviewSessions?: InterviewSessionUncheckedCreateNestedManyWithoutUserInput
    sharedResults?: SharedInterviewResultUncheckedCreateNestedManyWithoutUserInput
    analytics?: InterviewAnalyticsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSubmissionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSubmissionsInput, UserUncheckedCreateWithoutSubmissionsInput>
  }

  export type ProblemCreateWithoutSubmissionsInput = {
    id?: string
    title: string
    slug: string
    difficulty: string
    description: string
    examples: JsonNullValueInput | InputJsonValue
    constraints?: ProblemCreateconstraintsInput | string[]
    starterCode: JsonNullValueInput | InputJsonValue
    solutions?: NullableJsonNullValueInput | InputJsonValue
    testCases?: NullableJsonNullValueInput | InputJsonValue
    pattern: string
    sheets?: ProblemCreatesheetsInput | string[]
    order: number
    createdAt?: Date | string
    progress?: UserProgressCreateNestedManyWithoutProblemInput
  }

  export type ProblemUncheckedCreateWithoutSubmissionsInput = {
    id?: string
    title: string
    slug: string
    difficulty: string
    description: string
    examples: JsonNullValueInput | InputJsonValue
    constraints?: ProblemCreateconstraintsInput | string[]
    starterCode: JsonNullValueInput | InputJsonValue
    solutions?: NullableJsonNullValueInput | InputJsonValue
    testCases?: NullableJsonNullValueInput | InputJsonValue
    pattern: string
    sheets?: ProblemCreatesheetsInput | string[]
    order: number
    createdAt?: Date | string
    progress?: UserProgressUncheckedCreateNestedManyWithoutProblemInput
  }

  export type ProblemCreateOrConnectWithoutSubmissionsInput = {
    where: ProblemWhereUniqueInput
    create: XOR<ProblemCreateWithoutSubmissionsInput, ProblemUncheckedCreateWithoutSubmissionsInput>
  }

  export type UserUpsertWithoutSubmissionsInput = {
    update: XOR<UserUpdateWithoutSubmissionsInput, UserUncheckedUpdateWithoutSubmissionsInput>
    create: XOR<UserCreateWithoutSubmissionsInput, UserUncheckedCreateWithoutSubmissionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSubmissionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSubmissionsInput, UserUncheckedUpdateWithoutSubmissionsInput>
  }

  export type UserUpdateWithoutSubmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: UserProgressUpdateManyWithoutUserNestedInput
    interviewSessions?: InterviewSessionUpdateManyWithoutUserNestedInput
    sharedResults?: SharedInterviewResultUpdateManyWithoutUserNestedInput
    analytics?: InterviewAnalyticsUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSubmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: UserProgressUncheckedUpdateManyWithoutUserNestedInput
    interviewSessions?: InterviewSessionUncheckedUpdateManyWithoutUserNestedInput
    sharedResults?: SharedInterviewResultUncheckedUpdateManyWithoutUserNestedInput
    analytics?: InterviewAnalyticsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type ProblemUpsertWithoutSubmissionsInput = {
    update: XOR<ProblemUpdateWithoutSubmissionsInput, ProblemUncheckedUpdateWithoutSubmissionsInput>
    create: XOR<ProblemCreateWithoutSubmissionsInput, ProblemUncheckedCreateWithoutSubmissionsInput>
    where?: ProblemWhereInput
  }

  export type ProblemUpdateToOneWithWhereWithoutSubmissionsInput = {
    where?: ProblemWhereInput
    data: XOR<ProblemUpdateWithoutSubmissionsInput, ProblemUncheckedUpdateWithoutSubmissionsInput>
  }

  export type ProblemUpdateWithoutSubmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    examples?: JsonNullValueInput | InputJsonValue
    constraints?: ProblemUpdateconstraintsInput | string[]
    starterCode?: JsonNullValueInput | InputJsonValue
    solutions?: NullableJsonNullValueInput | InputJsonValue
    testCases?: NullableJsonNullValueInput | InputJsonValue
    pattern?: StringFieldUpdateOperationsInput | string
    sheets?: ProblemUpdatesheetsInput | string[]
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: UserProgressUpdateManyWithoutProblemNestedInput
  }

  export type ProblemUncheckedUpdateWithoutSubmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    examples?: JsonNullValueInput | InputJsonValue
    constraints?: ProblemUpdateconstraintsInput | string[]
    starterCode?: JsonNullValueInput | InputJsonValue
    solutions?: NullableJsonNullValueInput | InputJsonValue
    testCases?: NullableJsonNullValueInput | InputJsonValue
    pattern?: StringFieldUpdateOperationsInput | string
    sheets?: ProblemUpdatesheetsInput | string[]
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: UserProgressUncheckedUpdateManyWithoutProblemNestedInput
  }

  export type LearnCategoryCreateWithoutDomainInput = {
    id?: string
    title: string
    order: number
    topics?: LearnTopicCreateNestedManyWithoutCategoryInput
  }

  export type LearnCategoryUncheckedCreateWithoutDomainInput = {
    id?: string
    title: string
    order: number
    topics?: LearnTopicUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type LearnCategoryCreateOrConnectWithoutDomainInput = {
    where: LearnCategoryWhereUniqueInput
    create: XOR<LearnCategoryCreateWithoutDomainInput, LearnCategoryUncheckedCreateWithoutDomainInput>
  }

  export type LearnCategoryCreateManyDomainInputEnvelope = {
    data: LearnCategoryCreateManyDomainInput | LearnCategoryCreateManyDomainInput[]
    skipDuplicates?: boolean
  }

  export type LearnCategoryUpsertWithWhereUniqueWithoutDomainInput = {
    where: LearnCategoryWhereUniqueInput
    update: XOR<LearnCategoryUpdateWithoutDomainInput, LearnCategoryUncheckedUpdateWithoutDomainInput>
    create: XOR<LearnCategoryCreateWithoutDomainInput, LearnCategoryUncheckedCreateWithoutDomainInput>
  }

  export type LearnCategoryUpdateWithWhereUniqueWithoutDomainInput = {
    where: LearnCategoryWhereUniqueInput
    data: XOR<LearnCategoryUpdateWithoutDomainInput, LearnCategoryUncheckedUpdateWithoutDomainInput>
  }

  export type LearnCategoryUpdateManyWithWhereWithoutDomainInput = {
    where: LearnCategoryScalarWhereInput
    data: XOR<LearnCategoryUpdateManyMutationInput, LearnCategoryUncheckedUpdateManyWithoutDomainInput>
  }

  export type LearnCategoryScalarWhereInput = {
    AND?: LearnCategoryScalarWhereInput | LearnCategoryScalarWhereInput[]
    OR?: LearnCategoryScalarWhereInput[]
    NOT?: LearnCategoryScalarWhereInput | LearnCategoryScalarWhereInput[]
    id?: StringFilter<"LearnCategory"> | string
    title?: StringFilter<"LearnCategory"> | string
    order?: IntFilter<"LearnCategory"> | number
    domainId?: StringFilter<"LearnCategory"> | string
  }

  export type LearnDomainCreateWithoutCategoriesInput = {
    id?: string
    slug: string
    title: string
    createdAt?: Date | string
  }

  export type LearnDomainUncheckedCreateWithoutCategoriesInput = {
    id?: string
    slug: string
    title: string
    createdAt?: Date | string
  }

  export type LearnDomainCreateOrConnectWithoutCategoriesInput = {
    where: LearnDomainWhereUniqueInput
    create: XOR<LearnDomainCreateWithoutCategoriesInput, LearnDomainUncheckedCreateWithoutCategoriesInput>
  }

  export type LearnTopicCreateWithoutCategoryInput = {
    id?: string
    title: string
    slug: string
    order: number
    content: string
    createdAt?: Date | string
  }

  export type LearnTopicUncheckedCreateWithoutCategoryInput = {
    id?: string
    title: string
    slug: string
    order: number
    content: string
    createdAt?: Date | string
  }

  export type LearnTopicCreateOrConnectWithoutCategoryInput = {
    where: LearnTopicWhereUniqueInput
    create: XOR<LearnTopicCreateWithoutCategoryInput, LearnTopicUncheckedCreateWithoutCategoryInput>
  }

  export type LearnTopicCreateManyCategoryInputEnvelope = {
    data: LearnTopicCreateManyCategoryInput | LearnTopicCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type LearnDomainUpsertWithoutCategoriesInput = {
    update: XOR<LearnDomainUpdateWithoutCategoriesInput, LearnDomainUncheckedUpdateWithoutCategoriesInput>
    create: XOR<LearnDomainCreateWithoutCategoriesInput, LearnDomainUncheckedCreateWithoutCategoriesInput>
    where?: LearnDomainWhereInput
  }

  export type LearnDomainUpdateToOneWithWhereWithoutCategoriesInput = {
    where?: LearnDomainWhereInput
    data: XOR<LearnDomainUpdateWithoutCategoriesInput, LearnDomainUncheckedUpdateWithoutCategoriesInput>
  }

  export type LearnDomainUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LearnDomainUncheckedUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LearnTopicUpsertWithWhereUniqueWithoutCategoryInput = {
    where: LearnTopicWhereUniqueInput
    update: XOR<LearnTopicUpdateWithoutCategoryInput, LearnTopicUncheckedUpdateWithoutCategoryInput>
    create: XOR<LearnTopicCreateWithoutCategoryInput, LearnTopicUncheckedCreateWithoutCategoryInput>
  }

  export type LearnTopicUpdateWithWhereUniqueWithoutCategoryInput = {
    where: LearnTopicWhereUniqueInput
    data: XOR<LearnTopicUpdateWithoutCategoryInput, LearnTopicUncheckedUpdateWithoutCategoryInput>
  }

  export type LearnTopicUpdateManyWithWhereWithoutCategoryInput = {
    where: LearnTopicScalarWhereInput
    data: XOR<LearnTopicUpdateManyMutationInput, LearnTopicUncheckedUpdateManyWithoutCategoryInput>
  }

  export type LearnTopicScalarWhereInput = {
    AND?: LearnTopicScalarWhereInput | LearnTopicScalarWhereInput[]
    OR?: LearnTopicScalarWhereInput[]
    NOT?: LearnTopicScalarWhereInput | LearnTopicScalarWhereInput[]
    id?: StringFilter<"LearnTopic"> | string
    title?: StringFilter<"LearnTopic"> | string
    slug?: StringFilter<"LearnTopic"> | string
    order?: IntFilter<"LearnTopic"> | number
    content?: StringFilter<"LearnTopic"> | string
    categoryId?: StringFilter<"LearnTopic"> | string
    createdAt?: DateTimeFilter<"LearnTopic"> | Date | string
  }

  export type LearnCategoryCreateWithoutTopicsInput = {
    id?: string
    title: string
    order: number
    domain: LearnDomainCreateNestedOneWithoutCategoriesInput
  }

  export type LearnCategoryUncheckedCreateWithoutTopicsInput = {
    id?: string
    title: string
    order: number
    domainId: string
  }

  export type LearnCategoryCreateOrConnectWithoutTopicsInput = {
    where: LearnCategoryWhereUniqueInput
    create: XOR<LearnCategoryCreateWithoutTopicsInput, LearnCategoryUncheckedCreateWithoutTopicsInput>
  }

  export type LearnCategoryUpsertWithoutTopicsInput = {
    update: XOR<LearnCategoryUpdateWithoutTopicsInput, LearnCategoryUncheckedUpdateWithoutTopicsInput>
    create: XOR<LearnCategoryCreateWithoutTopicsInput, LearnCategoryUncheckedCreateWithoutTopicsInput>
    where?: LearnCategoryWhereInput
  }

  export type LearnCategoryUpdateToOneWithWhereWithoutTopicsInput = {
    where?: LearnCategoryWhereInput
    data: XOR<LearnCategoryUpdateWithoutTopicsInput, LearnCategoryUncheckedUpdateWithoutTopicsInput>
  }

  export type LearnCategoryUpdateWithoutTopicsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    domain?: LearnDomainUpdateOneRequiredWithoutCategoriesNestedInput
  }

  export type LearnCategoryUncheckedUpdateWithoutTopicsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    domainId?: StringFieldUpdateOperationsInput | string
  }

  export type UserCreateWithoutInterviewSessionsInput = {
    id: string
    email: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    progress?: UserProgressCreateNestedManyWithoutUserInput
    submissions?: SubmissionCreateNestedManyWithoutUserInput
    sharedResults?: SharedInterviewResultCreateNestedManyWithoutUserInput
    analytics?: InterviewAnalyticsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutInterviewSessionsInput = {
    id: string
    email: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    progress?: UserProgressUncheckedCreateNestedManyWithoutUserInput
    submissions?: SubmissionUncheckedCreateNestedManyWithoutUserInput
    sharedResults?: SharedInterviewResultUncheckedCreateNestedManyWithoutUserInput
    analytics?: InterviewAnalyticsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutInterviewSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInterviewSessionsInput, UserUncheckedCreateWithoutInterviewSessionsInput>
  }

  export type InterviewFeedbackCreateWithoutSessionInput = {
    id?: string
    overallScore: number
    communicationClarity: number
    technicalDepth: number
    confidence: number
    roleAlignment: number
    skillRatings: JsonNullValueInput | InputJsonValue
    strengths?: InterviewFeedbackCreatestrengthsInput | string[]
    weaknesses?: InterviewFeedbackCreateweaknessesInput | string[]
    improvements?: InterviewFeedbackCreateimprovementsInput | string[]
    suggestedTopics?: InterviewFeedbackCreatesuggestedTopicsInput | string[]
    learningRoadmap: string
    aiSummary: string
    createdAt?: Date | string
  }

  export type InterviewFeedbackUncheckedCreateWithoutSessionInput = {
    id?: string
    overallScore: number
    communicationClarity: number
    technicalDepth: number
    confidence: number
    roleAlignment: number
    skillRatings: JsonNullValueInput | InputJsonValue
    strengths?: InterviewFeedbackCreatestrengthsInput | string[]
    weaknesses?: InterviewFeedbackCreateweaknessesInput | string[]
    improvements?: InterviewFeedbackCreateimprovementsInput | string[]
    suggestedTopics?: InterviewFeedbackCreatesuggestedTopicsInput | string[]
    learningRoadmap: string
    aiSummary: string
    createdAt?: Date | string
  }

  export type InterviewFeedbackCreateOrConnectWithoutSessionInput = {
    where: InterviewFeedbackWhereUniqueInput
    create: XOR<InterviewFeedbackCreateWithoutSessionInput, InterviewFeedbackUncheckedCreateWithoutSessionInput>
  }

  export type SharedInterviewResultCreateWithoutSessionInput = {
    id?: string
    shareToken: string
    isPublic?: boolean
    expiresAt?: Date | string | null
    viewCount?: number
    lastViewedAt?: Date | string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutSharedResultsInput
  }

  export type SharedInterviewResultUncheckedCreateWithoutSessionInput = {
    id?: string
    userId: string
    shareToken: string
    isPublic?: boolean
    expiresAt?: Date | string | null
    viewCount?: number
    lastViewedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type SharedInterviewResultCreateOrConnectWithoutSessionInput = {
    where: SharedInterviewResultWhereUniqueInput
    create: XOR<SharedInterviewResultCreateWithoutSessionInput, SharedInterviewResultUncheckedCreateWithoutSessionInput>
  }

  export type UserUpsertWithoutInterviewSessionsInput = {
    update: XOR<UserUpdateWithoutInterviewSessionsInput, UserUncheckedUpdateWithoutInterviewSessionsInput>
    create: XOR<UserCreateWithoutInterviewSessionsInput, UserUncheckedCreateWithoutInterviewSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInterviewSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInterviewSessionsInput, UserUncheckedUpdateWithoutInterviewSessionsInput>
  }

  export type UserUpdateWithoutInterviewSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: UserProgressUpdateManyWithoutUserNestedInput
    submissions?: SubmissionUpdateManyWithoutUserNestedInput
    sharedResults?: SharedInterviewResultUpdateManyWithoutUserNestedInput
    analytics?: InterviewAnalyticsUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutInterviewSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: UserProgressUncheckedUpdateManyWithoutUserNestedInput
    submissions?: SubmissionUncheckedUpdateManyWithoutUserNestedInput
    sharedResults?: SharedInterviewResultUncheckedUpdateManyWithoutUserNestedInput
    analytics?: InterviewAnalyticsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type InterviewFeedbackUpsertWithoutSessionInput = {
    update: XOR<InterviewFeedbackUpdateWithoutSessionInput, InterviewFeedbackUncheckedUpdateWithoutSessionInput>
    create: XOR<InterviewFeedbackCreateWithoutSessionInput, InterviewFeedbackUncheckedCreateWithoutSessionInput>
    where?: InterviewFeedbackWhereInput
  }

  export type InterviewFeedbackUpdateToOneWithWhereWithoutSessionInput = {
    where?: InterviewFeedbackWhereInput
    data: XOR<InterviewFeedbackUpdateWithoutSessionInput, InterviewFeedbackUncheckedUpdateWithoutSessionInput>
  }

  export type InterviewFeedbackUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    overallScore?: IntFieldUpdateOperationsInput | number
    communicationClarity?: IntFieldUpdateOperationsInput | number
    technicalDepth?: IntFieldUpdateOperationsInput | number
    confidence?: IntFieldUpdateOperationsInput | number
    roleAlignment?: IntFieldUpdateOperationsInput | number
    skillRatings?: JsonNullValueInput | InputJsonValue
    strengths?: InterviewFeedbackUpdatestrengthsInput | string[]
    weaknesses?: InterviewFeedbackUpdateweaknessesInput | string[]
    improvements?: InterviewFeedbackUpdateimprovementsInput | string[]
    suggestedTopics?: InterviewFeedbackUpdatesuggestedTopicsInput | string[]
    learningRoadmap?: StringFieldUpdateOperationsInput | string
    aiSummary?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterviewFeedbackUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    overallScore?: IntFieldUpdateOperationsInput | number
    communicationClarity?: IntFieldUpdateOperationsInput | number
    technicalDepth?: IntFieldUpdateOperationsInput | number
    confidence?: IntFieldUpdateOperationsInput | number
    roleAlignment?: IntFieldUpdateOperationsInput | number
    skillRatings?: JsonNullValueInput | InputJsonValue
    strengths?: InterviewFeedbackUpdatestrengthsInput | string[]
    weaknesses?: InterviewFeedbackUpdateweaknessesInput | string[]
    improvements?: InterviewFeedbackUpdateimprovementsInput | string[]
    suggestedTopics?: InterviewFeedbackUpdatesuggestedTopicsInput | string[]
    learningRoadmap?: StringFieldUpdateOperationsInput | string
    aiSummary?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SharedInterviewResultUpsertWithoutSessionInput = {
    update: XOR<SharedInterviewResultUpdateWithoutSessionInput, SharedInterviewResultUncheckedUpdateWithoutSessionInput>
    create: XOR<SharedInterviewResultCreateWithoutSessionInput, SharedInterviewResultUncheckedCreateWithoutSessionInput>
    where?: SharedInterviewResultWhereInput
  }

  export type SharedInterviewResultUpdateToOneWithWhereWithoutSessionInput = {
    where?: SharedInterviewResultWhereInput
    data: XOR<SharedInterviewResultUpdateWithoutSessionInput, SharedInterviewResultUncheckedUpdateWithoutSessionInput>
  }

  export type SharedInterviewResultUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    shareToken?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    lastViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSharedResultsNestedInput
  }

  export type SharedInterviewResultUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    shareToken?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    lastViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterviewSessionCreateWithoutFeedbackInput = {
    id?: string
    role: string
    duration: number
    status: string
    resumeSnapshot: string
    jobDescription?: string | null
    resumeSummary?: string | null
    jdSummary?: string | null
    vapiCallId?: string | null
    vapiAssistantId?: string | null
    transcript?: NullableJsonNullValueInput | InputJsonValue
    videoUrl?: string | null
    videoRecorded?: boolean
    createdAt?: Date | string
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    user: UserCreateNestedOneWithoutInterviewSessionsInput
    sharedResult?: SharedInterviewResultCreateNestedOneWithoutSessionInput
  }

  export type InterviewSessionUncheckedCreateWithoutFeedbackInput = {
    id?: string
    userId: string
    role: string
    duration: number
    status: string
    resumeSnapshot: string
    jobDescription?: string | null
    resumeSummary?: string | null
    jdSummary?: string | null
    vapiCallId?: string | null
    vapiAssistantId?: string | null
    transcript?: NullableJsonNullValueInput | InputJsonValue
    videoUrl?: string | null
    videoRecorded?: boolean
    createdAt?: Date | string
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    sharedResult?: SharedInterviewResultUncheckedCreateNestedOneWithoutSessionInput
  }

  export type InterviewSessionCreateOrConnectWithoutFeedbackInput = {
    where: InterviewSessionWhereUniqueInput
    create: XOR<InterviewSessionCreateWithoutFeedbackInput, InterviewSessionUncheckedCreateWithoutFeedbackInput>
  }

  export type InterviewSessionUpsertWithoutFeedbackInput = {
    update: XOR<InterviewSessionUpdateWithoutFeedbackInput, InterviewSessionUncheckedUpdateWithoutFeedbackInput>
    create: XOR<InterviewSessionCreateWithoutFeedbackInput, InterviewSessionUncheckedCreateWithoutFeedbackInput>
    where?: InterviewSessionWhereInput
  }

  export type InterviewSessionUpdateToOneWithWhereWithoutFeedbackInput = {
    where?: InterviewSessionWhereInput
    data: XOR<InterviewSessionUpdateWithoutFeedbackInput, InterviewSessionUncheckedUpdateWithoutFeedbackInput>
  }

  export type InterviewSessionUpdateWithoutFeedbackInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    resumeSnapshot?: StringFieldUpdateOperationsInput | string
    jobDescription?: NullableStringFieldUpdateOperationsInput | string | null
    resumeSummary?: NullableStringFieldUpdateOperationsInput | string | null
    jdSummary?: NullableStringFieldUpdateOperationsInput | string | null
    vapiCallId?: NullableStringFieldUpdateOperationsInput | string | null
    vapiAssistantId?: NullableStringFieldUpdateOperationsInput | string | null
    transcript?: NullableJsonNullValueInput | InputJsonValue
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    videoRecorded?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutInterviewSessionsNestedInput
    sharedResult?: SharedInterviewResultUpdateOneWithoutSessionNestedInput
  }

  export type InterviewSessionUncheckedUpdateWithoutFeedbackInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    resumeSnapshot?: StringFieldUpdateOperationsInput | string
    jobDescription?: NullableStringFieldUpdateOperationsInput | string | null
    resumeSummary?: NullableStringFieldUpdateOperationsInput | string | null
    jdSummary?: NullableStringFieldUpdateOperationsInput | string | null
    vapiCallId?: NullableStringFieldUpdateOperationsInput | string | null
    vapiAssistantId?: NullableStringFieldUpdateOperationsInput | string | null
    transcript?: NullableJsonNullValueInput | InputJsonValue
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    videoRecorded?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sharedResult?: SharedInterviewResultUncheckedUpdateOneWithoutSessionNestedInput
  }

  export type InterviewSessionCreateWithoutSharedResultInput = {
    id?: string
    role: string
    duration: number
    status: string
    resumeSnapshot: string
    jobDescription?: string | null
    resumeSummary?: string | null
    jdSummary?: string | null
    vapiCallId?: string | null
    vapiAssistantId?: string | null
    transcript?: NullableJsonNullValueInput | InputJsonValue
    videoUrl?: string | null
    videoRecorded?: boolean
    createdAt?: Date | string
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    user: UserCreateNestedOneWithoutInterviewSessionsInput
    feedback?: InterviewFeedbackCreateNestedOneWithoutSessionInput
  }

  export type InterviewSessionUncheckedCreateWithoutSharedResultInput = {
    id?: string
    userId: string
    role: string
    duration: number
    status: string
    resumeSnapshot: string
    jobDescription?: string | null
    resumeSummary?: string | null
    jdSummary?: string | null
    vapiCallId?: string | null
    vapiAssistantId?: string | null
    transcript?: NullableJsonNullValueInput | InputJsonValue
    videoUrl?: string | null
    videoRecorded?: boolean
    createdAt?: Date | string
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    feedback?: InterviewFeedbackUncheckedCreateNestedOneWithoutSessionInput
  }

  export type InterviewSessionCreateOrConnectWithoutSharedResultInput = {
    where: InterviewSessionWhereUniqueInput
    create: XOR<InterviewSessionCreateWithoutSharedResultInput, InterviewSessionUncheckedCreateWithoutSharedResultInput>
  }

  export type UserCreateWithoutSharedResultsInput = {
    id: string
    email: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    progress?: UserProgressCreateNestedManyWithoutUserInput
    submissions?: SubmissionCreateNestedManyWithoutUserInput
    interviewSessions?: InterviewSessionCreateNestedManyWithoutUserInput
    analytics?: InterviewAnalyticsCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSharedResultsInput = {
    id: string
    email: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    progress?: UserProgressUncheckedCreateNestedManyWithoutUserInput
    submissions?: SubmissionUncheckedCreateNestedManyWithoutUserInput
    interviewSessions?: InterviewSessionUncheckedCreateNestedManyWithoutUserInput
    analytics?: InterviewAnalyticsUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSharedResultsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSharedResultsInput, UserUncheckedCreateWithoutSharedResultsInput>
  }

  export type InterviewSessionUpsertWithoutSharedResultInput = {
    update: XOR<InterviewSessionUpdateWithoutSharedResultInput, InterviewSessionUncheckedUpdateWithoutSharedResultInput>
    create: XOR<InterviewSessionCreateWithoutSharedResultInput, InterviewSessionUncheckedCreateWithoutSharedResultInput>
    where?: InterviewSessionWhereInput
  }

  export type InterviewSessionUpdateToOneWithWhereWithoutSharedResultInput = {
    where?: InterviewSessionWhereInput
    data: XOR<InterviewSessionUpdateWithoutSharedResultInput, InterviewSessionUncheckedUpdateWithoutSharedResultInput>
  }

  export type InterviewSessionUpdateWithoutSharedResultInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    resumeSnapshot?: StringFieldUpdateOperationsInput | string
    jobDescription?: NullableStringFieldUpdateOperationsInput | string | null
    resumeSummary?: NullableStringFieldUpdateOperationsInput | string | null
    jdSummary?: NullableStringFieldUpdateOperationsInput | string | null
    vapiCallId?: NullableStringFieldUpdateOperationsInput | string | null
    vapiAssistantId?: NullableStringFieldUpdateOperationsInput | string | null
    transcript?: NullableJsonNullValueInput | InputJsonValue
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    videoRecorded?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutInterviewSessionsNestedInput
    feedback?: InterviewFeedbackUpdateOneWithoutSessionNestedInput
  }

  export type InterviewSessionUncheckedUpdateWithoutSharedResultInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    resumeSnapshot?: StringFieldUpdateOperationsInput | string
    jobDescription?: NullableStringFieldUpdateOperationsInput | string | null
    resumeSummary?: NullableStringFieldUpdateOperationsInput | string | null
    jdSummary?: NullableStringFieldUpdateOperationsInput | string | null
    vapiCallId?: NullableStringFieldUpdateOperationsInput | string | null
    vapiAssistantId?: NullableStringFieldUpdateOperationsInput | string | null
    transcript?: NullableJsonNullValueInput | InputJsonValue
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    videoRecorded?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    feedback?: InterviewFeedbackUncheckedUpdateOneWithoutSessionNestedInput
  }

  export type UserUpsertWithoutSharedResultsInput = {
    update: XOR<UserUpdateWithoutSharedResultsInput, UserUncheckedUpdateWithoutSharedResultsInput>
    create: XOR<UserCreateWithoutSharedResultsInput, UserUncheckedCreateWithoutSharedResultsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSharedResultsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSharedResultsInput, UserUncheckedUpdateWithoutSharedResultsInput>
  }

  export type UserUpdateWithoutSharedResultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: UserProgressUpdateManyWithoutUserNestedInput
    submissions?: SubmissionUpdateManyWithoutUserNestedInput
    interviewSessions?: InterviewSessionUpdateManyWithoutUserNestedInput
    analytics?: InterviewAnalyticsUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSharedResultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: UserProgressUncheckedUpdateManyWithoutUserNestedInput
    submissions?: SubmissionUncheckedUpdateManyWithoutUserNestedInput
    interviewSessions?: InterviewSessionUncheckedUpdateManyWithoutUserNestedInput
    analytics?: InterviewAnalyticsUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateWithoutAnalyticsInput = {
    id: string
    email: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    progress?: UserProgressCreateNestedManyWithoutUserInput
    submissions?: SubmissionCreateNestedManyWithoutUserInput
    interviewSessions?: InterviewSessionCreateNestedManyWithoutUserInput
    sharedResults?: SharedInterviewResultCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAnalyticsInput = {
    id: string
    email: string
    name?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    progress?: UserProgressUncheckedCreateNestedManyWithoutUserInput
    submissions?: SubmissionUncheckedCreateNestedManyWithoutUserInput
    interviewSessions?: InterviewSessionUncheckedCreateNestedManyWithoutUserInput
    sharedResults?: SharedInterviewResultUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAnalyticsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAnalyticsInput, UserUncheckedCreateWithoutAnalyticsInput>
  }

  export type UserUpsertWithoutAnalyticsInput = {
    update: XOR<UserUpdateWithoutAnalyticsInput, UserUncheckedUpdateWithoutAnalyticsInput>
    create: XOR<UserCreateWithoutAnalyticsInput, UserUncheckedCreateWithoutAnalyticsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAnalyticsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAnalyticsInput, UserUncheckedUpdateWithoutAnalyticsInput>
  }

  export type UserUpdateWithoutAnalyticsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: UserProgressUpdateManyWithoutUserNestedInput
    submissions?: SubmissionUpdateManyWithoutUserNestedInput
    interviewSessions?: InterviewSessionUpdateManyWithoutUserNestedInput
    sharedResults?: SharedInterviewResultUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAnalyticsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: UserProgressUncheckedUpdateManyWithoutUserNestedInput
    submissions?: SubmissionUncheckedUpdateManyWithoutUserNestedInput
    interviewSessions?: InterviewSessionUncheckedUpdateManyWithoutUserNestedInput
    sharedResults?: SharedInterviewResultUncheckedUpdateManyWithoutUserNestedInput
  }

  export type RoadmapPhaseCreateWithoutRoadmapInput = {
    id?: string
    title: string
    description: string
    order: number
    steps?: RoadmapStepCreateNestedManyWithoutPhaseInput
  }

  export type RoadmapPhaseUncheckedCreateWithoutRoadmapInput = {
    id?: string
    title: string
    description: string
    order: number
    steps?: RoadmapStepUncheckedCreateNestedManyWithoutPhaseInput
  }

  export type RoadmapPhaseCreateOrConnectWithoutRoadmapInput = {
    where: RoadmapPhaseWhereUniqueInput
    create: XOR<RoadmapPhaseCreateWithoutRoadmapInput, RoadmapPhaseUncheckedCreateWithoutRoadmapInput>
  }

  export type RoadmapPhaseCreateManyRoadmapInputEnvelope = {
    data: RoadmapPhaseCreateManyRoadmapInput | RoadmapPhaseCreateManyRoadmapInput[]
    skipDuplicates?: boolean
  }

  export type RoadmapProgressCreateWithoutRoadmapInput = {
    id?: string
    userId: string
    completed?: boolean
    notes?: string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    step: RoadmapStepCreateNestedOneWithoutProgressInput
  }

  export type RoadmapProgressUncheckedCreateWithoutRoadmapInput = {
    id?: string
    userId: string
    stepId: string
    completed?: boolean
    notes?: string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoadmapProgressCreateOrConnectWithoutRoadmapInput = {
    where: RoadmapProgressWhereUniqueInput
    create: XOR<RoadmapProgressCreateWithoutRoadmapInput, RoadmapProgressUncheckedCreateWithoutRoadmapInput>
  }

  export type RoadmapProgressCreateManyRoadmapInputEnvelope = {
    data: RoadmapProgressCreateManyRoadmapInput | RoadmapProgressCreateManyRoadmapInput[]
    skipDuplicates?: boolean
  }

  export type RoadmapPhaseUpsertWithWhereUniqueWithoutRoadmapInput = {
    where: RoadmapPhaseWhereUniqueInput
    update: XOR<RoadmapPhaseUpdateWithoutRoadmapInput, RoadmapPhaseUncheckedUpdateWithoutRoadmapInput>
    create: XOR<RoadmapPhaseCreateWithoutRoadmapInput, RoadmapPhaseUncheckedCreateWithoutRoadmapInput>
  }

  export type RoadmapPhaseUpdateWithWhereUniqueWithoutRoadmapInput = {
    where: RoadmapPhaseWhereUniqueInput
    data: XOR<RoadmapPhaseUpdateWithoutRoadmapInput, RoadmapPhaseUncheckedUpdateWithoutRoadmapInput>
  }

  export type RoadmapPhaseUpdateManyWithWhereWithoutRoadmapInput = {
    where: RoadmapPhaseScalarWhereInput
    data: XOR<RoadmapPhaseUpdateManyMutationInput, RoadmapPhaseUncheckedUpdateManyWithoutRoadmapInput>
  }

  export type RoadmapPhaseScalarWhereInput = {
    AND?: RoadmapPhaseScalarWhereInput | RoadmapPhaseScalarWhereInput[]
    OR?: RoadmapPhaseScalarWhereInput[]
    NOT?: RoadmapPhaseScalarWhereInput | RoadmapPhaseScalarWhereInput[]
    id?: StringFilter<"RoadmapPhase"> | string
    roadmapId?: StringFilter<"RoadmapPhase"> | string
    title?: StringFilter<"RoadmapPhase"> | string
    description?: StringFilter<"RoadmapPhase"> | string
    order?: IntFilter<"RoadmapPhase"> | number
  }

  export type RoadmapProgressUpsertWithWhereUniqueWithoutRoadmapInput = {
    where: RoadmapProgressWhereUniqueInput
    update: XOR<RoadmapProgressUpdateWithoutRoadmapInput, RoadmapProgressUncheckedUpdateWithoutRoadmapInput>
    create: XOR<RoadmapProgressCreateWithoutRoadmapInput, RoadmapProgressUncheckedCreateWithoutRoadmapInput>
  }

  export type RoadmapProgressUpdateWithWhereUniqueWithoutRoadmapInput = {
    where: RoadmapProgressWhereUniqueInput
    data: XOR<RoadmapProgressUpdateWithoutRoadmapInput, RoadmapProgressUncheckedUpdateWithoutRoadmapInput>
  }

  export type RoadmapProgressUpdateManyWithWhereWithoutRoadmapInput = {
    where: RoadmapProgressScalarWhereInput
    data: XOR<RoadmapProgressUpdateManyMutationInput, RoadmapProgressUncheckedUpdateManyWithoutRoadmapInput>
  }

  export type RoadmapProgressScalarWhereInput = {
    AND?: RoadmapProgressScalarWhereInput | RoadmapProgressScalarWhereInput[]
    OR?: RoadmapProgressScalarWhereInput[]
    NOT?: RoadmapProgressScalarWhereInput | RoadmapProgressScalarWhereInput[]
    id?: StringFilter<"RoadmapProgress"> | string
    userId?: StringFilter<"RoadmapProgress"> | string
    roadmapId?: StringFilter<"RoadmapProgress"> | string
    stepId?: StringFilter<"RoadmapProgress"> | string
    completed?: BoolFilter<"RoadmapProgress"> | boolean
    notes?: StringNullableFilter<"RoadmapProgress"> | string | null
    completedAt?: DateTimeNullableFilter<"RoadmapProgress"> | Date | string | null
    createdAt?: DateTimeFilter<"RoadmapProgress"> | Date | string
    updatedAt?: DateTimeFilter<"RoadmapProgress"> | Date | string
  }

  export type RoadmapCreateWithoutPhasesInput = {
    id?: string
    slug: string
    title: string
    description: string
    icon: string
    level: string
    duration: string
    gradient: string
    skills?: RoadmapCreateskillsInput | string[]
    popularity?: number
    isActive?: boolean
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    progress?: RoadmapProgressCreateNestedManyWithoutRoadmapInput
  }

  export type RoadmapUncheckedCreateWithoutPhasesInput = {
    id?: string
    slug: string
    title: string
    description: string
    icon: string
    level: string
    duration: string
    gradient: string
    skills?: RoadmapCreateskillsInput | string[]
    popularity?: number
    isActive?: boolean
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    progress?: RoadmapProgressUncheckedCreateNestedManyWithoutRoadmapInput
  }

  export type RoadmapCreateOrConnectWithoutPhasesInput = {
    where: RoadmapWhereUniqueInput
    create: XOR<RoadmapCreateWithoutPhasesInput, RoadmapUncheckedCreateWithoutPhasesInput>
  }

  export type RoadmapStepCreateWithoutPhaseInput = {
    id?: string
    title: string
    description: string
    difficulty: string
    estimatedTime: string
    order: number
    topics?: RoadmapStepCreatetopicsInput | string[]
    prerequisites?: RoadmapStepCreateprerequisitesInput | string[]
    resources: JsonNullValueInput | InputJsonValue
    checkpoints?: RoadmapStepCreatecheckpointsInput | string[]
    relatedCheatsheets?: RoadmapStepCreaterelatedCheatsheetsInput | string[]
    relatedDSA?: RoadmapStepCreaterelatedDSAInput | string[]
    relatedInterviews?: RoadmapStepCreaterelatedInterviewsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    progress?: RoadmapProgressCreateNestedManyWithoutStepInput
  }

  export type RoadmapStepUncheckedCreateWithoutPhaseInput = {
    id?: string
    title: string
    description: string
    difficulty: string
    estimatedTime: string
    order: number
    topics?: RoadmapStepCreatetopicsInput | string[]
    prerequisites?: RoadmapStepCreateprerequisitesInput | string[]
    resources: JsonNullValueInput | InputJsonValue
    checkpoints?: RoadmapStepCreatecheckpointsInput | string[]
    relatedCheatsheets?: RoadmapStepCreaterelatedCheatsheetsInput | string[]
    relatedDSA?: RoadmapStepCreaterelatedDSAInput | string[]
    relatedInterviews?: RoadmapStepCreaterelatedInterviewsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    progress?: RoadmapProgressUncheckedCreateNestedManyWithoutStepInput
  }

  export type RoadmapStepCreateOrConnectWithoutPhaseInput = {
    where: RoadmapStepWhereUniqueInput
    create: XOR<RoadmapStepCreateWithoutPhaseInput, RoadmapStepUncheckedCreateWithoutPhaseInput>
  }

  export type RoadmapStepCreateManyPhaseInputEnvelope = {
    data: RoadmapStepCreateManyPhaseInput | RoadmapStepCreateManyPhaseInput[]
    skipDuplicates?: boolean
  }

  export type RoadmapUpsertWithoutPhasesInput = {
    update: XOR<RoadmapUpdateWithoutPhasesInput, RoadmapUncheckedUpdateWithoutPhasesInput>
    create: XOR<RoadmapCreateWithoutPhasesInput, RoadmapUncheckedCreateWithoutPhasesInput>
    where?: RoadmapWhereInput
  }

  export type RoadmapUpdateToOneWithWhereWithoutPhasesInput = {
    where?: RoadmapWhereInput
    data: XOR<RoadmapUpdateWithoutPhasesInput, RoadmapUncheckedUpdateWithoutPhasesInput>
  }

  export type RoadmapUpdateWithoutPhasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    gradient?: StringFieldUpdateOperationsInput | string
    skills?: RoadmapUpdateskillsInput | string[]
    popularity?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: RoadmapProgressUpdateManyWithoutRoadmapNestedInput
  }

  export type RoadmapUncheckedUpdateWithoutPhasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    gradient?: StringFieldUpdateOperationsInput | string
    skills?: RoadmapUpdateskillsInput | string[]
    popularity?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: RoadmapProgressUncheckedUpdateManyWithoutRoadmapNestedInput
  }

  export type RoadmapStepUpsertWithWhereUniqueWithoutPhaseInput = {
    where: RoadmapStepWhereUniqueInput
    update: XOR<RoadmapStepUpdateWithoutPhaseInput, RoadmapStepUncheckedUpdateWithoutPhaseInput>
    create: XOR<RoadmapStepCreateWithoutPhaseInput, RoadmapStepUncheckedCreateWithoutPhaseInput>
  }

  export type RoadmapStepUpdateWithWhereUniqueWithoutPhaseInput = {
    where: RoadmapStepWhereUniqueInput
    data: XOR<RoadmapStepUpdateWithoutPhaseInput, RoadmapStepUncheckedUpdateWithoutPhaseInput>
  }

  export type RoadmapStepUpdateManyWithWhereWithoutPhaseInput = {
    where: RoadmapStepScalarWhereInput
    data: XOR<RoadmapStepUpdateManyMutationInput, RoadmapStepUncheckedUpdateManyWithoutPhaseInput>
  }

  export type RoadmapStepScalarWhereInput = {
    AND?: RoadmapStepScalarWhereInput | RoadmapStepScalarWhereInput[]
    OR?: RoadmapStepScalarWhereInput[]
    NOT?: RoadmapStepScalarWhereInput | RoadmapStepScalarWhereInput[]
    id?: StringFilter<"RoadmapStep"> | string
    phaseId?: StringFilter<"RoadmapStep"> | string
    title?: StringFilter<"RoadmapStep"> | string
    description?: StringFilter<"RoadmapStep"> | string
    difficulty?: StringFilter<"RoadmapStep"> | string
    estimatedTime?: StringFilter<"RoadmapStep"> | string
    order?: IntFilter<"RoadmapStep"> | number
    topics?: StringNullableListFilter<"RoadmapStep">
    prerequisites?: StringNullableListFilter<"RoadmapStep">
    resources?: JsonFilter<"RoadmapStep">
    checkpoints?: StringNullableListFilter<"RoadmapStep">
    relatedCheatsheets?: StringNullableListFilter<"RoadmapStep">
    relatedDSA?: StringNullableListFilter<"RoadmapStep">
    relatedInterviews?: StringNullableListFilter<"RoadmapStep">
    createdAt?: DateTimeFilter<"RoadmapStep"> | Date | string
    updatedAt?: DateTimeFilter<"RoadmapStep"> | Date | string
  }

  export type RoadmapPhaseCreateWithoutStepsInput = {
    id?: string
    title: string
    description: string
    order: number
    roadmap: RoadmapCreateNestedOneWithoutPhasesInput
  }

  export type RoadmapPhaseUncheckedCreateWithoutStepsInput = {
    id?: string
    roadmapId: string
    title: string
    description: string
    order: number
  }

  export type RoadmapPhaseCreateOrConnectWithoutStepsInput = {
    where: RoadmapPhaseWhereUniqueInput
    create: XOR<RoadmapPhaseCreateWithoutStepsInput, RoadmapPhaseUncheckedCreateWithoutStepsInput>
  }

  export type RoadmapProgressCreateWithoutStepInput = {
    id?: string
    userId: string
    completed?: boolean
    notes?: string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roadmap: RoadmapCreateNestedOneWithoutProgressInput
  }

  export type RoadmapProgressUncheckedCreateWithoutStepInput = {
    id?: string
    userId: string
    roadmapId: string
    completed?: boolean
    notes?: string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoadmapProgressCreateOrConnectWithoutStepInput = {
    where: RoadmapProgressWhereUniqueInput
    create: XOR<RoadmapProgressCreateWithoutStepInput, RoadmapProgressUncheckedCreateWithoutStepInput>
  }

  export type RoadmapProgressCreateManyStepInputEnvelope = {
    data: RoadmapProgressCreateManyStepInput | RoadmapProgressCreateManyStepInput[]
    skipDuplicates?: boolean
  }

  export type RoadmapPhaseUpsertWithoutStepsInput = {
    update: XOR<RoadmapPhaseUpdateWithoutStepsInput, RoadmapPhaseUncheckedUpdateWithoutStepsInput>
    create: XOR<RoadmapPhaseCreateWithoutStepsInput, RoadmapPhaseUncheckedCreateWithoutStepsInput>
    where?: RoadmapPhaseWhereInput
  }

  export type RoadmapPhaseUpdateToOneWithWhereWithoutStepsInput = {
    where?: RoadmapPhaseWhereInput
    data: XOR<RoadmapPhaseUpdateWithoutStepsInput, RoadmapPhaseUncheckedUpdateWithoutStepsInput>
  }

  export type RoadmapPhaseUpdateWithoutStepsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    roadmap?: RoadmapUpdateOneRequiredWithoutPhasesNestedInput
  }

  export type RoadmapPhaseUncheckedUpdateWithoutStepsInput = {
    id?: StringFieldUpdateOperationsInput | string
    roadmapId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
  }

  export type RoadmapProgressUpsertWithWhereUniqueWithoutStepInput = {
    where: RoadmapProgressWhereUniqueInput
    update: XOR<RoadmapProgressUpdateWithoutStepInput, RoadmapProgressUncheckedUpdateWithoutStepInput>
    create: XOR<RoadmapProgressCreateWithoutStepInput, RoadmapProgressUncheckedCreateWithoutStepInput>
  }

  export type RoadmapProgressUpdateWithWhereUniqueWithoutStepInput = {
    where: RoadmapProgressWhereUniqueInput
    data: XOR<RoadmapProgressUpdateWithoutStepInput, RoadmapProgressUncheckedUpdateWithoutStepInput>
  }

  export type RoadmapProgressUpdateManyWithWhereWithoutStepInput = {
    where: RoadmapProgressScalarWhereInput
    data: XOR<RoadmapProgressUpdateManyMutationInput, RoadmapProgressUncheckedUpdateManyWithoutStepInput>
  }

  export type RoadmapCreateWithoutProgressInput = {
    id?: string
    slug: string
    title: string
    description: string
    icon: string
    level: string
    duration: string
    gradient: string
    skills?: RoadmapCreateskillsInput | string[]
    popularity?: number
    isActive?: boolean
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    phases?: RoadmapPhaseCreateNestedManyWithoutRoadmapInput
  }

  export type RoadmapUncheckedCreateWithoutProgressInput = {
    id?: string
    slug: string
    title: string
    description: string
    icon: string
    level: string
    duration: string
    gradient: string
    skills?: RoadmapCreateskillsInput | string[]
    popularity?: number
    isActive?: boolean
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    phases?: RoadmapPhaseUncheckedCreateNestedManyWithoutRoadmapInput
  }

  export type RoadmapCreateOrConnectWithoutProgressInput = {
    where: RoadmapWhereUniqueInput
    create: XOR<RoadmapCreateWithoutProgressInput, RoadmapUncheckedCreateWithoutProgressInput>
  }

  export type RoadmapStepCreateWithoutProgressInput = {
    id?: string
    title: string
    description: string
    difficulty: string
    estimatedTime: string
    order: number
    topics?: RoadmapStepCreatetopicsInput | string[]
    prerequisites?: RoadmapStepCreateprerequisitesInput | string[]
    resources: JsonNullValueInput | InputJsonValue
    checkpoints?: RoadmapStepCreatecheckpointsInput | string[]
    relatedCheatsheets?: RoadmapStepCreaterelatedCheatsheetsInput | string[]
    relatedDSA?: RoadmapStepCreaterelatedDSAInput | string[]
    relatedInterviews?: RoadmapStepCreaterelatedInterviewsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    phase: RoadmapPhaseCreateNestedOneWithoutStepsInput
  }

  export type RoadmapStepUncheckedCreateWithoutProgressInput = {
    id?: string
    phaseId: string
    title: string
    description: string
    difficulty: string
    estimatedTime: string
    order: number
    topics?: RoadmapStepCreatetopicsInput | string[]
    prerequisites?: RoadmapStepCreateprerequisitesInput | string[]
    resources: JsonNullValueInput | InputJsonValue
    checkpoints?: RoadmapStepCreatecheckpointsInput | string[]
    relatedCheatsheets?: RoadmapStepCreaterelatedCheatsheetsInput | string[]
    relatedDSA?: RoadmapStepCreaterelatedDSAInput | string[]
    relatedInterviews?: RoadmapStepCreaterelatedInterviewsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoadmapStepCreateOrConnectWithoutProgressInput = {
    where: RoadmapStepWhereUniqueInput
    create: XOR<RoadmapStepCreateWithoutProgressInput, RoadmapStepUncheckedCreateWithoutProgressInput>
  }

  export type RoadmapUpsertWithoutProgressInput = {
    update: XOR<RoadmapUpdateWithoutProgressInput, RoadmapUncheckedUpdateWithoutProgressInput>
    create: XOR<RoadmapCreateWithoutProgressInput, RoadmapUncheckedCreateWithoutProgressInput>
    where?: RoadmapWhereInput
  }

  export type RoadmapUpdateToOneWithWhereWithoutProgressInput = {
    where?: RoadmapWhereInput
    data: XOR<RoadmapUpdateWithoutProgressInput, RoadmapUncheckedUpdateWithoutProgressInput>
  }

  export type RoadmapUpdateWithoutProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    gradient?: StringFieldUpdateOperationsInput | string
    skills?: RoadmapUpdateskillsInput | string[]
    popularity?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phases?: RoadmapPhaseUpdateManyWithoutRoadmapNestedInput
  }

  export type RoadmapUncheckedUpdateWithoutProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    gradient?: StringFieldUpdateOperationsInput | string
    skills?: RoadmapUpdateskillsInput | string[]
    popularity?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phases?: RoadmapPhaseUncheckedUpdateManyWithoutRoadmapNestedInput
  }

  export type RoadmapStepUpsertWithoutProgressInput = {
    update: XOR<RoadmapStepUpdateWithoutProgressInput, RoadmapStepUncheckedUpdateWithoutProgressInput>
    create: XOR<RoadmapStepCreateWithoutProgressInput, RoadmapStepUncheckedCreateWithoutProgressInput>
    where?: RoadmapStepWhereInput
  }

  export type RoadmapStepUpdateToOneWithWhereWithoutProgressInput = {
    where?: RoadmapStepWhereInput
    data: XOR<RoadmapStepUpdateWithoutProgressInput, RoadmapStepUncheckedUpdateWithoutProgressInput>
  }

  export type RoadmapStepUpdateWithoutProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    estimatedTime?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    topics?: RoadmapStepUpdatetopicsInput | string[]
    prerequisites?: RoadmapStepUpdateprerequisitesInput | string[]
    resources?: JsonNullValueInput | InputJsonValue
    checkpoints?: RoadmapStepUpdatecheckpointsInput | string[]
    relatedCheatsheets?: RoadmapStepUpdaterelatedCheatsheetsInput | string[]
    relatedDSA?: RoadmapStepUpdaterelatedDSAInput | string[]
    relatedInterviews?: RoadmapStepUpdaterelatedInterviewsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phase?: RoadmapPhaseUpdateOneRequiredWithoutStepsNestedInput
  }

  export type RoadmapStepUncheckedUpdateWithoutProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    phaseId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    estimatedTime?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    topics?: RoadmapStepUpdatetopicsInput | string[]
    prerequisites?: RoadmapStepUpdateprerequisitesInput | string[]
    resources?: JsonNullValueInput | InputJsonValue
    checkpoints?: RoadmapStepUpdatecheckpointsInput | string[]
    relatedCheatsheets?: RoadmapStepUpdaterelatedCheatsheetsInput | string[]
    relatedDSA?: RoadmapStepUpdaterelatedDSAInput | string[]
    relatedInterviews?: RoadmapStepUpdaterelatedInterviewsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CheatsheetCreateWithoutCategoryInput = {
    id?: string
    slug: string
    title: string
    subtitle?: string | null
    description?: string | null
    icon?: string | null
    difficulty?: string | null
    tags?: CheatsheetCreatetagsInput | string[]
    popularity?: number
    overview?: string | null
    syntax?: NullableJsonNullValueInput | InputJsonValue
    operations?: NullableJsonNullValueInput | InputJsonValue
    examples?: NullableJsonNullValueInput | InputJsonValue
    mistakes?: CheatsheetCreatemistakesInput | string[]
    tips?: CheatsheetCreatetipsInput | string[]
    relatedCheatsheets?: CheatsheetCreaterelatedCheatsheetsInput | string[]
    relatedRoadmaps?: CheatsheetCreaterelatedRoadmapsInput | string[]
    relatedDSA?: CheatsheetCreaterelatedDSAInput | string[]
    aiExplanation?: string | null
    voiceExplainer?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CheatsheetUncheckedCreateWithoutCategoryInput = {
    id?: string
    slug: string
    title: string
    subtitle?: string | null
    description?: string | null
    icon?: string | null
    difficulty?: string | null
    tags?: CheatsheetCreatetagsInput | string[]
    popularity?: number
    overview?: string | null
    syntax?: NullableJsonNullValueInput | InputJsonValue
    operations?: NullableJsonNullValueInput | InputJsonValue
    examples?: NullableJsonNullValueInput | InputJsonValue
    mistakes?: CheatsheetCreatemistakesInput | string[]
    tips?: CheatsheetCreatetipsInput | string[]
    relatedCheatsheets?: CheatsheetCreaterelatedCheatsheetsInput | string[]
    relatedRoadmaps?: CheatsheetCreaterelatedRoadmapsInput | string[]
    relatedDSA?: CheatsheetCreaterelatedDSAInput | string[]
    aiExplanation?: string | null
    voiceExplainer?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CheatsheetCreateOrConnectWithoutCategoryInput = {
    where: CheatsheetWhereUniqueInput
    create: XOR<CheatsheetCreateWithoutCategoryInput, CheatsheetUncheckedCreateWithoutCategoryInput>
  }

  export type CheatsheetCreateManyCategoryInputEnvelope = {
    data: CheatsheetCreateManyCategoryInput | CheatsheetCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type CheatsheetUpsertWithWhereUniqueWithoutCategoryInput = {
    where: CheatsheetWhereUniqueInput
    update: XOR<CheatsheetUpdateWithoutCategoryInput, CheatsheetUncheckedUpdateWithoutCategoryInput>
    create: XOR<CheatsheetCreateWithoutCategoryInput, CheatsheetUncheckedCreateWithoutCategoryInput>
  }

  export type CheatsheetUpdateWithWhereUniqueWithoutCategoryInput = {
    where: CheatsheetWhereUniqueInput
    data: XOR<CheatsheetUpdateWithoutCategoryInput, CheatsheetUncheckedUpdateWithoutCategoryInput>
  }

  export type CheatsheetUpdateManyWithWhereWithoutCategoryInput = {
    where: CheatsheetScalarWhereInput
    data: XOR<CheatsheetUpdateManyMutationInput, CheatsheetUncheckedUpdateManyWithoutCategoryInput>
  }

  export type CheatsheetScalarWhereInput = {
    AND?: CheatsheetScalarWhereInput | CheatsheetScalarWhereInput[]
    OR?: CheatsheetScalarWhereInput[]
    NOT?: CheatsheetScalarWhereInput | CheatsheetScalarWhereInput[]
    id?: StringFilter<"Cheatsheet"> | string
    categoryId?: StringFilter<"Cheatsheet"> | string
    slug?: StringFilter<"Cheatsheet"> | string
    title?: StringFilter<"Cheatsheet"> | string
    subtitle?: StringNullableFilter<"Cheatsheet"> | string | null
    description?: StringNullableFilter<"Cheatsheet"> | string | null
    icon?: StringNullableFilter<"Cheatsheet"> | string | null
    difficulty?: StringNullableFilter<"Cheatsheet"> | string | null
    tags?: StringNullableListFilter<"Cheatsheet">
    popularity?: IntFilter<"Cheatsheet"> | number
    overview?: StringNullableFilter<"Cheatsheet"> | string | null
    syntax?: JsonNullableFilter<"Cheatsheet">
    operations?: JsonNullableFilter<"Cheatsheet">
    examples?: JsonNullableFilter<"Cheatsheet">
    mistakes?: StringNullableListFilter<"Cheatsheet">
    tips?: StringNullableListFilter<"Cheatsheet">
    relatedCheatsheets?: StringNullableListFilter<"Cheatsheet">
    relatedRoadmaps?: StringNullableListFilter<"Cheatsheet">
    relatedDSA?: StringNullableListFilter<"Cheatsheet">
    aiExplanation?: StringNullableFilter<"Cheatsheet"> | string | null
    voiceExplainer?: StringNullableFilter<"Cheatsheet"> | string | null
    createdAt?: DateTimeFilter<"Cheatsheet"> | Date | string
    updatedAt?: DateTimeFilter<"Cheatsheet"> | Date | string
  }

  export type CheatsheetCategoryCreateWithoutCheatsheetsInput = {
    id?: string
    slug: string
    title: string
    description?: string | null
    icon?: string | null
    order?: number
    color?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CheatsheetCategoryUncheckedCreateWithoutCheatsheetsInput = {
    id?: string
    slug: string
    title: string
    description?: string | null
    icon?: string | null
    order?: number
    color?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CheatsheetCategoryCreateOrConnectWithoutCheatsheetsInput = {
    where: CheatsheetCategoryWhereUniqueInput
    create: XOR<CheatsheetCategoryCreateWithoutCheatsheetsInput, CheatsheetCategoryUncheckedCreateWithoutCheatsheetsInput>
  }

  export type CheatsheetCategoryUpsertWithoutCheatsheetsInput = {
    update: XOR<CheatsheetCategoryUpdateWithoutCheatsheetsInput, CheatsheetCategoryUncheckedUpdateWithoutCheatsheetsInput>
    create: XOR<CheatsheetCategoryCreateWithoutCheatsheetsInput, CheatsheetCategoryUncheckedCreateWithoutCheatsheetsInput>
    where?: CheatsheetCategoryWhereInput
  }

  export type CheatsheetCategoryUpdateToOneWithWhereWithoutCheatsheetsInput = {
    where?: CheatsheetCategoryWhereInput
    data: XOR<CheatsheetCategoryUpdateWithoutCheatsheetsInput, CheatsheetCategoryUncheckedUpdateWithoutCheatsheetsInput>
  }

  export type CheatsheetCategoryUpdateWithoutCheatsheetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CheatsheetCategoryUncheckedUpdateWithoutCheatsheetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserProgressCreateManyUserInput = {
    id?: string
    problemId: string
    status: string
    starred?: boolean
    lastAttempt?: Date | string
    createdAt?: Date | string
  }

  export type SubmissionCreateManyUserInput = {
    id?: string
    problemId: string
    code: string
    language: string
    status: string
    runtime?: number | null
    memory?: number | null
    createdAt?: Date | string
  }

  export type InterviewSessionCreateManyUserInput = {
    id?: string
    role: string
    duration: number
    status: string
    resumeSnapshot: string
    jobDescription?: string | null
    resumeSummary?: string | null
    jdSummary?: string | null
    vapiCallId?: string | null
    vapiAssistantId?: string | null
    transcript?: NullableJsonNullValueInput | InputJsonValue
    videoUrl?: string | null
    videoRecorded?: boolean
    createdAt?: Date | string
    startedAt?: Date | string | null
    endedAt?: Date | string | null
  }

  export type SharedInterviewResultCreateManyUserInput = {
    id?: string
    sessionId: string
    shareToken: string
    isPublic?: boolean
    expiresAt?: Date | string | null
    viewCount?: number
    lastViewedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type UserProgressUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    starred?: BoolFieldUpdateOperationsInput | boolean
    lastAttempt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    problem?: ProblemUpdateOneRequiredWithoutProgressNestedInput
  }

  export type UserProgressUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    problemId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    starred?: BoolFieldUpdateOperationsInput | boolean
    lastAttempt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserProgressUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    problemId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    starred?: BoolFieldUpdateOperationsInput | boolean
    lastAttempt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubmissionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    runtime?: NullableIntFieldUpdateOperationsInput | number | null
    memory?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    problem?: ProblemUpdateOneRequiredWithoutSubmissionsNestedInput
  }

  export type SubmissionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    problemId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    runtime?: NullableIntFieldUpdateOperationsInput | number | null
    memory?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubmissionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    problemId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    runtime?: NullableIntFieldUpdateOperationsInput | number | null
    memory?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterviewSessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    resumeSnapshot?: StringFieldUpdateOperationsInput | string
    jobDescription?: NullableStringFieldUpdateOperationsInput | string | null
    resumeSummary?: NullableStringFieldUpdateOperationsInput | string | null
    jdSummary?: NullableStringFieldUpdateOperationsInput | string | null
    vapiCallId?: NullableStringFieldUpdateOperationsInput | string | null
    vapiAssistantId?: NullableStringFieldUpdateOperationsInput | string | null
    transcript?: NullableJsonNullValueInput | InputJsonValue
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    videoRecorded?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    feedback?: InterviewFeedbackUpdateOneWithoutSessionNestedInput
    sharedResult?: SharedInterviewResultUpdateOneWithoutSessionNestedInput
  }

  export type InterviewSessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    resumeSnapshot?: StringFieldUpdateOperationsInput | string
    jobDescription?: NullableStringFieldUpdateOperationsInput | string | null
    resumeSummary?: NullableStringFieldUpdateOperationsInput | string | null
    jdSummary?: NullableStringFieldUpdateOperationsInput | string | null
    vapiCallId?: NullableStringFieldUpdateOperationsInput | string | null
    vapiAssistantId?: NullableStringFieldUpdateOperationsInput | string | null
    transcript?: NullableJsonNullValueInput | InputJsonValue
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    videoRecorded?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    feedback?: InterviewFeedbackUncheckedUpdateOneWithoutSessionNestedInput
    sharedResult?: SharedInterviewResultUncheckedUpdateOneWithoutSessionNestedInput
  }

  export type InterviewSessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    resumeSnapshot?: StringFieldUpdateOperationsInput | string
    jobDescription?: NullableStringFieldUpdateOperationsInput | string | null
    resumeSummary?: NullableStringFieldUpdateOperationsInput | string | null
    jdSummary?: NullableStringFieldUpdateOperationsInput | string | null
    vapiCallId?: NullableStringFieldUpdateOperationsInput | string | null
    vapiAssistantId?: NullableStringFieldUpdateOperationsInput | string | null
    transcript?: NullableJsonNullValueInput | InputJsonValue
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    videoRecorded?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SharedInterviewResultUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    shareToken?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    lastViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: InterviewSessionUpdateOneRequiredWithoutSharedResultNestedInput
  }

  export type SharedInterviewResultUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    shareToken?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    lastViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SharedInterviewResultUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    shareToken?: StringFieldUpdateOperationsInput | string
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    lastViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DSALessonCreateManyTopicInput = {
    id?: string
    slug: string
    title: string
    content: string
    codeExamples?: NullableJsonNullValueInput | InputJsonValue
    difficulty?: string | null
    order: number
    createdAt?: Date | string
  }

  export type DSALessonUpdateWithoutTopicInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    codeExamples?: NullableJsonNullValueInput | InputJsonValue
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DSALessonUncheckedUpdateWithoutTopicInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    codeExamples?: NullableJsonNullValueInput | InputJsonValue
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DSALessonUncheckedUpdateManyWithoutTopicInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    codeExamples?: NullableJsonNullValueInput | InputJsonValue
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserProgressCreateManyProblemInput = {
    id?: string
    userId: string
    status: string
    starred?: boolean
    lastAttempt?: Date | string
    createdAt?: Date | string
  }

  export type SubmissionCreateManyProblemInput = {
    id?: string
    userId: string
    code: string
    language: string
    status: string
    runtime?: number | null
    memory?: number | null
    createdAt?: Date | string
  }

  export type UserProgressUpdateWithoutProblemInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    starred?: BoolFieldUpdateOperationsInput | boolean
    lastAttempt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProgressNestedInput
  }

  export type UserProgressUncheckedUpdateWithoutProblemInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    starred?: BoolFieldUpdateOperationsInput | boolean
    lastAttempt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserProgressUncheckedUpdateManyWithoutProblemInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    starred?: BoolFieldUpdateOperationsInput | boolean
    lastAttempt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubmissionUpdateWithoutProblemInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    runtime?: NullableIntFieldUpdateOperationsInput | number | null
    memory?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSubmissionsNestedInput
  }

  export type SubmissionUncheckedUpdateWithoutProblemInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    runtime?: NullableIntFieldUpdateOperationsInput | number | null
    memory?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubmissionUncheckedUpdateManyWithoutProblemInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    runtime?: NullableIntFieldUpdateOperationsInput | number | null
    memory?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LearnCategoryCreateManyDomainInput = {
    id?: string
    title: string
    order: number
  }

  export type LearnCategoryUpdateWithoutDomainInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    topics?: LearnTopicUpdateManyWithoutCategoryNestedInput
  }

  export type LearnCategoryUncheckedUpdateWithoutDomainInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    topics?: LearnTopicUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type LearnCategoryUncheckedUpdateManyWithoutDomainInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
  }

  export type LearnTopicCreateManyCategoryInput = {
    id?: string
    title: string
    slug: string
    order: number
    content: string
    createdAt?: Date | string
  }

  export type LearnTopicUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LearnTopicUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LearnTopicUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoadmapPhaseCreateManyRoadmapInput = {
    id?: string
    title: string
    description: string
    order: number
  }

  export type RoadmapProgressCreateManyRoadmapInput = {
    id?: string
    userId: string
    stepId: string
    completed?: boolean
    notes?: string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoadmapPhaseUpdateWithoutRoadmapInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    steps?: RoadmapStepUpdateManyWithoutPhaseNestedInput
  }

  export type RoadmapPhaseUncheckedUpdateWithoutRoadmapInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    steps?: RoadmapStepUncheckedUpdateManyWithoutPhaseNestedInput
  }

  export type RoadmapPhaseUncheckedUpdateManyWithoutRoadmapInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
  }

  export type RoadmapProgressUpdateWithoutRoadmapInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    step?: RoadmapStepUpdateOneRequiredWithoutProgressNestedInput
  }

  export type RoadmapProgressUncheckedUpdateWithoutRoadmapInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    stepId?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoadmapProgressUncheckedUpdateManyWithoutRoadmapInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    stepId?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoadmapStepCreateManyPhaseInput = {
    id?: string
    title: string
    description: string
    difficulty: string
    estimatedTime: string
    order: number
    topics?: RoadmapStepCreatetopicsInput | string[]
    prerequisites?: RoadmapStepCreateprerequisitesInput | string[]
    resources: JsonNullValueInput | InputJsonValue
    checkpoints?: RoadmapStepCreatecheckpointsInput | string[]
    relatedCheatsheets?: RoadmapStepCreaterelatedCheatsheetsInput | string[]
    relatedDSA?: RoadmapStepCreaterelatedDSAInput | string[]
    relatedInterviews?: RoadmapStepCreaterelatedInterviewsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoadmapStepUpdateWithoutPhaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    estimatedTime?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    topics?: RoadmapStepUpdatetopicsInput | string[]
    prerequisites?: RoadmapStepUpdateprerequisitesInput | string[]
    resources?: JsonNullValueInput | InputJsonValue
    checkpoints?: RoadmapStepUpdatecheckpointsInput | string[]
    relatedCheatsheets?: RoadmapStepUpdaterelatedCheatsheetsInput | string[]
    relatedDSA?: RoadmapStepUpdaterelatedDSAInput | string[]
    relatedInterviews?: RoadmapStepUpdaterelatedInterviewsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: RoadmapProgressUpdateManyWithoutStepNestedInput
  }

  export type RoadmapStepUncheckedUpdateWithoutPhaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    estimatedTime?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    topics?: RoadmapStepUpdatetopicsInput | string[]
    prerequisites?: RoadmapStepUpdateprerequisitesInput | string[]
    resources?: JsonNullValueInput | InputJsonValue
    checkpoints?: RoadmapStepUpdatecheckpointsInput | string[]
    relatedCheatsheets?: RoadmapStepUpdaterelatedCheatsheetsInput | string[]
    relatedDSA?: RoadmapStepUpdaterelatedDSAInput | string[]
    relatedInterviews?: RoadmapStepUpdaterelatedInterviewsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: RoadmapProgressUncheckedUpdateManyWithoutStepNestedInput
  }

  export type RoadmapStepUncheckedUpdateManyWithoutPhaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    estimatedTime?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    topics?: RoadmapStepUpdatetopicsInput | string[]
    prerequisites?: RoadmapStepUpdateprerequisitesInput | string[]
    resources?: JsonNullValueInput | InputJsonValue
    checkpoints?: RoadmapStepUpdatecheckpointsInput | string[]
    relatedCheatsheets?: RoadmapStepUpdaterelatedCheatsheetsInput | string[]
    relatedDSA?: RoadmapStepUpdaterelatedDSAInput | string[]
    relatedInterviews?: RoadmapStepUpdaterelatedInterviewsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoadmapProgressCreateManyStepInput = {
    id?: string
    userId: string
    roadmapId: string
    completed?: boolean
    notes?: string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoadmapProgressUpdateWithoutStepInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roadmap?: RoadmapUpdateOneRequiredWithoutProgressNestedInput
  }

  export type RoadmapProgressUncheckedUpdateWithoutStepInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    roadmapId?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoadmapProgressUncheckedUpdateManyWithoutStepInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    roadmapId?: StringFieldUpdateOperationsInput | string
    completed?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CheatsheetCreateManyCategoryInput = {
    id?: string
    slug: string
    title: string
    subtitle?: string | null
    description?: string | null
    icon?: string | null
    difficulty?: string | null
    tags?: CheatsheetCreatetagsInput | string[]
    popularity?: number
    overview?: string | null
    syntax?: NullableJsonNullValueInput | InputJsonValue
    operations?: NullableJsonNullValueInput | InputJsonValue
    examples?: NullableJsonNullValueInput | InputJsonValue
    mistakes?: CheatsheetCreatemistakesInput | string[]
    tips?: CheatsheetCreatetipsInput | string[]
    relatedCheatsheets?: CheatsheetCreaterelatedCheatsheetsInput | string[]
    relatedRoadmaps?: CheatsheetCreaterelatedRoadmapsInput | string[]
    relatedDSA?: CheatsheetCreaterelatedDSAInput | string[]
    aiExplanation?: string | null
    voiceExplainer?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CheatsheetUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: CheatsheetUpdatetagsInput | string[]
    popularity?: IntFieldUpdateOperationsInput | number
    overview?: NullableStringFieldUpdateOperationsInput | string | null
    syntax?: NullableJsonNullValueInput | InputJsonValue
    operations?: NullableJsonNullValueInput | InputJsonValue
    examples?: NullableJsonNullValueInput | InputJsonValue
    mistakes?: CheatsheetUpdatemistakesInput | string[]
    tips?: CheatsheetUpdatetipsInput | string[]
    relatedCheatsheets?: CheatsheetUpdaterelatedCheatsheetsInput | string[]
    relatedRoadmaps?: CheatsheetUpdaterelatedRoadmapsInput | string[]
    relatedDSA?: CheatsheetUpdaterelatedDSAInput | string[]
    aiExplanation?: NullableStringFieldUpdateOperationsInput | string | null
    voiceExplainer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CheatsheetUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: CheatsheetUpdatetagsInput | string[]
    popularity?: IntFieldUpdateOperationsInput | number
    overview?: NullableStringFieldUpdateOperationsInput | string | null
    syntax?: NullableJsonNullValueInput | InputJsonValue
    operations?: NullableJsonNullValueInput | InputJsonValue
    examples?: NullableJsonNullValueInput | InputJsonValue
    mistakes?: CheatsheetUpdatemistakesInput | string[]
    tips?: CheatsheetUpdatetipsInput | string[]
    relatedCheatsheets?: CheatsheetUpdaterelatedCheatsheetsInput | string[]
    relatedRoadmaps?: CheatsheetUpdaterelatedRoadmapsInput | string[]
    relatedDSA?: CheatsheetUpdaterelatedDSAInput | string[]
    aiExplanation?: NullableStringFieldUpdateOperationsInput | string | null
    voiceExplainer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CheatsheetUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: CheatsheetUpdatetagsInput | string[]
    popularity?: IntFieldUpdateOperationsInput | number
    overview?: NullableStringFieldUpdateOperationsInput | string | null
    syntax?: NullableJsonNullValueInput | InputJsonValue
    operations?: NullableJsonNullValueInput | InputJsonValue
    examples?: NullableJsonNullValueInput | InputJsonValue
    mistakes?: CheatsheetUpdatemistakesInput | string[]
    tips?: CheatsheetUpdatetipsInput | string[]
    relatedCheatsheets?: CheatsheetUpdaterelatedCheatsheetsInput | string[]
    relatedRoadmaps?: CheatsheetUpdaterelatedRoadmapsInput | string[]
    relatedDSA?: CheatsheetUpdaterelatedDSAInput | string[]
    aiExplanation?: NullableStringFieldUpdateOperationsInput | string | null
    voiceExplainer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DSATopicCountOutputTypeDefaultArgs instead
     */
    export type DSATopicCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DSATopicCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProblemCountOutputTypeDefaultArgs instead
     */
    export type ProblemCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProblemCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LearnDomainCountOutputTypeDefaultArgs instead
     */
    export type LearnDomainCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LearnDomainCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LearnCategoryCountOutputTypeDefaultArgs instead
     */
    export type LearnCategoryCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LearnCategoryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoadmapCountOutputTypeDefaultArgs instead
     */
    export type RoadmapCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoadmapCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoadmapPhaseCountOutputTypeDefaultArgs instead
     */
    export type RoadmapPhaseCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoadmapPhaseCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoadmapStepCountOutputTypeDefaultArgs instead
     */
    export type RoadmapStepCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoadmapStepCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CheatsheetCategoryCountOutputTypeDefaultArgs instead
     */
    export type CheatsheetCategoryCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CheatsheetCategoryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DSATopicDefaultArgs instead
     */
    export type DSATopicArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DSATopicDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DSALessonDefaultArgs instead
     */
    export type DSALessonArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DSALessonDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProblemDefaultArgs instead
     */
    export type ProblemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProblemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserProgressDefaultArgs instead
     */
    export type UserProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserProgressDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SubmissionDefaultArgs instead
     */
    export type SubmissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SubmissionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LearnDomainDefaultArgs instead
     */
    export type LearnDomainArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LearnDomainDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LearnCategoryDefaultArgs instead
     */
    export type LearnCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LearnCategoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LearnTopicDefaultArgs instead
     */
    export type LearnTopicArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LearnTopicDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InterviewSessionDefaultArgs instead
     */
    export type InterviewSessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InterviewSessionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InterviewFeedbackDefaultArgs instead
     */
    export type InterviewFeedbackArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InterviewFeedbackDefaultArgs<ExtArgs>
    /**
     * @deprecated Use QuestionBankDefaultArgs instead
     */
    export type QuestionBankArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = QuestionBankDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SharedInterviewResultDefaultArgs instead
     */
    export type SharedInterviewResultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SharedInterviewResultDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InterviewAnalyticsDefaultArgs instead
     */
    export type InterviewAnalyticsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InterviewAnalyticsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoadmapDefaultArgs instead
     */
    export type RoadmapArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoadmapDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoadmapPhaseDefaultArgs instead
     */
    export type RoadmapPhaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoadmapPhaseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoadmapStepDefaultArgs instead
     */
    export type RoadmapStepArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoadmapStepDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoadmapProgressDefaultArgs instead
     */
    export type RoadmapProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoadmapProgressDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CheatsheetCategoryDefaultArgs instead
     */
    export type CheatsheetCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CheatsheetCategoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CheatsheetDefaultArgs instead
     */
    export type CheatsheetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CheatsheetDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}